import {
  __commonJS
} from "./chunk-ULBN3QDT.js";

// node_modules/@badgateway/oauth2-client/browser/oauth2-client.min.js
var require_oauth2_client_min = __commonJS({
  "node_modules/@badgateway/oauth2-client/browser/oauth2-client.min.js"(exports, module) {
    !(function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.OAuth2Client = t() : e.OAuth2Client = t();
    })(self, (() => (() => {
      var e = { 985: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OAuth2Client = void 0, t2.generateQueryString = i;
        const n2 = r2(854), o = r2(129);
        function s(e3, t3) {
          return new URL(e3, t3).toString();
        }
        function i(e3) {
          const t3 = new URLSearchParams();
          for (const [r3, n3] of Object.entries(e3)) if (Array.isArray(n3)) for (const e4 of n3) t3.append(r3, e4);
          else void 0 !== n3 && t3.set(r3, n3.toString());
          return t3.toString();
        }
        t2.OAuth2Client = class {
          constructor(e3) {
            this.discoveryDone = false, this.serverMetadata = null, (null == e3 ? void 0 : e3.fetch) || (e3.fetch = fetch.bind(globalThis)), this.settings = e3;
          }
          async refreshToken(e3, t3) {
            if (!e3.refreshToken) throw new Error("This token didn't have a refreshToken. It's not possible to refresh this");
            const r3 = { grant_type: "refresh_token", refresh_token: e3.refreshToken };
            this.settings.clientSecret || (r3.client_id = this.settings.clientId), (null == t3 ? void 0 : t3.scope) && (r3.scope = t3.scope.join(" ")), (null == t3 ? void 0 : t3.resource) && (r3.resource = t3.resource);
            const n3 = await this.tokenResponseToOAuth2Token(this.request("tokenEndpoint", r3));
            return !n3.refreshToken && e3.refreshToken && (n3.refreshToken = e3.refreshToken), n3;
          }
          async clientCredentials(e3) {
            var t3;
            const r3 = ["client_id", "client_secret", "grant_type", "scope"];
            if ((null == e3 ? void 0 : e3.extraParams) && Object.keys(e3.extraParams).filter(((e4) => r3.includes(e4))).length > 0) throw new Error(`The following extraParams are disallowed: '${r3.join("', '")}'`);
            const n3 = { grant_type: "client_credentials", scope: null === (t3 = null == e3 ? void 0 : e3.scope) || void 0 === t3 ? void 0 : t3.join(" "), resource: null == e3 ? void 0 : e3.resource, ...null == e3 ? void 0 : e3.extraParams };
            if (!this.settings.clientSecret) throw new Error("A clientSecret must be provided to use client_credentials");
            return this.tokenResponseToOAuth2Token(this.request("tokenEndpoint", n3));
          }
          async password(e3) {
            var t3;
            const r3 = { grant_type: "password", ...e3, scope: null === (t3 = e3.scope) || void 0 === t3 ? void 0 : t3.join(" ") };
            return this.tokenResponseToOAuth2Token(this.request("tokenEndpoint", r3));
          }
          get authorizationCode() {
            return new o.OAuth2AuthorizationCodeClient(this);
          }
          async introspect(e3) {
            const t3 = { token: e3.accessToken, token_type_hint: "access_token" };
            return this.request("introspectionEndpoint", t3);
          }
          async revoke(e3, t3 = "access_token") {
            let r3 = e3.accessToken;
            "refresh_token" === t3 && (r3 = e3.refreshToken);
            const n3 = { token: r3, token_type_hint: t3 };
            return this.request("revocationEndpoint", n3);
          }
          async getEndpoint(e3) {
            if (void 0 !== this.settings[e3]) return s(this.settings[e3], this.settings.server);
            if ("discoveryEndpoint" !== e3 && (await this.discover(), void 0 !== this.settings[e3])) return s(this.settings[e3], this.settings.server);
            if (!this.settings.server) throw new Error(`Could not determine the location of ${e3}. Either specify ${e3} in the settings, or the "server" endpoint to let the client discover it.`);
            switch (e3) {
              case "authorizationEndpoint":
                return s("/authorize", this.settings.server);
              case "tokenEndpoint":
                return s("/token", this.settings.server);
              case "discoveryEndpoint":
                return s("/.well-known/oauth-authorization-server", this.settings.server);
              case "introspectionEndpoint":
                return s("/introspect", this.settings.server);
              case "revocationEndpoint":
                return s("/revoke", this.settings.server);
            }
          }
          async discover() {
            var e3;
            if (this.discoveryDone) return;
            let t3;
            this.discoveryDone = true;
            try {
              t3 = await this.getEndpoint("discoveryEndpoint");
            } catch (e4) {
              return void console.warn('[oauth2] OAuth2 discovery endpoint could not be determined. Either specify the "server" or "discoveryEndpoint');
            }
            const r3 = await this.settings.fetch(t3, { headers: { Accept: "application/json" } });
            if (!r3.ok) return;
            if (!(null === (e3 = r3.headers.get("Content-Type")) || void 0 === e3 ? void 0 : e3.startsWith("application/json"))) return void console.warn("[oauth2] OAuth2 discovery endpoint was not a JSON response. Response is ignored");
            this.serverMetadata = await r3.json();
            const n3 = [["authorization_endpoint", "authorizationEndpoint"], ["token_endpoint", "tokenEndpoint"], ["introspection_endpoint", "introspectionEndpoint"], ["revocation_endpoint", "revocationEndpoint"]];
            if (null !== this.serverMetadata) {
              for (const [e4, r4] of n3) this.serverMetadata[e4] && (this.settings[r4] = s(this.serverMetadata[e4], t3));
              this.serverMetadata.token_endpoint_auth_methods_supported && !this.settings.authenticationMethod && (this.settings.authenticationMethod = this.serverMetadata.token_endpoint_auth_methods_supported[0]);
            }
          }
          async request(e3, t3) {
            const r3 = await this.getEndpoint(e3), o2 = { "Content-Type": "application/x-www-form-urlencoded", Accept: "application/json" };
            let s2 = this.settings.authenticationMethod;
            switch (this.settings.clientSecret || (s2 = "client_secret_post"), s2 || (s2 = "client_secret_basic"), s2) {
              case "client_secret_basic":
                o2.Authorization = "Basic " + btoa(this.settings.clientId + ":" + this.settings.clientSecret);
                break;
              case "client_secret_post":
                t3.client_id = this.settings.clientId, this.settings.clientSecret && (t3.client_secret = this.settings.clientSecret);
                break;
              default:
                throw new Error("Authentication method not yet supported:" + s2 + ". Open a feature request if you want this!");
            }
            const a = await this.settings.fetch(r3, { method: "POST", body: i(t3), headers: o2 });
            let c, h, u;
            if (204 !== a.status && a.headers.has("Content-Type") && a.headers.get("Content-Type").match(/^application\/(.*\+)?json/) && (c = await a.json()), a.ok) return c;
            throw (null == c ? void 0 : c.error) ? (h = "OAuth2 error " + c.error + ".", c.error_description && (h += " " + c.error_description), u = c.error) : (h = "HTTP Error " + a.status + " " + a.statusText, 401 === a.status && this.settings.clientSecret && (h += ". It's likely that the clientId and/or clientSecret was incorrect"), u = null), new n2.OAuth2HttpError(h, u, a, c);
          }
          async tokenResponseToOAuth2Token(e3) {
            var t3;
            const r3 = await e3;
            if (!(null == r3 ? void 0 : r3.access_token)) throw console.warn("Invalid OAuth2 Token Response: ", r3), new TypeError("We received an invalid token response from an OAuth2 server.");
            return { accessToken: r3.access_token, expiresAt: r3.expires_in ? Date.now() + 1e3 * r3.expires_in : null, refreshToken: null !== (t3 = r3.refresh_token) && void 0 !== t3 ? t3 : null };
          }
        };
      }, 129: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OAuth2AuthorizationCodeClient = void 0, t2.generateCodeVerifier = async function() {
          const e3 = s();
          if (e3) {
            const t3 = new Uint8Array(32);
            return e3.getRandomValues(t3), a(t3);
          }
          {
            const e4 = r2(483);
            return new Promise(((t3, r3) => {
              e4.randomBytes(32, ((e5, n3) => {
                e5 && r3(e5), t3(n3.toString("base64url"));
              }));
            }));
          }
        }, t2.getCodeChallenge = o;
        const n2 = r2(854);
        async function o(e3) {
          const t3 = s();
          if (null == t3 ? void 0 : t3.subtle) return ["S256", a(await t3.subtle.digest("SHA-256", i(e3)))];
          {
            const t4 = r2(483).createHash("sha256");
            return t4.update(i(e3)), ["S256", t4.digest("base64url")];
          }
        }
        function s() {
          if ("undefined" != typeof window && window.crypto) return window.crypto;
          if ("undefined" != typeof self && self.crypto) return self.crypto;
          const e3 = r2(483);
          return e3.webcrypto ? e3.webcrypto : null;
        }
        function i(e3) {
          const t3 = new Uint8Array(e3.length);
          for (let r3 = 0; r3 < e3.length; r3++) t3[r3] = 255 & e3.charCodeAt(r3);
          return t3;
        }
        function a(e3) {
          return btoa(String.fromCharCode(...new Uint8Array(e3))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        }
        t2.OAuth2AuthorizationCodeClient = class {
          constructor(e3) {
            this.client = e3;
          }
          async getAuthorizeUri(e3) {
            const [t3, r3] = await Promise.all([e3.codeVerifier ? o(e3.codeVerifier) : void 0, this.client.getEndpoint("authorizationEndpoint")]), n3 = new URLSearchParams({ client_id: this.client.settings.clientId, response_type: "code", redirect_uri: e3.redirectUri });
            if (t3 && (n3.set("code_challenge_method", t3[0]), n3.set("code_challenge", t3[1])), e3.state && n3.set("state", e3.state), e3.scope && n3.set("scope", e3.scope.join(" ")), e3.resource) for (const t4 of [].concat(e3.resource)) n3.append("resource", t4);
            if (e3.responseMode && "query" !== e3.responseMode && n3.append("response_mode", e3.responseMode), e3.extraParams) for (const [t4, r4] of Object.entries(e3.extraParams)) {
              if (n3.has(t4)) throw new Error(`Property in extraParams would overwrite standard property: ${t4}`);
              n3.set(t4, r4);
            }
            return r3 + "?" + n3.toString();
          }
          async getTokenFromCodeRedirect(e3, t3) {
            const { code: r3 } = this.validateResponse(e3, { state: t3.state });
            return this.getToken({ code: r3, redirectUri: t3.redirectUri, codeVerifier: t3.codeVerifier });
          }
          validateResponse(e3, t3) {
            var r3;
            let o2 = (e3 = new URL(e3)).searchParams;
            if (!o2.has("code") && !o2.has("error") && e3.hash.length > 0 && (o2 = new URLSearchParams(e3.hash.slice(1))), o2.has("error")) throw new n2.OAuth2Error(null !== (r3 = o2.get("error_description")) && void 0 !== r3 ? r3 : "OAuth2 error", o2.get("error"));
            if (!o2.has("code")) throw new Error(`The url did not contain a code parameter ${e3}`);
            if (t3.state && t3.state !== o2.get("state")) throw new Error(`The "state" parameter in the url did not match the expected value of ${t3.state}`);
            return { code: o2.get("code"), scope: o2.has("scope") ? o2.get("scope").split(" ") : void 0 };
          }
          async getToken(e3) {
            const t3 = { grant_type: "authorization_code", code: e3.code, redirect_uri: e3.redirectUri, code_verifier: e3.codeVerifier, resource: e3.resource };
            return this.client.tokenResponseToOAuth2Token(this.client.request("tokenEndpoint", t3));
          }
        };
      }, 854: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OAuth2HttpError = t2.OAuth2Error = void 0;
        class r2 extends Error {
          constructor(e3, t3) {
            super(e3), this.oauth2Code = t3;
          }
        }
        t2.OAuth2Error = r2, t2.OAuth2HttpError = class extends r2 {
          constructor(e3, t3, r3, n2) {
            super(e3, t3), this.httpCode = r3.status, this.response = r3, this.parsedBody = n2;
          }
        };
      }, 238: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OAuth2Fetch = void 0, t2.OAuth2Fetch = class {
          constructor(e3) {
            this.token = null, this.activeGetStoredToken = null, this.activeRefresh = null, this.refreshTimer = null, void 0 === (null == e3 ? void 0 : e3.scheduleRefresh) && (e3.scheduleRefresh = true), this.options = e3, e3.getStoredToken && (this.activeGetStoredToken = (async () => {
              this.token = await e3.getStoredToken(), this.activeGetStoredToken = null;
            })()), this.scheduleRefresh();
          }
          async fetch(e3, t3) {
            const r2 = new Request(e3, t3);
            return this.mw()(r2, ((e4) => fetch(e4)));
          }
          mw() {
            return async (e3, t3) => {
              const r2 = await this.getAccessToken();
              let n2 = e3.clone();
              n2.headers.set("Authorization", "Bearer " + r2);
              let o = await t3(n2);
              if (!o.ok && 401 === o.status) {
                const r3 = await this.refreshToken();
                n2 = e3.clone(), n2.headers.set("Authorization", "Bearer " + r3.accessToken), o = await t3(n2);
              }
              return o;
            };
          }
          async getToken() {
            return this.token && (null === this.token.expiresAt || this.token.expiresAt > Date.now()) ? this.token : this.refreshToken();
          }
          async getAccessToken() {
            return await this.activeGetStoredToken, (await this.getToken()).accessToken;
          }
          async refreshToken() {
            var e3, t3;
            if (this.activeRefresh) return this.activeRefresh;
            const r2 = this.token;
            this.activeRefresh = (async () => {
              var e4, t4;
              let n2 = null;
              try {
                (null == r2 ? void 0 : r2.refreshToken) && (n2 = await this.options.client.refreshToken(r2));
              } catch (e5) {
                console.warn("[oauth2] refresh token not accepted, we'll try reauthenticating");
              }
              if (n2 || (n2 = await this.options.getNewToken()), !n2) {
                const r3 = new Error("Unable to obtain OAuth2 tokens, a full reauth may be needed");
                throw null === (t4 = (e4 = this.options).onError) || void 0 === t4 || t4.call(e4, r3), r3;
              }
              return n2;
            })();
            try {
              const r3 = await this.activeRefresh;
              return this.token = r3, null === (t3 = (e3 = this.options).storeToken) || void 0 === t3 || t3.call(e3, r3), this.scheduleRefresh(), r3;
            } catch (e4) {
              throw this.options.onError && this.options.onError(e4), e4;
            } finally {
              this.activeRefresh = null;
            }
          }
          scheduleRefresh() {
            var e3;
            if (!this.options.scheduleRefresh) return;
            if (this.refreshTimer && (clearTimeout(this.refreshTimer), this.refreshTimer = null), !(null === (e3 = this.token) || void 0 === e3 ? void 0 : e3.expiresAt) || !this.token.refreshToken) return;
            const t3 = this.token.expiresAt - Date.now();
            t3 < 12e4 || (this.refreshTimer = setTimeout((async () => {
              try {
                await this.refreshToken();
              } catch (e4) {
                console.error("[fetch-mw-oauth2] error while doing a background OAuth2 auto-refresh", e4);
              }
            }), t3 - 6e4));
          }
        };
      }, 483: () => {
      } }, t = {};
      function r(n2) {
        var o = t[n2];
        if (void 0 !== o) return o.exports;
        var s = t[n2] = { exports: {} };
        return e[n2](s, s.exports, r), s.exports;
      }
      var n = {};
      return (() => {
        "use strict";
        var e2 = n;
        Object.defineProperty(e2, "__esModule", { value: true }), e2.OAuth2HttpError = e2.OAuth2Error = e2.OAuth2Fetch = e2.generateCodeVerifier = e2.OAuth2AuthorizationCodeClient = e2.OAuth2Client = void 0;
        var t2 = r(985);
        Object.defineProperty(e2, "OAuth2Client", { enumerable: true, get: function() {
          return t2.OAuth2Client;
        } });
        var o = r(129);
        Object.defineProperty(e2, "OAuth2AuthorizationCodeClient", { enumerable: true, get: function() {
          return o.OAuth2AuthorizationCodeClient;
        } }), Object.defineProperty(e2, "generateCodeVerifier", { enumerable: true, get: function() {
          return o.generateCodeVerifier;
        } });
        var s = r(238);
        Object.defineProperty(e2, "OAuth2Fetch", { enumerable: true, get: function() {
          return s.OAuth2Fetch;
        } });
        var i = r(854);
        Object.defineProperty(e2, "OAuth2Error", { enumerable: true, get: function() {
          return i.OAuth2Error;
        } }), Object.defineProperty(e2, "OAuth2HttpError", { enumerable: true, get: function() {
          return i.OAuth2HttpError;
        } });
      })(), n;
    })()));
  }
});
export default require_oauth2_client_min();
//# sourceMappingURL=@badgateway_oauth2-client.js.map
