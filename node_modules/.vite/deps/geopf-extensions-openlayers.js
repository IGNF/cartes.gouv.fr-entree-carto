import {
  WMTS_default as WMTS_default2
} from "./chunk-2LTA75MA.js";
import {
  TileWMS_default,
  createLoader,
  getFeatureInfoUrl,
  getLegendUrl
} from "./chunk-U467VVKO.js";
import {
  GPX_default
} from "./chunk-JQ4DNEX4.js";
import {
  KML_default
} from "./chunk-IUG6PVLM.js";
import {
  isDocument,
  makeArrayPusher,
  makeObjectPropertyPusher,
  makeObjectPropertySetter,
  makeStructureNS,
  parse,
  pushParseAndPop,
  readBooleanString,
  readDecimal,
  readDecimalString,
  readNonNegativeIntegerString,
  readPositiveInteger,
  readString
} from "./chunk-NXJ3XFGM.js";
import {
  Draw_default,
  Modify_default,
  Select_default
} from "./chunk-H6GLWF75.js";
import {
  Overlay_default,
  TileJSON_default,
  applyStyle,
  updateMapboxLayer
} from "./chunk-3H6ZIZKV.js";
import {
  Tile_default
} from "./chunk-YFKPCRPS.js";
import {
  VectorTile_default as VectorTile_default2
} from "./chunk-QQJC5LUN.js";
import "./chunk-PXRPP2N7.js";
import {
  Attribution_default,
  MapProperty_default,
  Map_default,
  Zoom_default
} from "./chunk-RRLVLT2C.js";
import {
  Image_default,
  defaultImageLoadFunction
} from "./chunk-SXACVEOG.js";
import "./chunk-2NYVGOCQ.js";
import {
  calculateSourceResolution
} from "./chunk-QDKP6ZDI.js";
import {
  VectorTile_default2 as VectorTile_default
} from "./chunk-XG4JV5BN.js";
import {
  createXYZ
} from "./chunk-YXQOICK3.js";
import {
  WMTS_default
} from "./chunk-P4YRBDRD.js";
import "./chunk-MT4RCSQE.js";
import "./chunk-NEFRPI2B.js";
import "./chunk-5D2XPBR2.js";
import {
  Control_default
} from "./chunk-KJY5NYWS.js";
import {
  GeoJSON_default
} from "./chunk-UNQXYW3Y.js";
import {
  MVT_default
} from "./chunk-MV2VUHK3.js";
import "./chunk-4ZE6P2VX.js";
import {
  Vector_default as Vector_default2
} from "./chunk-VGD5ZFRF.js";
import "./chunk-GW27V3Z3.js";
import "./chunk-HM3IY3H4.js";
import "./chunk-ZS6NWXXU.js";
import {
  MapBrowserEvent_default
} from "./chunk-SQZBUHDP.js";
import "./chunk-R2GHMFI7.js";
import {
  Base_default
} from "./chunk-TCIJLOO2.js";
import {
  ViewProperty_default,
  View_default
} from "./chunk-35QVNFWV.js";
import "./chunk-LMC3RO5P.js";
import "./chunk-FM44FOIC.js";
import {
  Vector_default,
  tile
} from "./chunk-ZGJDJBRN.js";
import {
  Collection_default
} from "./chunk-SWSLWUOK.js";
import "./chunk-RW3V7S4F.js";
import "./chunk-O2N2VZIO.js";
import "./chunk-PN7WQG2G.js";
import {
  pointerMove,
  singleClick
} from "./chunk-V7BLJ6OU.js";
import {
  MapEventType_default
} from "./chunk-BHVDQB66.js";
import {
  Circle_default as Circle_default2,
  Fill_default,
  Icon_default,
  Image_default as Image_default2,
  Stroke_default,
  Style_default,
  Text_default
} from "./chunk-5NYXTALQ.js";
import "./chunk-ZT77SKJS.js";
import {
  decode
} from "./chunk-CQE3WXS6.js";
import {
  replaceNode
} from "./chunk-UB2MKVXK.js";
import "./chunk-PPP4FLHO.js";
import "./chunk-GT2H4U2V.js";
import {
  CLASS_COLLAPSED,
  CLASS_CONTROL,
  CLASS_UNSELECTABLE,
  CLASS_UNSUPPORTED
} from "./chunk-GNM7L5BH.js";
import {
  Circle_default,
  LineString_default,
  MultiLineString_default,
  MultiPoint_default,
  MultiPolygon_default
} from "./chunk-4IIN5XG6.js";
import "./chunk-JFXZSSOM.js";
import {
  LinearRing_default,
  Point_default,
  Polygon_default,
  fromExtent
} from "./chunk-TEVKF24P.js";
import "./chunk-GBB7CYUH.js";
import "./chunk-UAWVI3Y5.js";
import {
  Projection_default,
  addCoordinateTransforms,
  addEquivalentProjections,
  addProjection,
  applyTransform,
  boundingExtent,
  compareVersions,
  containsExtent,
  createEmpty,
  equals,
  fromLonLat,
  get,
  get2,
  getArea2 as getArea,
  getBottomRight,
  getDistance,
  getTopLeft,
  getTransform,
  getWidth,
  intersects,
  scaleFromCenter,
  transform,
  transformExtent
} from "./chunk-L3VKSXTG.js";
import "./chunk-54BTDBAD.js";
import {
  Feature_default
} from "./chunk-ZDIOP7UL.js";
import "./chunk-QFCIXVZ3.js";
import {
  ObjectEventType_default,
  listen,
  listenOnce,
  unByKey,
  unlistenByKey
} from "./chunk-6ND2A3JA.js";
import {
  abstract
} from "./chunk-DFJETQDJ.js";
import "./chunk-5RHQVMYD.js";
import {
  EventType_default
} from "./chunk-FWIKGVSX.js";
import "./chunk-MEMX2J2S.js";
import {
  __commonJS,
  __privateAdd,
  __privateMethod,
  __publicField,
  __require,
  __toESM
} from "./chunk-ULBN3QDT.js";

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports4, module) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports4, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger3(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger50 = _loggersByName[name];
        if (!logger50) {
          logger50 = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger50;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers2() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/es6-promise/dist/es6-promise.js
var require_es6_promise = __commonJS({
  "node_modules/es6-promise/dist/es6-promise.js"(exports4, module) {
    (function(global2, factory) {
      typeof exports4 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.ES6Promise = factory();
    })(exports4, (function() {
      "use strict";
      function objectOrFunction(x3) {
        var type = typeof x3;
        return x3 !== null && (type === "object" || type === "function");
      }
      function isFunction(x3) {
        return typeof x3 === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x3) {
          return Object.prototype.toString.call(x3) === "[object Array]";
        };
      }
      var isArray = _isArray;
      var len = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap2(callback, arg) {
        queue[len] = callback;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : void 0;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process.nextTick(flush);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode("");
        observer.observe(node, { characterData: true });
        return function() {
          node.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush, 1);
        };
      }
      var queue = new Array(1e3);
      function flush() {
        for (var i = 0; i < len; i += 2) {
          var callback = queue[i];
          var arg = queue[i + 1];
          callback(arg);
          queue[i] = void 0;
          queue[i + 1] = void 0;
        }
        len = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === void 0 && typeof __require === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop);
        if (child[PROMISE_ID] === void 0) {
          makePromise(child);
        }
        var _state = parent._state;
        if (_state) {
          var callback = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback, parent._result);
          });
        } else {
          subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$1(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(noop);
        resolve(promise, object);
        return promise;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop() {
      }
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function tryThen(then$$1, value2, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value2, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise2) {
          var sealed = false;
          var error = tryThen(then$$1, thenable, function(value2) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value2) {
              resolve(promise2, value2);
            } else {
              fulfill(promise2, value2);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise2, reason);
          }, "Settle: " + (promise2._label || " unknown promise"));
          if (!sealed && error) {
            sealed = true;
            reject(promise2, error);
          }
        }, promise);
      }
      function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise, thenable._result);
        } else {
          subscribe(thenable, void 0, function(value2) {
            return resolve(promise, value2);
          }, function(reason) {
            return reject(promise, reason);
          });
        }
      }
      function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
          handleOwnThenable(promise, maybeThenable);
        } else {
          if (then$$1 === void 0) {
            fulfill(promise, maybeThenable);
          } else if (isFunction(then$$1)) {
            handleForeignThenable(promise, maybeThenable, then$$1);
          } else {
            fulfill(promise, maybeThenable);
          }
        }
      }
      function resolve(promise, value2) {
        if (promise === value2) {
          reject(promise, selfFulfillment());
        } else if (objectOrFunction(value2)) {
          var then$$1 = void 0;
          try {
            then$$1 = value2.then;
          } catch (error) {
            reject(promise, error);
            return;
          }
          handleMaybeThenable(promise, value2, then$$1);
        } else {
          fulfill(promise, value2);
        }
      }
      function publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        publish(promise);
      }
      function fulfill(promise, value2) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._result = value2;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) {
          asap(publish, promise);
        }
      }
      function reject(promise, reason) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
      }
      function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length = _subscribers.length;
        parent._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          asap(publish, parent);
        }
      }
      function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback = void 0, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback), value2 = void 0, error = void 0, succeeded = true;
        if (hasCallback) {
          try {
            value2 = callback(detail);
          } catch (e) {
            succeeded = false;
            error = e;
          }
          if (promise === value2) {
            reject(promise, cannotReturnOwn());
            return;
          }
        } else {
          value2 = detail;
        }
        if (promise._state !== PENDING) {
        } else if (hasCallback && succeeded) {
          resolve(promise, value2);
        } else if (succeeded === false) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          fulfill(promise, value2);
        } else if (settled === REJECTED) {
          reject(promise, value2);
        }
      }
      function initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value2) {
            resolve(promise, value2);
          }, function rejectPromise(reason) {
            reject(promise, reason);
          });
        } catch (e) {
          reject(promise, e);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = void 0;
        promise._result = void 0;
        promise._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = (function() {
        function Enumerator2(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator2.prototype._enumerate = function _enumerate(input) {
          for (var i = 0; this._state === PENDING && i < input.length; i++) {
            this._eachEntry(input[i], i);
          }
        };
        Enumerator2.prototype._eachEntry = function _eachEntry(entry, i) {
          var c = this._instanceConstructor;
          var resolve$$1 = c.resolve;
          if (resolve$$1 === resolve$1) {
            var _then = void 0;
            var error = void 0;
            var didError = false;
            try {
              _then = entry.then;
            } catch (e) {
              didError = true;
              error = e;
            }
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i] = entry;
            } else if (c === Promise$1) {
              var promise = new c(noop);
              if (didError) {
                reject(promise, error);
              } else {
                handleMaybeThenable(promise, entry, _then);
              }
              this._willSettleAt(promise, i);
            } else {
              this._willSettleAt(new c(function(resolve$$12) {
                return resolve$$12(entry);
              }), i);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i);
          }
        };
        Enumerator2.prototype._settledAt = function _settledAt(state, i, value2) {
          var promise = this.promise;
          if (promise._state === PENDING) {
            this._remaining--;
            if (state === REJECTED) {
              reject(promise, value2);
            } else {
              this._result[i] = value2;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise, this._result);
          }
        };
        Enumerator2.prototype._willSettleAt = function _willSettleAt(promise, i) {
          var enumerator = this;
          subscribe(promise, void 0, function(value2) {
            return enumerator._settledAt(FULFILLED, i, value2);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i, reason);
          });
        };
        return Enumerator2;
      })();
      function all(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray(entries)) {
          return new Constructor(function(_3, reject2) {
            return reject2(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve2, reject2) {
            var length = entries.length;
            for (var i = 0; i < length; i++) {
              Constructor.resolve(entries[i]).then(resolve2, reject2);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise = new Constructor(noop);
        reject(promise, reason);
        return promise;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = (function() {
        function Promise2(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = void 0;
          this._subscribers = [];
          if (noop !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise2.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise2.prototype.finally = function _finally(callback) {
          var promise = this;
          var constructor = promise.constructor;
          if (isFunction(callback)) {
            return promise.then(function(value2) {
              return constructor.resolve(callback()).then(function() {
                return value2;
              });
            }, function(reason) {
              return constructor.resolve(callback()).then(function() {
                throw reason;
              });
            });
          }
          return promise.then(callback, callback);
        };
        return Promise2;
      })();
      Promise$1.prototype.then = then;
      Promise$1.all = all;
      Promise$1.race = race;
      Promise$1.resolve = resolve$1;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") {
          local = global;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P3 = local.Promise;
        if (P3) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P3.resolve());
          } catch (e) {
          }
          if (promiseToString === "[object Promise]" && !P3.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    }));
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports4, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module.exports = exports4 = globalObject.fetch;
    if (globalObject.fetch) {
      exports4.default = globalObject.fetch.bind(globalObject);
    }
    exports4.Headers = globalObject.Headers;
    exports4.Request = globalObject.Request;
    exports4.Response = globalObject.Response;
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports4) {
    "use strict";
    function find2(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (hasOwn(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      if (oc && typeof oc.getOwnPropertyDescriptors === "function") {
        object = oc.create(null, oc.getOwnPropertyDescriptors(object));
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function hasOwn(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    function assign(target2, source) {
      if (target2 === null || typeof target2 !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (hasOwn(source, key)) {
          target2[key] = source[key];
        }
      }
      return target2;
    }
    var HTML_BOOLEAN_ATTRIBUTES = freeze({
      allowfullscreen: true,
      async: true,
      autofocus: true,
      autoplay: true,
      checked: true,
      controls: true,
      default: true,
      defer: true,
      disabled: true,
      formnovalidate: true,
      hidden: true,
      ismap: true,
      itemscope: true,
      loop: true,
      multiple: true,
      muted: true,
      nomodule: true,
      novalidate: true,
      open: true,
      playsinline: true,
      readonly: true,
      required: true,
      reversed: true,
      selected: true
    });
    function isHTMLBooleanAttribute(name) {
      return hasOwn(HTML_BOOLEAN_ATTRIBUTES, name.toLowerCase());
    }
    var HTML_VOID_ELEMENTS = freeze({
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    });
    function isHTMLVoidElement(tagName) {
      return hasOwn(HTML_VOID_ELEMENTS, tagName.toLowerCase());
    }
    var HTML_RAW_TEXT_ELEMENTS = freeze({
      script: false,
      style: false,
      textarea: true,
      title: true
    });
    function isHTMLRawTextElement(tagName) {
      var key = tagName.toLowerCase();
      return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && !HTML_RAW_TEXT_ELEMENTS[key];
    }
    function isHTMLEscapableRawTextElement(tagName) {
      var key = tagName.toLowerCase();
      return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && HTML_RAW_TEXT_ELEMENTS[key];
    }
    function isHTMLMimeType(mimeType) {
      return mimeType === MIME_TYPE.HTML;
    }
    function hasDefaultHTMLNamespace(mimeType) {
      return isHTMLMimeType(mimeType) || mimeType === MIME_TYPE.XML_XHTML_APPLICATION;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
       *      WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
       *      registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/xml`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
       *      registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var _MIME_TYPES = Object.keys(MIME_TYPE).map(function(key) {
      return MIME_TYPE[key];
    });
    function isValidMimeType(mimeType) {
      return _MIME_TYPES.indexOf(mimeType) > -1;
    }
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace.
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports4.assign = assign;
    exports4.find = find2;
    exports4.freeze = freeze;
    exports4.HTML_BOOLEAN_ATTRIBUTES = HTML_BOOLEAN_ATTRIBUTES;
    exports4.HTML_RAW_TEXT_ELEMENTS = HTML_RAW_TEXT_ELEMENTS;
    exports4.HTML_VOID_ELEMENTS = HTML_VOID_ELEMENTS;
    exports4.hasDefaultHTMLNamespace = hasDefaultHTMLNamespace;
    exports4.hasOwn = hasOwn;
    exports4.isHTMLBooleanAttribute = isHTMLBooleanAttribute;
    exports4.isHTMLRawTextElement = isHTMLRawTextElement;
    exports4.isHTMLEscapableRawTextElement = isHTMLEscapableRawTextElement;
    exports4.isHTMLMimeType = isHTMLMimeType;
    exports4.isHTMLVoidElement = isHTMLVoidElement;
    exports4.isValidMimeType = isValidMimeType;
    exports4.MIME_TYPE = MIME_TYPE;
    exports4.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@xmldom/xmldom/lib/errors.js"(exports4) {
    "use strict";
    var conventions = require_conventions();
    function extendError(constructor, writableName) {
      constructor.prototype = Object.create(Error.prototype, {
        constructor: { value: constructor },
        name: { value: constructor.name, enumerable: true, writable: writableName }
      });
    }
    var DOMExceptionName = conventions.freeze({
      /**
       * the default value as defined by the spec
       */
      Error: "Error",
      /**
       * @deprecated
       * Use RangeError instead.
       */
      IndexSizeError: "IndexSizeError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      DomstringSizeError: "DomstringSizeError",
      HierarchyRequestError: "HierarchyRequestError",
      WrongDocumentError: "WrongDocumentError",
      InvalidCharacterError: "InvalidCharacterError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      NoDataAllowedError: "NoDataAllowedError",
      NoModificationAllowedError: "NoModificationAllowedError",
      NotFoundError: "NotFoundError",
      NotSupportedError: "NotSupportedError",
      InUseAttributeError: "InUseAttributeError",
      InvalidStateError: "InvalidStateError",
      SyntaxError: "SyntaxError",
      InvalidModificationError: "InvalidModificationError",
      NamespaceError: "NamespaceError",
      /**
       * @deprecated
       * Use TypeError for invalid arguments,
       * "NotSupportedError" DOMException for unsupported operations,
       * and "NotAllowedError" DOMException for denied requests instead.
       */
      InvalidAccessError: "InvalidAccessError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      ValidationError: "ValidationError",
      /**
       * @deprecated
       * Use TypeError instead.
       */
      TypeMismatchError: "TypeMismatchError",
      SecurityError: "SecurityError",
      NetworkError: "NetworkError",
      AbortError: "AbortError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      URLMismatchError: "URLMismatchError",
      QuotaExceededError: "QuotaExceededError",
      TimeoutError: "TimeoutError",
      InvalidNodeTypeError: "InvalidNodeTypeError",
      DataCloneError: "DataCloneError",
      EncodingError: "EncodingError",
      NotReadableError: "NotReadableError",
      UnknownError: "UnknownError",
      ConstraintError: "ConstraintError",
      DataError: "DataError",
      TransactionInactiveError: "TransactionInactiveError",
      ReadOnlyError: "ReadOnlyError",
      VersionError: "VersionError",
      OperationError: "OperationError",
      NotAllowedError: "NotAllowedError",
      OptOutError: "OptOutError"
    });
    var DOMExceptionNames = Object.keys(DOMExceptionName);
    function isValidDomExceptionCode(value2) {
      return typeof value2 === "number" && value2 >= 1 && value2 <= 25;
    }
    function endsWithError(value2) {
      return typeof value2 === "string" && value2.substring(value2.length - DOMExceptionName.Error.length) === DOMExceptionName.Error;
    }
    function DOMException(messageOrCode, nameOrMessage) {
      if (isValidDomExceptionCode(messageOrCode)) {
        this.name = DOMExceptionNames[messageOrCode];
        this.message = nameOrMessage || "";
      } else {
        this.message = messageOrCode;
        this.name = endsWithError(nameOrMessage) ? nameOrMessage : DOMExceptionName.Error;
      }
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }
    extendError(DOMException, true);
    Object.defineProperties(DOMException.prototype, {
      code: {
        enumerable: true,
        get: function() {
          var code = DOMExceptionNames.indexOf(this.name);
          if (isValidDomExceptionCode(code)) return code;
          return 0;
        }
      }
    });
    var ExceptionCode = {
      INDEX_SIZE_ERR: 1,
      DOMSTRING_SIZE_ERR: 2,
      HIERARCHY_REQUEST_ERR: 3,
      WRONG_DOCUMENT_ERR: 4,
      INVALID_CHARACTER_ERR: 5,
      NO_DATA_ALLOWED_ERR: 6,
      NO_MODIFICATION_ALLOWED_ERR: 7,
      NOT_FOUND_ERR: 8,
      NOT_SUPPORTED_ERR: 9,
      INUSE_ATTRIBUTE_ERR: 10,
      INVALID_STATE_ERR: 11,
      SYNTAX_ERR: 12,
      INVALID_MODIFICATION_ERR: 13,
      NAMESPACE_ERR: 14,
      INVALID_ACCESS_ERR: 15,
      VALIDATION_ERR: 16,
      TYPE_MISMATCH_ERR: 17,
      SECURITY_ERR: 18,
      NETWORK_ERR: 19,
      ABORT_ERR: 20,
      URL_MISMATCH_ERR: 21,
      QUOTA_EXCEEDED_ERR: 22,
      TIMEOUT_ERR: 23,
      INVALID_NODE_TYPE_ERR: 24,
      DATA_CLONE_ERR: 25
    };
    var entries = Object.entries(ExceptionCode);
    for (i = 0; i < entries.length; i++) {
      key = entries[i][0];
      DOMException[key] = entries[i][1];
    }
    var key;
    var i;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    extendError(ParseError);
    exports4.DOMException = DOMException;
    exports4.DOMExceptionName = DOMExceptionName;
    exports4.ExceptionCode = ExceptionCode;
    exports4.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/@xmldom/xmldom/lib/grammar.js"(exports4) {
    "use strict";
    function detectUnicodeSupport(RegExpImpl) {
      try {
        if (typeof RegExpImpl !== "function") {
          RegExpImpl = RegExp;
        }
        var match2 = new RegExpImpl("ðŒ†", "u").exec("ðŒ†");
        return !!match2 && match2[0].length === 2;
      } catch (error) {
      }
      return false;
    }
    var UNICODE_SUPPORT = detectUnicodeSupport();
    function chars(regexp) {
      if (regexp.source[0] !== "[") {
        throw new Error(regexp + " can not be used with chars");
      }
      return regexp.source.slice(1, regexp.source.lastIndexOf("]"));
    }
    function chars_without(regexp, search) {
      if (regexp.source[0] !== "[") {
        throw new Error("/" + regexp.source + "/ can not be used with chars_without");
      }
      if (!search || typeof search !== "string") {
        throw new Error(JSON.stringify(search) + " is not a valid search");
      }
      if (regexp.source.indexOf(search) === -1) {
        throw new Error('"' + search + '" is not is /' + regexp.source + "/");
      }
      if (search === "-" && regexp.source.indexOf(search) !== 1) {
        throw new Error('"' + search + '" is not at the first postion of /' + regexp.source + "/");
      }
      return new RegExp(regexp.source.replace(search, ""), UNICODE_SUPPORT ? "u" : "");
    }
    function reg(args) {
      var self2 = this;
      return new RegExp(
        Array.prototype.slice.call(arguments).map(function(part) {
          var isStr = typeof part === "string";
          if (isStr && self2 === void 0 && part === "|") {
            throw new Error("use regg instead of reg to wrap expressions with `|`!");
          }
          return isStr ? part : part.source;
        }).join(""),
        UNICODE_SUPPORT ? "mu" : "m"
      );
    }
    function regg(args) {
      if (arguments.length === 0) {
        throw new Error("no parameters provided");
      }
      return reg.apply(regg, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
    }
    var UNICODE_REPLACEMENT_CHARACTER = "ï¿½";
    var Char = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
    if (UNICODE_SUPPORT) {
      Char = reg("[", chars(Char), "\\u{10000}-\\u{10FFFF}", "]");
    }
    var _SChar = /[\x20\x09\x0D\x0A]/;
    var SChar_s = chars(_SChar);
    var S3 = reg(_SChar, "+");
    var S_OPT = reg(_SChar, "*");
    var NameStartChar = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    if (UNICODE_SUPPORT) {
      NameStartChar = reg("[", chars(NameStartChar), "\\u{10000}-\\u{10FFFF}", "]");
    }
    var NameStartChar_s = chars(NameStartChar);
    var NameChar = reg("[", NameStartChar_s, chars(/[-.0-9\xB7]/), chars(/[\u0300-\u036F\u203F-\u2040]/), "]");
    var Name = reg(NameStartChar, NameChar, "*");
    var Nmtoken = reg(NameChar, "+");
    var EntityRef = reg("&", Name, ";");
    var CharRef = regg(/&#[0-9]+;|&#x[0-9a-fA-F]+;/);
    var Reference = regg(EntityRef, "|", CharRef);
    var PEReference = reg("%", Name, ";");
    var EntityValue = regg(
      reg('"', regg(/[^%&"]/, "|", PEReference, "|", Reference), "*", '"'),
      "|",
      reg("'", regg(/[^%&']/, "|", PEReference, "|", Reference), "*", "'")
    );
    var AttValue = regg('"', regg(/[^<&"]/, "|", Reference), "*", '"', "|", "'", regg(/[^<&']/, "|", Reference), "*", "'");
    var NCNameStartChar = chars_without(NameStartChar, ":");
    var NCNameChar = chars_without(NameChar, ":");
    var NCName = reg(NCNameStartChar, NCNameChar, "*");
    var QName = reg(NCName, regg(":", NCName), "?");
    var QName_exact = reg("^", QName, "$");
    var QName_group = reg("(", QName, ")");
    var SystemLiteral = regg(/"[^"]*"|'[^']*'/);
    var PI = reg(/^<\?/, "(", Name, ")", regg(S3, "(", Char, "*?)"), "?", /\?>/);
    var PubidChar = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/;
    var PubidLiteral = regg('"', PubidChar, '*"', "|", "'", chars_without(PubidChar, "'"), "*'");
    var COMMENT_START = "<!--";
    var COMMENT_END = "-->";
    var Comment = reg(COMMENT_START, regg(chars_without(Char, "-"), "|", reg("-", chars_without(Char, "-"))), "*", COMMENT_END);
    var PCDATA = "#PCDATA";
    var Mixed = regg(
      reg(/\(/, S_OPT, PCDATA, regg(S_OPT, /\|/, S_OPT, QName), "*", S_OPT, /\)\*/),
      "|",
      reg(/\(/, S_OPT, PCDATA, S_OPT, /\)/)
    );
    var _children_quantity = /[?*+]?/;
    var children = reg(
      /\([^>]+\)/,
      _children_quantity
      /*regg(choice, '|', seq), _children_quantity*/
    );
    var contentspec = regg("EMPTY", "|", "ANY", "|", Mixed, "|", children);
    var ELEMENTDECL_START = "<!ELEMENT";
    var elementdecl = reg(ELEMENTDECL_START, S3, regg(QName, "|", PEReference), S3, regg(contentspec, "|", PEReference), S_OPT, ">");
    var NotationType = reg("NOTATION", S3, /\(/, S_OPT, Name, regg(S_OPT, /\|/, S_OPT, Name), "*", S_OPT, /\)/);
    var Enumeration = reg(/\(/, S_OPT, Nmtoken, regg(S_OPT, /\|/, S_OPT, Nmtoken), "*", S_OPT, /\)/);
    var EnumeratedType = regg(NotationType, "|", Enumeration);
    var AttType = regg(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", EnumeratedType);
    var DefaultDecl = regg(/#REQUIRED|#IMPLIED/, "|", regg(regg("#FIXED", S3), "?", AttValue));
    var AttDef = regg(S3, Name, S3, AttType, S3, DefaultDecl);
    var ATTLIST_DECL_START = "<!ATTLIST";
    var AttlistDecl = reg(ATTLIST_DECL_START, S3, Name, AttDef, "*", S_OPT, ">");
    var ABOUT_LEGACY_COMPAT = "about:legacy-compat";
    var ABOUT_LEGACY_COMPAT_SystemLiteral = regg('"' + ABOUT_LEGACY_COMPAT + '"', "|", "'" + ABOUT_LEGACY_COMPAT + "'");
    var SYSTEM = "SYSTEM";
    var PUBLIC = "PUBLIC";
    var ExternalID = regg(regg(SYSTEM, S3, SystemLiteral), "|", regg(PUBLIC, S3, PubidLiteral, S3, SystemLiteral));
    var ExternalID_match = reg(
      "^",
      regg(
        regg(SYSTEM, S3, "(?<SystemLiteralOnly>", SystemLiteral, ")"),
        "|",
        regg(PUBLIC, S3, "(?<PubidLiteral>", PubidLiteral, ")", S3, "(?<SystemLiteral>", SystemLiteral, ")")
      )
    );
    var NDataDecl = regg(S3, "NDATA", S3, Name);
    var EntityDef = regg(EntityValue, "|", regg(ExternalID, NDataDecl, "?"));
    var ENTITY_DECL_START = "<!ENTITY";
    var GEDecl = reg(ENTITY_DECL_START, S3, Name, S3, EntityDef, S_OPT, ">");
    var PEDef = regg(EntityValue, "|", ExternalID);
    var PEDecl = reg(ENTITY_DECL_START, S3, "%", S3, Name, S3, PEDef, S_OPT, ">");
    var EntityDecl = regg(GEDecl, "|", PEDecl);
    var PublicID = reg(PUBLIC, S3, PubidLiteral);
    var NotationDecl = reg("<!NOTATION", S3, Name, S3, regg(ExternalID, "|", PublicID), S_OPT, ">");
    var Eq = reg(S_OPT, "=", S_OPT);
    var VersionNum = /1[.]\d+/;
    var VersionInfo = reg(S3, "version", Eq, regg("'", VersionNum, "'", "|", '"', VersionNum, '"'));
    var EncName = /[A-Za-z][-A-Za-z0-9._]*/;
    var EncodingDecl = regg(S3, "encoding", Eq, regg('"', EncName, '"', "|", "'", EncName, "'"));
    var SDDecl = regg(S3, "standalone", Eq, regg("'", regg("yes", "|", "no"), "'", "|", '"', regg("yes", "|", "no"), '"'));
    var XMLDecl = reg(/^<\?xml/, VersionInfo, EncodingDecl, "?", SDDecl, "?", S_OPT, /\?>/);
    var DOCTYPE_DECL_START = "<!DOCTYPE";
    var CDATA_START = "<![CDATA[";
    var CDATA_END = "]]>";
    var CDStart = /<!\[CDATA\[/;
    var CDEnd = /\]\]>/;
    var CData = reg(Char, "*?", CDEnd);
    var CDSect = reg(CDStart, CData);
    exports4.chars = chars;
    exports4.chars_without = chars_without;
    exports4.detectUnicodeSupport = detectUnicodeSupport;
    exports4.reg = reg;
    exports4.regg = regg;
    exports4.ABOUT_LEGACY_COMPAT = ABOUT_LEGACY_COMPAT;
    exports4.ABOUT_LEGACY_COMPAT_SystemLiteral = ABOUT_LEGACY_COMPAT_SystemLiteral;
    exports4.AttlistDecl = AttlistDecl;
    exports4.CDATA_START = CDATA_START;
    exports4.CDATA_END = CDATA_END;
    exports4.CDSect = CDSect;
    exports4.Char = Char;
    exports4.Comment = Comment;
    exports4.COMMENT_START = COMMENT_START;
    exports4.COMMENT_END = COMMENT_END;
    exports4.DOCTYPE_DECL_START = DOCTYPE_DECL_START;
    exports4.elementdecl = elementdecl;
    exports4.EntityDecl = EntityDecl;
    exports4.EntityValue = EntityValue;
    exports4.ExternalID = ExternalID;
    exports4.ExternalID_match = ExternalID_match;
    exports4.Name = Name;
    exports4.NotationDecl = NotationDecl;
    exports4.Reference = Reference;
    exports4.PEReference = PEReference;
    exports4.PI = PI;
    exports4.PUBLIC = PUBLIC;
    exports4.PubidLiteral = PubidLiteral;
    exports4.QName = QName;
    exports4.QName_exact = QName_exact;
    exports4.QName_group = QName_group;
    exports4.S = S3;
    exports4.SChar_s = SChar_s;
    exports4.S_OPT = S_OPT;
    exports4.SYSTEM = SYSTEM;
    exports4.SystemLiteral = SystemLiteral;
    exports4.UNICODE_REPLACEMENT_CHARACTER = UNICODE_REPLACEMENT_CHARACTER;
    exports4.UNICODE_SUPPORT = UNICODE_SUPPORT;
    exports4.XMLDecl = XMLDecl;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports4) {
    "use strict";
    var conventions = require_conventions();
    var find2 = conventions.find;
    var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    var hasOwn = conventions.hasOwn;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
    var isHTMLVoidElement = conventions.isHTMLVoidElement;
    var MIME_TYPE = conventions.MIME_TYPE;
    var NAMESPACE = conventions.NAMESPACE;
    var PDC = Symbol();
    var errors = require_errors();
    var DOMException = errors.DOMException;
    var DOMExceptionName = errors.DOMExceptionName;
    var g = require_grammar();
    function checkSymbol(symbol) {
      if (symbol !== PDC) {
        throw new TypeError("Illegal constructor");
      }
    }
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!hasOwn(current, element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function validateQualifiedName(qualifiedName) {
      if (!g.QName_exact.test(qualifiedName)) {
        throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + qualifiedName + '"');
      }
    }
    function validateAndExtract(namespace, qualifiedName) {
      validateQualifiedName(qualifiedName);
      namespace = namespace || null;
      var prefix = null;
      var localName = qualifiedName;
      if (qualifiedName.indexOf(":") >= 0) {
        var splitResult = qualifiedName.split(":");
        prefix = splitResult[0];
        localName = splitResult[1];
      }
      if (prefix !== null && namespace === null) {
        throw new DOMException(DOMException.NAMESPACE_ERR, "prefix is non-null and namespace is null");
      }
      if (prefix === "xml" && namespace !== conventions.NAMESPACE.XML) {
        throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
      }
      if ((prefix === "xmlns" || qualifiedName === "xmlns") && namespace !== conventions.NAMESPACE.XMLNS) {
        throw new DOMException(
          DOMException.NAMESPACE_ERR,
          'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
        );
      }
      if (namespace === conventions.NAMESPACE.XMLNS && prefix !== "xmlns" && qualifiedName !== "xmlns") {
        throw new DOMException(
          DOMException.NAMESPACE_ERR,
          'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
        );
      }
      return [namespace, prefix, localName];
    }
    function copy(src, dest) {
      for (var p2 in src) {
        if (hasOwn(src, p2)) {
          dest[p2] = src[p2];
        }
      }
    }
    function _extends2(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t = function() {
        };
        t.prototype = Super.prototype;
        t = new t();
        copy(pt, t);
        Class.prototype = pt = t;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var DocumentPosition = conventions.freeze({
      DOCUMENT_POSITION_DISCONNECTED: 1,
      DOCUMENT_POSITION_PRECEDING: 2,
      DOCUMENT_POSITION_FOLLOWING: 4,
      DOCUMENT_POSITION_CONTAINS: 8,
      DOCUMENT_POSITION_CONTAINED_BY: 16,
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
    });
    function commonAncestor(a2, b3) {
      if (b3.length < a2.length) return commonAncestor(b3, a2);
      var c = null;
      for (var n in a2) {
        if (a2[n] !== b3[n]) return c;
        c = a2[n];
      }
      return c;
    }
    function docGUID(doc) {
      if (!doc.guid) doc.guid = Math.random();
      return doc.guid;
    }
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1
       * inclusive.
       *
       * @type {number}
       */
      length: 0,
      /**
       * Returns the item at `index`. If index is greater than or equal to the number of nodes in
       * the list, this returns null.
       *
       * @param index
       * Unsigned long Index into the collection.
       * @returns {Node | null}
       * The node at position `index` in the NodeList,
       * or null if that is not a valid index.
       */
      item: function(index2) {
        return index2 >= 0 && index2 < this.length ? this[index2] : null;
      },
      /**
       * Returns a string representation of the NodeList.
       *
       * @param {unknown} nodeFilter
       * __A filter function? Not implemented according to the spec?__.
       * @returns {string}
       * A string representation of the NodeList.
       */
      toString: function(nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * Filters the NodeList based on a predicate.
       *
       * @param {function(Node): boolean} predicate
       * - A predicate function to filter the NodeList.
       * @returns {Node[]}
       * An array of nodes that satisfy the predicate.
       * @private
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
       * not present.
       *
       * @param {Node} item
       * - The Node item to locate in the NodeList.
       * @returns {number}
       * The first index of the node in the NodeList; -1 if not found.
       * @private
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    NodeList.prototype[Symbol.iterator] = function() {
      var me2 = this;
      var index2 = 0;
      return {
        next: function() {
          if (index2 < me2.length) {
            return {
              value: me2[index2++],
              done: false
            };
          } else {
            return {
              done: true
            };
          }
        },
        return: function() {
          return {
            done: true
          };
        }
      };
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (hasOwn(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends2(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = 0;
      while (i < list.length) {
        if (list[i] === node) {
          return i;
        }
        i++;
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length] = newAttr;
        list.length++;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i <= lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
          }
          attr.ownerElement = null;
        }
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      /**
       * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
       * document.
       *
       * @param {string} localName
       * The local name of the attribute.
       * @returns {Attr | null}
       * The attribute with the given local name, or null if no such attribute exists.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
       */
      getNamedItem: function(localName) {
        if (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {
          localName = localName.toLowerCase();
        }
        var i = 0;
        while (i < this.length) {
          var attr = this[i];
          if (attr.nodeName === localName) {
            return attr;
          }
          i++;
        }
        return null;
      },
      /**
       * Set an attribute.
       *
       * @param {Attr} attr
       * The attribute to set.
       * @returns {Attr | null}
       * The old attribute with the same local name and namespace URI as the new one, or null if no
       * such attribute exists.
       * @throws {DOMException}
       * With code:
       * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
       * element.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
       */
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el !== this._ownerElement) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        if (oldAttr === attr) {
          return attr;
        }
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /**
       * Set an attribute, replacing an existing attribute with the same local name and namespace
       * URI if one exists.
       *
       * @param {Attr} attr
       * The attribute to set.
       * @returns {Attr | null}
       * The old attribute with the same local name and namespace URI as the new one, or null if no
       * such attribute exists.
       * @throws {DOMException}
       * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
       * attribute of another element.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
       */
      setNamedItemNS: function(attr) {
        return this.setNamedItem(attr);
      },
      /**
       * Removes an attribute specified by the local name.
       *
       * @param {string} localName
       * The local name of the attribute to be removed.
       * @returns {Attr}
       * The attribute node that was removed.
       * @throws {DOMException}
       * With code:
       * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
       * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
       */
      removeNamedItem: function(localName) {
        var attr = this.getNamedItem(localName);
        if (!attr) {
          throw new DOMException(DOMException.NOT_FOUND_ERR, localName);
        }
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      /**
       * Removes an attribute specified by the namespace and local name.
       *
       * @param {string | null} namespaceURI
       * The namespace URI of the attribute to be removed.
       * @param {string} localName
       * The local name of the attribute to be removed.
       * @returns {Attr}
       * The attribute node that was removed.
       * @throws {DOMException}
       * With code:
       * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
       * name is found.
       * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
       */
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        if (!attr) {
          throw new DOMException(DOMException.NOT_FOUND_ERR, namespaceURI ? namespaceURI + " : " + localName : localName);
        }
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      /**
       * Get an attribute by namespace and local name.
       *
       * @param {string | null} namespaceURI
       * The namespace URI of the attribute.
       * @param {string} localName
       * The local name of the attribute.
       * @returns {Attr | null}
       * The attribute with the given namespace URI and local name, or null if no such attribute
       * exists.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
       */
      getNamedItemNS: function(namespaceURI, localName) {
        if (!namespaceURI) {
          namespaceURI = null;
        }
        var i = 0;
        while (i < this.length) {
          var node = this[i];
          if (node.localName === localName && node.namespaceURI === namespaceURI) {
            return node;
          }
          i++;
        }
        return null;
      }
    };
    NamedNodeMap.prototype[Symbol.iterator] = function() {
      var me2 = this;
      var index2 = 0;
      return {
        next: function() {
          if (index2 < me2.length) {
            return {
              value: me2[index2++],
              done: false
            };
          } else {
            return {
              done: true
            };
          }
        },
        return: function() {
          return {
            done: true
          };
        }
      };
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * Test if the DOM implementation implements a specific feature and version, as specified in
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
       *
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
       * feature is supported. The different implementations fairly diverged in what kind of
       * features were reported. The latest version of the spec settled to force this method to
       * always return true, where the functionality was accurate and in use.
       *
       * @deprecated
       * It is deprecated and modern browsers return true in all cases.
       * @function DOMImplementation#hasFeature
       * @param {string} feature
       * The name of the feature to test.
       * @param {string} [version]
       * This is the version number of the feature to test.
       * @returns {boolean}
       * Always returns true.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
       */
      hasFeature: function(feature, version3) {
        return true;
      },
      /**
       * Creates a DOM Document object of the specified type with its document element. Note that
       * based on the {@link DocumentType}
       * given to create the document, the implementation may instantiate specialized
       * {@link Document} objects that support additional features than the "Core", such as "HTML"
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
       * On the other hand, setting the {@link DocumentType} after the document was created makes
       * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
       * such as createHTMLDocument
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
       * can be used to obtain specific types of {@link Document} objects.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document`
       * instance (with it's `type` set to `'xml'`).
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       *
       * @function DOMImplementation.createDocument
       * @param {string | null} namespaceURI
       * The
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
       * of the document element to create or null.
       * @param {string | null} qualifiedName
       * The
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
       * of the document element to be created or null.
       * @param {DocumentType | null} [doctype=null]
       * The type of document to be created or null. When doctype is not null, its
       * {@link Node#ownerDocument} attribute is set to the document being created. Default is
       * `null`
       * @returns {Document}
       * A new {@link Document} object with its document element. If the NamespaceURI,
       * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
       * document element.
       * @throws {DOMException}
       * With code:
       *
       * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
       * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
       * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
       * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
       * is different from null, or if the qualifiedName has a prefix that is "xml" and the
       * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
       * or if the DOM implementation does not support the "XML" feature but a non-null namespace
       * URI was provided, since namespaces were defined by XML.
       * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
       * or was created from a different implementation.
       * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
       * "XML" and the language exposed through the Document does not support XML Namespaces (such
       * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
       * @since DOM Level 2.
       * @see {@link #createHTMLDocument}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
       *      Level 3 Core
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
       *      Level 2 Core (initial)
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var contentType = MIME_TYPE.XML_APPLICATION;
        if (namespaceURI === NAMESPACE.HTML) {
          contentType = MIME_TYPE.XML_XHTML_APPLICATION;
        } else if (namespaceURI === NAMESPACE.SVG) {
          contentType = MIME_TYPE.XML_SVG_IMAGE;
        }
        var doc = new Document(PDC, { contentType });
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Creates an empty DocumentType node. Entity declarations and notations are not made
       * available. Entity reference expansions and default attribute additions do not occur.
       *
       * **This behavior is slightly different from the one in the specs**:
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - `publicId` and `systemId` contain the raw data including any possible quotes,
       *   so they can always be serialized back to the original value
       * - `internalSubset` contains the raw string between `[` and `]` if present,
       *   but is not parsed or validated in any form.
       *
       * @function DOMImplementation#createDocumentType
       * @param {string} qualifiedName
       * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
       * name} of the document type to be created.
       * @param {string} [publicId]
       * The external subset public identifier.
       * @param {string} [systemId]
       * The external subset system identifier.
       * @param {string} [internalSubset]
       * the internal subset or an empty string if it is not present
       * @returns {DocumentType}
       * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
       * @throws {DOMException}
       * With code:
       *
       * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
       * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
       * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
       * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
       * "XML" and the language exposed through the Document does not support XML Namespaces (such
       * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
       * @since DOM Level 2.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
       *      MDN
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
       *      Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
       *      Level 3 Core
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
       *      Level 2 Core
       * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
       * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
       * @prettierignore
       */
      createDocumentType: function(qualifiedName, publicId, systemId, internalSubset) {
        validateQualifiedName(qualifiedName);
        var node = new DocumentType(PDC);
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        node.internalSubset = internalSubset || "";
        node.childNodes = new NodeList();
        return node;
      },
      /**
       * Returns an HTML document, that might already have a basic DOM structure.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
       * omitted)
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       *
       * @param {string | false} [title]
       * A string containing the title to give the new HTML document.
       * @returns {Document}
       * The HTML document.
       * @since WHATWG Living Standard.
       * @see {@link #createDocument}
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
       * @see https://dom.spec.whatwg.org/#html-document
       */
      createHTMLDocument: function(title3) {
        var doc = new Document(PDC, { contentType: MIME_TYPE.HTML });
        doc.implementation = this;
        doc.childNodes = new NodeList();
        if (title3 !== false) {
          doc.doctype = this.createDocumentType("html");
          doc.doctype.ownerDocument = doc;
          doc.appendChild(doc.doctype);
          var htmlNode = doc.createElement("html");
          doc.appendChild(htmlNode);
          var headNode = doc.createElement("head");
          htmlNode.appendChild(headNode);
          if (typeof title3 === "string") {
            var titleNode = doc.createElement("title");
            titleNode.appendChild(doc.createTextNode(title3));
            headNode.appendChild(titleNode);
          }
          htmlNode.appendChild(doc.createElement("body"));
        }
        return doc;
      }
    };
    function Node2(symbol) {
      checkSymbol(symbol);
    }
    Node2.prototype = {
      /**
       * The first child of this node.
       *
       * @type {Node | null}
       */
      firstChild: null,
      /**
       * The last child of this node.
       *
       * @type {Node | null}
       */
      lastChild: null,
      /**
       * The previous sibling of this node.
       *
       * @type {Node | null}
       */
      previousSibling: null,
      /**
       * The next sibling of this node.
       *
       * @type {Node | null}
       */
      nextSibling: null,
      /**
       * The parent node of this node.
       *
       * @type {Node | null}
       */
      parentNode: null,
      /**
       * The parent element of this node.
       *
       * @type {Element | null}
       */
      get parentElement() {
        return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
      },
      /**
       * The child nodes of this node.
       *
       * @type {NodeList}
       */
      childNodes: null,
      /**
       * The document object associated with this node.
       *
       * @type {Document | null}
       */
      ownerDocument: null,
      /**
       * The value of this node.
       *
       * @type {string | null}
       */
      nodeValue: null,
      /**
       * The namespace URI of this node.
       *
       * @type {string | null}
       */
      namespaceURI: null,
      /**
       * The prefix of the namespace for this node.
       *
       * @type {string | null}
       */
      prefix: null,
      /**
       * The local part of the qualified name of this node.
       *
       * @type {string | null}
       */
      localName: null,
      /**
       * The baseURI is currently always `about:blank`,
       * since that's what happens when you create a document from scratch.
       *
       * @type {'about:blank'}
       */
      baseURI: "about:blank",
      /**
       * Is true if this node is part of a document.
       *
       * @type {boolean}
       */
      get isConnected() {
        var rootNode = this.getRootNode();
        return rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;
      },
      /**
       * Checks whether `other` is an inclusive descendant of this node.
       *
       * @param {Node | null | undefined} other
       * The node to check.
       * @returns {boolean}
       * True if `other` is an inclusive descendant of this node; false otherwise.
       * @see https://dom.spec.whatwg.org/#dom-node-contains
       */
      contains: function(other) {
        if (!other) return false;
        var parent = other;
        do {
          if (this === parent) return true;
          parent = other.parentNode;
        } while (parent);
        return false;
      },
      /**
       * @typedef GetRootNodeOptions
       * @property {boolean} [composed=false]
       */
      /**
       * Searches for the root node of this node.
       *
       * **This behavior is slightly different from the in the specs**:
       * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
       *
       * @param {GetRootNodeOptions} [options]
       * @returns {Node}
       * Root node.
       * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
       * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
       */
      getRootNode: function(options) {
        var parent = this;
        do {
          if (!parent.parentNode) {
            return parent;
          }
          parent = parent.parentNode;
        } while (parent);
      },
      /**
       * Checks whether the given node is equal to this node.
       *
       * @param {Node} [otherNode]
       * @see https://dom.spec.whatwg.org/#concept-node-equals
       */
      isEqualNode: function(otherNode) {
        if (!otherNode) return false;
        if (this.nodeType !== otherNode.nodeType) return false;
        switch (this.nodeType) {
          case this.DOCUMENT_TYPE_NODE:
            if (this.name !== otherNode.name) return false;
            if (this.publicId !== otherNode.publicId) return false;
            if (this.systemId !== otherNode.systemId) return false;
            break;
          case this.ELEMENT_NODE:
            if (this.namespaceURI !== otherNode.namespaceURI) return false;
            if (this.prefix !== otherNode.prefix) return false;
            if (this.localName !== otherNode.localName) return false;
            if (this.attributes.length !== otherNode.attributes.length) return false;
            for (var i = 0; i < this.attributes.length; i++) {
              var attr = this.attributes.item(i);
              if (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {
                return false;
              }
            }
            break;
          case this.ATTRIBUTE_NODE:
            if (this.namespaceURI !== otherNode.namespaceURI) return false;
            if (this.localName !== otherNode.localName) return false;
            if (this.value !== otherNode.value) return false;
            break;
          case this.PROCESSING_INSTRUCTION_NODE:
            if (this.target !== otherNode.target || this.data !== otherNode.data) {
              return false;
            }
            break;
          case this.TEXT_NODE:
          case this.COMMENT_NODE:
            if (this.data !== otherNode.data) return false;
            break;
        }
        if (this.childNodes.length !== otherNode.childNodes.length) {
          return false;
        }
        for (var i = 0; i < this.childNodes.length; i++) {
          if (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {
            return false;
          }
        }
        return true;
      },
      /**
       * Checks whether or not the given node is this node.
       *
       * @param {Node} [otherNode]
       */
      isSameNode: function(otherNode) {
        return this === otherNode;
      },
      /**
       * Inserts a node before a reference node as a child of this node.
       *
       * @param {Node} newChild
       * The new child node to be inserted.
       * @param {Node | null} refChild
       * The reference node before which newChild will be inserted.
       * @returns {Node}
       * The new child node successfully inserted.
       * @throws {DOMException}
       * Throws a DOMException if inserting the node would result in a DOM tree that is not
       * well-formed, or if `child` is provided but is not a child of `parent`.
       * See {@link _insertBefore} for more details.
       * @since Modified in DOM L2
       */
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      /**
       * Replaces an old child node with a new child node within this node.
       *
       * @param {Node} newChild
       * The new node that is to replace the old node.
       * If it already exists in the DOM, it is removed from its original position.
       * @param {Node} oldChild
       * The existing child node to be replaced.
       * @returns {Node}
       * Returns the replaced child node.
       * @throws {DOMException}
       * Throws a DOMException if replacing the node would result in a DOM tree that is not
       * well-formed, or if `oldChild` is not a child of `this`.
       * This can also occur if the pre-replacement validity assertion fails.
       * See {@link _insertBefore}, {@link Node.removeChild}, and
       * {@link assertPreReplacementValidityInDocument} for more details.
       * @see https://dom.spec.whatwg.org/#concept-node-replace
       */
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      /**
       * Removes an existing child node from this node.
       *
       * @param {Node} oldChild
       * The child node to be removed.
       * @returns {Node}
       * Returns the removed child node.
       * @throws {DOMException}
       * Throws a DOMException if `oldChild` is not a child of `this`.
       * See {@link _removeChild} for more details.
       */
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      /**
       * Appends a child node to this node.
       *
       * @param {Node} newChild
       * The child node to be appended to this node.
       * If it already exists in the DOM, it is removed from its original position.
       * @returns {Node}
       * Returns the appended child node.
       * @throws {DOMException}
       * Throws a DOMException if appending the node would result in a DOM tree that is not
       * well-formed, or if `newChild` is not a valid Node.
       * See {@link insertBefore} for more details.
       */
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      /**
       * Determines whether this node has any child nodes.
       *
       * @returns {boolean}
       * Returns true if this node has any child nodes, and false otherwise.
       */
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      /**
       * Creates a copy of the calling node.
       *
       * @param {boolean} deep
       * If true, the contents of the node are recursively copied.
       * If false, only the node itself (and its attributes, if it is an element) are copied.
       * @returns {Node}
       * Returns the newly created copy of the node.
       * @throws {DOMException}
       * May throw a DOMException if operations within {@link Element#setAttributeNode} or
       * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
       * specific constraints.
       * @see {@link cloneNode}
       */
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      /**
       * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
       * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
       *
       * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
       * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
       * nodes.
       *
       * This method operates recursively, so it also normalizes any and all descendent nodes within
       * the subtree.
       *
       * @throws {DOMException}
       * May throw a DOMException if operations within removeChild or appendData (which are
       * potentially invoked in this method) do not meet their specific constraints.
       * @since Modified in DOM Level 2
       * @see {@link Node.removeChild}
       * @see {@link CharacterData.appendData}
       */
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      /**
       * Checks whether the DOM implementation implements a specific feature and its version.
       *
       * @deprecated
       * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
       * @param {string} feature
       * The package name of the feature to test. This is the same name that can be passed to the
       * method `hasFeature` on `DOMImplementation`.
       * @param {string} version
       * This is the version number of the package name to test.
       * @returns {boolean}
       * Returns true in all cases in the current implementation.
       * @since Introduced in DOM Level 2
       * @see {@link DOMImplementation.hasFeature}
       */
      isSupported: function(feature, version3) {
        return this.ownerDocument.implementation.hasFeature(feature, version3);
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} namespaceURI
       * The namespace URI for which to find the associated prefix.
       * @returns {string | null}
       * The associated prefix, if found; otherwise, null.
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       * @prettierignore
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (hasOwn(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      /**
       * This function is used to look up the namespace URI associated with the given prefix,
       * starting from this node.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} prefix
       * The prefix for which to find the associated namespace URI.
       * @returns {string | null}
       * The associated namespace URI, if found; otherwise, null.
       * @since DOM Level 3
       * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
       * @prettierignore
       */
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (hasOwn(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      /**
       * Determines whether the given namespace URI is the default namespace.
       *
       * The function works by looking up the prefix associated with the given namespace URI. If no
       * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
       * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
       * the default.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} namespaceURI
       * The namespace URI to be checked.
       * @returns {boolean}
       * Returns true if the given namespace URI is the default namespace, false otherwise.
       * @since DOM Level 3
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
       * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
       * @prettierignore
       */
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      },
      /**
       * Compares the reference node with a node with regard to their position in the document and
       * according to the document order.
       *
       * @param {Node} other
       * The node to compare the reference node to.
       * @returns {number}
       * Returns how the node is positioned relatively to the reference node according to the
       * bitmask. 0 if reference node and given node are the same.
       * @since DOM Level 3
       * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
       * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
       */
      compareDocumentPosition: function(other) {
        if (this === other) return 0;
        var node1 = other;
        var node2 = this;
        var attr1 = null;
        var attr2 = null;
        if (node1 instanceof Attr) {
          attr1 = node1;
          node1 = attr1.ownerElement;
        }
        if (node2 instanceof Attr) {
          attr2 = node2;
          node2 = attr2.ownerElement;
          if (attr1 && node1 && node2 === node1) {
            for (var i = 0, attr; attr = node2.attributes[i]; i++) {
              if (attr === attr1)
                return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
              if (attr === attr2)
                return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
            }
          }
        }
        if (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {
          return DocumentPosition.DOCUMENT_POSITION_DISCONNECTED + DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument) ? DocumentPosition.DOCUMENT_POSITION_FOLLOWING : DocumentPosition.DOCUMENT_POSITION_PRECEDING);
        }
        if (attr2 && node1 === node2) {
          return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
        }
        if (attr1 && node1 === node2) {
          return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
        }
        var chain1 = [];
        var ancestor1 = node1.parentNode;
        while (ancestor1) {
          if (!attr2 && ancestor1 === node2) {
            return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          }
          chain1.push(ancestor1);
          ancestor1 = ancestor1.parentNode;
        }
        chain1.reverse();
        var chain2 = [];
        var ancestor2 = node2.parentNode;
        while (ancestor2) {
          if (!attr1 && ancestor2 === node1) {
            return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
          }
          chain2.push(ancestor2);
          ancestor2 = ancestor2.parentNode;
        }
        chain2.reverse();
        var ca = commonAncestor(chain1, chain2);
        for (var n in ca.childNodes) {
          var child = ca.childNodes[n];
          if (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          if (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
          if (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          if (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
        }
        return 0;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node2);
    copy(NodeType, Node2.prototype);
    copy(DocumentPosition, Node2);
    copy(DocumentPosition, Node2.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document(symbol, options) {
      checkSymbol(symbol);
      var opt = options || {};
      this.ownerDocument = this;
      this.contentType = opt.contentType || MIME_TYPE.XML_APPLICATION;
      this.type = isHTMLMimeType(this.contentType) ? "html" : "xml";
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, parent, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var childNodes = parent.childNodes;
        if (newChild && !newChild.nextSibling) {
          childNodes[childNodes.length++] = newChild;
        } else {
          var child = parent.firstChild;
          var i = 0;
          while (child) {
            childNodes[i++] = child;
            child = child.nextSibling;
          }
          childNodes.length = i;
          delete childNodes[childNodes.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      if (parentNode !== child.parentNode) {
        throw new DOMException(DOMException.NOT_FOUND_ERR, "child's parent is not parent");
      }
      var oldPreviousSibling = child.previousSibling;
      var oldNextSibling = child.nextSibling;
      if (oldPreviousSibling) {
        oldPreviousSibling.nextSibling = oldNextSibling;
      } else {
        parentNode.firstChild = oldNextSibling;
      }
      if (oldNextSibling) {
        oldNextSibling.previousSibling = oldPreviousSibling;
      } else {
        parentNode.lastChild = oldPreviousSibling;
      }
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node2.DOCUMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (node.nodeType === Node2.CDATA_SECTION_NODE || node.nodeType === Node2.COMMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.DOCUMENT_TYPE_NODE || node.nodeType === Node2.ELEMENT_NODE || node.nodeType === Node2.PROCESSING_INSTRUCTION_NODE || node.nodeType === Node2.TEXT_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node2.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node2.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node2.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find2(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find2(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(DOMException.NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node2.DOCUMENT_NODE
      ) {
        throw new DOMException(
          DOMException.HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find2(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        if (find2(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node2.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent, node);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    Document.prototype = {
      /**
       * The implementation that created this document.
       *
       * @type DOMImplementation
       * @readonly
       */
      implementation: null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @type DocumentType
       * @readonly
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        var removed = _removeChild(this, oldChild);
        if (removed === this.documentElement) {
          this.documentElement = null;
        }
        return removed;
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * Creates a new `Element` that is owned by this `Document`.
       * In HTML Documents `localName` is the lower cased `tagName`,
       * otherwise no transformation is being applied.
       * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
       *
       * __This implementation differs from the specification:__ - The provided name is not checked
       * against the `Name` production,
       * so no related error will be thrown.
       * - There is no interface `HTMLElement`, it is always an `Element`.
       * - There is no support for a second argument to indicate using custom elements.
       *
       * @param {string} tagName
       * @returns {Element}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
       * @see https://dom.spec.whatwg.org/#dom-document-createelement
       * @see https://dom.spec.whatwg.org/#concept-create-element
       */
      createElement: function(tagName) {
        var node = new Element(PDC);
        node.ownerDocument = this;
        if (this.type === "html") {
          tagName = tagName.toLowerCase();
        }
        if (hasDefaultHTMLNamespace(this.contentType)) {
          node.namespaceURI = NAMESPACE.HTML;
        }
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      /**
       * @returns {DocumentFragment}
       */
      createDocumentFragment: function() {
        var node = new DocumentFragment(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      /**
       * @param {string} data
       * @returns {Text}
       */
      createTextNode: function(data) {
        var node = new Text(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} data
       * @returns {Comment}
       */
      createComment: function(data) {
        var node = new Comment(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} data
       * @returns {CDATASection}
       */
      createCDATASection: function(data) {
        var node = new CDATASection(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} target
       * @param {string} data
       * @returns {ProcessingInstruction}
       */
      createProcessingInstruction: function(target2, data) {
        var node = new ProcessingInstruction(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = node.target = target2;
        node.nodeValue = node.data = data;
        return node;
      },
      /**
       * Creates an `Attr` node that is owned by this document.
       * In HTML Documents `localName` is the lower cased `name`,
       * otherwise no transformation is being applied.
       *
       * __This implementation differs from the specification:__ - The provided name is not checked
       * against the `Name` production,
       * so no related error will be thrown.
       *
       * @param {string} name
       * @returns {Attr}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
       * @see https://dom.spec.whatwg.org/#dom-document-createattribute
       */
      createAttribute: function(name) {
        if (!g.QName_exact.test(name)) {
          throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in name "' + name + '"');
        }
        if (this.type === "html") {
          name = name.toLowerCase();
        }
        return this._createAttribute(name);
      },
      _createAttribute: function(name) {
        var node = new Attr(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      /**
       * Creates an EntityReference object.
       * The current implementation does not fill the `childNodes` with those of the corresponding
       * `Entity`
       *
       * @deprecated
       * In DOM Level 4.
       * @param {string} name
       * The name of the entity to reference. No namespace well-formedness checks are performed.
       * @returns {EntityReference}
       * @throws {DOMException}
       * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
       * @throws {DOMException}
       * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
       */
      createEntityReference: function(name) {
        if (!g.Name.test(name)) {
          throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'not a valid xml name "' + name + '"');
        }
        if (this.type === "html") {
          throw new DOMException("document is an html document", DOMExceptionName.NotSupportedError);
        }
        var node = new EntityReference(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      /**
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @returns {Element}
       */
      createElementNS: function(namespaceURI, qualifiedName) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var node = new Element(PDC);
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = validated[0];
        node.prefix = validated[1];
        node.localName = validated[2];
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      /**
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @returns {Attr}
       */
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var node = new Attr(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.specified = true;
        node.namespaceURI = validated[0];
        node.prefix = validated[1];
        node.localName = validated[2];
        return node;
      }
    };
    _extends2(Document, Node2);
    function Element(symbol) {
      checkSymbol(symbol);
      this._nsMap = /* @__PURE__ */ Object.create(null);
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      /**
       * The attributes of this element.
       *
       * @type {NamedNodeMap | null}
       */
      attributes: null,
      getQualifiedName: function() {
        return this.prefix ? this.prefix + ":" + this.localName : this.localName;
      },
      _isInHTMLDocumentAndNamespace: function() {
        return this.ownerDocument.type === "html" && this.namespaceURI === NAMESPACE.HTML;
      },
      /**
       * Implementaton of Level2 Core function hasAttributes.
       *
       * @returns {boolean}
       * True if attribute list is not empty.
       * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
       */
      hasAttributes: function() {
        return !!(this.attributes && this.attributes.length);
      },
      hasAttribute: function(name) {
        return !!this.getAttributeNode(name);
      },
      /**
       * Returns elementâ€™s first attribute whose qualified name is `name`, and `null`
       * if there is no such attribute.
       *
       * @param {string} name
       * @returns {string | null}
       */
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr ? attr.value : null;
      },
      getAttributeNode: function(name) {
        if (this._isInHTMLDocumentAndNamespace()) {
          name = name.toLowerCase();
        }
        return this.attributes.getNamedItem(name);
      },
      /**
       * Sets the value of elementâ€™s first attribute whose qualified name is qualifiedName to value.
       *
       * @param {string} name
       * @param {string} value
       */
      setAttribute: function(name, value2) {
        if (this._isInHTMLDocumentAndNamespace()) {
          name = name.toLowerCase();
        }
        var attr = this.getAttributeNode(name);
        if (attr) {
          attr.value = attr.nodeValue = "" + value2;
        } else {
          attr = this.ownerDocument._createAttribute(name);
          attr.value = attr.nodeValue = "" + value2;
          this.setAttributeNode(attr);
        }
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      /**
       * Returns elementâ€™s attribute whose namespace is `namespaceURI` and local name is
       * `localName`,
       * or `null` if there is no such attribute.
       *
       * @param {string} namespaceURI
       * @param {string} localName
       * @returns {string | null}
       */
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr ? attr.value : null;
      },
      /**
       * Sets the value of elementâ€™s attribute whose namespace is `namespaceURI` and local name is
       * `localName` to value.
       *
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @param {string} value
       * @see https://dom.spec.whatwg.org/#dom-element-setattributens
       */
      setAttributeNS: function(namespaceURI, qualifiedName, value2) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var localName = validated[2];
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        if (attr) {
          attr.value = attr.nodeValue = "" + value2;
        } else {
          attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value2;
          this.setAttributeNode(attr);
        }
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      /**
       * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classNames` is an empty string or only contains HTML white space
       * characters.
       *
       * Warning: This returns a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames
       * Is a string representing the class name(s) to match; multiple class names are separated by
       * (ASCII-)whitespace.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches2 = classNames === nodeClassNames;
                  if (!matches2) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches2 = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches2) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      /**
       * Returns a LiveNodeList of elements with the given qualifiedName.
       * Searching for all descendants can be done by passing `*` as `qualifiedName`.
       *
       * All descendants of the specified element are searched, but not the element itself.
       * The returned list is live, which means it updates itself with the DOM tree automatically.
       * Therefore, there is no need to call `Element.getElementsByTagName()`
       * with the same element and arguments repeatedly if the DOM changes in between calls.
       *
       * When called on an HTML element in an HTML document,
       * `getElementsByTagName` lower-cases the argument before searching for it.
       * This is undesirable when trying to match camel-cased SVG elements (such as
       * `<linearGradient>`) in an HTML document.
       * Instead, use `Element.getElementsByTagNameNS()`,
       * which preserves the capitalization of the tag name.
       *
       * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
       * except that it only searches for elements that are descendants of the specified element.
       *
       * @param {string} qualifiedName
       * @returns {LiveNodeList}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
       */
      getElementsByTagName: function(qualifiedName) {
        var isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === "html";
        var lowerQualifiedName = qualifiedName.toLowerCase();
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node === base || node.nodeType !== ELEMENT_NODE) {
              return;
            }
            if (qualifiedName === "*") {
              ls.push(node);
            } else {
              var nodeQualifiedName = node.getQualifiedName();
              var matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE.HTML ? lowerQualifiedName : qualifiedName;
              if (nodeQualifiedName === matchingQName) {
                ls.push(node);
              }
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByClassName = Element.prototype.getElementsByClassName;
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends2(Element, Node2);
    function Attr(symbol) {
      checkSymbol(symbol);
      this.namespaceURI = null;
      this.prefix = null;
      this.ownerElement = null;
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends2(Attr, Node2);
    function CharacterData(symbol) {
      checkSymbol(symbol);
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start2 = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start2 + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends2(CharacterData, Node2);
    function Text(symbol) {
      checkSymbol(symbol);
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends2(Text, CharacterData);
    function Comment(symbol) {
      checkSymbol(symbol);
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends2(Comment, CharacterData);
    function CDATASection(symbol) {
      checkSymbol(symbol);
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends2(CDATASection, Text);
    function DocumentType(symbol) {
      checkSymbol(symbol);
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends2(DocumentType, Node2);
    function Notation(symbol) {
      checkSymbol(symbol);
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends2(Notation, Node2);
    function Entity(symbol) {
      checkSymbol(symbol);
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends2(Entity, Node2);
    function EntityReference(symbol) {
      checkSymbol(symbol);
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends2(EntityReference, Node2);
    function DocumentFragment(symbol) {
      checkSymbol(symbol);
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends2(DocumentFragment, Node2);
    function ProcessingInstruction(symbol) {
      checkSymbol(symbol);
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends2(ProcessingInstruction, CharacterData);
    function XMLSerializer2() {
    }
    XMLSerializer2.prototype.serializeToString = function(node, nodeFilter) {
      return nodeSerializeToString.call(node, nodeFilter);
    };
    Node2.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(nodeFilter) {
      var buf = [];
      var refNode = this.nodeType === DOCUMENT_NODE && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value2) {
      buf.push(" ", qualifiedName, '="', value2.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      var doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;
      var isHTML = doc.type === "html";
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({
                prefix: attr.localName,
                namespace: attr.value
              });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          var canCloseTag = !child;
          if (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE.HTML)) {
            canCloseTag = isHTMLVoidElement(nodeName);
          }
          if (canCloseTag) {
            buf.push("/>");
          } else {
            buf.push(">");
            if (isHTML && isHTMLRawTextElement(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
        case CDATA_SECTION_NODE:
          return buf.push(g.CDATA_START, node.data, g.CDATA_END);
        case COMMENT_NODE:
          return buf.push(g.COMMENT_START, node.data, g.COMMENT_END);
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push(g.DOCTYPE_DECL_START, " ", node.name);
          if (pubid) {
            buf.push(" ", g.PUBLIC, " ", pubid);
            if (sysid && sysid !== ".") {
              buf.push(" ", sysid);
            }
          } else if (sysid && sysid !== ".") {
            buf.push(" ", g.SYSTEM, " ", sysid);
          }
          if (node.internalSubset) {
            buf.push(" [", node.internalSubset, "]");
          }
          buf.push(">");
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor(PDC);
      for (var n in node) {
        if (hasOwn(node, n)) {
          var v2 = node[n];
          if (typeof v2 != "object") {
            if (v2 != node2[n]) {
              node2[n] = v2;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value2) {
      object[key] = value2;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node2.prototype, "textContent", {
          get: function() {
            return getTextContent(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value2) {
          object["$$" + key] = value2;
        };
      }
    } catch (e) {
    }
    exports4._updateLiveList = _updateLiveList;
    exports4.Attr = Attr;
    exports4.CDATASection = CDATASection;
    exports4.CharacterData = CharacterData;
    exports4.Comment = Comment;
    exports4.Document = Document;
    exports4.DocumentFragment = DocumentFragment;
    exports4.DocumentType = DocumentType;
    exports4.DOMImplementation = DOMImplementation;
    exports4.Element = Element;
    exports4.Entity = Entity;
    exports4.EntityReference = EntityReference;
    exports4.LiveNodeList = LiveNodeList;
    exports4.NamedNodeMap = NamedNodeMap;
    exports4.Node = Node2;
    exports4.NodeList = NodeList;
    exports4.Notation = Notation;
    exports4.Text = Text;
    exports4.ProcessingInstruction = ProcessingInstruction;
    exports4.XMLSerializer = XMLSerializer2;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports4) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports4.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports4.HTML_ENTITIES = freeze({
      Aacute: "Ã",
      aacute: "Ã¡",
      Abreve: "Ä‚",
      abreve: "Äƒ",
      ac: "âˆ¾",
      acd: "âˆ¿",
      acE: "âˆ¾Ì³",
      Acirc: "Ã‚",
      acirc: "Ã¢",
      acute: "Â´",
      Acy: "Ð",
      acy: "Ð°",
      AElig: "Ã†",
      aelig: "Ã¦",
      af: "â¡",
      Afr: "ð”„",
      afr: "ð”ž",
      Agrave: "Ã€",
      agrave: "Ã ",
      alefsym: "â„µ",
      aleph: "â„µ",
      Alpha: "Î‘",
      alpha: "Î±",
      Amacr: "Ä€",
      amacr: "Ä",
      amalg: "â¨¿",
      AMP: "&",
      amp: "&",
      And: "â©“",
      and: "âˆ§",
      andand: "â©•",
      andd: "â©œ",
      andslope: "â©˜",
      andv: "â©š",
      ang: "âˆ ",
      ange: "â¦¤",
      angle: "âˆ ",
      angmsd: "âˆ¡",
      angmsdaa: "â¦¨",
      angmsdab: "â¦©",
      angmsdac: "â¦ª",
      angmsdad: "â¦«",
      angmsdae: "â¦¬",
      angmsdaf: "â¦­",
      angmsdag: "â¦®",
      angmsdah: "â¦¯",
      angrt: "âˆŸ",
      angrtvb: "âŠ¾",
      angrtvbd: "â¦",
      angsph: "âˆ¢",
      angst: "Ã…",
      angzarr: "â¼",
      Aogon: "Ä„",
      aogon: "Ä…",
      Aopf: "ð”¸",
      aopf: "ð•’",
      ap: "â‰ˆ",
      apacir: "â©¯",
      apE: "â©°",
      ape: "â‰Š",
      apid: "â‰‹",
      apos: "'",
      ApplyFunction: "â¡",
      approx: "â‰ˆ",
      approxeq: "â‰Š",
      Aring: "Ã…",
      aring: "Ã¥",
      Ascr: "ð’œ",
      ascr: "ð’¶",
      Assign: "â‰”",
      ast: "*",
      asymp: "â‰ˆ",
      asympeq: "â‰",
      Atilde: "Ãƒ",
      atilde: "Ã£",
      Auml: "Ã„",
      auml: "Ã¤",
      awconint: "âˆ³",
      awint: "â¨‘",
      backcong: "â‰Œ",
      backepsilon: "Ï¶",
      backprime: "â€µ",
      backsim: "âˆ½",
      backsimeq: "â‹",
      Backslash: "âˆ–",
      Barv: "â«§",
      barvee: "âŠ½",
      Barwed: "âŒ†",
      barwed: "âŒ…",
      barwedge: "âŒ…",
      bbrk: "âŽµ",
      bbrktbrk: "âŽ¶",
      bcong: "â‰Œ",
      Bcy: "Ð‘",
      bcy: "Ð±",
      bdquo: "â€ž",
      becaus: "âˆµ",
      Because: "âˆµ",
      because: "âˆµ",
      bemptyv: "â¦°",
      bepsi: "Ï¶",
      bernou: "â„¬",
      Bernoullis: "â„¬",
      Beta: "Î’",
      beta: "Î²",
      beth: "â„¶",
      between: "â‰¬",
      Bfr: "ð”…",
      bfr: "ð”Ÿ",
      bigcap: "â‹‚",
      bigcirc: "â—¯",
      bigcup: "â‹ƒ",
      bigodot: "â¨€",
      bigoplus: "â¨",
      bigotimes: "â¨‚",
      bigsqcup: "â¨†",
      bigstar: "â˜…",
      bigtriangledown: "â–½",
      bigtriangleup: "â–³",
      biguplus: "â¨„",
      bigvee: "â‹",
      bigwedge: "â‹€",
      bkarow: "â¤",
      blacklozenge: "â§«",
      blacksquare: "â–ª",
      blacktriangle: "â–´",
      blacktriangledown: "â–¾",
      blacktriangleleft: "â—‚",
      blacktriangleright: "â–¸",
      blank: "â£",
      blk12: "â–’",
      blk14: "â–‘",
      blk34: "â–“",
      block: "â–ˆ",
      bne: "=âƒ¥",
      bnequiv: "â‰¡âƒ¥",
      bNot: "â«­",
      bnot: "âŒ",
      Bopf: "ð”¹",
      bopf: "ð•“",
      bot: "âŠ¥",
      bottom: "âŠ¥",
      bowtie: "â‹ˆ",
      boxbox: "â§‰",
      boxDL: "â•—",
      boxDl: "â•–",
      boxdL: "â••",
      boxdl: "â”",
      boxDR: "â•”",
      boxDr: "â•“",
      boxdR: "â•’",
      boxdr: "â”Œ",
      boxH: "â•",
      boxh: "â”€",
      boxHD: "â•¦",
      boxHd: "â•¤",
      boxhD: "â•¥",
      boxhd: "â”¬",
      boxHU: "â•©",
      boxHu: "â•§",
      boxhU: "â•¨",
      boxhu: "â”´",
      boxminus: "âŠŸ",
      boxplus: "âŠž",
      boxtimes: "âŠ ",
      boxUL: "â•",
      boxUl: "â•œ",
      boxuL: "â•›",
      boxul: "â”˜",
      boxUR: "â•š",
      boxUr: "â•™",
      boxuR: "â•˜",
      boxur: "â””",
      boxV: "â•‘",
      boxv: "â”‚",
      boxVH: "â•¬",
      boxVh: "â•«",
      boxvH: "â•ª",
      boxvh: "â”¼",
      boxVL: "â•£",
      boxVl: "â•¢",
      boxvL: "â•¡",
      boxvl: "â”¤",
      boxVR: "â• ",
      boxVr: "â•Ÿ",
      boxvR: "â•ž",
      boxvr: "â”œ",
      bprime: "â€µ",
      Breve: "Ë˜",
      breve: "Ë˜",
      brvbar: "Â¦",
      Bscr: "â„¬",
      bscr: "ð’·",
      bsemi: "â",
      bsim: "âˆ½",
      bsime: "â‹",
      bsol: "\\",
      bsolb: "â§…",
      bsolhsub: "âŸˆ",
      bull: "â€¢",
      bullet: "â€¢",
      bump: "â‰Ž",
      bumpE: "âª®",
      bumpe: "â‰",
      Bumpeq: "â‰Ž",
      bumpeq: "â‰",
      Cacute: "Ä†",
      cacute: "Ä‡",
      Cap: "â‹’",
      cap: "âˆ©",
      capand: "â©„",
      capbrcup: "â©‰",
      capcap: "â©‹",
      capcup: "â©‡",
      capdot: "â©€",
      CapitalDifferentialD: "â……",
      caps: "âˆ©ï¸€",
      caret: "â",
      caron: "Ë‡",
      Cayleys: "â„­",
      ccaps: "â©",
      Ccaron: "ÄŒ",
      ccaron: "Ä",
      Ccedil: "Ã‡",
      ccedil: "Ã§",
      Ccirc: "Äˆ",
      ccirc: "Ä‰",
      Cconint: "âˆ°",
      ccups: "â©Œ",
      ccupssm: "â©",
      Cdot: "ÄŠ",
      cdot: "Ä‹",
      cedil: "Â¸",
      Cedilla: "Â¸",
      cemptyv: "â¦²",
      cent: "Â¢",
      CenterDot: "Â·",
      centerdot: "Â·",
      Cfr: "â„­",
      cfr: "ð” ",
      CHcy: "Ð§",
      chcy: "Ñ‡",
      check: "âœ“",
      checkmark: "âœ“",
      Chi: "Î§",
      chi: "Ï‡",
      cir: "â—‹",
      circ: "Ë†",
      circeq: "â‰—",
      circlearrowleft: "â†º",
      circlearrowright: "â†»",
      circledast: "âŠ›",
      circledcirc: "âŠš",
      circleddash: "âŠ",
      CircleDot: "âŠ™",
      circledR: "Â®",
      circledS: "â“ˆ",
      CircleMinus: "âŠ–",
      CirclePlus: "âŠ•",
      CircleTimes: "âŠ—",
      cirE: "â§ƒ",
      cire: "â‰—",
      cirfnint: "â¨",
      cirmid: "â«¯",
      cirscir: "â§‚",
      ClockwiseContourIntegral: "âˆ²",
      CloseCurlyDoubleQuote: "â€",
      CloseCurlyQuote: "â€™",
      clubs: "â™£",
      clubsuit: "â™£",
      Colon: "âˆ·",
      colon: ":",
      Colone: "â©´",
      colone: "â‰”",
      coloneq: "â‰”",
      comma: ",",
      commat: "@",
      comp: "âˆ",
      compfn: "âˆ˜",
      complement: "âˆ",
      complexes: "â„‚",
      cong: "â‰…",
      congdot: "â©­",
      Congruent: "â‰¡",
      Conint: "âˆ¯",
      conint: "âˆ®",
      ContourIntegral: "âˆ®",
      Copf: "â„‚",
      copf: "ð•”",
      coprod: "âˆ",
      Coproduct: "âˆ",
      COPY: "Â©",
      copy: "Â©",
      copysr: "â„—",
      CounterClockwiseContourIntegral: "âˆ³",
      crarr: "â†µ",
      Cross: "â¨¯",
      cross: "âœ—",
      Cscr: "ð’ž",
      cscr: "ð’¸",
      csub: "â«",
      csube: "â«‘",
      csup: "â«",
      csupe: "â«’",
      ctdot: "â‹¯",
      cudarrl: "â¤¸",
      cudarrr: "â¤µ",
      cuepr: "â‹ž",
      cuesc: "â‹Ÿ",
      cularr: "â†¶",
      cularrp: "â¤½",
      Cup: "â‹“",
      cup: "âˆª",
      cupbrcap: "â©ˆ",
      CupCap: "â‰",
      cupcap: "â©†",
      cupcup: "â©Š",
      cupdot: "âŠ",
      cupor: "â©…",
      cups: "âˆªï¸€",
      curarr: "â†·",
      curarrm: "â¤¼",
      curlyeqprec: "â‹ž",
      curlyeqsucc: "â‹Ÿ",
      curlyvee: "â‹Ž",
      curlywedge: "â‹",
      curren: "Â¤",
      curvearrowleft: "â†¶",
      curvearrowright: "â†·",
      cuvee: "â‹Ž",
      cuwed: "â‹",
      cwconint: "âˆ²",
      cwint: "âˆ±",
      cylcty: "âŒ­",
      Dagger: "â€¡",
      dagger: "â€ ",
      daleth: "â„¸",
      Darr: "â†¡",
      dArr: "â‡“",
      darr: "â†“",
      dash: "â€",
      Dashv: "â«¤",
      dashv: "âŠ£",
      dbkarow: "â¤",
      dblac: "Ë",
      Dcaron: "ÄŽ",
      dcaron: "Ä",
      Dcy: "Ð”",
      dcy: "Ð´",
      DD: "â……",
      dd: "â…†",
      ddagger: "â€¡",
      ddarr: "â‡Š",
      DDotrahd: "â¤‘",
      ddotseq: "â©·",
      deg: "Â°",
      Del: "âˆ‡",
      Delta: "Î”",
      delta: "Î´",
      demptyv: "â¦±",
      dfisht: "â¥¿",
      Dfr: "ð”‡",
      dfr: "ð”¡",
      dHar: "â¥¥",
      dharl: "â‡ƒ",
      dharr: "â‡‚",
      DiacriticalAcute: "Â´",
      DiacriticalDot: "Ë™",
      DiacriticalDoubleAcute: "Ë",
      DiacriticalGrave: "`",
      DiacriticalTilde: "Ëœ",
      diam: "â‹„",
      Diamond: "â‹„",
      diamond: "â‹„",
      diamondsuit: "â™¦",
      diams: "â™¦",
      die: "Â¨",
      DifferentialD: "â…†",
      digamma: "Ï",
      disin: "â‹²",
      div: "Ã·",
      divide: "Ã·",
      divideontimes: "â‹‡",
      divonx: "â‹‡",
      DJcy: "Ð‚",
      djcy: "Ñ’",
      dlcorn: "âŒž",
      dlcrop: "âŒ",
      dollar: "$",
      Dopf: "ð”»",
      dopf: "ð••",
      Dot: "Â¨",
      dot: "Ë™",
      DotDot: "âƒœ",
      doteq: "â‰",
      doteqdot: "â‰‘",
      DotEqual: "â‰",
      dotminus: "âˆ¸",
      dotplus: "âˆ”",
      dotsquare: "âŠ¡",
      doublebarwedge: "âŒ†",
      DoubleContourIntegral: "âˆ¯",
      DoubleDot: "Â¨",
      DoubleDownArrow: "â‡“",
      DoubleLeftArrow: "â‡",
      DoubleLeftRightArrow: "â‡”",
      DoubleLeftTee: "â«¤",
      DoubleLongLeftArrow: "âŸ¸",
      DoubleLongLeftRightArrow: "âŸº",
      DoubleLongRightArrow: "âŸ¹",
      DoubleRightArrow: "â‡’",
      DoubleRightTee: "âŠ¨",
      DoubleUpArrow: "â‡‘",
      DoubleUpDownArrow: "â‡•",
      DoubleVerticalBar: "âˆ¥",
      DownArrow: "â†“",
      Downarrow: "â‡“",
      downarrow: "â†“",
      DownArrowBar: "â¤“",
      DownArrowUpArrow: "â‡µ",
      DownBreve: "Ì‘",
      downdownarrows: "â‡Š",
      downharpoonleft: "â‡ƒ",
      downharpoonright: "â‡‚",
      DownLeftRightVector: "â¥",
      DownLeftTeeVector: "â¥ž",
      DownLeftVector: "â†½",
      DownLeftVectorBar: "â¥–",
      DownRightTeeVector: "â¥Ÿ",
      DownRightVector: "â‡",
      DownRightVectorBar: "â¥—",
      DownTee: "âŠ¤",
      DownTeeArrow: "â†§",
      drbkarow: "â¤",
      drcorn: "âŒŸ",
      drcrop: "âŒŒ",
      Dscr: "ð’Ÿ",
      dscr: "ð’¹",
      DScy: "Ð…",
      dscy: "Ñ•",
      dsol: "â§¶",
      Dstrok: "Ä",
      dstrok: "Ä‘",
      dtdot: "â‹±",
      dtri: "â–¿",
      dtrif: "â–¾",
      duarr: "â‡µ",
      duhar: "â¥¯",
      dwangle: "â¦¦",
      DZcy: "Ð",
      dzcy: "ÑŸ",
      dzigrarr: "âŸ¿",
      Eacute: "Ã‰",
      eacute: "Ã©",
      easter: "â©®",
      Ecaron: "Äš",
      ecaron: "Ä›",
      ecir: "â‰–",
      Ecirc: "ÃŠ",
      ecirc: "Ãª",
      ecolon: "â‰•",
      Ecy: "Ð­",
      ecy: "Ñ",
      eDDot: "â©·",
      Edot: "Ä–",
      eDot: "â‰‘",
      edot: "Ä—",
      ee: "â…‡",
      efDot: "â‰’",
      Efr: "ð”ˆ",
      efr: "ð”¢",
      eg: "âªš",
      Egrave: "Ãˆ",
      egrave: "Ã¨",
      egs: "âª–",
      egsdot: "âª˜",
      el: "âª™",
      Element: "âˆˆ",
      elinters: "â§",
      ell: "â„“",
      els: "âª•",
      elsdot: "âª—",
      Emacr: "Ä’",
      emacr: "Ä“",
      empty: "âˆ…",
      emptyset: "âˆ…",
      EmptySmallSquare: "â—»",
      emptyv: "âˆ…",
      EmptyVerySmallSquare: "â–«",
      emsp: "â€ƒ",
      emsp13: "â€„",
      emsp14: "â€…",
      ENG: "ÅŠ",
      eng: "Å‹",
      ensp: "â€‚",
      Eogon: "Ä˜",
      eogon: "Ä™",
      Eopf: "ð”¼",
      eopf: "ð•–",
      epar: "â‹•",
      eparsl: "â§£",
      eplus: "â©±",
      epsi: "Îµ",
      Epsilon: "Î•",
      epsilon: "Îµ",
      epsiv: "Ïµ",
      eqcirc: "â‰–",
      eqcolon: "â‰•",
      eqsim: "â‰‚",
      eqslantgtr: "âª–",
      eqslantless: "âª•",
      Equal: "â©µ",
      equals: "=",
      EqualTilde: "â‰‚",
      equest: "â‰Ÿ",
      Equilibrium: "â‡Œ",
      equiv: "â‰¡",
      equivDD: "â©¸",
      eqvparsl: "â§¥",
      erarr: "â¥±",
      erDot: "â‰“",
      Escr: "â„°",
      escr: "â„¯",
      esdot: "â‰",
      Esim: "â©³",
      esim: "â‰‚",
      Eta: "Î—",
      eta: "Î·",
      ETH: "Ã",
      eth: "Ã°",
      Euml: "Ã‹",
      euml: "Ã«",
      euro: "â‚¬",
      excl: "!",
      exist: "âˆƒ",
      Exists: "âˆƒ",
      expectation: "â„°",
      ExponentialE: "â…‡",
      exponentiale: "â…‡",
      fallingdotseq: "â‰’",
      Fcy: "Ð¤",
      fcy: "Ñ„",
      female: "â™€",
      ffilig: "ï¬ƒ",
      fflig: "ï¬€",
      ffllig: "ï¬„",
      Ffr: "ð”‰",
      ffr: "ð”£",
      filig: "ï¬",
      FilledSmallSquare: "â—¼",
      FilledVerySmallSquare: "â–ª",
      fjlig: "fj",
      flat: "â™­",
      fllig: "ï¬‚",
      fltns: "â–±",
      fnof: "Æ’",
      Fopf: "ð”½",
      fopf: "ð•—",
      ForAll: "âˆ€",
      forall: "âˆ€",
      fork: "â‹”",
      forkv: "â«™",
      Fouriertrf: "â„±",
      fpartint: "â¨",
      frac12: "Â½",
      frac13: "â…“",
      frac14: "Â¼",
      frac15: "â…•",
      frac16: "â…™",
      frac18: "â…›",
      frac23: "â…”",
      frac25: "â…–",
      frac34: "Â¾",
      frac35: "â…—",
      frac38: "â…œ",
      frac45: "â…˜",
      frac56: "â…š",
      frac58: "â…",
      frac78: "â…ž",
      frasl: "â„",
      frown: "âŒ¢",
      Fscr: "â„±",
      fscr: "ð’»",
      gacute: "Çµ",
      Gamma: "Î“",
      gamma: "Î³",
      Gammad: "Ïœ",
      gammad: "Ï",
      gap: "âª†",
      Gbreve: "Äž",
      gbreve: "ÄŸ",
      Gcedil: "Ä¢",
      Gcirc: "Äœ",
      gcirc: "Ä",
      Gcy: "Ð“",
      gcy: "Ð³",
      Gdot: "Ä ",
      gdot: "Ä¡",
      gE: "â‰§",
      ge: "â‰¥",
      gEl: "âªŒ",
      gel: "â‹›",
      geq: "â‰¥",
      geqq: "â‰§",
      geqslant: "â©¾",
      ges: "â©¾",
      gescc: "âª©",
      gesdot: "âª€",
      gesdoto: "âª‚",
      gesdotol: "âª„",
      gesl: "â‹›ï¸€",
      gesles: "âª”",
      Gfr: "ð”Š",
      gfr: "ð”¤",
      Gg: "â‹™",
      gg: "â‰«",
      ggg: "â‹™",
      gimel: "â„·",
      GJcy: "Ðƒ",
      gjcy: "Ñ“",
      gl: "â‰·",
      gla: "âª¥",
      glE: "âª’",
      glj: "âª¤",
      gnap: "âªŠ",
      gnapprox: "âªŠ",
      gnE: "â‰©",
      gne: "âªˆ",
      gneq: "âªˆ",
      gneqq: "â‰©",
      gnsim: "â‹§",
      Gopf: "ð”¾",
      gopf: "ð•˜",
      grave: "`",
      GreaterEqual: "â‰¥",
      GreaterEqualLess: "â‹›",
      GreaterFullEqual: "â‰§",
      GreaterGreater: "âª¢",
      GreaterLess: "â‰·",
      GreaterSlantEqual: "â©¾",
      GreaterTilde: "â‰³",
      Gscr: "ð’¢",
      gscr: "â„Š",
      gsim: "â‰³",
      gsime: "âªŽ",
      gsiml: "âª",
      Gt: "â‰«",
      GT: ">",
      gt: ">",
      gtcc: "âª§",
      gtcir: "â©º",
      gtdot: "â‹—",
      gtlPar: "â¦•",
      gtquest: "â©¼",
      gtrapprox: "âª†",
      gtrarr: "â¥¸",
      gtrdot: "â‹—",
      gtreqless: "â‹›",
      gtreqqless: "âªŒ",
      gtrless: "â‰·",
      gtrsim: "â‰³",
      gvertneqq: "â‰©ï¸€",
      gvnE: "â‰©ï¸€",
      Hacek: "Ë‡",
      hairsp: "â€Š",
      half: "Â½",
      hamilt: "â„‹",
      HARDcy: "Ðª",
      hardcy: "ÑŠ",
      hArr: "â‡”",
      harr: "â†”",
      harrcir: "â¥ˆ",
      harrw: "â†­",
      Hat: "^",
      hbar: "â„",
      Hcirc: "Ä¤",
      hcirc: "Ä¥",
      hearts: "â™¥",
      heartsuit: "â™¥",
      hellip: "â€¦",
      hercon: "âŠ¹",
      Hfr: "â„Œ",
      hfr: "ð”¥",
      HilbertSpace: "â„‹",
      hksearow: "â¤¥",
      hkswarow: "â¤¦",
      hoarr: "â‡¿",
      homtht: "âˆ»",
      hookleftarrow: "â†©",
      hookrightarrow: "â†ª",
      Hopf: "â„",
      hopf: "ð•™",
      horbar: "â€•",
      HorizontalLine: "â”€",
      Hscr: "â„‹",
      hscr: "ð’½",
      hslash: "â„",
      Hstrok: "Ä¦",
      hstrok: "Ä§",
      HumpDownHump: "â‰Ž",
      HumpEqual: "â‰",
      hybull: "âƒ",
      hyphen: "â€",
      Iacute: "Ã",
      iacute: "Ã­",
      ic: "â£",
      Icirc: "ÃŽ",
      icirc: "Ã®",
      Icy: "Ð˜",
      icy: "Ð¸",
      Idot: "Ä°",
      IEcy: "Ð•",
      iecy: "Ðµ",
      iexcl: "Â¡",
      iff: "â‡”",
      Ifr: "â„‘",
      ifr: "ð”¦",
      Igrave: "ÃŒ",
      igrave: "Ã¬",
      ii: "â…ˆ",
      iiiint: "â¨Œ",
      iiint: "âˆ­",
      iinfin: "â§œ",
      iiota: "â„©",
      IJlig: "Ä²",
      ijlig: "Ä³",
      Im: "â„‘",
      Imacr: "Äª",
      imacr: "Ä«",
      image: "â„‘",
      ImaginaryI: "â…ˆ",
      imagline: "â„",
      imagpart: "â„‘",
      imath: "Ä±",
      imof: "âŠ·",
      imped: "Æµ",
      Implies: "â‡’",
      in: "âˆˆ",
      incare: "â„…",
      infin: "âˆž",
      infintie: "â§",
      inodot: "Ä±",
      Int: "âˆ¬",
      int: "âˆ«",
      intcal: "âŠº",
      integers: "â„¤",
      Integral: "âˆ«",
      intercal: "âŠº",
      Intersection: "â‹‚",
      intlarhk: "â¨—",
      intprod: "â¨¼",
      InvisibleComma: "â£",
      InvisibleTimes: "â¢",
      IOcy: "Ð",
      iocy: "Ñ‘",
      Iogon: "Ä®",
      iogon: "Ä¯",
      Iopf: "ð•€",
      iopf: "ð•š",
      Iota: "Î™",
      iota: "Î¹",
      iprod: "â¨¼",
      iquest: "Â¿",
      Iscr: "â„",
      iscr: "ð’¾",
      isin: "âˆˆ",
      isindot: "â‹µ",
      isinE: "â‹¹",
      isins: "â‹´",
      isinsv: "â‹³",
      isinv: "âˆˆ",
      it: "â¢",
      Itilde: "Ä¨",
      itilde: "Ä©",
      Iukcy: "Ð†",
      iukcy: "Ñ–",
      Iuml: "Ã",
      iuml: "Ã¯",
      Jcirc: "Ä´",
      jcirc: "Äµ",
      Jcy: "Ð™",
      jcy: "Ð¹",
      Jfr: "ð”",
      jfr: "ð”§",
      jmath: "È·",
      Jopf: "ð•",
      jopf: "ð•›",
      Jscr: "ð’¥",
      jscr: "ð’¿",
      Jsercy: "Ðˆ",
      jsercy: "Ñ˜",
      Jukcy: "Ð„",
      jukcy: "Ñ”",
      Kappa: "Îš",
      kappa: "Îº",
      kappav: "Ï°",
      Kcedil: "Ä¶",
      kcedil: "Ä·",
      Kcy: "Ðš",
      kcy: "Ðº",
      Kfr: "ð”Ž",
      kfr: "ð”¨",
      kgreen: "Ä¸",
      KHcy: "Ð¥",
      khcy: "Ñ…",
      KJcy: "ÐŒ",
      kjcy: "Ñœ",
      Kopf: "ð•‚",
      kopf: "ð•œ",
      Kscr: "ð’¦",
      kscr: "ð“€",
      lAarr: "â‡š",
      Lacute: "Ä¹",
      lacute: "Äº",
      laemptyv: "â¦´",
      lagran: "â„’",
      Lambda: "Î›",
      lambda: "Î»",
      Lang: "âŸª",
      lang: "âŸ¨",
      langd: "â¦‘",
      langle: "âŸ¨",
      lap: "âª…",
      Laplacetrf: "â„’",
      laquo: "Â«",
      Larr: "â†ž",
      lArr: "â‡",
      larr: "â†",
      larrb: "â‡¤",
      larrbfs: "â¤Ÿ",
      larrfs: "â¤",
      larrhk: "â†©",
      larrlp: "â†«",
      larrpl: "â¤¹",
      larrsim: "â¥³",
      larrtl: "â†¢",
      lat: "âª«",
      lAtail: "â¤›",
      latail: "â¤™",
      late: "âª­",
      lates: "âª­ï¸€",
      lBarr: "â¤Ž",
      lbarr: "â¤Œ",
      lbbrk: "â²",
      lbrace: "{",
      lbrack: "[",
      lbrke: "â¦‹",
      lbrksld: "â¦",
      lbrkslu: "â¦",
      Lcaron: "Ä½",
      lcaron: "Ä¾",
      Lcedil: "Ä»",
      lcedil: "Ä¼",
      lceil: "âŒˆ",
      lcub: "{",
      Lcy: "Ð›",
      lcy: "Ð»",
      ldca: "â¤¶",
      ldquo: "â€œ",
      ldquor: "â€ž",
      ldrdhar: "â¥§",
      ldrushar: "â¥‹",
      ldsh: "â†²",
      lE: "â‰¦",
      le: "â‰¤",
      LeftAngleBracket: "âŸ¨",
      LeftArrow: "â†",
      Leftarrow: "â‡",
      leftarrow: "â†",
      LeftArrowBar: "â‡¤",
      LeftArrowRightArrow: "â‡†",
      leftarrowtail: "â†¢",
      LeftCeiling: "âŒˆ",
      LeftDoubleBracket: "âŸ¦",
      LeftDownTeeVector: "â¥¡",
      LeftDownVector: "â‡ƒ",
      LeftDownVectorBar: "â¥™",
      LeftFloor: "âŒŠ",
      leftharpoondown: "â†½",
      leftharpoonup: "â†¼",
      leftleftarrows: "â‡‡",
      LeftRightArrow: "â†”",
      Leftrightarrow: "â‡”",
      leftrightarrow: "â†”",
      leftrightarrows: "â‡†",
      leftrightharpoons: "â‡‹",
      leftrightsquigarrow: "â†­",
      LeftRightVector: "â¥Ž",
      LeftTee: "âŠ£",
      LeftTeeArrow: "â†¤",
      LeftTeeVector: "â¥š",
      leftthreetimes: "â‹‹",
      LeftTriangle: "âŠ²",
      LeftTriangleBar: "â§",
      LeftTriangleEqual: "âŠ´",
      LeftUpDownVector: "â¥‘",
      LeftUpTeeVector: "â¥ ",
      LeftUpVector: "â†¿",
      LeftUpVectorBar: "â¥˜",
      LeftVector: "â†¼",
      LeftVectorBar: "â¥’",
      lEg: "âª‹",
      leg: "â‹š",
      leq: "â‰¤",
      leqq: "â‰¦",
      leqslant: "â©½",
      les: "â©½",
      lescc: "âª¨",
      lesdot: "â©¿",
      lesdoto: "âª",
      lesdotor: "âªƒ",
      lesg: "â‹šï¸€",
      lesges: "âª“",
      lessapprox: "âª…",
      lessdot: "â‹–",
      lesseqgtr: "â‹š",
      lesseqqgtr: "âª‹",
      LessEqualGreater: "â‹š",
      LessFullEqual: "â‰¦",
      LessGreater: "â‰¶",
      lessgtr: "â‰¶",
      LessLess: "âª¡",
      lesssim: "â‰²",
      LessSlantEqual: "â©½",
      LessTilde: "â‰²",
      lfisht: "â¥¼",
      lfloor: "âŒŠ",
      Lfr: "ð”",
      lfr: "ð”©",
      lg: "â‰¶",
      lgE: "âª‘",
      lHar: "â¥¢",
      lhard: "â†½",
      lharu: "â†¼",
      lharul: "â¥ª",
      lhblk: "â–„",
      LJcy: "Ð‰",
      ljcy: "Ñ™",
      Ll: "â‹˜",
      ll: "â‰ª",
      llarr: "â‡‡",
      llcorner: "âŒž",
      Lleftarrow: "â‡š",
      llhard: "â¥«",
      lltri: "â—º",
      Lmidot: "Ä¿",
      lmidot: "Å€",
      lmoust: "âŽ°",
      lmoustache: "âŽ°",
      lnap: "âª‰",
      lnapprox: "âª‰",
      lnE: "â‰¨",
      lne: "âª‡",
      lneq: "âª‡",
      lneqq: "â‰¨",
      lnsim: "â‹¦",
      loang: "âŸ¬",
      loarr: "â‡½",
      lobrk: "âŸ¦",
      LongLeftArrow: "âŸµ",
      Longleftarrow: "âŸ¸",
      longleftarrow: "âŸµ",
      LongLeftRightArrow: "âŸ·",
      Longleftrightarrow: "âŸº",
      longleftrightarrow: "âŸ·",
      longmapsto: "âŸ¼",
      LongRightArrow: "âŸ¶",
      Longrightarrow: "âŸ¹",
      longrightarrow: "âŸ¶",
      looparrowleft: "â†«",
      looparrowright: "â†¬",
      lopar: "â¦…",
      Lopf: "ð•ƒ",
      lopf: "ð•",
      loplus: "â¨­",
      lotimes: "â¨´",
      lowast: "âˆ—",
      lowbar: "_",
      LowerLeftArrow: "â†™",
      LowerRightArrow: "â†˜",
      loz: "â—Š",
      lozenge: "â—Š",
      lozf: "â§«",
      lpar: "(",
      lparlt: "â¦“",
      lrarr: "â‡†",
      lrcorner: "âŒŸ",
      lrhar: "â‡‹",
      lrhard: "â¥­",
      lrm: "â€Ž",
      lrtri: "âŠ¿",
      lsaquo: "â€¹",
      Lscr: "â„’",
      lscr: "ð“",
      Lsh: "â†°",
      lsh: "â†°",
      lsim: "â‰²",
      lsime: "âª",
      lsimg: "âª",
      lsqb: "[",
      lsquo: "â€˜",
      lsquor: "â€š",
      Lstrok: "Å",
      lstrok: "Å‚",
      Lt: "â‰ª",
      LT: "<",
      lt: "<",
      ltcc: "âª¦",
      ltcir: "â©¹",
      ltdot: "â‹–",
      lthree: "â‹‹",
      ltimes: "â‹‰",
      ltlarr: "â¥¶",
      ltquest: "â©»",
      ltri: "â—ƒ",
      ltrie: "âŠ´",
      ltrif: "â—‚",
      ltrPar: "â¦–",
      lurdshar: "â¥Š",
      luruhar: "â¥¦",
      lvertneqq: "â‰¨ï¸€",
      lvnE: "â‰¨ï¸€",
      macr: "Â¯",
      male: "â™‚",
      malt: "âœ ",
      maltese: "âœ ",
      Map: "â¤…",
      map: "â†¦",
      mapsto: "â†¦",
      mapstodown: "â†§",
      mapstoleft: "â†¤",
      mapstoup: "â†¥",
      marker: "â–®",
      mcomma: "â¨©",
      Mcy: "Ðœ",
      mcy: "Ð¼",
      mdash: "â€”",
      mDDot: "âˆº",
      measuredangle: "âˆ¡",
      MediumSpace: "âŸ",
      Mellintrf: "â„³",
      Mfr: "ð”",
      mfr: "ð”ª",
      mho: "â„§",
      micro: "Âµ",
      mid: "âˆ£",
      midast: "*",
      midcir: "â«°",
      middot: "Â·",
      minus: "âˆ’",
      minusb: "âŠŸ",
      minusd: "âˆ¸",
      minusdu: "â¨ª",
      MinusPlus: "âˆ“",
      mlcp: "â«›",
      mldr: "â€¦",
      mnplus: "âˆ“",
      models: "âŠ§",
      Mopf: "ð•„",
      mopf: "ð•ž",
      mp: "âˆ“",
      Mscr: "â„³",
      mscr: "ð“‚",
      mstpos: "âˆ¾",
      Mu: "Îœ",
      mu: "Î¼",
      multimap: "âŠ¸",
      mumap: "âŠ¸",
      nabla: "âˆ‡",
      Nacute: "Åƒ",
      nacute: "Å„",
      nang: "âˆ âƒ’",
      nap: "â‰‰",
      napE: "â©°Ì¸",
      napid: "â‰‹Ì¸",
      napos: "Å‰",
      napprox: "â‰‰",
      natur: "â™®",
      natural: "â™®",
      naturals: "â„•",
      nbsp: "Â ",
      nbump: "â‰ŽÌ¸",
      nbumpe: "â‰Ì¸",
      ncap: "â©ƒ",
      Ncaron: "Å‡",
      ncaron: "Åˆ",
      Ncedil: "Å…",
      ncedil: "Å†",
      ncong: "â‰‡",
      ncongdot: "â©­Ì¸",
      ncup: "â©‚",
      Ncy: "Ð",
      ncy: "Ð½",
      ndash: "â€“",
      ne: "â‰ ",
      nearhk: "â¤¤",
      neArr: "â‡—",
      nearr: "â†—",
      nearrow: "â†—",
      nedot: "â‰Ì¸",
      NegativeMediumSpace: "â€‹",
      NegativeThickSpace: "â€‹",
      NegativeThinSpace: "â€‹",
      NegativeVeryThinSpace: "â€‹",
      nequiv: "â‰¢",
      nesear: "â¤¨",
      nesim: "â‰‚Ì¸",
      NestedGreaterGreater: "â‰«",
      NestedLessLess: "â‰ª",
      NewLine: "\n",
      nexist: "âˆ„",
      nexists: "âˆ„",
      Nfr: "ð”‘",
      nfr: "ð”«",
      ngE: "â‰§Ì¸",
      nge: "â‰±",
      ngeq: "â‰±",
      ngeqq: "â‰§Ì¸",
      ngeqslant: "â©¾Ì¸",
      nges: "â©¾Ì¸",
      nGg: "â‹™Ì¸",
      ngsim: "â‰µ",
      nGt: "â‰«âƒ’",
      ngt: "â‰¯",
      ngtr: "â‰¯",
      nGtv: "â‰«Ì¸",
      nhArr: "â‡Ž",
      nharr: "â†®",
      nhpar: "â«²",
      ni: "âˆ‹",
      nis: "â‹¼",
      nisd: "â‹º",
      niv: "âˆ‹",
      NJcy: "ÐŠ",
      njcy: "Ñš",
      nlArr: "â‡",
      nlarr: "â†š",
      nldr: "â€¥",
      nlE: "â‰¦Ì¸",
      nle: "â‰°",
      nLeftarrow: "â‡",
      nleftarrow: "â†š",
      nLeftrightarrow: "â‡Ž",
      nleftrightarrow: "â†®",
      nleq: "â‰°",
      nleqq: "â‰¦Ì¸",
      nleqslant: "â©½Ì¸",
      nles: "â©½Ì¸",
      nless: "â‰®",
      nLl: "â‹˜Ì¸",
      nlsim: "â‰´",
      nLt: "â‰ªâƒ’",
      nlt: "â‰®",
      nltri: "â‹ª",
      nltrie: "â‹¬",
      nLtv: "â‰ªÌ¸",
      nmid: "âˆ¤",
      NoBreak: "â ",
      NonBreakingSpace: "Â ",
      Nopf: "â„•",
      nopf: "ð•Ÿ",
      Not: "â«¬",
      not: "Â¬",
      NotCongruent: "â‰¢",
      NotCupCap: "â‰­",
      NotDoubleVerticalBar: "âˆ¦",
      NotElement: "âˆ‰",
      NotEqual: "â‰ ",
      NotEqualTilde: "â‰‚Ì¸",
      NotExists: "âˆ„",
      NotGreater: "â‰¯",
      NotGreaterEqual: "â‰±",
      NotGreaterFullEqual: "â‰§Ì¸",
      NotGreaterGreater: "â‰«Ì¸",
      NotGreaterLess: "â‰¹",
      NotGreaterSlantEqual: "â©¾Ì¸",
      NotGreaterTilde: "â‰µ",
      NotHumpDownHump: "â‰ŽÌ¸",
      NotHumpEqual: "â‰Ì¸",
      notin: "âˆ‰",
      notindot: "â‹µÌ¸",
      notinE: "â‹¹Ì¸",
      notinva: "âˆ‰",
      notinvb: "â‹·",
      notinvc: "â‹¶",
      NotLeftTriangle: "â‹ª",
      NotLeftTriangleBar: "â§Ì¸",
      NotLeftTriangleEqual: "â‹¬",
      NotLess: "â‰®",
      NotLessEqual: "â‰°",
      NotLessGreater: "â‰¸",
      NotLessLess: "â‰ªÌ¸",
      NotLessSlantEqual: "â©½Ì¸",
      NotLessTilde: "â‰´",
      NotNestedGreaterGreater: "âª¢Ì¸",
      NotNestedLessLess: "âª¡Ì¸",
      notni: "âˆŒ",
      notniva: "âˆŒ",
      notnivb: "â‹¾",
      notnivc: "â‹½",
      NotPrecedes: "âŠ€",
      NotPrecedesEqual: "âª¯Ì¸",
      NotPrecedesSlantEqual: "â‹ ",
      NotReverseElement: "âˆŒ",
      NotRightTriangle: "â‹«",
      NotRightTriangleBar: "â§Ì¸",
      NotRightTriangleEqual: "â‹­",
      NotSquareSubset: "âŠÌ¸",
      NotSquareSubsetEqual: "â‹¢",
      NotSquareSuperset: "âŠÌ¸",
      NotSquareSupersetEqual: "â‹£",
      NotSubset: "âŠ‚âƒ’",
      NotSubsetEqual: "âŠˆ",
      NotSucceeds: "âŠ",
      NotSucceedsEqual: "âª°Ì¸",
      NotSucceedsSlantEqual: "â‹¡",
      NotSucceedsTilde: "â‰¿Ì¸",
      NotSuperset: "âŠƒâƒ’",
      NotSupersetEqual: "âŠ‰",
      NotTilde: "â‰",
      NotTildeEqual: "â‰„",
      NotTildeFullEqual: "â‰‡",
      NotTildeTilde: "â‰‰",
      NotVerticalBar: "âˆ¤",
      npar: "âˆ¦",
      nparallel: "âˆ¦",
      nparsl: "â«½âƒ¥",
      npart: "âˆ‚Ì¸",
      npolint: "â¨”",
      npr: "âŠ€",
      nprcue: "â‹ ",
      npre: "âª¯Ì¸",
      nprec: "âŠ€",
      npreceq: "âª¯Ì¸",
      nrArr: "â‡",
      nrarr: "â†›",
      nrarrc: "â¤³Ì¸",
      nrarrw: "â†Ì¸",
      nRightarrow: "â‡",
      nrightarrow: "â†›",
      nrtri: "â‹«",
      nrtrie: "â‹­",
      nsc: "âŠ",
      nsccue: "â‹¡",
      nsce: "âª°Ì¸",
      Nscr: "ð’©",
      nscr: "ð“ƒ",
      nshortmid: "âˆ¤",
      nshortparallel: "âˆ¦",
      nsim: "â‰",
      nsime: "â‰„",
      nsimeq: "â‰„",
      nsmid: "âˆ¤",
      nspar: "âˆ¦",
      nsqsube: "â‹¢",
      nsqsupe: "â‹£",
      nsub: "âŠ„",
      nsubE: "â«…Ì¸",
      nsube: "âŠˆ",
      nsubset: "âŠ‚âƒ’",
      nsubseteq: "âŠˆ",
      nsubseteqq: "â«…Ì¸",
      nsucc: "âŠ",
      nsucceq: "âª°Ì¸",
      nsup: "âŠ…",
      nsupE: "â«†Ì¸",
      nsupe: "âŠ‰",
      nsupset: "âŠƒâƒ’",
      nsupseteq: "âŠ‰",
      nsupseteqq: "â«†Ì¸",
      ntgl: "â‰¹",
      Ntilde: "Ã‘",
      ntilde: "Ã±",
      ntlg: "â‰¸",
      ntriangleleft: "â‹ª",
      ntrianglelefteq: "â‹¬",
      ntriangleright: "â‹«",
      ntrianglerighteq: "â‹­",
      Nu: "Î",
      nu: "Î½",
      num: "#",
      numero: "â„–",
      numsp: "â€‡",
      nvap: "â‰âƒ’",
      nVDash: "âŠ¯",
      nVdash: "âŠ®",
      nvDash: "âŠ­",
      nvdash: "âŠ¬",
      nvge: "â‰¥âƒ’",
      nvgt: ">âƒ’",
      nvHarr: "â¤„",
      nvinfin: "â§ž",
      nvlArr: "â¤‚",
      nvle: "â‰¤âƒ’",
      nvlt: "<âƒ’",
      nvltrie: "âŠ´âƒ’",
      nvrArr: "â¤ƒ",
      nvrtrie: "âŠµâƒ’",
      nvsim: "âˆ¼âƒ’",
      nwarhk: "â¤£",
      nwArr: "â‡–",
      nwarr: "â†–",
      nwarrow: "â†–",
      nwnear: "â¤§",
      Oacute: "Ã“",
      oacute: "Ã³",
      oast: "âŠ›",
      ocir: "âŠš",
      Ocirc: "Ã”",
      ocirc: "Ã´",
      Ocy: "Ðž",
      ocy: "Ð¾",
      odash: "âŠ",
      Odblac: "Å",
      odblac: "Å‘",
      odiv: "â¨¸",
      odot: "âŠ™",
      odsold: "â¦¼",
      OElig: "Å’",
      oelig: "Å“",
      ofcir: "â¦¿",
      Ofr: "ð”’",
      ofr: "ð”¬",
      ogon: "Ë›",
      Ograve: "Ã’",
      ograve: "Ã²",
      ogt: "â§",
      ohbar: "â¦µ",
      ohm: "Î©",
      oint: "âˆ®",
      olarr: "â†º",
      olcir: "â¦¾",
      olcross: "â¦»",
      oline: "â€¾",
      olt: "â§€",
      Omacr: "ÅŒ",
      omacr: "Å",
      Omega: "Î©",
      omega: "Ï‰",
      Omicron: "ÎŸ",
      omicron: "Î¿",
      omid: "â¦¶",
      ominus: "âŠ–",
      Oopf: "ð•†",
      oopf: "ð• ",
      opar: "â¦·",
      OpenCurlyDoubleQuote: "â€œ",
      OpenCurlyQuote: "â€˜",
      operp: "â¦¹",
      oplus: "âŠ•",
      Or: "â©”",
      or: "âˆ¨",
      orarr: "â†»",
      ord: "â©",
      order: "â„´",
      orderof: "â„´",
      ordf: "Âª",
      ordm: "Âº",
      origof: "âŠ¶",
      oror: "â©–",
      orslope: "â©—",
      orv: "â©›",
      oS: "â“ˆ",
      Oscr: "ð’ª",
      oscr: "â„´",
      Oslash: "Ã˜",
      oslash: "Ã¸",
      osol: "âŠ˜",
      Otilde: "Ã•",
      otilde: "Ãµ",
      Otimes: "â¨·",
      otimes: "âŠ—",
      otimesas: "â¨¶",
      Ouml: "Ã–",
      ouml: "Ã¶",
      ovbar: "âŒ½",
      OverBar: "â€¾",
      OverBrace: "âž",
      OverBracket: "âŽ´",
      OverParenthesis: "âœ",
      par: "âˆ¥",
      para: "Â¶",
      parallel: "âˆ¥",
      parsim: "â«³",
      parsl: "â«½",
      part: "âˆ‚",
      PartialD: "âˆ‚",
      Pcy: "ÐŸ",
      pcy: "Ð¿",
      percnt: "%",
      period: ".",
      permil: "â€°",
      perp: "âŠ¥",
      pertenk: "â€±",
      Pfr: "ð”“",
      pfr: "ð”­",
      Phi: "Î¦",
      phi: "Ï†",
      phiv: "Ï•",
      phmmat: "â„³",
      phone: "â˜Ž",
      Pi: "Î ",
      pi: "Ï€",
      pitchfork: "â‹”",
      piv: "Ï–",
      planck: "â„",
      planckh: "â„Ž",
      plankv: "â„",
      plus: "+",
      plusacir: "â¨£",
      plusb: "âŠž",
      pluscir: "â¨¢",
      plusdo: "âˆ”",
      plusdu: "â¨¥",
      pluse: "â©²",
      PlusMinus: "Â±",
      plusmn: "Â±",
      plussim: "â¨¦",
      plustwo: "â¨§",
      pm: "Â±",
      Poincareplane: "â„Œ",
      pointint: "â¨•",
      Popf: "â„™",
      popf: "ð•¡",
      pound: "Â£",
      Pr: "âª»",
      pr: "â‰º",
      prap: "âª·",
      prcue: "â‰¼",
      prE: "âª³",
      pre: "âª¯",
      prec: "â‰º",
      precapprox: "âª·",
      preccurlyeq: "â‰¼",
      Precedes: "â‰º",
      PrecedesEqual: "âª¯",
      PrecedesSlantEqual: "â‰¼",
      PrecedesTilde: "â‰¾",
      preceq: "âª¯",
      precnapprox: "âª¹",
      precneqq: "âªµ",
      precnsim: "â‹¨",
      precsim: "â‰¾",
      Prime: "â€³",
      prime: "â€²",
      primes: "â„™",
      prnap: "âª¹",
      prnE: "âªµ",
      prnsim: "â‹¨",
      prod: "âˆ",
      Product: "âˆ",
      profalar: "âŒ®",
      profline: "âŒ’",
      profsurf: "âŒ“",
      prop: "âˆ",
      Proportion: "âˆ·",
      Proportional: "âˆ",
      propto: "âˆ",
      prsim: "â‰¾",
      prurel: "âŠ°",
      Pscr: "ð’«",
      pscr: "ð“…",
      Psi: "Î¨",
      psi: "Ïˆ",
      puncsp: "â€ˆ",
      Qfr: "ð””",
      qfr: "ð”®",
      qint: "â¨Œ",
      Qopf: "â„š",
      qopf: "ð•¢",
      qprime: "â—",
      Qscr: "ð’¬",
      qscr: "ð“†",
      quaternions: "â„",
      quatint: "â¨–",
      quest: "?",
      questeq: "â‰Ÿ",
      QUOT: '"',
      quot: '"',
      rAarr: "â‡›",
      race: "âˆ½Ì±",
      Racute: "Å”",
      racute: "Å•",
      radic: "âˆš",
      raemptyv: "â¦³",
      Rang: "âŸ«",
      rang: "âŸ©",
      rangd: "â¦’",
      range: "â¦¥",
      rangle: "âŸ©",
      raquo: "Â»",
      Rarr: "â† ",
      rArr: "â‡’",
      rarr: "â†’",
      rarrap: "â¥µ",
      rarrb: "â‡¥",
      rarrbfs: "â¤ ",
      rarrc: "â¤³",
      rarrfs: "â¤ž",
      rarrhk: "â†ª",
      rarrlp: "â†¬",
      rarrpl: "â¥…",
      rarrsim: "â¥´",
      Rarrtl: "â¤–",
      rarrtl: "â†£",
      rarrw: "â†",
      rAtail: "â¤œ",
      ratail: "â¤š",
      ratio: "âˆ¶",
      rationals: "â„š",
      RBarr: "â¤",
      rBarr: "â¤",
      rbarr: "â¤",
      rbbrk: "â³",
      rbrace: "}",
      rbrack: "]",
      rbrke: "â¦Œ",
      rbrksld: "â¦Ž",
      rbrkslu: "â¦",
      Rcaron: "Å˜",
      rcaron: "Å™",
      Rcedil: "Å–",
      rcedil: "Å—",
      rceil: "âŒ‰",
      rcub: "}",
      Rcy: "Ð ",
      rcy: "Ñ€",
      rdca: "â¤·",
      rdldhar: "â¥©",
      rdquo: "â€",
      rdquor: "â€",
      rdsh: "â†³",
      Re: "â„œ",
      real: "â„œ",
      realine: "â„›",
      realpart: "â„œ",
      reals: "â„",
      rect: "â–­",
      REG: "Â®",
      reg: "Â®",
      ReverseElement: "âˆ‹",
      ReverseEquilibrium: "â‡‹",
      ReverseUpEquilibrium: "â¥¯",
      rfisht: "â¥½",
      rfloor: "âŒ‹",
      Rfr: "â„œ",
      rfr: "ð”¯",
      rHar: "â¥¤",
      rhard: "â‡",
      rharu: "â‡€",
      rharul: "â¥¬",
      Rho: "Î¡",
      rho: "Ï",
      rhov: "Ï±",
      RightAngleBracket: "âŸ©",
      RightArrow: "â†’",
      Rightarrow: "â‡’",
      rightarrow: "â†’",
      RightArrowBar: "â‡¥",
      RightArrowLeftArrow: "â‡„",
      rightarrowtail: "â†£",
      RightCeiling: "âŒ‰",
      RightDoubleBracket: "âŸ§",
      RightDownTeeVector: "â¥",
      RightDownVector: "â‡‚",
      RightDownVectorBar: "â¥•",
      RightFloor: "âŒ‹",
      rightharpoondown: "â‡",
      rightharpoonup: "â‡€",
      rightleftarrows: "â‡„",
      rightleftharpoons: "â‡Œ",
      rightrightarrows: "â‡‰",
      rightsquigarrow: "â†",
      RightTee: "âŠ¢",
      RightTeeArrow: "â†¦",
      RightTeeVector: "â¥›",
      rightthreetimes: "â‹Œ",
      RightTriangle: "âŠ³",
      RightTriangleBar: "â§",
      RightTriangleEqual: "âŠµ",
      RightUpDownVector: "â¥",
      RightUpTeeVector: "â¥œ",
      RightUpVector: "â†¾",
      RightUpVectorBar: "â¥”",
      RightVector: "â‡€",
      RightVectorBar: "â¥“",
      ring: "Ëš",
      risingdotseq: "â‰“",
      rlarr: "â‡„",
      rlhar: "â‡Œ",
      rlm: "â€",
      rmoust: "âŽ±",
      rmoustache: "âŽ±",
      rnmid: "â«®",
      roang: "âŸ­",
      roarr: "â‡¾",
      robrk: "âŸ§",
      ropar: "â¦†",
      Ropf: "â„",
      ropf: "ð•£",
      roplus: "â¨®",
      rotimes: "â¨µ",
      RoundImplies: "â¥°",
      rpar: ")",
      rpargt: "â¦”",
      rppolint: "â¨’",
      rrarr: "â‡‰",
      Rrightarrow: "â‡›",
      rsaquo: "â€º",
      Rscr: "â„›",
      rscr: "ð“‡",
      Rsh: "â†±",
      rsh: "â†±",
      rsqb: "]",
      rsquo: "â€™",
      rsquor: "â€™",
      rthree: "â‹Œ",
      rtimes: "â‹Š",
      rtri: "â–¹",
      rtrie: "âŠµ",
      rtrif: "â–¸",
      rtriltri: "â§Ž",
      RuleDelayed: "â§´",
      ruluhar: "â¥¨",
      rx: "â„ž",
      Sacute: "Åš",
      sacute: "Å›",
      sbquo: "â€š",
      Sc: "âª¼",
      sc: "â‰»",
      scap: "âª¸",
      Scaron: "Å ",
      scaron: "Å¡",
      sccue: "â‰½",
      scE: "âª´",
      sce: "âª°",
      Scedil: "Åž",
      scedil: "ÅŸ",
      Scirc: "Åœ",
      scirc: "Å",
      scnap: "âªº",
      scnE: "âª¶",
      scnsim: "â‹©",
      scpolint: "â¨“",
      scsim: "â‰¿",
      Scy: "Ð¡",
      scy: "Ñ",
      sdot: "â‹…",
      sdotb: "âŠ¡",
      sdote: "â©¦",
      searhk: "â¤¥",
      seArr: "â‡˜",
      searr: "â†˜",
      searrow: "â†˜",
      sect: "Â§",
      semi: ";",
      seswar: "â¤©",
      setminus: "âˆ–",
      setmn: "âˆ–",
      sext: "âœ¶",
      Sfr: "ð”–",
      sfr: "ð”°",
      sfrown: "âŒ¢",
      sharp: "â™¯",
      SHCHcy: "Ð©",
      shchcy: "Ñ‰",
      SHcy: "Ð¨",
      shcy: "Ñˆ",
      ShortDownArrow: "â†“",
      ShortLeftArrow: "â†",
      shortmid: "âˆ£",
      shortparallel: "âˆ¥",
      ShortRightArrow: "â†’",
      ShortUpArrow: "â†‘",
      shy: "Â­",
      Sigma: "Î£",
      sigma: "Ïƒ",
      sigmaf: "Ï‚",
      sigmav: "Ï‚",
      sim: "âˆ¼",
      simdot: "â©ª",
      sime: "â‰ƒ",
      simeq: "â‰ƒ",
      simg: "âªž",
      simgE: "âª ",
      siml: "âª",
      simlE: "âªŸ",
      simne: "â‰†",
      simplus: "â¨¤",
      simrarr: "â¥²",
      slarr: "â†",
      SmallCircle: "âˆ˜",
      smallsetminus: "âˆ–",
      smashp: "â¨³",
      smeparsl: "â§¤",
      smid: "âˆ£",
      smile: "âŒ£",
      smt: "âªª",
      smte: "âª¬",
      smtes: "âª¬ï¸€",
      SOFTcy: "Ð¬",
      softcy: "ÑŒ",
      sol: "/",
      solb: "â§„",
      solbar: "âŒ¿",
      Sopf: "ð•Š",
      sopf: "ð•¤",
      spades: "â™ ",
      spadesuit: "â™ ",
      spar: "âˆ¥",
      sqcap: "âŠ“",
      sqcaps: "âŠ“ï¸€",
      sqcup: "âŠ”",
      sqcups: "âŠ”ï¸€",
      Sqrt: "âˆš",
      sqsub: "âŠ",
      sqsube: "âŠ‘",
      sqsubset: "âŠ",
      sqsubseteq: "âŠ‘",
      sqsup: "âŠ",
      sqsupe: "âŠ’",
      sqsupset: "âŠ",
      sqsupseteq: "âŠ’",
      squ: "â–¡",
      Square: "â–¡",
      square: "â–¡",
      SquareIntersection: "âŠ“",
      SquareSubset: "âŠ",
      SquareSubsetEqual: "âŠ‘",
      SquareSuperset: "âŠ",
      SquareSupersetEqual: "âŠ’",
      SquareUnion: "âŠ”",
      squarf: "â–ª",
      squf: "â–ª",
      srarr: "â†’",
      Sscr: "ð’®",
      sscr: "ð“ˆ",
      ssetmn: "âˆ–",
      ssmile: "âŒ£",
      sstarf: "â‹†",
      Star: "â‹†",
      star: "â˜†",
      starf: "â˜…",
      straightepsilon: "Ïµ",
      straightphi: "Ï•",
      strns: "Â¯",
      Sub: "â‹",
      sub: "âŠ‚",
      subdot: "âª½",
      subE: "â«…",
      sube: "âŠ†",
      subedot: "â«ƒ",
      submult: "â«",
      subnE: "â«‹",
      subne: "âŠŠ",
      subplus: "âª¿",
      subrarr: "â¥¹",
      Subset: "â‹",
      subset: "âŠ‚",
      subseteq: "âŠ†",
      subseteqq: "â«…",
      SubsetEqual: "âŠ†",
      subsetneq: "âŠŠ",
      subsetneqq: "â«‹",
      subsim: "â«‡",
      subsub: "â«•",
      subsup: "â«“",
      succ: "â‰»",
      succapprox: "âª¸",
      succcurlyeq: "â‰½",
      Succeeds: "â‰»",
      SucceedsEqual: "âª°",
      SucceedsSlantEqual: "â‰½",
      SucceedsTilde: "â‰¿",
      succeq: "âª°",
      succnapprox: "âªº",
      succneqq: "âª¶",
      succnsim: "â‹©",
      succsim: "â‰¿",
      SuchThat: "âˆ‹",
      Sum: "âˆ‘",
      sum: "âˆ‘",
      sung: "â™ª",
      Sup: "â‹‘",
      sup: "âŠƒ",
      sup1: "Â¹",
      sup2: "Â²",
      sup3: "Â³",
      supdot: "âª¾",
      supdsub: "â«˜",
      supE: "â«†",
      supe: "âŠ‡",
      supedot: "â«„",
      Superset: "âŠƒ",
      SupersetEqual: "âŠ‡",
      suphsol: "âŸ‰",
      suphsub: "â«—",
      suplarr: "â¥»",
      supmult: "â«‚",
      supnE: "â«Œ",
      supne: "âŠ‹",
      supplus: "â«€",
      Supset: "â‹‘",
      supset: "âŠƒ",
      supseteq: "âŠ‡",
      supseteqq: "â«†",
      supsetneq: "âŠ‹",
      supsetneqq: "â«Œ",
      supsim: "â«ˆ",
      supsub: "â«”",
      supsup: "â«–",
      swarhk: "â¤¦",
      swArr: "â‡™",
      swarr: "â†™",
      swarrow: "â†™",
      swnwar: "â¤ª",
      szlig: "ÃŸ",
      Tab: "	",
      target: "âŒ–",
      Tau: "Î¤",
      tau: "Ï„",
      tbrk: "âŽ´",
      Tcaron: "Å¤",
      tcaron: "Å¥",
      Tcedil: "Å¢",
      tcedil: "Å£",
      Tcy: "Ð¢",
      tcy: "Ñ‚",
      tdot: "âƒ›",
      telrec: "âŒ•",
      Tfr: "ð”—",
      tfr: "ð”±",
      there4: "âˆ´",
      Therefore: "âˆ´",
      therefore: "âˆ´",
      Theta: "Î˜",
      theta: "Î¸",
      thetasym: "Ï‘",
      thetav: "Ï‘",
      thickapprox: "â‰ˆ",
      thicksim: "âˆ¼",
      ThickSpace: "âŸâ€Š",
      thinsp: "â€‰",
      ThinSpace: "â€‰",
      thkap: "â‰ˆ",
      thksim: "âˆ¼",
      THORN: "Ãž",
      thorn: "Ã¾",
      Tilde: "âˆ¼",
      tilde: "Ëœ",
      TildeEqual: "â‰ƒ",
      TildeFullEqual: "â‰…",
      TildeTilde: "â‰ˆ",
      times: "Ã—",
      timesb: "âŠ ",
      timesbar: "â¨±",
      timesd: "â¨°",
      tint: "âˆ­",
      toea: "â¤¨",
      top: "âŠ¤",
      topbot: "âŒ¶",
      topcir: "â«±",
      Topf: "ð•‹",
      topf: "ð•¥",
      topfork: "â«š",
      tosa: "â¤©",
      tprime: "â€´",
      TRADE: "â„¢",
      trade: "â„¢",
      triangle: "â–µ",
      triangledown: "â–¿",
      triangleleft: "â—ƒ",
      trianglelefteq: "âŠ´",
      triangleq: "â‰œ",
      triangleright: "â–¹",
      trianglerighteq: "âŠµ",
      tridot: "â—¬",
      trie: "â‰œ",
      triminus: "â¨º",
      TripleDot: "âƒ›",
      triplus: "â¨¹",
      trisb: "â§",
      tritime: "â¨»",
      trpezium: "â¢",
      Tscr: "ð’¯",
      tscr: "ð“‰",
      TScy: "Ð¦",
      tscy: "Ñ†",
      TSHcy: "Ð‹",
      tshcy: "Ñ›",
      Tstrok: "Å¦",
      tstrok: "Å§",
      twixt: "â‰¬",
      twoheadleftarrow: "â†ž",
      twoheadrightarrow: "â† ",
      Uacute: "Ãš",
      uacute: "Ãº",
      Uarr: "â†Ÿ",
      uArr: "â‡‘",
      uarr: "â†‘",
      Uarrocir: "â¥‰",
      Ubrcy: "ÐŽ",
      ubrcy: "Ñž",
      Ubreve: "Å¬",
      ubreve: "Å­",
      Ucirc: "Ã›",
      ucirc: "Ã»",
      Ucy: "Ð£",
      ucy: "Ñƒ",
      udarr: "â‡…",
      Udblac: "Å°",
      udblac: "Å±",
      udhar: "â¥®",
      ufisht: "â¥¾",
      Ufr: "ð”˜",
      ufr: "ð”²",
      Ugrave: "Ã™",
      ugrave: "Ã¹",
      uHar: "â¥£",
      uharl: "â†¿",
      uharr: "â†¾",
      uhblk: "â–€",
      ulcorn: "âŒœ",
      ulcorner: "âŒœ",
      ulcrop: "âŒ",
      ultri: "â—¸",
      Umacr: "Åª",
      umacr: "Å«",
      uml: "Â¨",
      UnderBar: "_",
      UnderBrace: "âŸ",
      UnderBracket: "âŽµ",
      UnderParenthesis: "â",
      Union: "â‹ƒ",
      UnionPlus: "âŠŽ",
      Uogon: "Å²",
      uogon: "Å³",
      Uopf: "ð•Œ",
      uopf: "ð•¦",
      UpArrow: "â†‘",
      Uparrow: "â‡‘",
      uparrow: "â†‘",
      UpArrowBar: "â¤’",
      UpArrowDownArrow: "â‡…",
      UpDownArrow: "â†•",
      Updownarrow: "â‡•",
      updownarrow: "â†•",
      UpEquilibrium: "â¥®",
      upharpoonleft: "â†¿",
      upharpoonright: "â†¾",
      uplus: "âŠŽ",
      UpperLeftArrow: "â†–",
      UpperRightArrow: "â†—",
      Upsi: "Ï’",
      upsi: "Ï…",
      upsih: "Ï’",
      Upsilon: "Î¥",
      upsilon: "Ï…",
      UpTee: "âŠ¥",
      UpTeeArrow: "â†¥",
      upuparrows: "â‡ˆ",
      urcorn: "âŒ",
      urcorner: "âŒ",
      urcrop: "âŒŽ",
      Uring: "Å®",
      uring: "Å¯",
      urtri: "â—¹",
      Uscr: "ð’°",
      uscr: "ð“Š",
      utdot: "â‹°",
      Utilde: "Å¨",
      utilde: "Å©",
      utri: "â–µ",
      utrif: "â–´",
      uuarr: "â‡ˆ",
      Uuml: "Ãœ",
      uuml: "Ã¼",
      uwangle: "â¦§",
      vangrt: "â¦œ",
      varepsilon: "Ïµ",
      varkappa: "Ï°",
      varnothing: "âˆ…",
      varphi: "Ï•",
      varpi: "Ï–",
      varpropto: "âˆ",
      vArr: "â‡•",
      varr: "â†•",
      varrho: "Ï±",
      varsigma: "Ï‚",
      varsubsetneq: "âŠŠï¸€",
      varsubsetneqq: "â«‹ï¸€",
      varsupsetneq: "âŠ‹ï¸€",
      varsupsetneqq: "â«Œï¸€",
      vartheta: "Ï‘",
      vartriangleleft: "âŠ²",
      vartriangleright: "âŠ³",
      Vbar: "â««",
      vBar: "â«¨",
      vBarv: "â«©",
      Vcy: "Ð’",
      vcy: "Ð²",
      VDash: "âŠ«",
      Vdash: "âŠ©",
      vDash: "âŠ¨",
      vdash: "âŠ¢",
      Vdashl: "â«¦",
      Vee: "â‹",
      vee: "âˆ¨",
      veebar: "âŠ»",
      veeeq: "â‰š",
      vellip: "â‹®",
      Verbar: "â€–",
      verbar: "|",
      Vert: "â€–",
      vert: "|",
      VerticalBar: "âˆ£",
      VerticalLine: "|",
      VerticalSeparator: "â˜",
      VerticalTilde: "â‰€",
      VeryThinSpace: "â€Š",
      Vfr: "ð”™",
      vfr: "ð”³",
      vltri: "âŠ²",
      vnsub: "âŠ‚âƒ’",
      vnsup: "âŠƒâƒ’",
      Vopf: "ð•",
      vopf: "ð•§",
      vprop: "âˆ",
      vrtri: "âŠ³",
      Vscr: "ð’±",
      vscr: "ð“‹",
      vsubnE: "â«‹ï¸€",
      vsubne: "âŠŠï¸€",
      vsupnE: "â«Œï¸€",
      vsupne: "âŠ‹ï¸€",
      Vvdash: "âŠª",
      vzigzag: "â¦š",
      Wcirc: "Å´",
      wcirc: "Åµ",
      wedbar: "â©Ÿ",
      Wedge: "â‹€",
      wedge: "âˆ§",
      wedgeq: "â‰™",
      weierp: "â„˜",
      Wfr: "ð”š",
      wfr: "ð”´",
      Wopf: "ð•Ž",
      wopf: "ð•¨",
      wp: "â„˜",
      wr: "â‰€",
      wreath: "â‰€",
      Wscr: "ð’²",
      wscr: "ð“Œ",
      xcap: "â‹‚",
      xcirc: "â—¯",
      xcup: "â‹ƒ",
      xdtri: "â–½",
      Xfr: "ð”›",
      xfr: "ð”µ",
      xhArr: "âŸº",
      xharr: "âŸ·",
      Xi: "Îž",
      xi: "Î¾",
      xlArr: "âŸ¸",
      xlarr: "âŸµ",
      xmap: "âŸ¼",
      xnis: "â‹»",
      xodot: "â¨€",
      Xopf: "ð•",
      xopf: "ð•©",
      xoplus: "â¨",
      xotime: "â¨‚",
      xrArr: "âŸ¹",
      xrarr: "âŸ¶",
      Xscr: "ð’³",
      xscr: "ð“",
      xsqcup: "â¨†",
      xuplus: "â¨„",
      xutri: "â–³",
      xvee: "â‹",
      xwedge: "â‹€",
      Yacute: "Ã",
      yacute: "Ã½",
      YAcy: "Ð¯",
      yacy: "Ñ",
      Ycirc: "Å¶",
      ycirc: "Å·",
      Ycy: "Ð«",
      ycy: "Ñ‹",
      yen: "Â¥",
      Yfr: "ð”œ",
      yfr: "ð”¶",
      YIcy: "Ð‡",
      yicy: "Ñ—",
      Yopf: "ð•",
      yopf: "ð•ª",
      Yscr: "ð’´",
      yscr: "ð“Ž",
      YUcy: "Ð®",
      yucy: "ÑŽ",
      Yuml: "Å¸",
      yuml: "Ã¿",
      Zacute: "Å¹",
      zacute: "Åº",
      Zcaron: "Å½",
      zcaron: "Å¾",
      Zcy: "Ð—",
      zcy: "Ð·",
      Zdot: "Å»",
      zdot: "Å¼",
      zeetrf: "â„¨",
      ZeroWidthSpace: "â€‹",
      Zeta: "Î–",
      zeta: "Î¶",
      Zfr: "â„¨",
      zfr: "ð”·",
      ZHcy: "Ð–",
      zhcy: "Ð¶",
      zigrarr: "â‡",
      Zopf: "â„¤",
      zopf: "ð•«",
      Zscr: "ð’µ",
      zscr: "ð“",
      zwj: "â€",
      zwnj: "â€Œ"
    });
    exports4.entityMap = exports4.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports4) {
    "use strict";
    var conventions = require_conventions();
    var g = require_grammar();
    var errors = require_errors();
    var isHTMLEscapableRawTextElement = conventions.isHTMLEscapableRawTextElement;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
    var hasOwn = conventions.hasOwn;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = errors.ParseError;
    var DOMException = errors.DOMException;
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = /* @__PURE__ */ Object.create(null));
        parse3(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    var ENTITY_REG = /&#?\w+;?/g;
    function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      var isHTML = isHTMLMimeType(domBuilder.mimeType);
      if (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {
        errorHandler.warning("Unicode replacement character detected, source encoding issues?");
      }
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a3) {
        var complete = a3[a3.length - 1] === ";" ? a3 : a3 + ";";
        if (!isHTML && complete !== a3) {
          errorHandler.error("EntityRef: expecting ;");
          return a3;
        }
        var match2 = g.Reference.exec(complete);
        if (!match2 || match2[0].length !== complete.length) {
          errorHandler.error("entity not matching Reference production: " + a3);
          return a3;
        }
        var k3 = complete.slice(1, -1);
        if (hasOwn(entityMap, k3)) {
          return entityMap[k3];
        } else if (k3.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k3.substring(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a3);
          return a3;
        }
      }
      function appendText(end2) {
        if (end2 > start2) {
          var xt = source.substring(start2, end2).replace(ENTITY_REG, entityReplacer);
          locator && position(start2);
          domBuilder.characters(xt, 0, end2 - start2);
          start2 = end2;
        }
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /\r\n?|\n|$/g;
      var locator = domBuilder.locator;
      function position(p2, m2) {
        while (p2 >= lineEnd && (m2 = linePattern.exec(source))) {
          lineStart = lineEnd;
          lineEnd = m2.index + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p2 - lineStart + 1;
      }
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var unclosedTags = [];
      var start2 = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start2);
          if (tagStart < 0) {
            if (!isHTML && unclosedTags.length > 0) {
              return errorHandler.fatalError("unclosed xml tag(s): " + unclosedTags.join(", "));
            }
            if (!source.substring(start2).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substring(start2));
              if (doc.documentElement) {
                return errorHandler.error("Extra content at the end of the document");
              }
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start2) {
            var fromSource = source.substring(start2, tagStart);
            if (!isHTML && unclosedTags.length === 0) {
              fromSource = fromSource.replace(new RegExp(g.S_OPT.source, "g"), "");
              fromSource && errorHandler.error("Unexpected content outside root element: '" + fromSource + "'");
            }
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 2);
              var tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : void 0);
              if (!tagNameRaw) {
                return errorHandler.fatalError("end tag name missing");
              }
              var tagNameMatch = end > 0 && g.reg("^", g.QName_group, g.S_OPT, "$").exec(tagNameRaw);
              if (!tagNameMatch) {
                return errorHandler.fatalError('end tag name contains invalid characters: "' + tagNameRaw + '"');
              }
              if (!domBuilder.currentElement && !domBuilder.doc.documentElement) {
                return;
              }
              var currentTagName = unclosedTags[unclosedTags.length - 1] || domBuilder.currentElement.tagName || domBuilder.doc.documentElement.tagName || "";
              if (currentTagName !== tagNameMatch[1]) {
                var tagNameLower = tagNameMatch[1].toLowerCase();
                if (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {
                  return errorHandler.fatalError('Opening and ending tag mismatch: "' + currentTagName + '" != "' + tagNameRaw + '"');
                }
              }
              var config = parseStack.pop();
              unclosedTags.pop();
              var localNSMap = config.localNSMap;
              domBuilder.endElement(config.uri, config.localName, currentTagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (hasOwn(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              end++;
              break;
            // end element
            case "?":
              locator && position(tagStart);
              end = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);
              var len = el.length;
              if (!el.closed) {
                if (isHTML && conventions.isHTMLVoidElement(el.tagName)) {
                  el.closed = true;
                } else {
                  unclosedTags.push(el.tagName);
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a2 = el[i];
                  position(a2.offset);
                  a2.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (isHTML && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          } else if (e instanceof DOMException) {
            throw new ParseError(e.name + ": " + e.message, domBuilder.locator, e);
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start2) {
          start2 = end;
        } else {
          appendText(Math.max(tagStart, start2) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler, isHTML) {
      function addAttribute(qname, value3, startIndex) {
        if (hasOwn(el.attributeNames, qname)) {
          return errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        if (!isHTML && value3.indexOf("<") >= 0) {
          return errorHandler.fatalError("Unescaped '<' not allowed in attributes values");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value3.replace(/[\t\n\r]/g, " ").replace(ENTITY_REG, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value2;
      var p2 = ++start2;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p2);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start2, p2);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start2, p2);
              }
              start2 = p2 + 1;
              p2 = source.indexOf(c, start2);
              if (p2 > 0) {
                value2 = source.slice(start2, p2);
                addAttribute(attrName, value2, start2 - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value2 = source.slice(start2, p2);
              addAttribute(attrName, value2, start2);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start2 = p2 + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start2, p2));
            }
            return p2;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value2 = source.slice(start2, p2);
                if (value2.slice(-1) === "/") {
                  el.closed = true;
                  value2 = value2.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value2 = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value2 + '" missed quot(")!');
                  addAttribute(attrName, value2, start2);
                } else {
                  if (!isHTML) {
                    errorHandler.warning('attribute "' + value2 + '" missed value!! "' + value2 + '" instead!!');
                  }
                  addAttribute(value2, value2, start2);
                }
                break;
              case S_EQ:
                if (!isHTML) {
                  return errorHandler.fatalError(`AttValue: ' or " expected`);
                }
            }
            return p2;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "Â€":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start2, p2));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start2, p2);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value2 = source.slice(start2, p2);
                  errorHandler.warning('attribute "' + value2 + '" missed quot(")!!');
                  addAttribute(attrName, value2, start2);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  if (!isHTML) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start2);
                  start2 = p2;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start2 = p2;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start2 = p2;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p2++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a2 = el[i];
        var qName = a2.qName;
        var value2 = a2.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a2.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a2.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = /* @__PURE__ */ Object.create(null);
            _copy(currentNSMap, currentNSMap = /* @__PURE__ */ Object.create(null));
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value2;
          a2.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value2);
        }
      }
      var i = el.length;
      while (i--) {
        a2 = el[i];
        if (a2.prefix) {
          if (a2.prefix === "xml") {
            a2.uri = NAMESPACE.XML;
          }
          if (a2.prefix !== "xmlns") {
            a2.uri = currentNSMap[a2.prefix];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (hasOwn(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      var isEscapableRaw = isHTMLEscapableRawTextElement(tagName);
      if (isEscapableRaw || isHTMLRawTextElement(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (isEscapableRaw) {
          text = text.replace(ENTITY_REG, entityReplacer);
        }
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
      return elStartEnd + 1;
    }
    function _copy(source, target2) {
      for (var n in source) {
        if (hasOwn(source, n)) {
          target2[n] = source[n];
        }
      }
    }
    function parseUtils(source, start2) {
      var index2 = start2;
      function char(n) {
        n = n || 0;
        return source.charAt(index2 + n);
      }
      function skip(n) {
        n = n || 1;
        index2 += n;
      }
      function skipBlanks() {
        var blanks = 0;
        while (index2 < source.length) {
          var c = char();
          if (c !== " " && c !== "\n" && c !== "	" && c !== "\r") {
            return blanks;
          }
          blanks++;
          skip();
        }
        return -1;
      }
      function substringFromIndex() {
        return source.substring(index2);
      }
      function substringStartsWith(text) {
        return source.substring(index2, index2 + text.length) === text;
      }
      function substringStartsWithCaseInsensitive(text) {
        return source.substring(index2, index2 + text.length).toUpperCase() === text.toUpperCase();
      }
      function getMatch(args) {
        var expr = g.reg("^", args);
        var match2 = expr.exec(substringFromIndex());
        if (match2) {
          skip(match2[0].length);
          return match2[0];
        }
        return null;
      }
      return {
        char,
        getIndex: function() {
          return index2;
        },
        getMatch,
        getSource: function() {
          return source;
        },
        skip,
        skipBlanks,
        substringFromIndex,
        substringStartsWith,
        substringStartsWithCaseInsensitive
      };
    }
    function parseDoctypeInternalSubset(p2, errorHandler) {
      function parsePI(p3, errorHandler2) {
        var match2 = g.PI.exec(p3.substringFromIndex());
        if (!match2) {
          return errorHandler2.fatalError("processing instruction is not well-formed at position " + p3.getIndex());
        }
        if (match2[1].toLowerCase() === "xml") {
          return errorHandler2.fatalError(
            "xml declaration is only allowed at the start of the document, but found at position " + p3.getIndex()
          );
        }
        p3.skip(match2[0].length);
        return match2[0];
      }
      var source = p2.getSource();
      if (p2.char() === "[") {
        p2.skip(1);
        var intSubsetStart = p2.getIndex();
        while (p2.getIndex() < source.length) {
          p2.skipBlanks();
          if (p2.char() === "]") {
            var internalSubset = source.substring(intSubsetStart, p2.getIndex());
            p2.skip(1);
            return internalSubset;
          }
          var current = null;
          if (p2.char() === "<" && p2.char(1) === "!") {
            switch (p2.char(2)) {
              case "E":
                if (p2.char(3) === "L") {
                  current = p2.getMatch(g.elementdecl);
                } else if (p2.char(3) === "N") {
                  current = p2.getMatch(g.EntityDecl);
                }
                break;
              case "A":
                current = p2.getMatch(g.AttlistDecl);
                break;
              case "N":
                current = p2.getMatch(g.NotationDecl);
                break;
              case "-":
                current = p2.getMatch(g.Comment);
                break;
            }
          } else if (p2.char() === "<" && p2.char(1) === "?") {
            current = parsePI(p2, errorHandler);
          } else if (p2.char() === "%") {
            current = p2.getMatch(g.PEReference);
          } else {
            return errorHandler.fatalError("Error detected in Markup declaration");
          }
          if (!current) {
            return errorHandler.fatalError("Error in internal subset at position " + p2.getIndex());
          }
        }
        return errorHandler.fatalError("doctype internal subset is not well-formed, missing ]");
      }
    }
    function parseDoctypeCommentOrCData(source, start2, domBuilder, errorHandler, isHTML) {
      var p2 = parseUtils(source, start2);
      switch (isHTML ? p2.char(2).toUpperCase() : p2.char(2)) {
        case "-":
          var comment = p2.getMatch(g.Comment);
          if (comment) {
            domBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);
            return p2.getIndex();
          } else {
            return errorHandler.fatalError("comment is not well-formed at position " + p2.getIndex());
          }
        case "[":
          var cdata = p2.getMatch(g.CDSect);
          if (cdata) {
            if (!isHTML && !domBuilder.currentElement) {
              return errorHandler.fatalError("CDATA outside of element");
            }
            domBuilder.startCDATA();
            domBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);
            domBuilder.endCDATA();
            return p2.getIndex();
          } else {
            return errorHandler.fatalError("Invalid CDATA starting at position " + start2);
          }
        case "D": {
          if (domBuilder.doc && domBuilder.doc.documentElement) {
            return errorHandler.fatalError("Doctype not allowed inside or after documentElement at position " + p2.getIndex());
          }
          if (isHTML ? !p2.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p2.substringStartsWith(g.DOCTYPE_DECL_START)) {
            return errorHandler.fatalError("Expected " + g.DOCTYPE_DECL_START + " at position " + p2.getIndex());
          }
          p2.skip(g.DOCTYPE_DECL_START.length);
          if (p2.skipBlanks() < 1) {
            return errorHandler.fatalError("Expected whitespace after " + g.DOCTYPE_DECL_START + " at position " + p2.getIndex());
          }
          var doctype = {
            name: void 0,
            publicId: void 0,
            systemId: void 0,
            internalSubset: void 0
          };
          doctype.name = p2.getMatch(g.Name);
          if (!doctype.name)
            return errorHandler.fatalError("doctype name missing or contains unexpected characters at position " + p2.getIndex());
          if (isHTML && doctype.name.toLowerCase() !== "html") {
            errorHandler.warning("Unexpected DOCTYPE in HTML document at position " + p2.getIndex());
          }
          p2.skipBlanks();
          if (p2.substringStartsWith(g.PUBLIC) || p2.substringStartsWith(g.SYSTEM)) {
            var match2 = g.ExternalID_match.exec(p2.substringFromIndex());
            if (!match2) {
              return errorHandler.fatalError("doctype external id is not well-formed at position " + p2.getIndex());
            }
            if (match2.groups.SystemLiteralOnly !== void 0) {
              doctype.systemId = match2.groups.SystemLiteralOnly;
            } else {
              doctype.systemId = match2.groups.SystemLiteral;
              doctype.publicId = match2.groups.PubidLiteral;
            }
            p2.skip(match2[0].length);
          } else if (isHTML && p2.substringStartsWithCaseInsensitive(g.SYSTEM)) {
            p2.skip(g.SYSTEM.length);
            if (p2.skipBlanks() < 1) {
              return errorHandler.fatalError("Expected whitespace after " + g.SYSTEM + " at position " + p2.getIndex());
            }
            doctype.systemId = p2.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);
            if (!doctype.systemId) {
              return errorHandler.fatalError(
                "Expected " + g.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + g.SYSTEM + " at position " + p2.getIndex()
              );
            }
          }
          if (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {
            errorHandler.warning("Unexpected doctype.systemId in HTML document at position " + p2.getIndex());
          }
          if (!isHTML) {
            p2.skipBlanks();
            doctype.internalSubset = parseDoctypeInternalSubset(p2, errorHandler);
          }
          p2.skipBlanks();
          if (p2.char() !== ">") {
            return errorHandler.fatalError("doctype not terminated with > at position " + p2.getIndex());
          }
          p2.skip(1);
          domBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);
          domBuilder.endDTD();
          return p2.getIndex();
        }
        default:
          return errorHandler.fatalError('Not well-formed XML starting with "<!" at position ' + start2);
      }
    }
    function parseProcessingInstruction(source, start2, domBuilder, errorHandler) {
      var match2 = source.substring(start2).match(g.PI);
      if (!match2) {
        return errorHandler.fatalError("Invalid processing instruction starting at position " + start2);
      }
      if (match2[1].toLowerCase() === "xml") {
        if (start2 > 0) {
          return errorHandler.fatalError(
            "processing instruction at position " + start2 + " is an xml declaration which is only at the start of the document"
          );
        }
        if (!g.XMLDecl.test(source.substring(start2))) {
          return errorHandler.fatalError("xml declaration is not well-formed");
        }
      }
      domBuilder.processingInstruction(match2[1], match2[2]);
      return start2 + match2[0].length;
    }
    function ElementAttributes() {
      this.attributeNames = /* @__PURE__ */ Object.create(null);
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!g.QName_exact.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value2, offset) {
        if (!g.QName_exact.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value: value2, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    exports4.XMLReader = XMLReader;
    exports4.parseUtils = parseUtils;
    exports4.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports4) {
    "use strict";
    var conventions = require_conventions();
    var dom = require_dom();
    var errors = require_errors();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isValidMimeType = conventions.isValidMimeType;
    var MIME_TYPE = conventions.MIME_TYPE;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = errors.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028\u2029]/g, "\n");
    }
    function DOMParser2(options) {
      options = options || {};
      if (options.locator === void 0) {
        options.locator = true;
      }
      this.assign = options.assign || conventions.assign;
      this.domHandler = options.domHandler || DOMHandler;
      this.onError = options.onError || options.errorHandler;
      if (options.errorHandler && typeof options.errorHandler !== "function") {
        throw new TypeError("errorHandler object is no longer supported, switch to onError!");
      } else if (options.errorHandler) {
        options.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this);
      }
      this.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings;
      this.locator = !!options.locator;
      this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), options.xmlns);
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      if (!isValidMimeType(mimeType)) {
        throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + mimeType + '" is not valid.');
      }
      var defaultNSMap = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns);
      var entityMap = entities.XML_ENTITIES;
      var defaultNamespace = defaultNSMap[""] || null;
      if (hasDefaultHTMLNamespace(mimeType)) {
        entityMap = entities.HTML_ENTITIES;
        defaultNamespace = NAMESPACE.HTML;
      } else if (mimeType === MIME_TYPE.XML_SVG_IMAGE) {
        defaultNamespace = NAMESPACE.SVG;
      }
      defaultNSMap[""] = defaultNamespace;
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var domBuilder = new this.domHandler({
        mimeType,
        defaultNamespace,
        onError: this.onError
      });
      var locator = this.locator ? {} : void 0;
      if (this.locator) {
        domBuilder.setDocumentLocator(locator);
      }
      var sax2 = new XMLReader();
      sax2.errorHandler = domBuilder;
      sax2.domBuilder = domBuilder;
      var isXml = !conventions.isHTMLMimeType(mimeType);
      if (isXml && typeof source !== "string") {
        sax2.errorHandler.fatalError("source is not a string");
      }
      sax2.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);
      if (!domBuilder.doc.documentElement) {
        sax2.errorHandler.fatalError("missing root element");
      }
      return domBuilder.doc;
    };
    function DOMHandler(options) {
      var opt = options || {};
      this.mimeType = opt.mimeType || MIME_TYPE.XML_APPLICATION;
      this.defaultNamespace = opt.defaultNamespace || null;
      this.cdata = false;
      this.currentElement = void 0;
      this.doc = void 0;
      this.locator = void 0;
      this.onError = opt.onError;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      /**
       * Either creates an XML or an HTML document and stores it under `this.doc`.
       * If it is an XML document, `this.defaultNamespace` is used to create it,
       * and it will not contain any `childNodes`.
       * If it is an HTML document, it will be created without any `childNodes`.
       *
       * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
       */
      startDocument: function() {
        var impl = new DOMImplementation();
        this.doc = isHTMLMimeType(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, "");
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value2 = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value2;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        this.currentElement = this.currentElement.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target2, data) {
        var ins = this.doc.createProcessingInstruction(target2, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start2, length) {
      },
      characters: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      /**
       * Stores the locator to be able to set the `columnNumber` and `lineNumber`
       * on the created DOM nodes.
       *
       * @param {Locator} locator
       */
      setDocumentLocator: function(locator) {
        if (locator) {
          locator.lineNumber = 0;
        }
        this.locator = locator;
      },
      //LexicalHandler
      comment: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId, internalSubset) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId, internalSubset);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      reportError: function(level, message) {
        if (typeof this.onError === "function") {
          try {
            this.onError(level, message, this);
          } catch (e) {
            throw new ParseError("Reporting " + level + ' "' + message + '" caused ' + e, this.locator);
          }
        } else {
          console.error("[xmldom " + level + "]	" + message, _locator(this.locator));
        }
      },
      /**
       * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(message) {
        this.reportError("warning", message);
      },
      error: function(message) {
        this.reportError("error", message);
      },
      /**
       * This function reports a fatal error and throws a ParseError.
       *
       * @param {string} message
       * - The message to be used for reporting and throwing the error.
       * @returns {never}
       * This function always throws an error and never returns a value.
       * @throws {ParseError}
       * Always throws a ParseError with the provided message.
       */
      fatalError: function(message) {
        this.reportError("fatalError", message);
        throw new ParseError(message, this.locator);
      }
    };
    function _locator(l3) {
      if (l3) {
        return "\n@#[line:" + l3.lineNumber + ",col:" + l3.columnNumber + "]";
      }
    }
    function _toString(chars, start2, length) {
      if (typeof chars == "string") {
        return chars.substr(start2, length);
      } else {
        if (chars.length >= start2 + length || start2) {
          return new java.lang.String(chars, start2, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
      /\w+/g,
      function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      }
    );
    function appendElement(handler, node) {
      if (!handler.currentElement) {
        handler.doc.appendChild(node);
      } else {
        handler.currentElement.appendChild(node);
      }
    }
    function onErrorStopParsing(level) {
      if (level === "error") throw "onErrorStopParsing";
    }
    function onWarningStopParsing() {
      throw "onWarningStopParsing";
    }
    exports4.__DOMHandler = DOMHandler;
    exports4.DOMParser = DOMParser2;
    exports4.normalizeLineEndings = normalizeLineEndings;
    exports4.onErrorStopParsing = onErrorStopParsing;
    exports4.onWarningStopParsing = onWarningStopParsing;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports4) {
    "use strict";
    var conventions = require_conventions();
    exports4.assign = conventions.assign;
    exports4.hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    exports4.isHTMLMimeType = conventions.isHTMLMimeType;
    exports4.isValidMimeType = conventions.isValidMimeType;
    exports4.MIME_TYPE = conventions.MIME_TYPE;
    exports4.NAMESPACE = conventions.NAMESPACE;
    var errors = require_errors();
    exports4.DOMException = errors.DOMException;
    exports4.DOMExceptionName = errors.DOMExceptionName;
    exports4.ExceptionCode = errors.ExceptionCode;
    exports4.ParseError = errors.ParseError;
    var dom = require_dom();
    exports4.Attr = dom.Attr;
    exports4.CDATASection = dom.CDATASection;
    exports4.CharacterData = dom.CharacterData;
    exports4.Comment = dom.Comment;
    exports4.Document = dom.Document;
    exports4.DocumentFragment = dom.DocumentFragment;
    exports4.DocumentType = dom.DocumentType;
    exports4.DOMImplementation = dom.DOMImplementation;
    exports4.Element = dom.Element;
    exports4.Entity = dom.Entity;
    exports4.EntityReference = dom.EntityReference;
    exports4.LiveNodeList = dom.LiveNodeList;
    exports4.NamedNodeMap = dom.NamedNodeMap;
    exports4.Node = dom.Node;
    exports4.NodeList = dom.NodeList;
    exports4.Notation = dom.Notation;
    exports4.ProcessingInstruction = dom.ProcessingInstruction;
    exports4.Text = dom.Text;
    exports4.XMLSerializer = dom.XMLSerializer;
    var domParser = require_dom_parser();
    exports4.DOMParser = domParser.DOMParser;
    exports4.normalizeLineEndings = domParser.normalizeLineEndings;
    exports4.onErrorStopParsing = domParser.onErrorStopParsing;
    exports4.onWarningStopParsing = domParser.onWarningStopParsing;
  }
});

// node_modules/eventbusjs/lib/eventbus.min.js
var require_eventbus_min = __commonJS({
  "node_modules/eventbusjs/lib/eventbus.min.js"(exports4, module) {
    (function(root, factory) {
      if (typeof exports4 === "object" && typeof module === "object") module.exports = factory();
      else if (typeof define === "function" && define.amd) define("EventBus", [], factory);
      else if (typeof exports4 === "object") exports4["EventBus"] = factory();
      else root["EventBus"] = factory();
    })(exports4, function() {
      var EventBusClass = {};
      EventBusClass = function() {
        this.listeners = {};
      };
      EventBusClass.prototype = { addEventListener: function(type, callback, scope) {
        var args = [];
        var numOfArgs = arguments.length;
        for (var i = 0; i < numOfArgs; i++) {
          args.push(arguments[i]);
        }
        args = args.length > 3 ? args.splice(3, args.length - 1) : [];
        if (typeof this.listeners[type] != "undefined") {
          this.listeners[type].push({ scope, callback, args });
        } else {
          this.listeners[type] = [{ scope, callback, args }];
        }
      }, removeEventListener: function(type, callback, scope) {
        if (typeof this.listeners[type] != "undefined") {
          var numOfCallbacks = this.listeners[type].length;
          var newArray = [];
          for (var i = 0; i < numOfCallbacks; i++) {
            var listener = this.listeners[type][i];
            if (listener.scope == scope && listener.callback == callback) {
            } else {
              newArray.push(listener);
            }
          }
          this.listeners[type] = newArray;
        }
      }, hasEventListener: function(type, callback, scope) {
        if (typeof this.listeners[type] != "undefined") {
          var numOfCallbacks = this.listeners[type].length;
          if (callback === void 0 && scope === void 0) {
            return numOfCallbacks > 0;
          }
          for (var i = 0; i < numOfCallbacks; i++) {
            var listener = this.listeners[type][i];
            if ((scope ? listener.scope == scope : true) && listener.callback == callback) {
              return true;
            }
          }
        }
        return false;
      }, dispatch: function(type, target2) {
        var event = { type, target: target2 };
        var args = [];
        var numOfArgs = arguments.length;
        for (var i = 0; i < numOfArgs; i++) {
          args.push(arguments[i]);
        }
        args = args.length > 2 ? args.splice(2, args.length - 1) : [];
        args = [event].concat(args);
        if (typeof this.listeners[type] != "undefined") {
          var listeners = this.listeners[type].slice();
          var numOfCallbacks = listeners.length;
          for (var i = 0; i < numOfCallbacks; i++) {
            var listener = listeners[i];
            if (listener && listener.callback) {
              var concatArgs = args.concat(listener.args);
              listener.callback.apply(listener.scope, concatArgs);
            }
          }
        }
      }, getEvents: function() {
        var str = "";
        for (var type in this.listeners) {
          var numOfCallbacks = this.listeners[type].length;
          for (var i = 0; i < numOfCallbacks; i++) {
            var listener = this.listeners[type][i];
            str += listener.scope && listener.scope.className ? listener.scope.className : "anonymous";
            str += " listen for '" + type + "'\n";
          }
        }
        return str;
      } };
      var EventBus9 = new EventBusClass();
      return EventBus9;
    });
  }
});

// node_modules/clusterize.js/clusterize.js
var require_clusterize = __commonJS({
  "node_modules/clusterize.js/clusterize.js"(exports4, module) {
    (function(name, definition) {
      if (typeof module != "undefined") module.exports = definition();
      else if (typeof define == "function" && typeof define.amd == "object") define(definition);
      else this[name] = definition();
    })("Clusterize", function() {
      "use strict";
      var ie2 = (function() {
        for (var v2 = 3, el = document.createElement("b"), all = el.all || []; el.innerHTML = "<!--[if gt IE " + ++v2 + "]><i><![endif]-->", all[0]; ) {
        }
        return v2 > 4 ? v2 : document.documentMode;
      })(), is_mac = navigator.platform.toLowerCase().indexOf("mac") + 1;
      var Clusterize2 = function(data) {
        if (!(this instanceof Clusterize2))
          return new Clusterize2(data);
        var self2 = this;
        var defaults2 = {
          rows_in_block: 50,
          blocks_in_cluster: 4,
          tag: null,
          show_no_data_row: true,
          no_data_class: "clusterize-no-data",
          no_data_text: "No data",
          keep_parity: true,
          callbacks: {}
        };
        self2.options = {};
        var options = ["rows_in_block", "blocks_in_cluster", "show_no_data_row", "no_data_class", "no_data_text", "keep_parity", "tag", "callbacks"];
        for (var i = 0, option2; option2 = options[i]; i++) {
          self2.options[option2] = typeof data[option2] != "undefined" && data[option2] != null ? data[option2] : defaults2[option2];
        }
        var elems = ["scroll", "content"];
        for (var i = 0, elem; elem = elems[i]; i++) {
          self2[elem + "_elem"] = data[elem + "Id"] ? document.getElementById(data[elem + "Id"]) : data[elem + "Elem"];
          if (!self2[elem + "_elem"])
            throw new Error("Error! Could not find " + elem + " element");
        }
        if (!self2.content_elem.hasAttribute("tabindex"))
          self2.content_elem.setAttribute("tabindex", 0);
        var rows = isArray(data.rows) ? data.rows : self2.fetchMarkup(), cache = {}, scroll_top = self2.scroll_elem.scrollTop;
        self2.insertToDOM(rows, cache);
        self2.scroll_elem.scrollTop = scroll_top;
        var last_cluster = false, scroll_debounce = 0, pointer_events_set = false, scrollEv = function() {
          if (is_mac) {
            if (!pointer_events_set) self2.content_elem.style.pointerEvents = "none";
            pointer_events_set = true;
            clearTimeout(scroll_debounce);
            scroll_debounce = setTimeout(function() {
              self2.content_elem.style.pointerEvents = "auto";
              pointer_events_set = false;
            }, 50);
          }
          if (last_cluster != (last_cluster = self2.getClusterNum(rows)))
            self2.insertToDOM(rows, cache);
          if (self2.options.callbacks.scrollingProgress)
            self2.options.callbacks.scrollingProgress(self2.getScrollProgress());
        }, resize_debounce = 0, resizeEv = function() {
          clearTimeout(resize_debounce);
          resize_debounce = setTimeout(self2.refresh, 100);
        };
        on2("scroll", self2.scroll_elem, scrollEv);
        on2("resize", window, resizeEv);
        self2.destroy = function(clean) {
          off2("scroll", self2.scroll_elem, scrollEv);
          off2("resize", window, resizeEv);
          self2.html((clean ? self2.generateEmptyRow() : rows).join(""));
        };
        self2.refresh = function(force) {
          if (self2.getRowsHeight(rows) || force) self2.update(rows);
        };
        self2.update = function(new_rows) {
          rows = isArray(new_rows) ? new_rows : [];
          var scroll_top2 = self2.scroll_elem.scrollTop;
          if (rows.length * self2.options.item_height < scroll_top2) {
            self2.scroll_elem.scrollTop = 0;
            last_cluster = 0;
          }
          self2.insertToDOM(rows, cache);
          self2.scroll_elem.scrollTop = scroll_top2;
        };
        self2.clear = function() {
          self2.update([]);
        };
        self2.getRowsAmount = function() {
          return rows.length;
        };
        self2.getScrollProgress = function() {
          return this.options.scroll_top / (rows.length * this.options.item_height) * 100 || 0;
        };
        var add2 = function(where, _new_rows) {
          var new_rows = isArray(_new_rows) ? _new_rows : [];
          if (!new_rows.length) return;
          rows = where == "append" ? rows.concat(new_rows) : new_rows.concat(rows);
          self2.insertToDOM(rows, cache);
        };
        self2.append = function(rows2) {
          add2("append", rows2);
        };
        self2.prepend = function(rows2) {
          add2("prepend", rows2);
        };
      };
      Clusterize2.prototype = {
        constructor: Clusterize2,
        // fetch existing markup
        fetchMarkup: function() {
          var rows = [], rows_nodes = this.getChildNodes(this.content_elem);
          while (rows_nodes.length) {
            rows.push(rows_nodes.shift().outerHTML);
          }
          return rows;
        },
        // get tag name, content tag name, tag height, calc cluster height
        exploreEnvironment: function(rows, cache) {
          var opts = this.options;
          opts.content_tag = this.content_elem.tagName.toLowerCase();
          if (!rows.length) return;
          if (ie2 && ie2 <= 9 && !opts.tag) opts.tag = rows[0].match(/<([^>\s/]*)/)[1].toLowerCase();
          if (this.content_elem.children.length <= 1) cache.data = this.html(rows[0] + rows[0] + rows[0]);
          if (!opts.tag) opts.tag = this.content_elem.children[0].tagName.toLowerCase();
          this.getRowsHeight(rows);
        },
        getRowsHeight: function(rows) {
          var opts = this.options, prev_item_height = opts.item_height;
          opts.cluster_height = 0;
          if (!rows.length) return;
          var nodes = this.content_elem.children;
          if (!nodes.length) return;
          var node = nodes[Math.floor(nodes.length / 2)];
          opts.item_height = node.offsetHeight;
          if (opts.tag == "tr" && getStyle("borderCollapse", this.content_elem) != "collapse")
            opts.item_height += parseInt(getStyle("borderSpacing", this.content_elem), 10) || 0;
          if (opts.tag != "tr") {
            var marginTop = parseInt(getStyle("marginTop", node), 10) || 0;
            var marginBottom = parseInt(getStyle("marginBottom", node), 10) || 0;
            opts.item_height += Math.max(marginTop, marginBottom);
          }
          opts.block_height = opts.item_height * opts.rows_in_block;
          opts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;
          opts.cluster_height = opts.blocks_in_cluster * opts.block_height;
          return prev_item_height != opts.item_height;
        },
        // get current cluster number
        getClusterNum: function(rows) {
          var opts = this.options;
          opts.scroll_top = this.scroll_elem.scrollTop;
          var cluster_divider = opts.cluster_height - opts.block_height;
          var current_cluster = Math.floor(opts.scroll_top / cluster_divider);
          var max_cluster = Math.floor(rows.length * opts.item_height / cluster_divider);
          return Math.min(current_cluster, max_cluster);
        },
        // generate empty row if no data provided
        generateEmptyRow: function() {
          var opts = this.options;
          if (!opts.tag || !opts.show_no_data_row) return [];
          var empty_row = document.createElement(opts.tag), no_data_content = document.createTextNode(opts.no_data_text), td;
          empty_row.className = opts.no_data_class;
          if (opts.tag == "tr") {
            td = document.createElement("td");
            td.colSpan = 100;
            td.appendChild(no_data_content);
          }
          empty_row.appendChild(td || no_data_content);
          return [empty_row.outerHTML];
        },
        // generate cluster for current scroll position
        generate: function(rows) {
          var opts = this.options, rows_len = rows.length;
          if (rows_len < opts.rows_in_block) {
            return {
              top_offset: 0,
              bottom_offset: 0,
              rows_above: 0,
              rows: rows_len ? rows : this.generateEmptyRow()
            };
          }
          var items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * this.getClusterNum(rows), 0), items_end = items_start + opts.rows_in_cluster, top_offset = Math.max(items_start * opts.item_height, 0), bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0), this_cluster_rows = [], rows_above = items_start;
          if (top_offset < 1) {
            rows_above++;
          }
          for (var i = items_start; i < items_end; i++) {
            rows[i] && this_cluster_rows.push(rows[i]);
          }
          return {
            top_offset,
            bottom_offset,
            rows_above,
            rows: this_cluster_rows
          };
        },
        renderExtraTag: function(class_name, height) {
          var tag = document.createElement(this.options.tag), clusterize_prefix = "clusterize-";
          tag.className = [clusterize_prefix + "extra-row", clusterize_prefix + class_name].join(" ");
          height && (tag.style.height = height + "px");
          return tag.outerHTML;
        },
        // if necessary verify data changed and insert to DOM
        insertToDOM: function(rows, cache) {
          if (!this.options.cluster_height) {
            this.exploreEnvironment(rows, cache);
          }
          var data = this.generate(rows), this_cluster_rows = data.rows.join(""), this_cluster_content_changed = this.checkChanges("data", this_cluster_rows, cache), top_offset_changed = this.checkChanges("top", data.top_offset, cache), only_bottom_offset_changed = this.checkChanges("bottom", data.bottom_offset, cache), callbacks = this.options.callbacks, layout = [];
          if (this_cluster_content_changed || top_offset_changed) {
            if (data.top_offset) {
              this.options.keep_parity && layout.push(this.renderExtraTag("keep-parity"));
              layout.push(this.renderExtraTag("top-space", data.top_offset));
            }
            layout.push(this_cluster_rows);
            data.bottom_offset && layout.push(this.renderExtraTag("bottom-space", data.bottom_offset));
            callbacks.clusterWillChange && callbacks.clusterWillChange();
            this.html(layout.join(""));
            this.options.content_tag == "ol" && this.content_elem.setAttribute("start", data.rows_above);
            this.content_elem.style["counter-increment"] = "clusterize-counter " + (data.rows_above - 1);
            callbacks.clusterChanged && callbacks.clusterChanged();
          } else if (only_bottom_offset_changed) {
            this.content_elem.lastChild.style.height = data.bottom_offset + "px";
          }
        },
        // unfortunately ie <= 9 does not allow to use innerHTML for table elements, so make a workaround
        html: function(data) {
          var content_elem = this.content_elem;
          if (ie2 && ie2 <= 9 && this.options.tag == "tr") {
            var div = document.createElement("div"), last;
            div.innerHTML = "<table><tbody>" + data + "</tbody></table>";
            while (last = content_elem.lastChild) {
              content_elem.removeChild(last);
            }
            var rows_nodes = this.getChildNodes(div.firstChild.firstChild);
            while (rows_nodes.length) {
              content_elem.appendChild(rows_nodes.shift());
            }
          } else {
            content_elem.innerHTML = data;
          }
        },
        getChildNodes: function(tag) {
          var child_nodes = tag.children, nodes = [];
          for (var i = 0, ii = child_nodes.length; i < ii; i++) {
            nodes.push(child_nodes[i]);
          }
          return nodes;
        },
        checkChanges: function(type, value2, cache) {
          var changed = value2 != cache[type];
          cache[type] = value2;
          return changed;
        }
      };
      function on2(evt, element, fnc) {
        return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent("on" + evt, fnc);
      }
      function off2(evt, element, fnc) {
        return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent("on" + evt, fnc);
      }
      function isArray(arr) {
        return Object.prototype.toString.call(arr) === "[object Array]";
      }
      function getStyle(prop, elem) {
        return window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop];
      }
      return Clusterize2;
    });
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.regexpCode = exports4.getEsmExportName = exports4.getProperty = exports4.safeStringify = exports4.stringify = exports4.strConcat = exports4.addCodeArg = exports4.str = exports4._ = exports4.nil = exports4._Code = exports4.Name = exports4.IDENTIFIER = exports4._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports4._CodeOrName = _CodeOrName;
    exports4.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports4.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports4.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names36, c) => {
          if (c instanceof Name)
            names36[c.str] = (names36[c.str] || 0) + 1;
          return names36;
        }, {});
      }
    };
    exports4._Code = _Code;
    exports4.nil = new _Code("");
    function _3(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports4._ = _3;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports4.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports4.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b3) {
      if (b3 === '""')
        return a2;
      if (a2 === '""')
        return b3;
      if (typeof a2 == "string") {
        if (b3 instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b3 != "string")
          return `${a2.slice(0, -1)}${b3}"`;
        if (b3[0] === '"')
          return a2.slice(0, -1) + b3.slice(1);
        return;
      }
      if (typeof b3 == "string" && b3[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b3.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports4.strConcat = strConcat;
    function interpolate(x3) {
      return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
    }
    function stringify(x3) {
      return new _Code(safeStringify(x3));
    }
    exports4.stringify = stringify;
    function safeStringify(x3) {
      return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports4.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports4.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
    }
    exports4.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports4.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports4.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports4.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.ValueScope = exports4.ValueScopeName = exports4.Scope = exports4.varKinds = exports4.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports4.UsedValueState = UsedValueState = {}));
    exports4.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports4.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value2, { property, itemIndex }) {
        this.value = value2;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports4.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value2) {
        var _a2;
        if (value2.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a2 = value2.key) !== null && _a2 !== void 0 ? _a2 : value2.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value2.ref;
        name.setValue(value2, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports4.varKinds.var : exports4.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports4.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.or = exports4.and = exports4.not = exports4.CodeGen = exports4.operators = exports4.varKinds = exports4.ValueScopeName = exports4.ValueScope = exports4.Scope = exports4.Name = exports4.regexpCode = exports4.stringify = exports4.getProperty = exports4.nil = exports4.strConcat = exports4.str = exports4._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports4, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports4, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports4, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports4, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports4, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports4, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports4, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports4, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports4, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports4, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports4, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports4, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports4.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names36, constants) {
        if (!names36[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names36, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names36, constants) {
        if (this.lhs instanceof code_1.Name && !names36[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names36, constants);
        return this;
      }
      get names() {
        const names36 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names36, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names36, constants) {
        this.code = optimizeExpr(this.code, names36, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names36, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names36, constants))
            continue;
          subtractNames(names36, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names36, n) => addNames(names36, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names36, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names36, constants);
        if (!(super.optimizeNames(names36, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names36, constants);
        return this;
      }
      get names() {
        const names36 = super.names;
        addExprNames(names36, this.condition);
        if (this.else)
          addNames(names36, this.else.names);
        return names36;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names36, constants) {
        if (!super.optimizeNames(names36, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names36, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names36 = addExprNames(super.names, this.from);
        return addExprNames(names36, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names36, constants) {
        if (!super.optimizeNames(names36, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names36, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names36, constants) {
        var _a2, _b;
        super.optimizeNames(names36, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names36, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names36, constants);
        return this;
      }
      get names() {
        const names36 = super.names;
        if (this.catch)
          addNames(names36, this.catch.names);
        if (this.finally)
          addNames(names36, this.finally.names);
        return names36;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value2) {
        const name = this._extScope.value(prefixOrName, value2);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports4.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value2] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value2 || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value2);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value2) {
        const node = new Return();
        this._blockNode(node);
        this.code(value2);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N22) {
        const n = this._currNode;
        if (n instanceof N1 || N22 && n instanceof N22) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports4.CodeGen = CodeGen;
    function addNames(names36, from) {
      for (const n in from)
        names36[n] = (names36[n] || 0) + (from[n] || 0);
      return names36;
    }
    function addExprNames(names36, from) {
      return from instanceof code_1._CodeOrName ? addNames(names36, from.names) : names36;
    }
    function optimizeExpr(expr, names36, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names36[n.str] !== 1)
          return n;
        delete names36[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names36[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names36, from) {
      for (const n in from)
        names36[n] = (names36[n] || 0) - (from[n] || 0);
    }
    function not(x3) {
      return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
    }
    exports4.not = not;
    var andCode = mappend(exports4.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports4.and = and;
    var orCode = mappend(exports4.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports4.or = or;
    function mappend(op) {
      return (x3, y3) => x3 === code_1.nil ? y3 : y3 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y3)}`;
    }
    function par(x3) {
      return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.checkStrictMode = exports4.getErrorPath = exports4.Type = exports4.useFunc = exports4.setEvaluated = exports4.evaluatedPropsToName = exports4.mergeEvaluated = exports4.eachItem = exports4.unescapeJsonPointer = exports4.escapeJsonPointer = exports4.escapeFragment = exports4.unescapeFragment = exports4.schemaRefOrVal = exports4.schemaHasRulesButRef = exports4.schemaHasRules = exports4.checkUnknownRules = exports4.alwaysValidSchema = exports4.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports4.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports4.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports4.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports4.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports4.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    exports4.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports4.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports4.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports4.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports4.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x3 of xs)
          f(x3);
      } else {
        f(xs);
      }
    }
    exports4.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports4.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports4.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    exports4.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports4.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports4.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports4.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode2 = it.opts.strictSchema) {
      if (!mode2)
        return;
      msg = `strict mode: ${msg}`;
      if (mode2 === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports4.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names36 = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports4.default = names36;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.extendErrors = exports4.resetErrorsCount = exports4.reportExtraError = exports4.reportError = exports4.keyword$DataError = exports4.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports4.keywordError = {
      message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports4.keyword$DataError = {
      message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports4.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports4.reportError = reportError;
    function reportExtraError(cxt, error = exports4.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports4.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports4.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports4.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params: params2, message }, keyValues) {
      const { keyword: keyword2, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E2.keyword, keyword2], [E2.params, typeof params2 == "function" ? params2(cxt) : params2 || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.boolOrEmptySchema = exports4.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports4.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports4.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.getRules = exports4.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x3) {
      return typeof x3 == "string" && jsonTypes.has(x3);
    }
    exports4.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports4.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.shouldUseRule = exports4.shouldUseGroup = exports4.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports4.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports4.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports4.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.reportTypeError = exports4.checkDataTypes = exports4.checkDataType = exports4.coerceAndCheckDataType = exports4.getJSONTypes = exports4.getSchemaTypes = exports4.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports4.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports4.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports4.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports4.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports4.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports4.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports4.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports4.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.validateUnion = exports4.validateArray = exports4.usePattern = exports4.callValidateCode = exports4.schemaProperties = exports4.allSchemaProperties = exports4.noPropertyInData = exports4.propertyInData = exports4.isOwnProperty = exports4.hasPropFunc = exports4.reportMissingProp = exports4.checkMissingProp = exports4.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports4.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports4.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports4.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports4.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports4.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports4.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports4.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    exports4.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
    }
    exports4.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports4.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports4.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports4.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports4.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.validateKeywordUsage = exports4.validSchemaType = exports4.funcKeywordCode = exports4.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports4.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword2, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports4.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports4.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword2) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports4.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.extendSubschemaMode = exports4.extendSubschemaData = exports4.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports4.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports4.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports4.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports4, module) {
    "use strict";
    module.exports = function equal(a2, b3) {
      if (a2 === b3) return true;
      if (a2 && b3 && typeof a2 == "object" && typeof b3 == "object") {
        if (a2.constructor !== b3.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b3.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a2[i], b3[i])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b3.source && a2.flags === b3.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b3.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b3.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b3).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a2[key], b3[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b3 !== b3;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports4, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.getSchemaRefs = exports4.resolveUrl = exports4.normalizeId = exports4._getFullPath = exports4.getFullPath = exports4.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports4.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p2 = resolver.parse(id);
      return _getFullPath(resolver, p2);
    }
    exports4.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    exports4._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports4.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports4.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports4.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.getData = exports4.KeywordCxt = exports4.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports4.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword2 in rules) {
        const rule = rules[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword2);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword2;
        this.data = it.data;
        this.schema = it.schema[keyword2];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports4.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword2, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword2);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches2 = RELATIVE_JSON_POINTER.exec($data);
        if (!matches2)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches2[1];
        jsonPointer = matches2[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports4.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports4.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports4.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.resolveSchema = exports4.getCompilingSchema = exports4.resolveRef = exports4.compileSchema = exports4.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports4.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports4.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports4.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports4.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p2 = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    exports4.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports4, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports4, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports4, module) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches2 = urnComponent.path.match(URN_REG);
      if (matches2) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches2[1].toLowerCase();
        urnComponent.nss = matches2[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports4, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse3(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse3(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target2 = {};
      if (!skipNormalization) {
        base = parse3(serialize(base, options), options);
        relative = parse3(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target2.scheme = relative.scheme;
        target2.userinfo = relative.userinfo;
        target2.host = relative.host;
        target2.port = relative.port;
        target2.path = removeDotSegments(relative.path || "");
        target2.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target2.userinfo = relative.userinfo;
          target2.host = relative.host;
          target2.port = relative.port;
          target2.path = removeDotSegments(relative.path || "");
          target2.query = relative.query;
        } else {
          if (!relative.path) {
            target2.path = base.path;
            if (relative.query !== void 0) {
              target2.query = relative.query;
            } else {
              target2.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target2.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target2.path = "/" + relative.path;
              } else if (!base.path) {
                target2.path = relative.path;
              } else {
                target2.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target2.path = removeDotSegments(target2.path);
            }
            target2.query = relative.query;
          }
          target2.userinfo = base.userinfo;
          target2.host = base.host;
          target2.port = base.port;
        }
        target2.scheme = base.scheme;
      }
      target2.fragment = relative.fragment;
      return target2;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches2 = uri.match(URI_PARSE);
      if (matches2) {
        parsed.scheme = matches2[1];
        parsed.userinfo = matches2[3];
        parsed.host = matches2[4];
        parsed.port = parseInt(matches2[5], 10);
        parsed.path = matches2[6] || "";
        parsed.query = matches2[7];
        parsed.fragment = matches2[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches2[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports4.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.CodeGen = exports4.Name = exports4.nil = exports4.stringify = exports4.str = exports4._ = exports4.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports4, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports4, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports4, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports4, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports4, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports4, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports4, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e2 = o.strictSchema) !== null && _e2 !== void 0 ? _e2 : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger3(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v2;
        if (typeof schemaKeyRef == "string") {
          v2 = this.getSchema(schemaKeyRef);
          if (!v2)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v2 = this.compile(schemaKeyRef);
        }
        const valid = v2(data);
        if (!("$async" in v2))
          this.errors = v2.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p2 = this._loading[ref];
          if (p2)
            return p2;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t) => addRule.call(this, k3, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports4.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log2 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs2) {
      if (Array.isArray(defs2)) {
        this.addVocabulary(defs2);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs2) {
        const def = defs2[keyword2];
        if (!def.keyword)
          def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger3(logger50) {
      if (logger50 === false)
        return noLogs;
      if (logger50 === void 0)
        return console;
      if (logger50.log && logger50.warn && logger50.error)
        return logger50;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.callRef = exports4.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v2 = getValidate(cxt, sch);
          callRef(cxt, v2, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports4.getValidate = getValidate;
    function callRef(cxt, v2, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
          addEvaluatedFrom(v2);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports4.callRef = callRef;
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports4.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value2;
      while (pos < len) {
        length++;
        value2 = str.charCodeAt(pos++);
        if (value2 >= 55296 && value2 <= 56319 && pos < len) {
          value2 = str.charCodeAt(pos);
          if ((value2 & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports4.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports4.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j: j2 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
      params: ({ params: { i, j: j2 } }) => (0, codegen_1._)`{i: ${i}, j: ${j2}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j2 = gen.let("j");
          cxt.setParams({ i, j: j2 });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j2) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j2, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j2) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j2}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports4.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword: keyword2, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports4.validateAdditionalItems = validateAdditionalItems;
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l3 = schArr.length;
        const fullTuple = l3 === sch.minItems && (l3 === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l3}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports4.validateTuple = validateTuple;
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.validateSchemaDeps = exports4.validatePropertyDeps = exports4.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports4.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports4.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports4.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports4.validateSchemaDeps = validateSchemaDeps;
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params: params2 }) => (0, codegen_1._)`{propertyName: ${params2.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params: params2 }) => (0, codegen_1._)`{additionalProperty: ${params2.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params: params2 }) => (0, codegen_1._)`{passingSchemas: ${params2.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: params2 }) => (0, codegen_1.str)`must match "${params2.ifClause}" schema`,
      params: ({ params: params2 }) => (0, codegen_1._)`{failingKeyword: ${params2.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it, keyword2) {
      const schema = it.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports4.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports4.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.contentVocabulary = exports4.metadataVocabulary = void 0;
    exports4.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports4.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports4.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports4.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports4.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports4, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports4, module) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.MissingRefError = exports4.ValidationError = exports4.CodeGen = exports4.Name = exports4.nil = exports4.stringify = exports4.str = exports4._ = exports4.KeywordCxt = exports4.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v2) => this.addVocabulary(v2));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports4.Ajv = Ajv2;
    module.exports = exports4 = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports4, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports4, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports4, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports4, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports4, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports4, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports4, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports4, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports4, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/formats.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.formatNames = exports4.fastFormats = exports4.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports4.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date2, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports4.fastFormats = {
      ...exports4.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports4.formatNames = Object.keys(exports4.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date2(str) {
      const matches2 = DATE.exec(str);
      if (!matches2)
        return false;
      const year = +matches2[1];
      const month = +matches2[2];
      const day = +matches2[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d22) {
      if (!(d1 && d22))
        return void 0;
      if (d1 > d22)
        return 1;
      if (d1 < d22)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time(str) {
        const matches2 = TIME.exec(str);
        if (!matches2)
          return false;
        const hr = +matches2[1];
        const min = +matches2[2];
        const sec = +matches2[3];
        const tz = matches2[4];
        const tzSign = matches2[5] === "-" ? -1 : 1;
        const tzH = +(matches2[6] || 0);
        const tzM = +(matches2[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d22 = new Date(dt2).valueOf();
      if (!(d1 && d22))
        return void 0;
      return d1 - d22;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d22, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d22);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value2) {
      return Number.isInteger(value2) && value2 <= MAX_INT32 && value2 >= MIN_INT32;
    }
    function validateInt64(value2) {
      return Number.isInteger(value2);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/limit.js"(exports4) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    exports4.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword2}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports4.formatLimitDefinition);
      return ajv;
    };
    exports4.default = formatLimitPlugin;
  }
});

// node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/geopf-extensions-openlayers/node_modules/ajv-formats/dist/index.js"(exports4, module) {
    "use strict";
    Object.defineProperty(exports4, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats2(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats2(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode2 = "full") => {
      const formats = mode2 === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats2(ajv, list, fs, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports4 = formatsPlugin;
    Object.defineProperty(exports4, "__esModule", { value: true });
    exports4.default = formatsPlugin;
  }
});

// node_modules/geopf-extensions-openlayers/package.json
var package_default = {
  name: "geopf-extensions-openlayers",
  description: "French Geoportal Extensions for OpenLayers libraries",
  version: "1.0.0-beta.6-468",
  date: "05/12/2025",
  module: "src/index.js",
  directories: {},
  engines: {
    node: ">=20"
  },
  repository: {
    type: "git",
    url: "https://github.com/IGNF/geopf-extensions-openlayers.git"
  },
  author: "IGNF",
  keywords: [
    "geoportail",
    "geoplateforme",
    "javascript",
    "OpenLayers 10"
  ],
  license: "AGPL-3.0",
  bugs: {
    url: "https://github.com/IGNF/geopf-extensions-openlayers/issues"
  },
  homepage: "https://github.com/IGNF/geopf-extensions-openlayers#readme",
  dependencies: {
    "@gouvfr/dsfr": "^1.13.1",
    "@mapbox/mapbox-gl-style-spec": "14.8.0",
    "@xmldom/xmldom": "^0.9.0",
    ajv: "^8.17.1",
    "ajv-formats": "^3.0.1",
    "clusterize.js": "^1.0.0",
    dompurify: "^3.2.6",
    eventbusjs: "0.2.0",
    "geoportal-access-lib": "3.4.6",
    loglevel: "^1.9.1",
    "markdown-toc": "^1.2.0",
    marked: "^16.2.1",
    ol: "^10.3.1",
    "ol-contextmenu": "^5.5.0",
    "ol-mapbox-style": "^12.3.5",
    proj4: "2.15.0",
    sortablejs: "1.15.3",
    typescript: "^5.3.3",
    "whatwg-fetch": "3.6.20",
    yargs: "^17.7.2"
  }
};

// node_modules/ol/source/ImageWMS.js
var ImageWMS = class extends Image_default {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.url_ = options.url;
    this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    this.params_ = Object.assign({}, options.params);
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.renderedRevision_ = 0;
    this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
    this.loaderProjection_ = null;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(coordinate, resolution, projection, params2) {
    const projectionObj = get2(projection);
    const sourceProjectionObj = this.getProjection();
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = calculateSourceResolution(
        sourceProjectionObj,
        projectionObj,
        coordinate,
        resolution
      );
      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
    }
    const options = {
      url: this.url_,
      params: {
        ...this.params_,
        ...params2
      },
      projection: sourceProjectionObj || projectionObj
    };
    return getFeatureInfoUrl(options, coordinate, resolution);
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(resolution, params2) {
    return getLegendUrl(
      {
        url: this.url_,
        params: {
          ...this.params_,
          ...params2
        }
      },
      resolution
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @override
   */
  getImageInternal(extent, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    if (!this.loader || this.loaderProjection_ !== projection) {
      this.loaderProjection_ = projection;
      this.loader = createLoader({
        crossOrigin: this.crossOrigin_,
        params: this.params_,
        projection,
        serverType: this.serverType_,
        hidpi: this.hidpi_,
        url: this.url_,
        ratio: this.ratio_,
        load: (image, src) => {
          this.image.setImage(image);
          this.imageLoadFunction_(this.image, src);
          return decode(image);
        }
      });
    }
    return super.getImageInternal(extent, resolution, pixelRatio, projection);
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(imageLoadFunction) {
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(url) {
    if (url != this.url_) {
      this.url_ = url;
      this.loader = null;
      this.changed();
    }
  }
  /**
   * Set the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  setParams(params2) {
    this.params_ = Object.assign({}, params2);
    this.changed();
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(params2) {
    Object.assign(this.params_, params2);
    this.changed();
  }
  /**
   * @override
   */
  changed() {
    this.image = null;
    super.changed();
  }
};
var ImageWMS_default = ImageWMS;

// node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js
var Log = __toESM(require_loglevel());
var LoggerByDefault = {
  /**
   * logger statique
   *
   * @static
   * @param {String} name - nom du logger
   * @returns {Object} retourne un logger
   */
  getLogger: function(name) {
    if (typeof process2 === "undefined") {
      var process2 = {};
      process2.env = {
        VERBOSE: false
      };
    }
    process2.env.VERBOSE ? Log.enableAll() : Log.disableAll();
    var logname = name || "default";
    return Log.getLogger(logname);
  }
};
var LoggerByDefault_default = LoggerByDefault;

// node_modules/geoportal-access-lib/src/Utils/MessagesResources.js
var MessagesResources = {
  // ParamÃ¨tres
  PARAM_MISSING: "Parameter(s) '%var%' missing",
  PARAM_EMPTY: "Parameter(s) '%var%' empty",
  PARAM_TYPE: "Wrong type(s) for parameter(s) '%var%'",
  PARAM_FORMAT: "Parameter(s) '%var%' not correctly formatted",
  PARAM_NOT_SUPPORT: "Value(s) for parameter(s) '%var%' not supported",
  PARAM_NOT_SUPPORT_NODEJS: "Value(s) for parameter(s) '%var%' not supported to NodeJS",
  PARAM_UNKNOWN: "Value(s) for parameter(s) '%var%' unknown",
  // Services
  // RequÃªte
  SERVICE_REQUEST_BUILD: "An error occurred during the request building of the service",
  SERVICE_REQUEST_EMPTY: "The request sent to the service is empty",
  // RÃ©ponse
  SERVICE_RESPONSE_EXCEPTION: "The service returned an exception : '%var%'",
  SERVICE_RESPONSE_EXCEPTION_2: "The service returned an exception",
  SERVICE_RESPONSE_ANALYSE: "An error occurred while parsing the response '%var%' of the service",
  SERVICE_RESPONSE_ANALYSE_2: "An unknown error occurred while parsing the response",
  SERVICE_RESPONSE_EMPTY: "The response of the service is empty",
  SERVICE_RESPONSE_EMPTY_2: "The response from the service could not be analyzed or is empty",
  SERVICE_RESPONSE_FORMAT: "The format of the service response is not supported (handled format(s) : '%var%')",
  SERVICE_RESPONSE_FORMAT_2: "The format of the service response is not supported",
  SERVICE_RESPONSE_FORMAT_3: "No suggestion matching the search",
  // Classes
  CLASS_CONSTRUCTOR: "'%var%' constructor cannot be called as a function.",
  /**
   * Fonction qui va retourner le message d'erreur associÃ© Ã  la clÃ© donnÃ©e
   *
   * @method getMessage
   * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)
   * @param {String[]} parametres - ParamÃ¨tres/variables concernÃ©s par le message d'erreur associÃ© Ã  la clef donnÃ©e
   * @return {String} message - String contenant le message de l'exception
   */
  getMessage: function(clef, parametres) {
    if (Object.keys(arguments).length === 0) {
      return "Message indefined !";
    }
    var params2 = Array.prototype.slice.call(arguments);
    var key = params2.shift();
    var args = params2;
    var message = this[key];
    try {
      if (Array.isArray(args) && args.length > 0) {
        message = message.replace("%var%", args.join(" - "));
      } else {
        message = message.replace("%var%", "%var% (not specified)");
      }
    } catch (e) {
    }
    return message;
  }
};
var MessagesResources_default = MessagesResources;

// node_modules/geoportal-access-lib/src/Utils/Helper.js
var Helper = {
  /**
   * concatenation des parametres key/value dans les urls
   *
   * @method normalyzeParameters
   * @static
   * @param {Object} params - tableau de clef/valeur
   *
   * @example
   *  Gp.Utils.Helper.normalyzeParameters ({
   *         key1:value1,
   *         key2:value2,
   *         key3:value3
   *  });
   *  // out : "key1=value1&key2=value2&key3=value3"
   *
   * @returns {String} retourne les paramÃ¨tres concatÃ©nÃ©s
   */
  normalyzeParameters: function(params2) {
    var myParams = null;
    if (params2) {
      var tabParams = [];
      for (var key in params2) {
        if (params2.hasOwnProperty(key)) {
          var value2 = params2[key];
          if (!value2) {
            value2 = "";
          }
          tabParams.push(key + "=" + value2);
        }
      }
      myParams = tabParams.join("&");
    }
    return myParams;
  },
  /**
   * ConcatÃ©nation et encodage des urls.
   *
   * @method normalyzeUrl
   * @static
   * @param {String} url - url
   * @param {Object|String} params - tableau de clef/valeur ou string
   * @param {Boolean} encode - true|false, false par defaut
   *
   * @example
   *  Gp.Utils.Helper.normalyzeUrl (url, {
   *         key1:value1,
   *         key2=:value2,
   *         key3:value3
   *  });
   *  // out : "url?key1=value1&key2=value2&key3=value3"
   *
   * @returns {String} retourne une url normalisÃ©e
   */
  normalyzeUrl: function(url, params2, encode2) {
    var myUrl = url;
    if (url) {
      if (url.split("?").length - 1 >= 2) {
        var firstOccuranceIndex = url.search(/\?/) + 1;
        myUrl = url.substring(0, firstOccuranceIndex) + url.slice(firstOccuranceIndex).replace(/\?/g, "&");
      }
      var k3 = url.indexOf("?");
      if (k3 === -1) {
        myUrl += "?";
      }
      if (k3 !== -1 && k3 !== url.length - 1) {
        myUrl += "&";
      }
    }
    if (params2) {
      if (typeof params2 === "string") {
        params2 = params2.replace("?", "");
        myUrl += params2;
      } else {
        myUrl += this.normalyzeParameters(params2);
      }
    }
    if (encode2) {
      myUrl = encodeURIComponent(myUrl);
    }
    return myUrl;
  },
  /**
   * Indentation d'une chaine
   *
   * @method indent
   * @static
   * @param {Number} n - nombre de tabulation
   * @param {String} msg - chaine
   *
   * @example
   * Gp.Utils.Helper.indent (2, "message Ã  indenter")
   * // out
   * // ........message Ã  indenter
   *
   * @returns {String} retourne une chaine indentÃ©e
   */
  indent: function(n, msg) {
    var num = n || 0;
    return new Array(num + 1).join("	") + msg;
  }
};
var Helper_default = Helper;

// node_modules/geoportal-access-lib/src/Protocols/XHR.js
var import_es6_promise = __toESM(require_es6_promise());
var XHR = {
  /**
   * Interface unique d'envoi d'une requÃªte.
   *
   * @method call
   * @static
   * @param {Object} settings - options generales
   * @param {String} settings.url    - url du service
   * @param {String} settings.method - GET, POST, PUT, DELETE
   * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)
   * @param {String} settings.data   - content (post) ou param (get)
   * @param {String} settings.proxy  - proxy url
   * @param {Object|String} settings.headers - (post) ex. referer
   * @param {Object|String} settings.content - (post) ex. 'application/json'
   * @param {String} settings.timeOut - timeout = 0 par defaut
   * @param {String} settings.scope - this
   * @param {Function} settings.onResponse - callback
   * @param {Function} settings.onFailure  - callback
   */
  call: function(settings) {
    var logger50 = LoggerByDefault_default.getLogger("XHR");
    logger50.trace("[XHR::call()]");
    import_es6_promise.default.polyfill();
    if (!settings.url) {
      throw new Error("missing parameter : url is not defined !");
    }
    if (!settings.method) {
      throw new Error("missing parameter : method is not defined !");
    }
    if (!settings.format) {
      settings.format = "text";
    }
    var options = {};
    options.url = settings.url;
    options.data = settings.data ? settings.data : null;
    options.method = settings.method;
    options.timeOut = settings.timeOut || 0;
    options.scope = settings.scope || this;
    options.proxy = settings.proxy || null;
    options.content = settings.content || null;
    options.headers = settings.headers || {
      referer: "http://localhost"
    };
    switch (settings.method) {
      case "DELETE":
      case "GET":
        break;
      case "PUT":
      case "POST":
        options.content = settings.content ? settings.content : "application/x-www-form-urlencoded";
        options.headers = settings.headers ? settings.headers : { referer: "http://localhost" };
        break;
      case "HEAD":
      case "OPTIONS":
        throw new Error("HTTP method not yet supported !");
      default:
        throw new Error("HTTP method unknown !");
    }
    switch (settings.format) {
      case "text":
        this.__call(options).then(function(response) {
          logger50.trace(response);
          settings.onResponse.call(this, response);
        }).catch(function(error) {
          settings.onFailure.call(this, error);
        });
        break;
      case "json":
        this.__callJSON(options).then(function(response) {
          logger50.trace(response);
          settings.onResponse.call(this, response);
        }).catch(function(error) {
          settings.onFailure.call(this, error);
        });
        break;
      case "xml":
        this.__callXML(options).then(function(response) {
          logger50.trace(response);
          settings.onResponse.call(this, response);
        }).catch(function(error) {
          settings.onFailure.call(this, error);
        });
        break;
      default:
        throw new Error("This output Format is not yet supported !");
    }
  },
  /**
   * Requete
   *
   * @method __call
   * @private
   * @param  {Object} options - options
   * @return {Object} promise
   */
  __call: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("XHR");
    logger50.trace("[XHR::__call()]");
    var promise = new Promise(
      function(resolve, reject) {
        var corps = options.method === "POST" || options.method === "PUT" ? 1 : 0;
        if (options.data && (typeof options.data === "object" && Object.keys(options.data).length || typeof options.data === "string" && options.data.length) && !corps) {
          options.url = Helper_default.normalyzeUrl(options.url, options.data);
        }
        logger50.trace("URL = ", options.url);
        var hXHR = null;
        if (typeof window === "undefined") {
          var nodefetch = require_browser();
          var opts = {
            headers: {
              Referer: "https://localhost"
            }
          };
          if (options.data && typeof options.data === "string" && corps) {
            opts = {
              method: options.method,
              body: options.data,
              headers: {
                "Content-Type": options.content,
                Referer: "https://localhost"
              }
            };
          }
          return nodefetch(options.url, opts).then(function(response) {
            if (response.ok) {
              resolve(response.text());
            } else {
              var message = "Errors Occured on Http Request (status : '" + response.statusText + "' | url : '" + response.url + "')";
              var status = response.status;
              reject({
                message,
                status
              });
            }
          }).catch(function(e) {
            reject({
              message: e,
              status: -1
            });
          });
        } else {
          if (window.XMLHttpRequest) {
            logger50.trace("XMLHttpRequest");
            hXHR = new XMLHttpRequest();
            hXHR.open(options.method, options.url, true);
            hXHR.overrideMimeType = options.content;
            var onTimeOutTrigger = null;
            if (options.timeOut > 0) {
              logger50.trace("XHR - TimeOut actif !");
              onTimeOutTrigger = window.setTimeout(
                function() {
                  var message = "TimeOut Occured on Http Request with XMLHttpRequest !";
                  reject({
                    message,
                    status: -1
                  });
                },
                options.timeOut
              );
            }
            if (corps) {
              logger50.trace("data = ", options.data);
              hXHR.setRequestHeader("Content-type", options.content);
            }
            hXHR.onerror = function(e) {
              console.log(e);
              reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
            };
            hXHR.ontimeout = function(e) {
              console.log(e);
              reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
            };
            hXHR.onreadystatechange = function(e) {
              if (hXHR.readyState === 4) {
                if (hXHR.status === 200) {
                  window.clearTimeout(onTimeOutTrigger);
                  resolve(hXHR.response);
                } else {
                  var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "' | response : '" + e.target.response + "')";
                  var status = e.target.status;
                  reject({
                    message,
                    status
                  });
                }
              }
            };
            var data4xhr = options.data && corps ? options.data : null;
            hXHR.send(data4xhr);
          } else if (window.XDomainRequest) {
            logger50.trace("XDomainRequest");
            hXHR = new XDomainRequest();
            hXHR.open(options.method, options.url);
            hXHR.overrideMimeType = options.content;
            if (options.timeOut > 0) {
              hXHR.timeout = options.timeout;
              logger50.trace("XHR - TimeOut actif !");
            }
            if (corps) {
              hXHR.setRequestHeader("Content-type", options.content);
            }
            hXHR.onerror = function() {
              reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
            };
            hXHR.ontimeout = function() {
              reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
            };
            hXHR.onload = function(e) {
              if (hXHR.status === 200) {
                resolve(hXHR.responseText);
              } else {
                var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "')";
                var status = e.target.status;
                reject({
                  message,
                  status
                });
              }
            };
            var data4xdr = options.data && corps ? options.data : null;
            hXHR.send(data4xdr);
          } else {
            throw new Error("CORS not supported");
          }
        }
      }
    );
    return promise;
  },
  /**
   * Requete avec parser JSON
   *
   * @method __callJSON
   * @private
   * @param  {Object} options - options
   * @return {Object} promise
   */
  __callJSON: function(options) {
    return this.__call(options).then(JSON.parse).catch(function(error) {
      console.log("_callJSON failed on : ", options.url, error);
    });
  },
  /**
   * Requete avec parser XML
   *
   * @method __callXML
   * @private
   * @param  {Object} options - options
   * @return {Object} promise
   */
  __callXML: function(options) {
    return this.__call(options).then(function(response) {
      var xmlDoc;
      if (typeof window === "undefined") {
        var DOMParser2 = require_lib().DOMParser;
        xmlDoc = new DOMParser2().parseFromString(response, "text/xml");
      } else {
        if (window.DOMParser) {
          var parser = new window.DOMParser();
          xmlDoc = parser.parseFromString(response, "text/xml");
        } else {
          xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = false;
          xmlDoc.loadXML(response);
        }
      }
      return xmlDoc;
    }).catch(function(error) {
      console.log("__callXML failed on : ", options.url, error);
    });
  }
};
var XHR_default = XHR;

// node_modules/geoportal-access-lib/src/Protocols/JSONP.js
var JSONP = {
  /**
   * Construction d'un identifiant statique basÃ© sur le timestamp,
   * et qui s'incremente de +1 Ã  chaque appel
   */
  uuid: (function() {
    var id = Math.floor(Date.now());
    return function() {
      return id++;
    };
  })(),
  /**
   * Cette fonction rÃ©alise l'appel du service fourni via le paramÃ¨tre "options.url"
   * en mettant en Å“uvre le protocole JSONP.
   *
   * @method call
   * @static
   * @param {Object} options - parametres d'invocation du service en JSONP
   * @param {String} options.url - URL du service Ã  invoquer (indÃ©pendamment du protocole JSONP).
   *  Cette URL contient dÃ©jÃ  les paramÃ¨tres du service.
   *  Si le paramÃ¨tre dÃ©diÃ© Ã  la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas prÃ©sent, il est rajoutÃ© par la fonction ;
   *  sa valeur est dÃ©terminÃ©e en fonction du paramÃ¨tre callbackName.
   * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considÃ¨re que le service n'a pas rÃ©pondu.
   *  Une valeur de 0 pour ce paramÃ¨tre permet de dÃ©sactiver la gestion du timeOut.
   * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback Ã  rajouter sur l'URL.
   *  Si aucun suffixe n'est spÃ©cifiÃ© (cas par dÃ©faut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: "callback1458574396582 ()"
   * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramÃ¨tre callback Ã  rajouter sur l'URL.
   *  Si l'URL fournie contient dÃ©jÃ  le paramÃ¨tre callback, le paramÃ¨tre callbackName ne sera pas pris en compte.
   *  La fonction de callback est crÃ©Ã©e dynamiquement par la fonction JSONP ;
   *  elle a deux fonctions :
   *    elle annule la condition de timeOut
   *    puis appelle la fonction fournie par l'utilisateur via le paramÃ¨tre onResponse.
   * @param {Function} options.onResponse - Nom de la fonction qui sera appelÃ©e lors de la rÃ©ception des rÃ©sultats du service.
   *  Ce paramÃ¨tre sera ignorÃ© si l'URL contient dÃ©jÃ  le paramÃ¨tre callback.
   *  La fonction de rappel appelÃ©e sera alors celle ayant pour nom la valeur de ce paramÃ¨tre.
   * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelÃ©e en cas de non rÃ©ponse du service.
   *  Le temps au bout duquel on considÃ¨re que le service n'a pas rÃ©pondu est dÃ©terminÃ© par le paramÃ¨tre timeOut.
   *  @example
   *  var options = {
   *      url : 'http://localhost/some/test.json&callback=myResults',
   *      timeOut : 100,
   *      callbackName : 'myResults',
   *      callbackSuffix : "",
   *      onResponse : function (response) {
   *          console.log('results : ', response);
   *      },
   *
   *   };
   *   JSONP.call(options);
   */
  call: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("JSONP");
    logger50.trace("[JSONP::call ()]");
    if (!options) {
      logger50.error("missing parameter : options !");
      throw new Error("missing parameter : options !");
    }
    if (!options.url) {
      logger50.error("missing parameter : options.url !");
      throw new Error("missing parameter : options.url !");
    }
    if (!options.timeOut) {
      logger50.info("setting 'options.timeOut' default value");
      options.timeOut = 0;
    }
    if (!options.onResponse) {
      logger50.error("missing parameter : options.onResponse !");
      throw new Error("missing parameter : options.onResponse !");
    }
    var callbackId = typeof options.callbackSuffix === "string" ? options.callbackSuffix : this.uuid();
    var urlHasCallbackKey = false;
    var urlHasCallbackName = false;
    var idx = options.url.indexOf("callback=");
    if (idx !== -1) {
      urlHasCallbackKey = true;
      var j2 = options.url.indexOf("&", idx);
      if (j2 === -1) {
        j2 = options.url.length;
      }
      var callbackName = options.url.substring(idx + 9, j2);
      if (callbackName) {
        urlHasCallbackName = true;
        options.callbackName = callbackName;
        logger50.info("setting 'options.callbackName' value (" + options.callbackName + ") from 'options.url' parameter");
      }
    }
    if (!urlHasCallbackKey) {
      var k3 = options.url.indexOf("?");
      if (k3 === -1) {
        options.url = options.url + "?callback=";
      } else if (k3 === options.url.length) {
        options.url = options.url + "callback=";
      } else {
        options.url = options.url + "&callback=";
      }
      logger50.info("setting callback default key in 'options.url' : " + options.url);
    }
    var HasCallbackName = options.callbackName ? true : urlHasCallbackName;
    if (!urlHasCallbackName) {
      if (!options.callbackName) {
        logger50.info("setting 'options.callbackName' default value");
        options.callbackName = "callback";
        if (callbackId || callbackId === "") {
          options.callbackName += callbackId;
        }
      }
      options.url = options.url.replace("callback=", "callback=" + options.callbackName);
      logger50.info("setting callback function name in 'options.url' : " + options.url);
    }
    if (!options.onTimeOut) {
      logger50.info("setting 'options.onTimeOut' default value");
      options.onTimeOut = function() {
        console.log("TimeOut while invoking url : " + options.url);
      };
    }
    if (!HasCallbackName) {
      var self2 = this;
      var onTimeOutTrigger = null;
      if (options.timeOut > 0) {
        onTimeOutTrigger = window.setTimeout(
          function() {
            window[options.callbackName] = function() {
            };
            options.onTimeOut();
            self2._deleteScript(callbackId);
          },
          options.timeOut
        );
      }
      window[options.callbackName] = function(data) {
        window.clearTimeout(onTimeOutTrigger);
        options.onResponse(data);
        self2._deleteScript(callbackId);
      };
    }
    this._createScript(callbackId, options.url);
  },
  /**
  * create Script
  * @param {String} callbackId - callback Id
  * @param {String} url - url
  * @private
  */
  _createScript: function(callbackId, url) {
    var scriptu;
    var scripto = document.getElementById("results" + callbackId);
    scriptu = document.createElement("script");
    scriptu.setAttribute("type", "text/javascript");
    scriptu.setAttribute("src", url);
    scriptu.setAttribute("charset", "UTF-8");
    scriptu.setAttribute("id", "results" + callbackId);
    scriptu.setAttribute("async", "true");
    var node = document.documentElement || document.getElementsByTagName("head")[0];
    if (scripto === null) {
      node.appendChild(scriptu);
    } else {
      node.replaceChild(scriptu, scripto);
    }
  },
  /**
  * delete Script
  * @param {String} callbackId - callback Id
  * @private
  */
  _deleteScript: function(callbackId) {
    var script = document.getElementById("results" + callbackId);
    if (script) {
      var node = script.parentNode || document.documentElement;
      if (!node) {
        return;
      }
      node.removeChild(script);
    }
  }
};
var JSONP_default = JSONP;

// node_modules/geoportal-access-lib/src/Protocols/Protocol.js
var Protocol = {
  /**
   * Interface unique d"envoi d"une requÃªte.
   *
   * @method send
   * @static
   * @param {Object} options - options generales
   * @param {String} options.url      - url du service
   * @param {String} options.method   - GET, POST, PUT, DELETE
   * @param {String} options.protocol - XHR | JSONP
   * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...
   * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)
   * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix="", la fonction s'appellera "callback")
   * @param {String} options.timeOut  - 0 ms
   * @param {Boolean} options.nocache  - true|false
   * @param {Object|String} options.data        - content (post) ou param (get)
   * @param {Object|String} options.headers     - (post) ex. referer
   * @param {Object|String} options.content - (post) ex. "application/json"
   * @param {String} options.scope       - this (TODO)
   * @param {Function} options.onResponse - callback
   * @param {Function} options.onFailure - callback
   * @param {Function} options.onTimeOut - callback
   * @param {String} options.proxyUrl -  (TODO)
   */
  send: function(options) {
    var settings = options || {
      method: "GET",
      // protocol : "JSONP",
      protocol: "XHR",
      timeOut: 0,
      format: null,
      wrap: true,
      nocache: true,
      output: "json",
      callback: null,
      callbackSuffix: null
    };
    if (typeof window === "undefined" && options.protocol === "JSONP") {
      console.log("Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS");
      return;
    }
    if (options.protocol === "XHR" || options.format === "json") {
      settings.wrap = false;
    } else if (options.protocol === "JSONP" && options.format === "xml") {
      settings.wrap = true;
    }
    settings.callback = null;
    settings.output = settings.wrap ? "json" : null;
    if (settings.wrap) {
      var params2 = {};
      params2.output = settings.output;
      params2.callback = settings.callback;
      delete params2.callback;
      settings.url = Helper_default.normalyzeUrl(options.url, params2);
    }
    switch (settings.protocol) {
      case "XHR":
        if (options.method === "GET" && options.nocache) {
          settings.url = Helper_default.normalyzeUrl(settings.url, {
            t: (/* @__PURE__ */ new Date()).getTime()
          });
        }
        XHR_default.call(settings);
        break;
      case "JSONP":
        if (settings.data) {
          settings.url = Helper_default.normalyzeUrl(settings.url, settings.data);
        }
        JSONP_default.call(settings);
        break;
      default:
        throw new Error("protocol not supported (XHR|JSONP) !");
    }
  }
};
var Protocol_default = Protocol;

// node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js
function ErrorService(error) {
  if (!(this instanceof ErrorService)) {
    throw new TypeError("ErrorService constructor cannot be called as a function.");
  }
  var e = error;
  if (typeof error === "string" || error instanceof String) {
    this.message = error;
    this.status = -1;
    this.type = ErrorService.TYPE_UNKERR;
  } else {
    this.message = e.message || "undefined!?";
    this.type = e.type;
    this.status = e.status || -1;
  }
  this.name = "ErrorService";
  this.stack = new Error().stack;
}
ErrorService.TYPE_SRVERR = "SERVICE_ERROR";
ErrorService.TYPE_USEERR = "USAGE_ERROR";
ErrorService.TYPE_UNKERR = "UNKNOWN_ERROR";
ErrorService.prototype = Object.create(Error.prototype, {
  constructor: {
    value: ErrorService,
    writable: true,
    configurable: true
  }
});
var ErrorService_default = ErrorService;

// node_modules/geoportal-access-lib/package.json
var package_default2 = {
  name: "geoportal-access-lib",
  version: "3.4.6",
  date: "19/12/2024",
  description: "French Geoportal resources access library",
  module: "src/Gp.js",
  main: "dist/GpServices-src.js",
  homepage: "https://github.com/IGNF/geoportal-access-lib#readme",
  scripts: {
    clean: 'echo "Warning: no yet implemented!" && exit 0',
    setup: "npm install",
    cover: "nyc --reporter=lcov --reporter=text npm run test",
    eslint: "eslint src/",
    build: "webpack --mode=none",
    "build:prod": "webpack --mode=production",
    "build:dev": "webpack --mode=development",
    test: 'npx instant-mocha --mode=development --reporter mochawesome --reporter-options reportDir=test-report,reportFilename=index --webpack-config ./test/webpack/webpack.test.js --glob "test_*.js" test/spec/',
    "test:serve": "webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.js",
    "test:serve:docker": "webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.docker.js",
    "test:end-to-end:serve": "webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.js",
    "test:end-to-end:serve:docker": "webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.docker.js",
    sample: "npm run sample:serve",
    "sample:serve": "webpack-dev-server --mode=none --open-page samples/index-src.html --https --content-base . --output-public-path '/dist/' --port 9001 --open",
    "sample:serve:prod": "webpack-dev-server --mode=production --open-page samples/index-prod.html --content-base . --output-public-path '/dist/' --port 9001 --open",
    "sample:serve:dev": "webpack-dev-server --mode=development --open-page samples/index-map.html --content-base . --output-public-path '/dist/' --port 9001 --open",
    doc: "npm run doc:serve",
    "doc:serve": "webpack-dev-server --content-base jsdoc --port 9001 --open"
  },
  engines: {
    node: ">=20"
  },
  nyc: {
    include: [
      "src/**/*.js"
    ],
    instrument: false,
    sourceMap: false
  },
  repository: {
    type: "git",
    url: "https://github.com/IGNF/geoportal-access-lib.git"
  },
  keywords: [
    "geoplateforme",
    "geoportail",
    "webservice",
    "javascript",
    "es6"
  ],
  author: "IGNF",
  license: "CECILL-B",
  dependencies: {
    "@xmldom/xmldom": "^0.9.6",
    "es6-promise": "^4.2.4",
    "node-fetch": "^2.6.1"
  },
  devDependencies: {
    "@babel/core": "^7.12.10",
    "@babel/plugin-transform-template-literals": "^7.12.1",
    "@babel/preset-env": "^7.12.11",
    "babel-loader": "^8.2.2",
    chai: "^4.1.2",
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^5.1.2",
    eslint: "^7.18.0",
    "eslint-config-standard": "^16.0.2",
    "eslint-loader": "^4.0.2",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-promise": "^4.2.1",
    "eslint-plugin-standard": "^5.0.0",
    glob: "^7.1.2",
    "handlebars-layouts": "^3.1.4",
    "handlebars-webpack-plugin": "^1.4.1",
    "html-webpack-plugin": "^4.5.2",
    "instant-mocha": "^1.5.3",
    "istanbul-instrumenter-loader": "^3.0.1",
    "jsdoc-webpack-plugin": "^0.3.0",
    loglevel: "^1.6.1",
    mocha: "^8.4.0",
    "mocha-loader": "^5.1.5",
    mochawesome: "^6.2.1",
    nyc: "^15.1.0",
    path: "^0.12.7",
    "replace-bundle-webpack-plugin": "^1.0.0",
    sinon: "^9.2.4",
    "sinon-es6": "0.0.3",
    "speed-measure-webpack-plugin": "^1.4.2",
    "string-template": "^1.0.0",
    "terser-webpack-plugin": "^4.2.3",
    webpack: "^4.47.0",
    "webpack-cli": "^3.3.12",
    "webpack-dev-server": "^3.11.2",
    "webpack-node-externals": "^2.5.2",
    "webpack-shell-plugin": "^0.5.0"
  },
  bundleDependencies: []
};

// node_modules/geoportal-access-lib/src/Services/CommonService.js
function CommonService(options) {
  if (!(this instanceof CommonService)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR"));
  }
  this.logger = LoggerByDefault_default.getLogger("CommonService");
  this.logger.trace("[Constructeur CommonService (options)]");
  this.options = {
    // protocol : "JSONP",
    protocol: "XHR",
    ssl: true,
    proxyURL: "",
    // callbackName : "",
    callbackSuffix: null,
    httpMethod: "GET",
    timeOut: 0,
    rawResponse: false,
    scope: this,
    /**
    * callback par defaut pour la reponse
    * @param {Object} response - response
    * @private
    */
    onSuccess: function(response) {
      console.log("onSuccess - la reponse est la suivante : ", response);
    },
    /**
    * callback par defaut pour les erreurs
    * @param {Object} error - error
    * @private
    */
    onFailure: function(error) {
      if (error.status === 200 || !error.status) {
        console.log("onFailure : ", error.message);
      } else {
        console.log("onFailure - Erreur (", error.status, ") : ", error.message);
      }
    }
  };
  for (var opt in options) {
    if (options.hasOwnProperty(opt)) {
      this.options[opt] = options[opt];
    }
  }
  if (this.options.rawResponse && !this.options.onSuccess) {
    this.options.onSuccess = function(response) {
      console.log("onSuccess - la rÃ©ponse brute du service est la suivante : ", response);
    };
  }
  var bOnSuccess = !!(this.options.onSuccess !== null && typeof this.options.onSuccess === "function");
  if (!bOnSuccess) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "onSuccess()"));
  }
  this.options.httpMethod = typeof options.httpMethod === "string" ? options.httpMethod.toUpperCase() : "GET";
  switch (this.options.httpMethod) {
    case "POST":
    case "GET":
      break;
    case "PUT":
    case "DELETE":
    case "HEAD":
    case "OPTIONS":
      throw new Error(MessagesResources_default.getMessage("PARAM_NOT_SUPPORT", "httpMethod"));
    default:
      throw new Error(MessagesResources_default.getMessage("PARAM_UNKNOWN", "httpMethod"));
  }
  this.options.protocol = typeof options.protocol === "string" ? options.protocol.toUpperCase() : "XHR";
  switch (this.options.protocol) {
    case "JSONP":
    case "XHR":
      break;
    default:
      throw new Error(MessagesResources_default.getMessage("PARAM_UNKNOWN", "protocol"));
  }
  if (typeof window === "undefined" && this.options.protocol === "JSONP") {
    throw new Error(MessagesResources_default.getMessage("PARAM_NOT_SUPPORT_NODEJS", "protocol=JSONP (instead use XHR)"));
  }
  if (this.options.protocol === "JSONP") {
    this.options.httpMethod = "GET";
  }
  this.options.nocache = options.nocache || false;
  this.options.outputFormat = null;
  this.request = null;
  this.response = null;
}
CommonService.prototype = {
  /*
   * Constructeur (alias)
   */
  constructor: CommonService,
  /**
   * Appel du service GÃ©oportail
   */
  call: function() {
    this.logger.trace("CommonService::call ()");
    var context = this;
    function run() {
      this.logger.trace("CommonService::run ()");
      this.buildRequest.call(context, onError, onBuildRequest);
    }
    run.call(context);
    function onBuildRequest(result) {
      this.logger.trace("CommonService::onBuildRequest : ", result);
      this.callService.call(context, onError, onCallService);
    }
    function onCallService(result) {
      this.logger.trace("CommonService::onCallService : ", result);
      this.analyzeResponse.call(context, onError, onAnalyzeResponse);
    }
    function onAnalyzeResponse(result) {
      this.logger.trace("CommonService::onAnalyzeResponse : ", result);
      if (result) {
        this.options.onSuccess.call(this, result);
      } else {
        return onError.call(this, new ErrorService_default("Analyse de la reponse en Ã©chec !?"));
      }
    }
    function onError(error) {
      this.logger.trace("CommonService::onError()");
      var e = error;
      if (!(e instanceof ErrorService_default)) {
        e = new ErrorService_default(error.message);
      }
      this.options.onFailure.call(this, e);
    }
  },
  /**
   * CrÃ©ation de la requÃªte
   * @param {Function} error - callback
   * @param {Function} success - callback
   */
  buildRequest: function(error, success) {
    this.logger.error("overwritten method !");
    if (error) {
      error.call(this, "This method must be overwritten !");
    }
    success.call(this, "This method must be overwritten !");
  },
  /**
   * Appel du service
   * @param {Function} error - callback
   * @param {Function} success - callback
   */
  callService: function(error, success) {
    var strUrlProxified = null;
    var strData = this.request;
    var bUrlProxified = !!(this.options.proxyURL && this.options.protocol === "XHR");
    var requestMetaOptions = {
      "gp-access-lib": package_default2.version
    };
    if (this.options.apiKey) {
      requestMetaOptions.apiKey = this.options.apiKey;
    }
    this.options.serverUrl = Helper_default.normalyzeUrl(this.options.serverUrl, requestMetaOptions, false);
    if (bUrlProxified) {
      if (this.options.httpMethod === "GET") {
        strUrlProxified = this.options.proxyURL + Helper_default.normalyzeUrl(this.options.serverUrl, this.request, true);
        strData = null;
      }
      if (this.options.httpMethod === "POST") {
        strUrlProxified = this.options.proxyURL + Helper_default.normalyzeUrl(this.options.serverUrl, null, true);
        strData = this.request;
      }
    }
    var self2 = this;
    var options = {
      url: strUrlProxified || this.options.serverUrl,
      method: this.options.httpMethod,
      protocol: this.options.protocol,
      timeOut: this.options.timeOut || 0,
      format: this.options.outputFormat,
      // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !
      nocache: this.options.nocache || false,
      // ceci permet d'ajouter un timestamp dans la requÃªte
      wrap: this.options.protocol !== "XHR",
      // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !
      callbackSuffix: this.options.callbackSuffix,
      // callbackName : this.options.callbackName || null,
      data: strData,
      headers: null,
      // TODO...
      content: this.options.contentType || "application/xml",
      scope: this.options.scope || this,
      // callback de reponse
      onResponse: function(response) {
        self2.logger.trace("callService::onResponse()");
        var content = null;
        if (self2.options.protocol === "XHR") {
          self2.logger.trace("Response XHR", response);
          content = response;
        }
        if (self2.options.protocol === "JSONP") {
          self2.logger.trace("Response JSON", response);
          if (response) {
            if (response.http) {
              if (response.http.status !== 200) {
                error.call(self2, new ErrorService_default({
                  status: response.http.status,
                  message: response.http.error,
                  type: ErrorService_default.TYPE_SRVERR
                }));
                return;
              } else {
                content = response.xml;
                if (self2.options.rawResponse) {
                  content = response;
                }
              }
            } else {
              content = response;
            }
          } else {
            error.call(self2, new ErrorService_default("Le contenu de la reponse est vide !?"));
            return;
          }
        }
        if (typeof self2.options.onBeforeParse === "function") {
          var newResponse = self2.options.onBeforeParse(content);
          if (typeof newResponse === "string") {
            content = newResponse;
          }
        }
        self2.response = content;
        success.call(self2, content);
      },
      // callback des erreurs
      onFailure: function(e) {
        self2.logger.trace("callService::onFailure()");
        e.type = ErrorService_default.TYPE_SRVERR;
        error.call(self2, new ErrorService_default(e));
      },
      // callback de timeOut
      onTimeOut: function() {
        self2.logger.trace("callService::onTimeOut()");
        error.call(self2, new ErrorService_default("TimeOut!"));
      }
    };
    Protocol_default.send(options);
  },
  /**
   * Analyse de la rÃ©ponse
   * @param {Function} error - callback
   * @param {Function} success - callback
   */
  analyzeResponse: function(error, success) {
    this.logger.error("overwritten method !");
    if (error) {
      error.call(this, "This method must be overwritten !");
    }
    success.call(this, "This method must be overwritten !");
  }
};
var CommonService_default = CommonService;

// node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js
var DefaultUrlService = {
  /** if set true, require the use of https protocol */
  ssl: true,
  /**
  * base new-url of geoplateforme services (ssl protocol management)
  * @param {String} path - path
  * @returns {String} url
  */
  newUrl: function(path) {
    var NEW_GPF_HOSTNAME = "data.geopf.fr";
    var _protocol;
    if (DefaultUrlService.ssl === false) {
      _protocol = "http://";
    } else {
      _protocol = "https://";
    }
    return _protocol + NEW_GPF_HOSTNAME + path;
  },
  /**
   * Elevation web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("elevation-json", "elevation-xml", "profil-json" or "profil-xml").
   */
  Alti: {
    new_key: {
      // rest
      "elevation-json": "/altimetrie/1.0/calcul/alti/rest/elevation.json",
      "elevation-xml": "/altimetrie/1.0/calcul/alti/rest/elevation.xml",
      "profil-json": "/altimetrie/1.0/calcul/alti/rest/elevationLine.json",
      "profil-xml": "/altimetrie/1.0/calcul/alti/rest/elevationLine.xml"
    },
    /**
    * newurl from geoplateforme service
    * @param {String} key - key
    * @returns {String} url
    */
    newUrl: function() {
      return {
        // rest
        "elevation-json": DefaultUrlService.newUrl(this.new_key["elevation-json"]),
        "elevation-xml": DefaultUrlService.newUrl(this.new_key["elevation-xml"]),
        "profil-json": DefaultUrlService.newUrl(this.new_key["profil-json"]),
        "profil-xml": DefaultUrlService.newUrl(this.new_key["profil-xml"])
      };
    }
  },
  /**
   * IsoCurve web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("iso-json" or "iso-xml").
   */
  ProcessIsoCurve: {
    new_key: "/navigation/isochrone",
    /**
    * url from geoplateforme service
    * @returns {String} url
    */
    newUrl: function() {
      return DefaultUrlService.newUrl(this.new_key);
    }
  },
  /**
   * Config web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns config service default urls with or without geoportal access key given as a parameter.
   */
  Config: {
    _key: "https://raw.githubusercontent.com/IGNF/geoportal-configuration/new-url/dist/",
    /**
    * url
    * @param {String} key - key
    * @returns {String} url
    */
    url: function(key) {
      if (!Array.isArray(key)) {
        key = key.split(",");
      }
      var url = [];
      for (var i = 0; i < key.length; i++) {
        url[i] = this._key + key[i] + "Config.json";
      }
      return url;
    }
  },
  /**
   * Autocompletion web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.
   */
  AutoComplete: {
    new_key: "/geocodage/completion",
    /**
    * url from geoplateforme service
    * @returns {String} url
    */
    newUrl: function() {
      return DefaultUrlService.newUrl(this.new_key);
    }
  },
  /**
   * Reverse geocoding web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
   */
  ReverseGeocode: {
    new_key: "/geocodage/reverse",
    /**
    * url from geoplateforme service
    * @returns {String} url
    */
    newUrl: function() {
      return DefaultUrlService.newUrl(this.new_key);
    }
  },
  /**
   * Geocoding web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
   */
  Geocode: {
    new_key: "/geocodage/search",
    /**
    * url from geoplateforme service
    * @returns {String} url
    */
    newUrl: function() {
      return DefaultUrlService.newUrl(this.new_key);
    }
  },
  /**
   * Routing web service access
   *
   * @member {Object}
   * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols.
   */
  Route: {
    new_key: "/navigation/itineraire",
    /**
    * url from geoplateforme service
    * @returns {String} url
    */
    newUrl: function() {
      return DefaultUrlService.newUrl(this.new_key);
    }
  }
};
var DefaultUrlService_default = DefaultUrlService;

// node_modules/geoportal-access-lib/src/Services/Config/ConfigInterface.js
function ConfigInterface() {
  if (!(this instanceof ConfigInterface)) {
    throw new TypeError("ConfigInterface constructor cannot be called as a function.");
  }
  this.generalOptions = {
    apiKeys: {},
    title: null,
    defaultGMLGFIStyle: null,
    theme: null,
    wgs84Resolutions: []
  };
  this.layers = {};
  this.tileMatrixSets = {};
}
ConfigInterface.prototype = {
  /*
   * Constructor (alias)
   */
  constructor: ConfigInterface,
  /**
   * Check if config is loaded for a given key
   *
   * @param {String} apiKey - Access key to Geoportal platform
   * @returns {Boolean} isKeyConfLoaded - true if config of the key is already loaded, false otherwise
   */
  isKeyConfLoaded: function(apiKey) {
    if (!apiKey) {
      return;
    }
    if (this.generalOptions.apiKeys[apiKey]) {
      return true;
    }
    return false;
  },
  /**
   * Returns an array of Geoportal layers identifiers, corresponding to an API contract key.
   *
   * @param {String} apiKey - Access key to Geoportal platform
   * @returns {Array} apiKeys - Array of geoportal layers identifiers
   */
  getLayersId: function(apiKey) {
    return this.generalOptions.apiKeys[apiKey];
  },
  /**
   * Returns the id of a Geoportal layer with its name and its service.
   *
   * @param {String} layerName - name of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS")
   * @param {String} service   - name of the service (ex. "WMS" ou "WMTS")
   * @returns {String} Id of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS")
   */
  getLayerId: function(layerName, service) {
    if (!layerName || !service) {
      return;
    }
    var layerId = null;
    if (this.layers) {
      var layers = this.layers;
      for (var key in layers) {
        if (layers.hasOwnProperty(key)) {
          var parts = key.split("$");
          if (layerName === parts[0]) {
            if (parts[1]) {
              var servicePartsLayer = parts[1].split(":");
              var servicePartsService = parts[1].split(";");
              if (servicePartsService[1] === service.toUpperCase()) {
                layerId = key;
                break;
              }
              if (servicePartsLayer[2] === service.toUpperCase()) {
                layerId = key;
                break;
              }
            }
          }
        }
      }
    }
    if (!layerId) {
      return;
    }
    return layerId;
  },
  /**
   * Returns an associative array of Geoportal layers configurations, corresponding to an API contract key.
   * If no key is specified, all layers from configuration are returned.
   *
   * @param {String} apiKey - Access key to Geoportal platform
   * @returns {Object} layers - Object which properties are layers identifiers.
   */
  getLayersConf: function(apiKey) {
    var layers = {};
    var layersIdArray = this.getLayersId(apiKey);
    if (layersIdArray) {
      for (var i = 0; i < layersIdArray.length; i++) {
        var lyrId = layersIdArray[i];
        layers[lyrId] = this.layers[lyrId];
      }
    }
    return layers;
  },
  /**
   * Returns a geoportal layer configuration, given its identifier
   *
   * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
   * @return {Object} layer - Layer configuration
   * @see Gp.Services.Config.Layer
   */
  getLayerConf: function(layerId) {
    if (!this.layers) {
      return;
    }
    return this.layers[layerId];
  },
  /**
   * Get all parameters needed to display a WFS, WMS or WMTS layer given its name, its service and its key
   *
   * @param {String} layerName - name of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS")
   * @param {String} service   - name of the service (ex. "WMS" ou "WMTS")
   * @param {String} [apiKey]  - Contract API key
   * @returns {Object} params  - params of the service (WFS, WMS or WMTS) for the given layer
   * @returns {String} params.url        - Url of the service to reach to display the layer
   * @returns {String} params.version    - Version of the service
   * @returns {String} params.styles     - Default style of the layer
   * @returns {String} params.format     - Default format of the layer
   * @returns {String} params.projection - Default projection of the layer
   * @returns {Number} params.minScale   - Min scale denominator of the layer
   * @returns {Number} params.maxScale   - Max scale denominator of the layer
   * @returns {Gp.BBox} params.extent    - Extent of the layer, in the projection of the layer
   * @returns {Array} params.legends     - Array of legends associated to the layer
   * @returns {Array} params.title       - Name of the layer, readable by a human
   * @returns {Array} params.description - Description of the layer
   * @returns {String} params.[TMSLink]          - Id of the Tile Matrix Set (TMS), in the case of WMTS layer
   * @returns {Gp.Point} params.[matrixOrigin]   - Originof the tile matrix (top left corner), in the case of WMTS layer
   * @returns {Array} params.[nativeResolutions] - Array with the resolution of each level of the tile matrix set, in the case of WMTS layer
   * @returns {Array} params.[matrixIds]         - Array with the ID of each level of the tile matrix set, in the case of WMTS layer
   */
  getLayerParams: function(layerName, service) {
    var params2 = {};
    if ((service === "WMS" || Object.keys(this.tileMatrixSets).length !== 0) && Object.keys(this.layers).length !== 0) {
      var layerId = this.getLayerId(layerName, service);
      if (layerId) {
        var layerConf = this.getLayerConf(layerId);
        var keys = this.getLayerKey(layerId);
        if (keys.length === 0) {
          return;
        }
        for (var i = 0; i < keys.length; i++) {
          if (layerConf.serviceParams.serverUrl[keys[i]]) {
            params2.url = layerConf.serviceParams.serverUrl[keys[i]];
          }
        }
        if (service !== "WFS") {
          const wmsTypeRegex = /\/v\//;
          if (wmsTypeRegex.test(params2.url)) {
            params2.styles = " ";
          } else {
            params2.styles = layerConf.styles[0].name;
          }
        }
        params2.version = layerConf.serviceParams.version;
        params2.format = layerConf.formats && layerConf.formats.length ? layerConf.formats[0].name : "";
        params2.projection = layerConf.defaultProjection;
        params2.minScale = layerConf.globalConstraint.minScaleDenominator;
        params2.maxScale = layerConf.globalConstraint.maxScaleDenominator;
        params2.extent = layerConf.globalConstraint.bbox;
        params2.legends = layerConf.legends;
        params2.title = layerConf.title;
        params2.description = layerConf.description;
        if (service === "WMS") {
          params2.metadata = layerConf.metadata;
        }
        if (layerConf.wmtsOptions) {
          params2.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;
          var TMSLink = layerConf.wmtsOptions.tileMatrixSetLink;
          if (TMSLink) {
            params2.TMSLink = TMSLink;
            var tmsConf = this.getTMSConf(TMSLink);
            params2.matrixIds = Object.keys(tmsConf.tileMatrices);
            params2.tileMatrices = tmsConf.tileMatrices;
            params2.nativeResolutions = tmsConf.nativeResolutions || this.getTMSConf("PM").nativeResolutions;
          }
        }
      }
    }
    return params2;
  },
  /**
   * Get the contract key(s) associated to a given layer.
   *
   * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
   * @return {Array} layerKey - array of key(s) associated to the given layer
   */
  getLayerKey: function(layerId) {
    var layerKey = [];
    if (this.generalOptions && this.generalOptions.apiKeys && Object.keys(this.generalOptions.apiKeys).length !== 0) {
      var resourcesByKey = this.generalOptions.apiKeys;
      for (var key in resourcesByKey) {
        var resourcesArray = resourcesByKey[key];
        resourcesArray.forEach(function(arrayLayerId) {
          if (arrayLayerId === layerId) {
            layerKey.push(key);
          }
        });
      }
    }
    return layerKey;
  },
  /**
   * Returns an associative array of Tile Matrix Sets configurations.
   *
   * @return {Object} tileMatrixSets - Object which properties are TMS identifiers
   *
   */
  getTileMatrixSets: function() {
    return this.tileMatrixSets;
  },
  /**
   * Returns a Tile Matrix Sets configuration, given its identifier.
   *
   * @param {String} tmsID - Tile Matrix Set identifier (e.g. : "PM")
   * @return {Object} tileMatrixSet - Tile Matrix Set configuration
   * @see Gp.Services.Config.TileMatrixSet
   */
  getTMSConf: function(tmsID) {
    if (!this.tileMatrixSets) {
      return;
    }
    return this.tileMatrixSets[tmsID];
  },
  /**
   * Get global constraints for a given Layer : extent, minScale, maxScale, projection
   *
   * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
   * @returns {Object} params - layer constraints
   * @returns {String} params.projection - default layer projection
   * @returns {Number} params.minScale   - layer min scale denominator
   * @returns {Number} params.maxScale   - layer max scale denominator
   * @returns {Gp.BBox} params.extent    - layer extent expressed in the layer projection
   */
  getGlobalConstraints: function(layerId) {
    var params2 = {};
    if (layerId) {
      var layerConf = this.getLayerConf(layerId);
      params2.projection = layerConf.defaultProjection;
      params2.minScale = layerConf.globalConstraint.minScaleDenominator;
      params2.maxScale = layerConf.globalConstraint.maxScaleDenominator;
      params2.extent = layerConf.globalConstraint.bbox;
    }
    return params2;
  }
};
var ConfigInterface_default = ConfigInterface;

// node_modules/geoportal-access-lib/src/Services/Config/Config.js
function Config(options) {
  if (!(this instanceof Config)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "Config"));
  }
  this.CLASSNAME = "Config";
  this.logger = LoggerByDefault_default.getLogger("Gp.Config");
  this.logger.trace("[Constructeur Config (options)]");
  var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");
  if (!bOnSuccess) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "onSuccess()"));
  }
  if (!options.apiKey && !options.customConfigFile) {
    options.apiKey = "full";
  }
  this.options = {};
  this.options.onSuccess = options.onSuccess;
  this.options.onFailure = options.onFailure;
  this.options.sync = options.sync || false;
  this.options.listConfigUrls = options.customConfigFile ? [options.customConfigFile] : !Array.isArray(options.apiKey) ? DefaultUrlService_default.Config.url(options.apiKey.split(",")) : DefaultUrlService_default.Config.url(options.apiKey);
}
Config.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
Config.prototype.constructor = Config;
Config.prototype.buildRequest = function(error, success) {
  this.listConfigUrls = this.options.listConfigUrls;
  if (!this.listConfigUrls) {
    error.call(this, new Error("url by default not found !"));
    return;
  }
  success.call(this, this.listConfigUrls);
};
Config.prototype.callService = function(error, success) {
  if (this.options.sync) {
    __callServiceSync.call(this, error, success);
  } else {
    __callService.call(this, error, success);
  }
};
var __callService = function(error, success) {
  this.listConfigResults = [];
  let Fetch = null;
  if (typeof window === "undefined") {
    var nodefetch = require_browser();
    Fetch = nodefetch;
  } else {
    Fetch = window.fetch;
  }
  var fetchFactory = (url) => {
    return Fetch(url, { credentials: "same-origin" }).then((response) => {
      if (response.ok) {
        return response.json().then((json) => {
          return json;
        }).catch((error2) => {
          throw new Error("Exception Json : " + error2);
        });
      } else {
        throw new Error("Exception HTTP : " + response.status + " (status code) !");
      }
    }).catch((error2) => {
      return new Promise((resolve, reject) => {
        reject(error2);
      });
    });
  };
  var promises = [];
  for (let index2 = 0; index2 < this.listConfigUrls.length; index2++) {
    const url = this.listConfigUrls[index2];
    promises.push(fetchFactory(url));
  }
  Promise.all(promises).then((results) => {
    if (!results) {
      throw new Error("results config empty !?");
    }
    results.forEach((result) => {
      this.listConfigResults.push(result);
    });
  }).then(() => {
    success.call(this, this.listConfigResults);
  }).catch((e) => {
    error.call(this, e);
  });
};
var __callServiceSync = function(error, success) {
  this.listConfigResults = [];
  for (var i = 0; i < this.listConfigUrls.length; i++) {
    const url = this.listConfigUrls[i];
    const request = new XMLHttpRequest();
    request.open("GET", url, false);
    request.send(null);
    if (request.status === 200) {
      var response = JSON.parse(request.responseText);
      this.listConfigResults.push(response);
    }
  }
  if (this.listConfigResults.length !== 0) {
    success.call(this, this.listConfigResults);
  } else {
    error.call(this, new Error("..."));
  }
};
Config.prototype.analyzeResponse = function(error, success) {
  var mergeConfig = function(objects) {
    var allLayersConfig = {};
    var allKeysConfig = {};
    var allTMSConfig = {};
    for (var i = 0; i < objects.length; i++) {
      if (!objects[i].generalOptions || !objects[i].layers) {
        return;
      }
      allKeysConfig = {
        ...allKeysConfig,
        ...objects[i].generalOptions.apiKeys
      };
      allLayersConfig = {
        ...allLayersConfig,
        ...objects[i].layers
      };
      allTMSConfig = {
        ...allTMSConfig,
        ...objects[i].tileMatrixSets
      };
    }
    var mergedConfig = {
      generalOptions: {
        apiKeys: allKeysConfig
      },
      layers: allLayersConfig,
      tileMatrixSets: allTMSConfig
    };
    return mergedConfig;
  };
  var ConfigJSON = mergeConfig(this.listConfigResults);
  if (!ConfigJSON) {
    error.call(this, new Error("configuration structure not conforme !"));
    return;
  }
  var IConfig = new ConfigInterface_default();
  Object.assign(IConfig, ConfigJSON);
  var scope = typeof window !== "undefined" ? window : {};
  if (!scope.Gp) {
    scope.Gp = {};
  }
  if (scope.Gp.Config) {
    Object.assign(scope.Gp.Config, IConfig);
    for (var property in IConfig) {
      scope.Gp.Config[property] = IConfig[property];
    }
  } else {
    scope.Gp.Config = IConfig;
  }
  success.call(this, scope.Gp.Config);
};
var Config_default = Config;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js
function AltiRequest(options) {
  if (!(this instanceof AltiRequest)) {
    throw new TypeError("AltiRequest constructor cannot be called as a function.");
  }
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur AltiRequest ()]");
  this.options = options || {};
  this.positions = this.options.positions || [];
  this.delimiter = this.options.delimiter || "|";
  this.indent = this.options.indent || false;
  this.crs = this.options.crs || "CRS:84";
  this.format = this.options.format || "json";
  this.resource = this.options.resource;
  this.measures = this.options.measures || false;
}
AltiRequest.CLASSNAME = "AltiRequest";
AltiRequest.prototype = {
  /**
   * @lends module:AltiRequest#
   */
  /**
   * Constructeur (alias)
   */
  constructor: AltiRequest,
  /**
   * Ajout d"une liste de coordonnÃ©es.
   *
   * @param {Object[]} lstPosition - liste de positions
   * @example
   * obj.setPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
   */
  setPositions: function(lstPosition) {
    var positions = [];
    for (var i = 0; i < lstPosition.length; i++) {
      var o = lstPosition[i];
      if (o.lon && o.lat) {
        positions.push(o);
      }
    }
    this.positions = positions;
  },
  /**
   * Liste des coordonnÃ©es.
   *
   * @param {Int} pos - position
   * @returns {positions}
   * @example
   * obj.getPositions ();  // [{lon : "", lat : ""}, {lon : "", lat : ""}]
   * obj.getPositions (0); // [{lon : "", lat : ""}]
   */
  getPositions: function(pos) {
    if (!pos) {
      return this.positions;
    }
    var index2 = this.positions.length - 1;
    if (pos > index2 || pos < index2) {
      this.logger.warn("index out of range !");
      return this.positions;
    }
    return this.positions[pos];
  },
  /**
   * Ajout d"une liste de coordonnÃ©es.
   *
   * @param {Object[]} lstPosition - liste de positions
   * @example
   * obj.addPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
   */
  addPositions: function(lstPosition) {
    for (var i = 0; i < lstPosition.length; i++) {
      var o = lstPosition[i];
      if (o.lon && o.lat) {
        this.positions.push(lstPosition[i]);
      }
    }
  },
  /**
   * Retourne la liste des longitudes avec un caractÃ¨re de sÃ©paration.
   *
   * @returns {String} - une liste de longitudes
   * @example
   * // out : 0.2367|2.1570|43.789|...
   */
  getLon: function() {
    var lstLon = [];
    for (var i = 0; i < this.positions.length; i++) {
      lstLon.push(this.positions[i].lon);
    }
    this.logger.trace(lstLon);
    return lstLon.join(this.delimiter);
  },
  /**
   * Retourne la liste des lattitudes avec un caractÃ¨re de sÃ©paration.
   *
   * @returns {String} - une liste de lattitudes
   * @example
   * // out : 0.2367|2.1570|43.789|...
   */
  getLat: function() {
    var lstLat = [];
    for (var i = 0; i < this.positions.length; i++) {
      lstLat.push(this.positions[i].lat);
    }
    this.logger.trace(lstLat);
    return lstLat.join(this.delimiter);
  }
};
AltiRequest.prototype.getData = function() {
  var map = [];
  map.push({
    k: "lon",
    v: this.getLon()
  });
  map.push({
    k: "lat",
    v: this.getLat()
  });
  map.push({
    k: "delimiter",
    v: this.delimiter
  });
  map.push({
    k: "indent",
    v: this.indent
  });
  map.push({
    k: "crs",
    v: this.crs
  });
  map.push({
    k: "format",
    v: this.format
  });
  return map;
};
var AltiRequest_default = AltiRequest;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js
function AltiElevationRequest(options) {
  if (!(this instanceof AltiElevationRequest)) {
    throw new TypeError("AltiElevationRequest constructor cannot be called as a function.");
  }
  this.CLASSNAME = "AltiElevationRequest";
  AltiRequest_default.apply(this, arguments);
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur AltiElevationRequest ()]");
  this.zonly = this.options.zonly || false;
}
AltiElevationRequest.prototype = Object.create(AltiRequest_default.prototype, {
  /**
   * Setter/getter pour "zonly"
   */
  zonly: {
    /** getter */
    get: function() {
      return this._zonly;
    },
    /** setter */
    set: function(z3) {
      this._zonly = z3;
    }
  }
});
AltiElevationRequest.prototype.constructor = AltiElevationRequest;
AltiElevationRequest.prototype.getData = function() {
  var map = [];
  map.push({
    k: "lon",
    v: this.getLon()
  });
  map.push({
    k: "lat",
    v: this.getLat()
  });
  map.push({
    k: "indent",
    v: this.indent
  });
  map.push({
    k: "crs",
    v: this.crs
  });
  map.push({
    k: "zonly",
    v: this.zonly
  });
  map.push({
    k: "format",
    v: this.format
  });
  map.push({
    k: "resource",
    v: this.resource
  });
  return map;
};
var AltiElevationRequest_default = AltiElevationRequest;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js
function AltiProfilRequest(options) {
  if (!(this instanceof AltiProfilRequest)) {
    throw new TypeError("AltiProfilRequest constructor cannot be called as a function.");
  }
  this.CLASSNAME = "AltiProfilRequest";
  AltiRequest_default.apply(this, arguments);
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur AltiProfilRequest ()]");
  this.sampling = this.options.sampling || 3;
}
AltiProfilRequest.prototype = Object.create(AltiRequest_default.prototype, {
  /**
   * Setter/getter pour "sampling"
   */
  sampling: {
    /** getter */
    get: function() {
      return this._sampling;
    },
    /** setter */
    set: function(value2) {
      this._sampling = value2;
    }
  }
});
AltiProfilRequest.prototype.constructor = AltiProfilRequest;
AltiProfilRequest.prototype.getData = function() {
  var map = [];
  map.push({
    k: "lon",
    v: this.getLon()
  });
  map.push({
    k: "lat",
    v: this.getLat()
  });
  map.push({
    k: "indent",
    v: this.indent
  });
  map.push({
    k: "crs",
    v: this.crs
  });
  map.push({
    k: "sampling",
    v: this.sampling
  });
  map.push({
    k: "format",
    v: this.format
  });
  map.push({
    k: "resource",
    v: this.resource
  });
  return map;
};
var AltiProfilRequest_default = AltiProfilRequest;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js
function AltiRequestREST(options) {
  this.logger = LoggerByDefault_default.getLogger("AltiRequestREST");
  this.logger.trace("[Constructeur AltiRequestREST ()]");
  if (!(this instanceof AltiRequestREST)) {
    throw new TypeError("AltiRequestREST constructor cannot be called as a function.");
  }
  this.options = options || {};
  if (!this.options) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "options"));
  }
  if (!this.options.type) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
  }
  this.DataObject = null;
  switch (this.options.type) {
    case "Elevation":
      this.DataObject = new AltiElevationRequest_default(this.options.param);
      break;
    case "Profil":
      this.DataObject = new AltiProfilRequest_default(this.options.param);
      break;
    default:
      throw new Error(MessagesResources_default.getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
  }
  this.method = this.options.method || "GET";
}
AltiRequestREST.prototype = {
  /**
   * request
   * @type {String}
   */
  requestString: null,
  /**
   * Constructeur (alias)
   */
  constructor: AltiRequestREST,
  /**
   * Template de la requÃªte.
   */
  template: {
    get: {
      // FIXME on retire le param 'delimiter' : &delimiter='__DELIMITER__'
      value: "lon=__LON__&lat=__LAT__&indent=__INDENT__&crs='__CRS__'&resource=__RESOURCE__&measures=__MEASURES__",
      input: {
        point: "&zonly=__ZONLY__",
        profil: "&sampling=__SAMPLING__"
      }
    },
    post: {
      // FIXME on retire le param 'delimiter' : delimiter='__DELIMITER__'\n\
      value: "lon=__LON__\nlat=__LAT__\nindent=__INDENT__\ncrs='__CRS__'\nresource='__RESOURCE__'\nmeasures='__MEASURES__'\n",
      input: {
        point: "zonly=__ZONLY__\n",
        profil: "sampling=__SAMPLING__"
      }
    }
  },
  /**
   * Construction de la requÃªte.
   *
   * @example
   * // GET  out : lon=0.2367,2.1570&lat=48.0551,46.6077&delimiter=,&indent=true&zonly=true&crs='CRS:84'
   * // POST out : Not yet supported method POST !
   * @returns {String}
   */
  processRequestString: function() {
    this.logger.trace("AltiRequestREST::processRequestString ()");
    var template = "";
    if (this.method === "POST") {
      template = this.template.post.value;
    } else if (this.method === "GET") {
      template = this.template.get.value;
    }
    template = template.replace(/__LON__/g, this.DataObject.getLon());
    template = template.replace(/__LAT__/g, this.DataObject.getLat());
    template = template.replace(/__INDENT__/g, this.DataObject.indent);
    template = template.replace(/__CRS__/g, this.DataObject.crs);
    template = template.replace(/__RESOURCE__/g, this.DataObject.resource);
    template = template.replace(/__MEASURES__/g, this.DataObject.measures);
    template = template + this.__addDataInputs();
    this.logger.trace("traduction tmpl", template);
    this.requestString = template;
    return this.requestString;
  },
  /**
   * Ajout de parametres spÃ©cifiques (ex. zonly)
   *
   * @returns {String}
   */
  __addDataInputs: function() {
    this.logger.trace("AltiRequestREST::addDataInput ()");
    var myTemplate;
    if (this.method === "POST") {
      myTemplate = this.template.post;
    } else if (this.method === "GET") {
      myTemplate = this.template.get;
    } else {
      throw new Error("No other HTTP method supported by the service !");
    }
    var tmpl = null;
    if (this.DataObject.CLASSNAME === "AltiElevationRequest") {
      tmpl = myTemplate.input.point;
      return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly.toString());
    } else if (this.DataObject.CLASSNAME === "AltiProfilRequest") {
      tmpl = myTemplate.input.profil;
      return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);
    } else {
      throw new Error("No other object supported than elevation or profil !?");
    }
  }
};
var AltiRequestREST_default = AltiRequestREST;

// node_modules/geoportal-access-lib/src/Formats/WPS.js
function WPS(options) {
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur WPS()]");
  if (!(this instanceof WPS)) {
    throw new TypeError("WPS constructor cannot be called as a function.");
  }
  this.options = options || {};
  this.DataObject = this.options.data;
  if (!this.DataObject) {
    throw new TypeError("This data object is not defined !");
  }
  this.paramservice = this.options.param.service || "WPS";
  this.paramversion = this.options.param.version || "1.0.0";
  this.paramidentifier = this.options.param.identifier || "gs:WPS";
  this.paramrawdataoutput = this.options.param.rawdataoutput || "result";
  this.paramrequest = this.options.param.request || "Execute";
  this.method = this.options.method || "GET";
}
WPS.prototype = {
  /**
   * @lends module:WPS#
   */
  /**
   * request
   * @type {String}
   */
  requestString: null,
  /**
   * Constructeur (alias)
   */
  constructor: WPS,
  /**
   * Template de la requÃªte.
   */
  template: {
    get: {
      value: "service=__SERVICE__&version=__VERSION__&rawdataoutput=__RAWDATAOUTPUT__&identifier=__IDENTIFIER__&request=__REQUEST__&datainputs=<!-- __DATAINPUTS__ -->",
      input: "__KEY__=__DATA__"
    },
    post: {
      value: '<?xml version="1.0" encoding="UTF-8"?><wps:__REQUEST__ version="__VERSION__" service="__SERVICE__" __NAMESPACE__ __SCHEMALOCATION__><ows:Identifier>__IDENTIFIER__</ows:Identifier><wps:DataInputs><!-- __DATAINPUTS__ --></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:__REQUEST__>',
      input: "<wps:Input><ows:Identifier>__KEY__</ows:Identifier><wps:Data><wps:LiteralData>__DATA__</wps:LiteralData></wps:Data></wps:Input>"
    }
  },
  /**
   * Namespace par defaut de la requete POST.
   *
   * @returns {String} namespace
   */
  namespaceByDefault: function() {
    var ns = [
      'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"',
      'xmlns="http://www.opengis.net/wps/1.0.0"',
      'xmlns:wfs="http://www.opengis.net/wfs"',
      'xmlns:wps="http://www.opengis.net/wps/1.0.0"',
      'xmlns:ows="http://www.opengis.net/ows/1.1"',
      'xmlns:gml="http://www.opengis.net/gml"',
      'xmlns:ogc="http://www.opengis.net/ogc"',
      'xmlns:wcs="http://www.opengis.net/wcs/1.1.1"',
      'xmlns:xlink="http://www.w3.org/1999/xlink"'
    ];
    return ns.join(" ");
  },
  /**
   * Schemalocation par defaut.
   *
   * @returns {String} schemaLocation
   */
  schemaLocationByDefault: function() {
    return 'xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd"';
  },
  /**
   * Construction de la requÃªte.
   *
   * @example
   * // GET  out :
   * //  service=__SERVICE__
   * //  &version=__VERSION__
   * //  &rawdataoutput=__RAWDATAOUTPUT__
   * //  &identifier=__IDENTIFIER__
   * //  &request=__REQUEST__
   * //  &datainputs="__DATAINPUTS__"
   * //  avec __DATAINPUTS__ = __KEY__=__DATA__;...
   *
   * // POST out :
   * //      <?xml version=\"1.0\" encoding=\"UTF-8\"?>
   * //      <wps:__REQUEST__ version=\"__VERSION__\" service=\"__SERVICE__\"
   * //         __NAMESPACE__ __SCHEMALOCATION__>
   * //          <ows:Identifier>__IDENTIFIER__</ows:Identifier>
   * //          <wps:DataInputs>
   * //              <!-- __DATAINPUTS__ -->
   * //          </wps:DataInputs>
   * //          <wps:ResponseForm>
   * //              <wps:RawDataOutput>
   * //              <ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>
   * //              </wps:RawDataOutput>
   * //          </wps:ResponseForm>
   * //      </wps:__REQUEST__>",
   * //      avec __DATAINPUTS__
   * //             <wps:Input>
   * //                  <ows:Identifier>__KEY__</ows:Identifier>
   * //                  <wps:Data>
   * //                    <wps:LiteralData>__DATA__</wps:LiteralData>
   * //                  </wps:Data>
   * //              </wps:Input>
   *
   * @returns {Boolean} validation de la construction de la requete
   */
  processRequestString: function() {
    this.logger.trace("WPS::processRequestString ()");
    var template = "";
    if (this.method === "POST") {
      template = this.template.post.value;
    } else if (this.method === "GET") {
      template = this.template.get.value;
    } else {
      this.logger.error("No other method supported by the service !");
      return false;
    }
    template = template.replace(/__SERVICE__/g, this.paramservice);
    template = template.replace(/__VERSION__/g, this.paramversion);
    template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);
    template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);
    template = template.replace(/__REQUEST__/g, this.paramrequest);
    if (this.method === "POST") {
      template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
      template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);
    }
    template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());
    if (!template) {
      this.logger.warn("traduction tmpl : empty request !?");
      return false;
    }
    this.requestString = template;
    this.logger.trace("traduction tmpl", template);
    return true;
  },
  /**
   * Ajout des donnÃ©es
   *
   * @returns {String} DonnÃ©es concatÃ©nÃ©es dans une chaine
   */
  __addDataInputs: function() {
    this.logger.trace("WPS::__addDataInputs ()");
    var tmpl = this.method === "GET" ? this.template.get.input : this.template.post.input;
    var sep = this.method === "GET" ? ";" : "";
    var result = "";
    var that = this;
    var map = this.DataObject.getData();
    for (var i = 0; i < map.length; i++) {
      (function(j2) {
        if (sep) {
          sep = j2 === map.length - 1 ? "" : ";";
        }
        result = result.concat(that.__addDataInput(tmpl, map[j2].k, map[j2].v), sep);
      })(i);
    }
    return result;
  },
  /**
   * Ajout d'une donnÃ©e.
   *
   * @param {String} tmpl - template
   * @param {String} key - clef
   * @param {String} data - valeur
   * @returns {String} chaine avec les substitutions clef/valeur
   */
  __addDataInput: function(tmpl, key, data) {
    var tmp = tmpl;
    tmp = tmp.replace(/__KEY__/g, key);
    tmp = tmp.replace(/__DATA__/g, data);
    return tmp;
  },
  /**
   * Definir le mode de requÃªte
   *
   * @param {String} method - GET|POST
   */
  setMethod: function(method) {
    if (method === "GET" || method === "POST") {
      this.method = method;
    } else {
      this.logger.warn("support only GET and POST method !");
    }
  },
  /**
   * Retourne le mode de requete (GET|POST).
   *
   * @returns {AltiRequest.options.mode|String} methode (GET|POST)
   */
  getMethod: function() {
    return this.method;
  }
};
var WPS_default = WPS;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js
var AltiRequestWPS = {
  /**
   * Interface unique de construction de la requÃªte.
   *
   * @method build
   * @param {Object} options - options
   * @param {Object}   options.param.positions - tableau de coordonnÃ©es lon/lat
   * @param {String}   options.param.delimiter - '|'
   * @param {Boolean}  options.param.indent - false|true
   * @param {String}   options.param.crs - 'CRS:84'
   * @param {String}   options.param.sampling - 3
   * @param {Boolean}  options.param.zonly - false|true
   * @param {String}   options.param.format - "JSON|XML" (only to POST)
   * @param {String}   options.wps.service - "WPS"
   * @param {String}   options.wps.version - "1.0.0"
   * @param {String}   options.wps.identifier - "gs:WPSElevation|gs:WPSLineElevation"
   * @param {String}   options.wps.rawdataoutput - "result"
   * @param {String}   options.wps.request - "Execute"
   * @param {String}   options.type - "Profil|Elevation"
   * @param {String}   options.method - GET|POST
   * @example
   *      var options = {
   *           type : 'Profil', // Elevation
   *           method : 'GET',  // par defaut
   *           param : {
   *               positions : [
   *                   {lon:'1.11', lat:'1.11'},
   *                   {lon:'1.10', lat:'1.10'},
   *                   {lon:'1.12', lat:'1.12'}
   *               ],
   *               delimiter : ";",         // par defaut
   *               indent    : true,        // par defaut
   *               crs       : 'EPSG:4326', // par defaut
   *               format    : 'json',      // par defaut (only to POST)
   *               sampling  : 3 ,          // par defaut (only use by Profil)
   *               zonly     : false,       // par defaut (only use by Elevation)
   *           },
   *           wps : {
   *                 service : 'WPS',         // par defaut
   *                 version : '1.0.0',       // par defaut
   *                 identifier : 'gs:WPS',   // par defaut, Elevation = gs:WPSElevation, Profil = gs:WPSLineElevation
   *                 rawdataoutput : 'result',// par defaut
   *                 request : 'Execute'      // par defaut
   *           }
   *       };
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("AltiRequestWPS");
    logger50.trace(["AltiRequestWPS::build()"]);
    if (!options) {
      throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "options"));
    }
    if (!options.type) {
      throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
    }
    var DataObject = null;
    switch (options.type) {
      case "Elevation":
        options.wps.identifier = "gs:WPSElevation";
        DataObject = new AltiElevationRequest_default(options.param);
        break;
      case "Profil":
        options.wps.identifier = "gs:WPSLineElevation";
        DataObject = new AltiProfilRequest_default(options.param);
        break;
      default:
        throw new Error(MessagesResources_default.getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
    }
    var settings = {
      data: DataObject,
      method: options.method,
      param: options.wps
    };
    var rqstWPS = new WPS_default(settings);
    if (!rqstWPS.processRequestString()) {
      throw new Error("Enable to process request !");
    }
    return rqstWPS.requestString;
  }
};
var AltiRequestWPS_default = AltiRequestWPS;

// node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js
var AltiRequestFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Alti
   *
   * @example
   *   var options = {
   *      httpMethod : 'GET', // GET|POST
   *      onSuccess : function (response) {},
   *      onError : function (error) {},
   *      scope : this,
   *      positions : [{lon:, lat:}, {lon:, lat:}],
   *      outputFormat : 'json' // json|xml
   *      sampling : 3,
   *      api : 'REST', // REST|WPS
   *      zonly : false // false|true
   *   };
   *
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("AltiRequestFactory");
    logger50.trace(["AltiRequestFactory::build()"]);
    var request = null;
    var settings = {
      // ajout des valeurs par defaut spÃ©cifiques au service
      type: options.sampling ? "Profil" : "Elevation",
      method: options.httpMethod,
      param: {
        positions: null,
        delimiter: null,
        // FIXME par defaut, on ne le met pas en place car Ã§a fait planter la requÃªte !?
        indent: null,
        // par defaut
        crs: null,
        // par defaut
        format: null,
        // (only to POST)
        sampling: null,
        // (only use by Profil)
        zonly: null,
        // (only use by Elevation)
        measures: null
        // (only use by Elevation)
      }
    };
    settings.param.positions = options.positions;
    settings.param.format = options.outputFormat;
    settings.param.sampling = options.sampling;
    settings.param.zonly = options.zonly;
    settings.param.measures = options.measures;
    settings.param.resource = options.resource;
    var bOnError = !!(options.onError !== null && typeof options.onError === "function");
    var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");
    var message = null;
    switch (options.api) {
      case "REST":
        var myReq = new AltiRequestREST_default(settings);
        if (!myReq.processRequestString()) {
          message = "Error in process request (rest) !";
          if (bOnError) {
            options.onError.call(options.scope, new ErrorService_default(message));
            return;
          }
          throw new Error(message);
        }
        request = myReq.requestString;
        break;
      case "WPS":
        settings.wps = {
          service: null,
          // par defaut
          version: null,
          // par defaut
          identifier: null,
          // par defaut
          rawdataoutput: null,
          // par defaut
          request: null
          // par defaut
        };
        request = AltiRequestWPS_default.build(settings);
        if (!request) {
          message = "Error in process request (wps) !";
          if (bOnError) {
            options.onError.call(options.scope, new ErrorService_default(message));
            return;
          }
          throw new Error(message);
        }
        break;
      default:
        message = "Type of API is not supported by service (REST or WPS) !";
        if (bOnError) {
          options.onError.call(options.scope, new ErrorService_default(message));
          return;
        }
        throw new Error(message);
    }
    if (bOnSuccess) {
      options.onSuccess.call(options.scope, request);
    }
    return request;
  }
};
var AltiRequestFactory_default = AltiRequestFactory;

// node_modules/geoportal-access-lib/src/Formats/XML.js
function XML(options) {
  if (!(this instanceof XML)) {
    throw new TypeError("XML constructor cannot be called as a function.");
  }
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur XML ()]");
  this.xmlString = null;
  this.xmlDoc = null;
  this.reader = null;
  if (options) {
    if (options.xmlString && typeof options.xmlString === "string") {
      this.xmlString = options.xmlString;
      this.xmlDoc = __getXMLDOC(options.xmlString);
    }
    if (options.reader) {
      this.setReader(options.reader);
    }
  }
}
XML.prototype = {
  /**
   * @lends module:XML
   */
  /*
   * Constructeur (alias)
   */
  constructor: XML,
  /**
   * MÃ©thode permettant de rÃ©cupÃ©rer la chaÃ®ne de caractÃ¨res associÃ©e au format XML
   *
   * @returns {String} xmlString - la chaÃ®ne de caractÃ¨res correspondant au format XML
   */
  getXMLString: function() {
    return this.xmlString;
  },
  /**
   * MÃ©thode permettant d'attribuer une chaÃ®ne de caractÃ¨res au format XML (attribut xmlString).
   * La mÃ©thode va aussi transformer cette chaÃ®ne de caractÃ¨res en document XML,
   * afin de remplir l'attribut xmlDoc.
   *
   * @param {String} xmlString - la chaÃ®ne de caractÃ¨res correspondant au format XML
   */
  setXMLString: function(xmlString) {
    if (xmlString && typeof xmlString === "string") {
      this.xmlString = xmlString;
      this.xmlDoc = __getXMLDOC(xmlString);
    }
  },
  /**
   * MÃ©thode permettant de rÃ©cupÃ©rer les readers associÃ©s au format XML, s'ils ont Ã©tÃ© dÃ©finis
   *
   * @return {Object} readers - les readers associÃ©s au format XML, s'ils existent,
   *      sous forme d'une collection de fonctions
   */
  getReader: function() {
    return this.reader;
  },
  /**
   * MÃ©thode permettant d'attribuer des readers, sous la forme d'un objet de fonctions (node, data),
   *      lorsqu'ils n'ont pas Ã©tÃ© dÃ©finis lors de l'instanciation par exemple (new XML (options)).
   *
   * @param {Object} reader - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)
   *      utile pour interprÃ©ter le XML lorsque sa structure est connue.
   *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.
   */
  setReader: function(reader) {
    if (reader && reader.read && typeof reader.read === "function") {
      this.reader = reader;
    }
  },
  /**
   * MÃ©thode permettant de rÃ©cupÃ©rer le document XML associÃ© au format, s'il existe.
   *
   * @return {DOMElement} xmlDoc - le document XML (DOM document node) s'il existe
   */
  getXMLDoc: function() {
    return this.xmlDoc;
  },
  /**
   * Setter
   */
  setXMLDoc: function(doc) {
    this.xmlDoc = doc;
  },
  /**
   * MÃ©thode initialisant la lecture du XML, Ã  partir d'un XML Document :
   *      crÃ©ation d'un objet JavaScript contenant les informations du XML,
   *      sauf dans le cas oÃ¹ il n'existe pas de XML Document Ã  interprÃ©ter (retourne un objet vide).
   *
   * @return {Object} [parserOutput] - un objet JavaScript contenant les informations du XML :
   * - soit toutes les informations si aucun reader n'a Ã©tÃ© spÃ©cifiÃ© Ã  la crÃ©ation du format
   * - soit les informations spÃ©cifiÃ©es dans le reader.
   */
  parse: function() {
    if (!this.xmlDoc && this.xmlString) {
      this.xmlDoc = __getXMLDOC(this.xmlString);
    }
    if (this.xmlDoc) {
      var root = __getRootNode(this.xmlDoc);
      if (root) {
        var parserOutput;
        if (this.reader && this.reader.read) {
          parserOutput = this.reader.read(root);
        } else {
          parserOutput = {};
          parserOutput[root.nodeName] = __readDefault(root);
        }
        return parserOutput;
      } else {
        return {};
      }
    }
  }
};
function __getXMLDOC(xmlString) {
  if (typeof window === "undefined") {
    var DOMParser2 = require_lib().DOMParser;
    return new DOMParser2().parseFromString(xmlString, "text/xml");
  } else {
    var parser;
    var xmlDoc;
    var errorMsg = "Erreur lors du parsing de la rÃ©ponse du service : XML non conforme";
    if (window.ActiveXObject) {
      xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
      xmlDoc.async = false;
      xmlDoc.loadXML(xmlString);
      var parseError = xmlDoc.parseError;
      if (parseError.errorCode) {
        if (parseError.line && parseError.linepos) {
          errorMsg += "( ligne " + parseError.line + ", colonne " + parseError.linepos;
        }
        if (parseError.reason) {
          errorMsg += ":  " + parseError.reason + ")";
        }
        throw new Error(errorMsg);
      }
      return xmlDoc;
    } else if (window.DOMParser) {
      parser = new window.DOMParser();
      try {
        xmlDoc = parser.parseFromString(xmlString, "text/xml");
      } catch (e) {
        if (e.message === "SyntaxError") {
          throw new Error(errorMsg);
        } else {
          throw new Error("Erreur lors du parsing de la rÃ©ponse du service : " + e.message);
        }
      }
      if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        var parsererror = xmlDoc.getElementsByTagName("parsererror");
        for (var i = 0; i < parsererror.length; i++) {
          var content = parsererror[i].innerHTML;
          if (content.indexOf("Huge input lookup") === -1) {
            errorMsg += "(" + content + ")";
            throw new Error(errorMsg);
          }
        }
      } else if (!xmlDoc.documentElement) {
        throw new Error(errorMsg);
      }
      return xmlDoc;
    } else {
      throw new Error("Incompatible DOM Parser pour ce navigateur !");
    }
  }
}
function __getRootNode(xmlDoc) {
  var root;
  if (xmlDoc.nodeType === 9) {
    root = xmlDoc.documentElement;
  } else if (xmlDoc.nodeType === 1) {
    root = xmlDoc;
  }
  return root;
}
function __readDefault(node) {
  var data = {};
  if (node.attributes.length > 0) {
    var dataAttributes = __getAttributes(node);
    data["attributes"] = dataAttributes;
  }
  if (node.hasChildNodes()) {
    var childData = {};
    var child;
    var children = node.childNodes;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.nodeType === 3) {
        data["textContent"] = child.nodeValue;
      } else if (child.nodeType === 1) {
        childData = __readDefault(child);
        if (!data[child.nodeName]) {
          data[child.nodeName] = childData;
        } else {
          if (!Array.isArray(data[child.nodeName])) {
            var old = data[child.nodeName];
            data[child.nodeName] = [];
            data[child.nodeName].push(old);
          }
          data[child.nodeName].push(childData);
        }
      }
    }
  }
  return data;
}
function __getAttributes(node) {
  if (node.attributes.length > 0) {
    var nodeAttributes = {};
    var attributes = node.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var attribute = attributes[i];
      nodeAttributes[attribute.nodeName] = attribute.nodeValue;
    }
    return nodeAttributes;
  }
}
var XML_default = XML;

// node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js
function AltiResponse() {
  if (!(this instanceof AltiResponse)) {
    throw new TypeError("AltiResponse constructor cannot be called as a function.");
  }
  this.elevations = [];
}
AltiResponse.prototype = {
  constructor: AltiResponse
};
var AltiResponse_default = AltiResponse;

// node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js
function Elevation() {
  if (!(this instanceof Elevation)) {
    throw new TypeError("Elevation constructor cannot be called as a function.");
  }
  this.z = null;
}
Elevation.prototype = {
  constructor: Elevation
};
var Elevation_default = Elevation;

// node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Measure.js
function Measure() {
  if (!(this instanceof Measure)) {
    throw new TypeError("Measure constructor cannot be called as a function.");
  }
  this.source_name = null;
  this.source_measure = null;
  this.z = null;
  this.acc = null;
}
Measure.prototype = {
  constructor: Measure
};
var Measure_default = Measure;

// node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js
var AltiResponseReader = {};
AltiResponseReader.READERS = {
  /**
   * Lecture d'un noeud "elevations" de la rÃ©ponse XML du service alti, correspondant logiquement Ã  la racine du document
   *      (contient un ou plusieurs childNodes correspondant chacun Ã  une Ã©lÃ©vation retournÃ©e)
   *
   * @param {DOMElement} root - racine de la rÃ©ponse XML
   * @static
   * @memberof AltiResponseReader
   * @returns {Object} Retourne un objet de type AltiResponse
   */
  elevations: function(root) {
    var altiResponse = new AltiResponse_default();
    if (root.hasChildNodes()) {
      var children = root.childNodes;
      var child;
      var elevation;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        if (AltiResponseReader.READERS[child.nodeName]) {
          elevation = AltiResponseReader.READERS[child.nodeName](child);
          altiResponse.elevations.push(elevation);
        }
      }
    }
    return altiResponse;
  },
  /**
   * Lecture d'un noeud "elevation" de la rÃ©ponse xml du service alti.
   *      (contient un ou 5 childNode (s) correspondant Ã  l'altitude (z) et Ã©ventuellement lat, lon, acc et measures)
   *
   * @param {DOMElement} node - noeud elevation Ã  lire pour rÃ©cupÃ©rer les informations de l'Ã©lÃ©vation retournÃ©e (z [, lon, lat, acc, measures])
   * @return {Array} elevationResponse - format de la rÃ©ponse en sortie, instance de AltiResponse
   * @static
   * @memberof AltiResponseReader
   */
  elevation: function(node) {
    var elevation = new Elevation_default();
    if (node.hasChildNodes()) {
      var children = node.childNodes;
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        if (AltiResponseReader.READERS[child.nodeName]) {
          AltiResponseReader.READERS[child.nodeName](child, elevation);
        }
      }
    }
    return elevation;
  },
  /**
   * Lecture d'un noeud "lat" de la rÃ©ponse xml du service alti.
   *      (contient une valeur de latitude, qui est un flottant)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la latitude
   * @param {Object} elevation - objet dans lequel stocker la latitude retournÃ©e
   * @static
   * @memberof AltiResponseReader
   */
  lat: function(node, elevation) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      elevation.lat = parseFloat(textNode.nodeValue);
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : latitude attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "lon" de la rÃ©ponse xml du service alti.
   *      (contient une valeur de longitude, qui est un flottant)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la longitude
   * @param {Object} elevation - objet dans lequel stocker la longitude retournÃ©e
   * @static
   * @memberof AltiResponseReader
   */
  lon: function(node, elevation) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      elevation.lon = parseFloat(textNode.nodeValue);
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : longitude attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "z" de la rÃ©ponse xml du service alti.
   *      (contient une valeur d'altitude, qui est un flottant)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer l'altitude
   * @param {Object} elevationObject - objet dans lequel stocker l'altitude retournÃ©e : elevation ou measure
   * @static
   * @memberof AltiResponseReader
   */
  z: function(node, elevationObject) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      if (elevationObject) {
        elevationObject.z = parseFloat(textNode.nodeValue);
      } else {
        elevationObject = new Elevation_default();
        elevationObject.z = parseFloat(textNode.nodeValue);
        return elevationObject;
      }
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : altitude attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "acc" de la rÃ©ponse xml du service alti.
   *      (contient une valeur de prÃ©cision, qui est un flottant)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la prÃ©cision
   * @param {Object} elevationObject - objet dans lequel stocker la prÃ©cision retournÃ©e : elevation ou measure
   * @static
   * @memberof AltiResponseReader
   */
  acc: function(node, elevationObject) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      elevationObject.acc = parseFloat(textNode.nodeValue);
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : prÃ©cision (acc) attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "source_name" de la rÃ©ponse xml du service alti.
   *      (contient le nom de la source, qui est un string)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la prÃ©cision
   * @param {Object} measure - objet dans lequel stocker le nom de la source retournÃ©
   * @static
   * @memberof AltiResponseReader
   */
  source_name: function(node, measure) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      measure.source_name = textNode.nodeValue;
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : source_name attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "source_measure" de la rÃ©ponse xml du service alti.
   *      (contient le nom de la mesure, qui est un string)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la prÃ©cision
   * @param {Object} measure - objet dans lequel stocker le nom de la source retournÃ©
   * @static
   * @memberof AltiResponseReader
   */
  source_measure: function(node, measure) {
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      measure.source_measure = textNode.nodeValue;
    } else {
      throw new Error("Erreur dans la lecture de la rÃ©ponse du service : source_measure attendue mais absente");
    }
  },
  /**
   * Lecture d'un noeud "measures" et de ses enfants "measure" de la rÃ©ponse xml du service alti.
   *      (contient une valeur de prÃ©cision, qui est un flottant)
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer la prÃ©cision
   * @param {Object} elevation - objet dans lequel stocker la prÃ©cision retournÃ©e
   * @static
   * @memberof AltiResponseReader
   */
  measures: function(node, elevation) {
    elevation.measures = [];
    var measure;
    if (node.hasChildNodes()) {
      var children = node.childNodes;
      var measureNode;
      var measureChildren;
      for (var i = 0; i < children.length; i++) {
        measure = new Measure_default();
        measureNode = children[i];
        measureChildren = measureNode.childNodes;
        for (var j2 = 0; j2 < measureChildren.length; j2++) {
          if (AltiResponseReader.READERS[measureChildren[j2].nodeName]) {
            AltiResponseReader.READERS[measureChildren[j2].nodeName](measureChildren[j2], measure);
          } else {
            throw new Error("Erreur dans la lecture de la rÃ©ponse du service : measures attendues mais absentes");
          }
        }
        elevation.measures.push(measure);
      }
    }
  },
  /**
   * Lecture d'un noeud "ExceptionReport" de la rÃ©ponse xml du service alti.
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer l'exception
   * @return {Object} exceptionReport - objet contenant l'exception
   * @static
   * @memberof AltiResponseReader
   */
  exceptionreport: function(node) {
    var response = {};
    if (node.hasChildNodes()) {
      var children = node.childNodes;
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        if (child.nodeName === "Exception") {
          response.exceptionReport = AltiResponseReader.READERS.exception(child);
        }
      }
    }
    return response;
  },
  /**
   * Lecture d'un noeud "Exception" de la rÃ©ponse xml du service alti.
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer l'exception
   * @return {Object} exceptionReport - objet contenant l'exception, avec deux attributs :
   *      {String} exceptionReport.exceptionCode - qui contient l'identifiant du code de l'exception
   *      {String} exceptionReport.exception - qui contient le message de l'exception
   * @static
   * @memberof AltiResponseReader
   */
  exception: function(node) {
    var exceptionReport = {};
    var exceptionCode = node.getAttribute("exceptionCode");
    if (exceptionCode) {
      exceptionReport.exceptionCode = exceptionCode;
    }
    var textNode = node.firstChild;
    if (textNode && textNode.nodeType === 3) {
      exceptionReport.exception = textNode.nodeValue;
    }
    return exceptionReport;
  },
  /**
   * Lecture d'un noeud "Error" de la rÃ©ponse xml du service alti.
   *
   * @param {DOMElement} node - noeud Ã  lire pour rÃ©cupÃ©rer l'exception
   * @return {Object} error - objet contenant l'exception
   * @static
   */
  error: function(node) {
    var response = {
      error: {}
    };
    if (node.hasChildNodes()) {
      var children = node.childNodes;
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        var textNode;
        if (child.nodeType === 1 && child.nodeName === "code") {
          textNode = child.firstChild;
          if (textNode && textNode.nodeType === 3) {
            response.error.code = textNode.nodeValue;
          }
        }
        if (child.nodeType === 1 && child.nodeName === "description") {
          textNode = child.firstChild;
          if (textNode && textNode.nodeType === 3) {
            response.error.description = textNode.nodeValue;
          }
        }
      }
    }
    return response;
  }
};
AltiResponseReader.read = function(root) {
  if (root.nodeName === "elevations") {
    var altiResponse = AltiResponseReader.READERS.elevations(root);
    return altiResponse;
  } else if (root.nodeName === "ExceptionReport") {
    var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);
    return exceptionReport;
  } else if (root.nodeName === "error") {
    var error = AltiResponseReader.READERS.error(root);
    return error;
  } else {
    throw new Error("Erreur lors de la lecture de la rÃ©ponse : elle n'est pas au format attendu.");
  }
};
var AltiResponseReader_default = AltiResponseReader;

// node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js
var AltiResponseFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Alti
   *
   * @example
   *   var options = {
   *      response :
   *      outputFormat :
   *      rawResponse :
   *      scope :
   *      onSuccess :
   *      onError :
   *   };
   *
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("AltiResponseFactory");
    logger50.trace(["AltiResponseFactory::build()"]);
    var data = null;
    if (options.response) {
      if (options.rawResponse) {
        logger50.trace("analyze response : raw");
        data = options.response;
      } else {
        switch (options.outputFormat) {
          case "xml":
            logger50.trace("analyze response : xml");
            try {
              var p2 = new XML_default({
                reader: AltiResponseReader_default
              });
              if (typeof options.response === "string") {
                p2.setXMLString(options.response);
              } else {
                p2.setXMLDoc(options.response);
              }
              data = p2.parse();
              if (!data) {
                throw new Error(MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION_2"));
              }
            } catch (e) {
              var message = e.message;
              options.onError.call(options.scope, new ErrorService_default({
                message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", message),
                status: 200,
                type: ErrorService_default.TYPE_SRVERR
              }));
              return;
            }
            break;
          case "json":
            logger50.trace("analyze response : json");
            logger50.trace("analyze response : ", typeof options.response);
            var JSONResponse = null;
            if (typeof options.response === "string") {
              JSONResponse = JSON.parse(options.response);
            } else {
              JSONResponse = options.response;
            }
            if (JSONResponse && JSONResponse.error) {
              options.onError.call(options.scope, new ErrorService_default({
                message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
                status: 200,
                type: ErrorService_default.TYPE_SRVERR
              }));
              return;
            }
            if (JSONResponse) {
              var elevations = JSONResponse.elevations;
              var altiResponse = new AltiResponse_default();
              var elevation;
              if (Array.isArray(elevations) && elevations.length) {
                for (var i = 0; i < elevations.length; i++) {
                  elevation = new Elevation_default();
                  if (typeof elevations[i] === "object") {
                    if (elevations[i].lon) {
                      elevation.lon = elevations[i].lon;
                    }
                    if (elevations[i].lat) {
                      elevation.lat = elevations[i].lat;
                    }
                    if (elevations[i].z) {
                      elevation.z = elevations[i].z;
                    }
                    if (elevations[i].acc) {
                      elevation.acc = elevations[i].acc;
                    }
                    if (elevations[i].measures) {
                      elevation.measures = elevations[i].measures;
                    }
                  } else if (typeof elevations[i] === "number") {
                    elevation.z = elevations[i];
                  }
                  if (Array.isArray(altiResponse.elevations)) {
                    altiResponse.elevations.push(elevation);
                  }
                }
              }
              data = altiResponse;
            }
            if (!data) {
              options.onError.call(options.scope, new ErrorService_default({
                message: MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE_2"),
                type: ErrorService_default.TYPE_UNKERR,
                status: -1
              }));
              return;
            }
            break;
          default:
            options.onError.call(options.scope, new ErrorService_default({
              message: MessagesResources_default.getMessage("SERVICE_RESPONSE_FORMAT_2"),
              type: ErrorService_default.TYPE_UNKERR,
              status: -1
            }));
            return;
        }
        if (data.exceptionReport) {
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
            type: ErrorService_default.TYPE_SRVERR,
            status: 200
          }));
          return;
        } else if (data.error) {
          var errorMess = data.error.description;
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", errorMess),
            type: ErrorService_default.TYPE_SRVERR,
            status: 200
          }));
          return;
        }
      }
    } else {
      options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
      return;
    }
    options.onSuccess.call(options.scope, data);
  }
};
var AltiResponseFactory_default = AltiResponseFactory;

// node_modules/geoportal-access-lib/src/Services/Alti/Alti.js
function Alti(options) {
  if (!(this instanceof Alti)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "Alti"));
  }
  this.CLASSNAME = "Alti";
  CommonService_default.apply(this, arguments);
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.Alti");
  this.logger.trace("[Constructeur Alti (options)]");
  if (!options.positions) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "positions"));
  }
  if (options.positions.length === 0) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "positions"));
  }
  this.options.positions = options.positions;
  this.options.outputFormat = typeof options.outputFormat === "string" ? options.outputFormat.toLowerCase() : "xml";
  this.options.resource = options.resource || "ign_rge_alti_wld";
  this.options.sampling = options.sampling || null;
  this.options.api = typeof options.api === "string" ? options.api.toUpperCase() : "REST";
  if (this.options.api === "REST") {
    this.options.httpMethod = "GET";
  }
  this.options.zonly = options.zonly || false;
  this.options.measures = options.measures || false;
  if (!this.options.serverUrl) {
    var lstUrlByDefault = DefaultUrlService_default.Alti.newUrl();
    var urlFound = null;
    switch (this.options.api) {
      case "WPS":
        urlFound = lstUrlByDefault.wps;
        break;
      case "REST":
        var key = (options.sampling ? "profil" : "elevation") + "-" + this.options.outputFormat;
        urlFound = lstUrlByDefault[key];
        break;
      default:
        throw new Error(MessagesResources_default.getMessage("PARAM_UNKNOWN", "api"));
    }
    if (!urlFound) {
      throw new Error("Url by default not found !");
    }
    this.options.serverUrl = urlFound;
    this.logger.trace("Server URL by default : " + this.options.serverUrl);
  }
  var idx = this.options.serverUrl.lastIndexOf(".");
  if (idx !== -1) {
    var extension = this.options.serverUrl.substring(idx + 1);
    if (extension && extension.length < 5) {
      this.logger.trace("Server Extension URL : " + extension);
      switch (extension.toLowerCase()) {
        case "json":
        case "xml":
          this.options.outputFormat = extension.toLowerCase();
          break;
        default:
          throw new Error("type of service : unknown or unsupported (json or xml) !");
      }
    }
  }
}
Alti.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
Alti.prototype.constructor = Alti;
Alti.prototype.buildRequest = function(error, success) {
  var options = {
    httpMethod: this.options.httpMethod,
    // callback
    onSuccess: function(result) {
      this.request = result;
      success.call(this, this.request);
    },
    onError: error,
    scope: this,
    // spÃ©cifique au service :
    resource: this.options.resource,
    positions: this.options.positions,
    outputFormat: this.options.outputFormat,
    sampling: this.options.sampling,
    api: this.options.api,
    zonly: this.options.zonly,
    measures: this.options.measures
  };
  AltiRequestFactory_default.build(options);
};
Alti.prototype.analyzeResponse = function(error, success) {
  if (this.response) {
    var options = {
      response: this.response,
      outputFormat: this.options.outputFormat,
      // utile pour parser la string en mode XHR : JSON ou XML !
      rawResponse: this.options.rawResponse,
      onError: error,
      onSuccess: success,
      scope: this
    };
    AltiResponseFactory_default.build(options);
  } else {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
var Alti_default = Alti;

// node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js
function GeocodeParamREST(options) {
  if (!(this instanceof GeocodeParamREST)) {
    throw new TypeError("GeocodeParamREST constructor cannot be called as a function.");
  }
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur GeocodeParamREST ()]");
  this.options = options || {};
  if (!this.options.geocodeMethod || this.options.geocodeMethod !== "search" && this.options.geocodeMethod !== "reverse") {
    throw new Error("Error geocodeMethod not valid");
  }
  this.geocodeMethod = this.options.geocodeMethod;
  this.query = typeof this.options !== "undefined" ? this.options.query : null;
  this.searchGeometry = this.options.searchGeometry || null;
  this.index = this.options.index || null;
  this.lon = this.options.position && this.options.position.lon ? this.options.position.lon : null;
  this.lat = this.options.position && this.options.position.lat ? this.options.position.lat : null;
  this.maxResp = this.options.maxResp || null;
  this.returnTrueGeometry = this.options.returnTrueGeometry || null;
  this.filters = this.options.filters || {};
}
GeocodeParamREST.CLASSNAME = "GeocodeParamREST";
GeocodeParamREST.prototype = {
  /**
   * @lends module:GeocodeParamREST#
   */
  /**
   * Constructeur (alias)
   */
  constructor: GeocodeParamREST,
  /**
   * Retourne les filtres
   * @returns {String} les filtres
   */
  getFilters: function() {
    var filters = {};
    for (var prop in this.filters) {
      if (this.filters.hasOwnProperty(prop)) {
        filters[prop] = this.filters[prop];
      }
    }
    return filters;
  },
  /**
   * Retourne l'index
   * @returns {String} l'index
   */
  getIndex: function() {
    if (this.index === void 0) {
      return null;
    }
    if (this.index === "StreetAddress") {
      return "address";
    } else if (this.index === "CadastralParcel") {
      return "parcel";
    } else if (this.index === "PositionOfInterest") {
      return "poi";
    } else if (this.index === "location") {
      return "location";
    }
    return this.index;
  },
  /**
   * Retourne la gÃ©omÃ©trie de recherche
   * @returns {String} la gÃ©omÃ©trie de recherche au format json
   */
  getSearchGeometry: function() {
    return JSON.stringify(this.searchGeometry);
  }
};
GeocodeParamREST.prototype.getParams = function() {
  var map = [];
  if (this.geocodeMethod === "search") {
    map.push({
      k: "q",
      v: this.query
    });
  }
  if (this.index) {
    map.push({
      k: "index",
      v: this.getIndex()
    });
  }
  if (this.geocodeMethod === "reverse" && this.searchGeometry) {
    map.push({
      k: "searchgeom",
      v: this.getSearchGeometry()
    });
  }
  if (this.lon && this.lat) {
    map.push({
      k: "lon",
      v: this.lon
    });
    map.push({
      k: "lat",
      v: this.lat
    });
  }
  if (this.maxResp) {
    map.push({
      k: "limit",
      v: this.maxResp
    });
  }
  if (this.returnTrueGeometry) {
    map.push({
      k: "returntruegeometry",
      v: this.returnTrueGeometry
    });
  }
  const filters = this.getFilters();
  for (var key in filters) {
    map.push({
      k: key,
      v: filters[key]
    });
  }
  return map;
};
var GeocodeParamREST_default = GeocodeParamREST;

// node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js
function GeocodeRequestREST(options) {
  this.logger = LoggerByDefault_default.getLogger("GeocodeRequestREST");
  this.logger.trace("[Constructeur GeocodeRequestREST ()]");
  if (!(this instanceof GeocodeRequestREST)) {
    throw new TypeError("GeocodeRequestREST constructor cannot be called as a function.");
  }
  if (!options) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "options"));
  }
  this.settings = options;
}
GeocodeRequestREST.prototype = {
  /**
   * @lends module:GeocodeRequestREST#
   */
  /**
   * request
   * @type {String}
   */
  requestString: null,
  /**
   * Constructeur (alias)
   */
  constructor: GeocodeRequestREST,
  /**
   * Construction de la requÃªte.
   *
   * @returns {String} request
   */
  processRequestString: function() {
    var request = "";
    const oParams = new GeocodeParamREST_default(this.settings);
    const params2 = oParams.getParams();
    for (var i = 0; i < params2.length; i++) {
      var o = params2[i];
      if (request) {
        request += "&";
      }
      request += o.k + "=" + o.v;
    }
    if (!this.settings.geocodeMethod || this.settings.geocodeMethod !== "search" && this.settings.geocodeMethod !== "reverse") {
      throw new Error("Error geocodeMethod not valid");
    }
    this.requestString = "?" + request;
    this.logger.trace(this.requestString);
    return this.requestString;
  }
};
var GeocodeRequestREST_default = GeocodeRequestREST;

// node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js
var GeocodeRequestFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Geocode
   *
   * @example
   *   var options = {
   *      // options specifiques du service
   *      geocodeMethod:
   *      query:
   *      filters:
   *      maximumResponses:
   *   };
   *   var result = GeocodeRequestFactory.build(options);
   *   if (!result) {
   *       // error...
   *   }
   * @returns {String} request
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("GeocodeRequestFactory");
    logger50.trace(["GeocodeRequestFactory::build()"]);
    var settings = options || {};
    var myReq = new GeocodeRequestREST_default(settings);
    if (!myReq.processRequestString()) {
      throw new Error("Error process request (rest) !");
    }
    var request = myReq.requestString;
    logger50.trace(request);
    return request;
  }
};
var GeocodeRequestFactory_default = GeocodeRequestFactory;

// node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js
function GeocodeResponse() {
  if (!(this instanceof GeocodeResponse)) {
    throw new TypeError("GeocodeResponse constructor cannot be called as a function.");
  }
  this.locations = [];
}
GeocodeResponse.prototype = {
  constructor: GeocodeResponse
};
var GeocodeResponse_default = GeocodeResponse;

// node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js
function GeocodedLocation() {
  if (!(this instanceof GeocodedLocation)) {
    throw new TypeError("GeocodedLocation constructor cannot be called as a function.");
  }
  this.position = null;
  this.matchType = null;
  this.placeAttributes = {};
  this.type = null;
  this.accuracy = null;
  this.CLASSNAME = "GeocodedLocation";
}
GeocodedLocation.prototype = {
  constructor: GeocodedLocation
};
var GeocodedLocation_default = GeocodedLocation;

// node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js
function GeocodeResponseParser() {
  if (!(this instanceof GeocodeResponseParser)) {
    throw new TypeError("GeocodeResponseParser constructor cannot be called as a function.");
  }
}
GeocodeResponseParser.prototype = {
  /**
   * @lends module:GeocodeResponseParser
   */
  /*
   * Constructeur (alias)
   */
  constructor: GeocodeResponseParser,
  /**
   * MÃ©thode permettant de lancer la lecture d'une rÃ©ponse GeoJSON,
   *
   * @param {String} json - rÃ©ponse au format GeoJSON
   * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la rÃ©ponse GeoJSON,
   *      sous la forme d'un objet GeocodeResponse, ou un objet littÃ©ral exceptionReport si le service a renvoyÃ© une exception.
   */
  parse: function(json) {
    var geocodeResponse = new GeocodeResponse_default();
    const obj = JSON.parse(json);
    if (obj.type === "FeatureCollection") {
      for (var i = 0; i < obj.features.length; ++i) {
        _parseFeature(obj.features[i], geocodeResponse);
      }
    } else if (obj.type === "Feature") {
      _parseFeature(obj, geocodeResponse);
    } else if (obj.type === "SERVICE_ERROR") {
      return _parseError(obj);
    } else {
      var mess = MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE", obj.type);
      throw new ErrorService_default({
        message: mess,
        type: ErrorService_default.TYPE_UNKERR,
        status: 200
      });
    }
    return geocodeResponse;
  }
};
function _parseFeature(feature, geocodeResponse) {
  var location = new GeocodedLocation_default();
  if (feature.geometry && feature.geometry.type === "Point") {
    location.position = {
      lon: feature.geometry.coordinates[0],
      lat: feature.geometry.coordinates[1]
    };
  }
  if (feature.properties) {
    for (var prop in feature.properties) {
      if (prop === "score") {
        location.accuracy = feature.properties[prop];
      } else if (prop === "_type") {
        if (feature.properties[prop] === "address") {
          location.type = "StreetAddress";
        } else if (feature.properties[prop] === "poi") {
          location.type = "PositionOfInterest";
        } else if (feature.properties[prop] === "parcel" || feature.properties[prop] === "cadastral") {
          location.type = "CadastralParcel";
        }
      } else {
        location.placeAttributes[prop] = feature.properties[prop];
      }
    }
    if (feature.properties._type === "address") {
      location.matchType = feature.properties.number !== void 0 && feature.properties.number !== null ? "street number" : "street";
    }
  }
  geocodeResponse.locations.push(location);
}
function _parseError(error) {
  return {
    exceptionReport: error
  };
}
var GeocodeResponseParser_default = GeocodeResponseParser;

// node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js
var GeocodeReponseFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Geocode
   *
   * @example
   *   var options = {
   *      response :
   *      rawResponse :
   *      scope :
   *      onSuccess :
   *      onError :
   *   };
   *
   */
  build: function(options) {
    var data = null;
    if (options.response) {
      if (options.rawResponse) {
        data = options.response;
      } else {
        try {
          const parser = new GeocodeResponseParser_default();
          data = parser.parse(options.response);
          if (!data) {
            throw new Error("L'analyse de la rÃ©ponse du service !?");
          }
        } catch (e) {
          var message = e.message;
          if (typeof options.response === "string") {
            message += "('" + options.response + "')";
          } else {
            message += "('" + options.response.documentElement.innerHTML + "')";
          }
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE", message),
            type: ErrorService_default.TYPE_UNKERR,
            status: -1
          }));
          return;
        }
        if (data.exceptionReport) {
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
            type: ErrorService_default.TYPE_SRVERR,
            status: 200
            // FIXME : 200 ?
          }));
          return;
        }
      }
    } else {
      options.onError.call(options.scope, new ErrorService_default({
        message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY"),
        type: ErrorService_default.TYPE_SRVERR,
        status: -1
        // FIXME : status response
      }));
      return;
    }
    options.onSuccess.call(options.scope, data);
  }
};
var GeocodeResponseFactory_default = GeocodeReponseFactory;

// node_modules/geoportal-access-lib/src/Services/Geocode/Geocode.js
function Geocode(options_) {
  if (!(this instanceof Geocode)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "Geocode"));
  }
  this.CLASSNAME = "Geocode";
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.Geocode");
  this.logger.trace("[Constructeur Geocode (options)]");
  var options = this.patchOptionConvertor(options_);
  if (!options.serverUrl) {
    options.serverUrl = DefaultUrlService_default.Geocode.newUrl();
  }
  CommonService_default.apply(this, [options]);
  if (!options.hasOwnProperty("query")) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "query"));
  }
  this.options.query = options.query;
  if (!options.index) {
    this.options.index = options.index = "StreetAddress";
  }
  if (options.filters) {
    var filter = Object.keys(options.filters);
    for (var i = 0; i < filter.length; i++) {
      var key = filter[i];
      if (typeof options.filters[key] === "undefined" || typeof options.filters[key] === "object" && Object.keys(options.filters[key]).length === 0 || typeof options.filters[key] === "string" && options.filters[key].length === 0 || Array.isArray(options.filters[key]) && options.filters[key].length === 0) {
        delete this.options.filters[key];
      }
    }
  }
  this.options.index = options.index || "StreetAddress";
  this.options.maximumResponses = options.maximumResponses || 20;
}
Geocode.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
Geocode.prototype.constructor = Geocode;
Geocode.prototype.patchOptionConvertor = function(options_) {
  const options = options_;
  if (options.hasOwnProperty("location")) {
    this.logger.warn("The parameter 'location' is deprecated");
    if (!options.query) {
      options.query = options.location;
    }
    delete options.location;
  }
  if (options.filterOptions) {
    this.logger.warn("The parameter 'filterOptions' is deprecated");
    if (!options.filters) {
      options.filters = options.filterOptions;
      if (options.filters.type) {
        this.logger.warn("The parameter 'filterOptions.type' is deprecated");
        if (!options.index) {
          if (Array.isArray(options.filters.type) && options.filters.type.length > 0) {
            options.index = options.filters.type[0];
          } else {
            options.index = options.filters.type;
          }
        }
        delete options.filters.type;
      }
      if (options.filters.bbox) {
        this.logger.warn("The parameter 'filterOptions.bbox' is deprecated");
        delete options.filters.bbox;
      }
    }
    delete options.filterOptions;
  }
  if (options.position) {
    if (options.position.x) {
      this.logger.warn("The parameter 'position.x' is deprecated");
      if (!options.position.lon) {
        options.position.lon = options.position.x;
      }
      delete options.position.x;
    }
    if (options.position.y) {
      this.logger.warn("The parameter 'position.y' is deprecated");
      if (!options.position.lat) {
        options.position.lat = options.position.y;
      }
      delete options.position.y;
    }
  }
  if (options.returnFreeForm) {
    this.logger.warn("The parameter 'returnFreeForm' is deprecated");
    delete options.returnFreeForm;
  }
  if (options.srs) {
    this.logger.warn("The parameter 'srs' is deprecated");
    delete options.srs;
  }
  return options;
};
Geocode.prototype.buildRequest = function(error, success) {
  var options = {
    httpMethod: this.options.httpMethod,
    // options specifiques du service
    geocodeMethod: "search",
    query: this.options.query,
    index: this.options.index,
    returnTrueGeometry: this.options.returnTrueGeometry,
    position: this.options.position,
    maxResp: this.options.maximumResponses,
    filters: this.options.filters
  };
  this.request = GeocodeRequestFactory_default.build(options);
  !this.request ? error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_REQUEST_BUILD"))) : success.call(this, this.request);
};
Geocode.prototype.analyzeResponse = function(error, success) {
  if (this.response) {
    var options = {
      response: this.response,
      rawResponse: this.options.rawResponse,
      onError: error,
      onSuccess: success,
      scope: this
    };
    GeocodeResponseFactory_default.build(options);
  } else {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
var Geocode_default = Geocode;

// node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js
function ReverseGeocode(options_) {
  if (!(this instanceof ReverseGeocode)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "ReverseGeocode"));
  }
  this.CLASSNAME = "ReverseGeocode";
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.ReverseGeocode");
  this.logger.trace("[Constructeur ReverseGeocode (options)]");
  var options = this.patchOptionConvertor(options_);
  if (!options.serverUrl) {
    options.serverUrl = DefaultUrlService_default.ReverseGeocode.newUrl();
  }
  CommonService_default.apply(this, [options]);
  if (!options.searchGeometry) {
    if (!options.position) {
      throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "searchGeometry"));
    }
  } else {
    this.options.searchGeometry = options.searchGeometry;
  }
  if (!options.index) {
    this.options.index = options.index = "StreetAddress";
  }
  if (options.filters) {
    var filter = Object.keys(options.filters);
    for (var i = 0; i < filter.length; i++) {
      var key = filter[i];
      if (typeof options.filters[key] === "undefined" || typeof options.filters[key] === "object" && Object.keys(options.filters[key]).length === 0 || typeof options.filters[key] === "string" && options.filters[key].length === 0 || Array.isArray(options.filters[key]) && options.filters[key].length === 0) {
        delete this.options.filters[key];
      }
    }
  }
  this.options.position = options.position;
  this.options.index = options.index || "StreetAddress";
  this.options.maximumResponses = options.maximumResponses || 20;
}
ReverseGeocode.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
ReverseGeocode.prototype.constructor = ReverseGeocode;
ReverseGeocode.prototype.patchOptionConvertor = function(options_) {
  var options = options_;
  if (options.filterOptions) {
    this.logger.warn("The parameter 'filterOptions' is deprecated");
    if (options.filterOptions.type) {
      this.logger.warn("The parameter 'filterOptions.type' is deprecated");
      if (!options.index) {
        if (Array.isArray(options.filterOptions.type) && options.filterOptions.type.length > 0) {
          options.index = options.filterOptions.type[0];
        } else {
          options.index = options.filterOptions.type;
        }
      }
      delete options.filterOptions.type;
    }
    if (options.filterOptions.bbox) {
      this.logger.warn("The parameter 'filterOptions.bbox' is deprecated");
      if (!options.searchGeometry) {
        options.searchGeometry = this.bbox2Json(options.filterOptions.bbox);
      }
      delete options.filterOptions.bbox;
    }
    if (options.filterOptions.circle) {
      this.logger.warn("The parameter 'filterOptions.circle' is deprecated");
      if (!options.searchGeometry) {
        options.searchGeometry = this.circle2Json(options.filterOptions.circle);
      }
      delete options.filterOptions.circle;
    }
    if (options.filterOptions.polygon) {
      this.logger.warn("The parameter 'filterOptions.polygon' is deprecated");
      if (!options.searchGeometry) {
        options.searchGeometry = this.polygon2Json(options.filterOptions.polygon);
      }
      delete options.filterOptions.polygon;
    }
    if (!options.filters && Object.keys(options.filterOptions).length > 0) {
      options.filters = options.filterOptions;
    }
    delete options.filterOptions;
  }
  if (options.position) {
    if (options.position.x) {
      this.logger.warn("The parameter 'position.x' is deprecated");
      if (!options.position.lon) {
        options.position.lon = options.position.x;
      }
      delete options.position.x;
    }
    if (options.position.y) {
      this.logger.warn("The parameter 'position.y' is deprecated");
      if (!options.position.lat) {
        options.position.lat = options.position.y;
      }
      delete options.position.y;
    }
  }
  if (options.srs) {
    this.logger.warn("The parameter 'srs' is deprecated");
    delete options.srs;
  }
  return options;
};
ReverseGeocode.prototype.buildRequest = function(error, success) {
  var options = {
    httpMethod: this.options.httpMethod,
    // options specifiques du service
    geocodeMethod: "reverse",
    searchGeometry: this.options.searchGeometry,
    index: this.options.index,
    position: this.options.position,
    returnTrueGeometry: this.options.returnTrueGeometry,
    maxResp: this.options.maximumResponses,
    filters: this.options.filters
  };
  this.request = GeocodeRequestFactory_default.build(options);
  !this.request ? error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_REQUEST_BUILD"))) : success.call(this, this.request);
};
ReverseGeocode.prototype.analyzeResponse = function(error, success) {
  if (this.response) {
    var options = {
      response: this.response,
      rawResponse: this.options.rawResponse,
      onError: error,
      onSuccess: success,
      scope: this
    };
    GeocodeResponseFactory_default.build(options);
  } else {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
ReverseGeocode.prototype.bbox2Json = function(bbox) {
  return {
    type: "Polygon",
    coordinates: [[
      [bbox.left, bbox.top],
      [bbox.right, bbox.top],
      [bbox.right, bbox.bottom],
      [bbox.left, bbox.bottom],
      [bbox.left, bbox.top]
    ]]
  };
};
ReverseGeocode.prototype.circle2Json = function(circle) {
  return {
    type: "Circle",
    radius: circle.radius,
    coordinates: [circle.x, circle.y]
  };
};
ReverseGeocode.prototype.polygon2Json = function(polygon) {
  var jsonGeom = {
    type: "Polygon",
    coordinates: [[]]
  };
  for (var i = 0; i < polygon.length; ++i) {
    jsonGeom.coordinates[0].push([polygon[i].x, polygon[i].y]);
  }
  return jsonGeom;
};
ReverseGeocode.geoEPSG = ["EPSG:4326"];
var ReverseGeocode_default = ReverseGeocode;

// node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/AutoCompleteResponse.js
function AutoCompleteResponse() {
  if (!(this instanceof AutoCompleteResponse)) {
    throw new TypeError("AutoCompleteResponse constructor cannot be called as a function.");
  }
  this.suggestedLocations = [];
}
AutoCompleteResponse.prototype = {
  constructor: AutoCompleteResponse
};
var AutoCompleteResponse_default = AutoCompleteResponse;

// node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/SuggestedLocation.js
function SuggestedLocation() {
  if (!(this instanceof SuggestedLocation)) {
    throw new TypeError("SuggestedLocation constructor cannot be called as a function.");
  }
  this.type = null;
  this.position = {
    x: null,
    y: null
  };
  this.commune = null;
  this.fullText = null;
  this.postalCode = null;
  this.classification = null;
  this.street = null;
  this.poi = null;
  this.kind = null;
}
SuggestedLocation.prototype = {
  constructor: SuggestedLocation
};
var SuggestedLocation_default = SuggestedLocation;

// node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/AutoCompleteResponseFactory.js
var AutoCompleteResponseFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Alti
   *
   * @example
   *   var options = {
   *      response :
   *      outputFormat :
   *      rawResponse :
   *      scope :
   *      onSuccess :
   *      onError :
   *   };
   *
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("AutoCompleteResponseFactory");
    logger50.trace(["AutoCompleteResponseFactory::build()"]);
    var data = null;
    if (options.response) {
      if (options.rawResponse) {
        logger50.trace("analyze response : raw");
        data = options.response;
      } else {
        var JSONResponse = null;
        if (typeof options.response === "string") {
          JSONResponse = JSON.parse(options.response);
        } else {
          JSONResponse = options.response;
        }
        if (JSONResponse) {
          if (JSONResponse.error) {
            options.onError.call(options.scope, new ErrorService_default({
              message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
              status: JSONResponse.error.code,
              type: ErrorService_default.TYPE_SRVERR
            }));
            return;
          }
          data = new AutoCompleteResponse_default();
          if (JSONResponse.results && Array.isArray(JSONResponse.results)) {
            var suggestedLocation = null;
            for (var i = 0; i < JSONResponse.results.length; i++) {
              var result = JSONResponse.results[i];
              suggestedLocation = new SuggestedLocation_default();
              if (result) {
                if (result.country === "StreetAddress") {
                  suggestedLocation.street = result.street;
                  suggestedLocation.type = "StreetAddress";
                } else if (result.country === "PositionOfInterest") {
                  suggestedLocation.poi = result.street;
                  suggestedLocation.type = "PositionOfInterest";
                  suggestedLocation.poiType = result.poiType;
                }
                if (suggestedLocation.position) {
                  suggestedLocation.position.x = result.x;
                  suggestedLocation.position.y = result.y;
                }
                suggestedLocation.kind = result.kind;
                suggestedLocation.commune = result.city;
                suggestedLocation.fullText = result.fulltext;
                suggestedLocation.postalCode = result.zipcode;
                suggestedLocation.classification = result.classification;
              }
              data.suggestedLocations.push(suggestedLocation);
            }
          } else {
            options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_FORMAT_3")));
            return;
          }
          if (!data.suggestedLocations.length) {
            options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_FORMAT_3")));
            return;
          }
        }
        if (!data) {
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE_2"),
            type: ErrorService_default.TYPE_UNKERR,
            status: -1
          }));
          return;
        }
        if (data.exceptionReport) {
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
            type: ErrorService_default.TYPE_SRVERR,
            status: 200
          }));
          return;
        }
      }
    } else {
      options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
      return;
    }
    options.onSuccess.call(options.scope, data);
  }
};
var AutoCompleteResponseFactory_default = AutoCompleteResponseFactory;

// node_modules/geoportal-access-lib/src/Services/AutoComplete/AutoComplete.js
function AutoComplete(options_) {
  if (!(this instanceof AutoComplete)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "AutoComplete"));
  }
  this.CLASSNAME = "AutoComplete";
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.AutoComplete");
  this.logger.trace("[Constructeur AutoComplete (options)]");
  var options = this.patchOptionConvertor(options_);
  if (!options.serverUrl) {
    options.serverUrl = DefaultUrlService_default.AutoComplete.newUrl();
  }
  CommonService_default.apply(this, arguments);
  if (!options.text) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "text"));
  }
  this.options.text = options.text;
  if (!options.type) {
    options.type = ["StreetAddress,PositionOfInterest"];
  }
  this.options.type = options.type;
  this.options.territory = options.terr || "";
  this.options.maximumResponses = options.maximumResponses || 10;
  if (this.options.protocol === "XHR" && this.options.httpMethod === "POST") {
    this.logger.warn("Le service ne gÃ©re pas le mode d'interrogation en POST, on bascule sur du GET !");
    this.options.httpMethod = "GET";
  }
  this.options.outputFormat = this.options.rawResponse ? "" : "json";
}
AutoComplete.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
AutoComplete.prototype.constructor = AutoComplete;
AutoComplete.prototype.patchOptionConvertor = function(options_) {
  const options = options_;
  if (options.filterOptions) {
    this.logger.warn("The parameter 'filterOptions' is deprecated");
    if (options.filterOptions.type) {
      this.logger.warn("The parameter 'filterOptions.type' is deprecated");
      if (!options.type) {
        options.type = options.filterOptions.type;
      }
    }
    if (options.filterOptions.territory) {
      this.logger.warn("The parameter 'filterOptions.territory' is deprecated");
      if (!options.terr) {
        options.terr = options.filterOptions.territory;
      }
    }
    delete options.filterOptions;
  }
  return options;
};
AutoComplete.prototype.buildRequest = function(error, success) {
  var territory = "";
  if (this.options.territory) {
    territory = this.options.territory;
  }
  var type = "";
  if (this.options.type) {
    type = this.options.type.join(",");
  }
  this.request = Helper_default.normalyzeParameters({
    text: encodeURIComponent(this.options.text),
    type,
    terr: territory,
    maximumResponses: this.options.maximumResponses
  });
  !this.request ? error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_REQUEST_BUILD"))) : success.call(this, this.request);
};
AutoComplete.prototype.analyzeResponse = function(error, success) {
  if (this.response) {
    var options = {
      response: this.response,
      rawResponse: this.options.rawResponse,
      onSuccess: success,
      onError: error,
      scope: this
    };
    AutoCompleteResponseFactory_default.build(options);
  } else {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
var AutoComplete_default = AutoComplete;

// node_modules/geoportal-access-lib/src/Services/Route/Request/model/RouteParamREST.js
function RouteParamREST(options) {
  if (!(this instanceof RouteParamREST)) {
    throw new TypeError("RouteParamREST constructor cannot be called as a function.");
  }
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur RouteParamREST ()]");
  this.options = options || {};
  this.resource = this.options.resource;
  this.start = this.options.startPoint.x + "," + this.options.startPoint.y;
  this.end = this.options.endPoint.x + "," + this.options.endPoint.y;
  this.intermediates = this.options.viaPoints;
  this.profile = this.options.graph;
  this.crs = this.options.srs;
  this.constraints = this.options.constraints;
  this.optimization = this.options.routePreference;
  this.getSteps = this.options.geometryInInstructions ? "true" : "false";
  this.distanceUnit = this.options.distanceUnit;
  this.timeUnit = this.options.timeUnit;
  this.waysAttributes = this.options.waysAttributes;
}
RouteParamREST.CLASSNAME = "RouteParamREST";
RouteParamREST.prototype = {
  /**
   * @lends module:RouteParamREST#
   */
  /**
   * Constructeur (alias)
   */
  constructor: RouteParamREST,
  /**
   * Retourne une liste de points
   * @returns {String} une liste de points (sep '|')
   */
  getIntermediates: function() {
    var array = [];
    if (this.intermediates.length !== 0) {
      for (var i = 0; i < this.intermediates.length; i++) {
        var obj = this.intermediates[i];
        array.push(obj.x + "," + obj.y);
      }
    }
    return array.join("|");
  },
  /**
   * Retourne une liste d'attributs
   * @returns {String} une liste d'attributs (sep '|')
   */
  getWaysAttributes: function() {
    return this.waysAttributes.join("|");
  },
  /**
   * Retourne un profile
   * @returns {String} profile
   */
  getProfile: function() {
    return this.profile;
  },
  /**
   * Retourne un distanceUnit
   * @returns {String} distanceUnit
   */
  getDistanceUnit: function() {
    if (this.distanceUnit === "m") {
      return "meter";
    }
    if (this.distanceUnit === "km") {
      return "kilometer";
    }
    return "";
  },
  /**
   * Retourne une optimisation
   * @returns {String} optimization
   */
  getOptimization: function() {
    if (this.optimization) {
      return this.optimization;
    } else {
      return "";
    }
  },
  /**
   * Retourne la liste des constraints
   * @returns {String} une liste des constraints (sep '|')
   */
  getConstraints: function() {
    var constraintArray = [];
    if (this.constraints.length !== 0) {
      for (var k3 = 0; k3 < this.constraints.length; k3++) {
        constraintArray.push(JSON.stringify(this.constraints[k3]));
      }
    }
    return constraintArray.join("|");
  }
};
RouteParamREST.prototype.getParams = function() {
  var map = [];
  map.push({
    k: "resource",
    v: this.resource
  });
  map.push({
    k: "start",
    v: this.start
  });
  map.push({
    k: "end",
    v: this.end
  });
  map.push({
    k: "geometryFormat",
    v: "geojson"
  });
  if (this.optimization) {
    map.push({
      k: "optimization",
      v: this.getOptimization()
    });
  }
  if (this.intermediates) {
    map.push({
      k: "intermediates",
      v: this.getIntermediates()
    });
  }
  if (this.profile) {
    map.push({
      k: "profile",
      v: this.getProfile()
    });
  }
  if (this.constraints) {
    map.push({
      k: "constraints",
      v: this.getConstraints()
    });
  }
  if (this.crs) {
    map.push({
      k: "crs",
      v: this.crs
    });
  }
  if (this.distanceUnit) {
    map.push({
      k: "distanceUnit",
      v: this.getDistanceUnit()
    });
  }
  if (this.timeUnit) {
    map.push({
      k: "timeUnit",
      v: this.timeUnit
    });
  }
  if (this.waysAttributes) {
    map.push({
      k: "waysAttributes",
      v: this.getWaysAttributes()
    });
  }
  return map;
};
var RouteParamREST_default = RouteParamREST;

// node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestREST.js
function RouteRequestREST(options) {
  this.logger = LoggerByDefault_default.getLogger("RouteRequestREST");
  this.logger.trace("[Constructeur RouteRequestREST ()]");
  if (!(this instanceof RouteRequestREST)) {
    throw new TypeError("RouteRequestREST constructor cannot be called as a function.");
  }
  if (!options) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "options"));
  }
  this.settings = options;
}
RouteRequestREST.prototype = {
  /**
   * @lends module:RouteRequestREST#
   */
  /**
   * request
   * @type {String}
   */
  requestString: null,
  /**
   * Constructeur (alias)
   */
  constructor: RouteRequestREST,
  /**
   * Construction de la requÃªte.
   *
   * @example
   * // GET  out : origin=2.416907353809513,48.8465772142297&destination=2.4248037771493673,48.84591353161838
   * // POST out : Not yet supported method POST !
   * @returns {String} request
   */
  processRequestString: function() {
    this.logger.warn(" PROTOTYPE !");
    var oParams = new RouteParamREST_default(this.settings);
    var params2 = oParams.getParams();
    var request = "";
    for (var i = 0; i < params2.length; i++) {
      var o = params2[i];
      if (request) {
        request += "&";
      }
      request += o.k + "=" + o.v;
    }
    this.logger.trace(request);
    this.requestString = request;
    return this.requestString;
  }
};
var RouteRequestREST_default = RouteRequestREST;

// node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestFactory.js
var RouteRequestFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Route
   *
   * @example
   *   // utilisation avec les callback
   *   var options = {
   *      (...)
   *      onSuccess : function (response) {},
   *      onError : function (error) {},
   *      // spÃ©cifique au service
   *      startPoint : {
   *          x : 42.1121,
   *          y : 1.5557
   *      },
   *      endPoint : {
   *          x : 42.1121,
   *          y : 1.5557
   *      },
   *      provideBbox : false,
   *      exclusions : ["bridge", "tunnel", "toll"],
   *      distanceUnit : "km",
   *      graph : "Voiture",
   *      geometryInInstructions : false,
   *      routePreference : "fastest"
   *   };
   *   RouteRequestFactory.build(options);
   *
   *   // utilisation sans callback
   *   var options = {...};
   *   try {
   *      var result = RouteRequestFactory.build(options);
   *      if (! result) { throw new Error("..."):}
   *   } catch (e) {
   *      // todo
   *   }
   * @returns {String} request
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("RouteRequestFactory");
    logger50.trace(["RouteRequestFactory::build()"]);
    var request = null;
    var settings = options || {};
    var bOnError = !!(options.onError !== null && typeof options.onError === "function");
    var message = null;
    var myReq = new RouteRequestREST_default(settings);
    if (!myReq.processRequestString()) {
      message = "Error process request (rest) !";
      if (bOnError) {
        options.onError.call(options.scope, new ErrorService_default(message));
        return;
      }
      throw new Error(message);
    }
    request = myReq.requestString;
    return request;
  }
};
var RouteRequestFactory_default = RouteRequestFactory;

// node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteResponse.js
function RouteResponse() {
  if (!(this instanceof RouteResponse)) {
    throw new TypeError("RouteResponse constructor cannot be called as a function.");
  }
  this.totalTime = null;
  this.totalDistance = null;
  this.bbox = {
    left: null,
    right: null,
    top: null,
    bottom: null
  };
  this.routeGeometry = null;
  this.routeInstructions = [];
}
RouteResponse.prototype = {
  constructor: RouteResponse
};
var RouteResponse_default = RouteResponse;

// node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteInstruction.js
function RouteInstruction() {
  if (!(this instanceof RouteInstruction)) {
    throw new TypeError("RouteInstruction constructor cannot be called as a function.");
  }
  this.duration = null;
  this.distance = null;
  this.code = null;
  this.instruction = null;
  this.geometry = null;
}
RouteInstruction.prototype = {
  constructor: RouteInstruction
};
var RouteInstruction_default = RouteInstruction;

// node_modules/geoportal-access-lib/src/Services/Route/Response/RouteResponseFactory.js
var RouteResponseFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant Route
   *
   * @example
   *   var options = {
   *      response :
   *      outputFormat :
   *      rawResponse :
   *      scope :
   *      onSuccess :
   *      onError :
   *   };
   *
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("RouteResponseFactory");
    logger50.trace("RouteResponseFactory::build()");
    var data = null;
    if (options.response) {
      if (options.rawResponse) {
        logger50.trace("analyze response : raw");
        data = options.response;
      } else {
        logger50.trace("analyze response : json");
        var JSONResponse;
        if (typeof options.response === "string") {
          JSONResponse = JSON.parse(options.response);
        } else {
          JSONResponse = options.response;
        }
        if (JSONResponse) {
          if (JSONResponse.message) {
            options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.message)));
            return;
          }
          var legs = [];
          var legSteps = [];
          var steps = [];
          data = new RouteResponse_default();
          if (data.hasOwnProperty("totalTime")) {
            data.totalTime = parseFloat(JSONResponse.duration);
          }
          if (data.hasOwnProperty("totalDistance")) {
            data.totalDistance = parseFloat(JSONResponse.distance);
          }
          if (data.hasOwnProperty("bbox")) {
            data.bbox.left = parseFloat(JSONResponse.bbox[0]);
            data.bbox.bottom = parseFloat(JSONResponse.bbox[1]);
            data.bbox.right = parseFloat(JSONResponse.bbox[2]);
            data.bbox.top = parseFloat(JSONResponse.bbox[3]);
          }
          if (data.hasOwnProperty("routeGeometry") && !options.geometryInInstructions) {
            data.routeGeometry = JSONResponse.geometry;
          }
          if (data.hasOwnProperty("routeInstructions") && options.geometryInInstructions) {
            var legList = JSONResponse.portions;
            var i;
            if (Array.isArray(legList) && legList.length) {
              for (i = 0; i < legList.length; i++) {
                legs.push(legList[i]);
              }
            }
            if (legs.length) {
              for (i = 0; i < legs.length; i++) {
                legSteps.push(legs[i].steps);
              }
            }
            if (legSteps.length) {
              for (i = 0; i < legSteps.length; i++) {
                steps = steps.concat(legSteps[i]);
              }
            }
            steps.forEach(function(step) {
              data.routeInstructions.push(new RouteInstruction_default());
              data.routeInstructions[data.routeInstructions.length - 1].duration = step.duration;
              data.routeInstructions[data.routeInstructions.length - 1].distance = step.distance;
              data.routeInstructions[data.routeInstructions.length - 1].code = "";
              data.routeInstructions[data.routeInstructions.length - 1].instruction = "";
              data.routeInstructions[data.routeInstructions.length - 1].geometry = step.geometry;
              if (step.name === "Valeur non renseignÃ©e") {
                step.name = "";
              }
              switch (step.instruction.type) {
                case "turn":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Tourner";
                  break;
                case "new name":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer tout droit";
                  break;
                case "depart":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "DÃ©part";
                  break;
                case "arrive":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "ArrivÃ©e";
                  break;
                case "merge":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Rejoindre";
                  break;
                case "ramp":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                  break;
                case "on ramp":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                  break;
                case "off ramp":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la sortie";
                  break;
                case "fork":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Sur la bifurcation, prendre";
                  break;
                case "end of road":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Ã€ la fin de la route, prendre";
                  break;
                case "use lane":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Utiliser la file";
                  break;
                case "continue":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer";
                  break;
                case "roundabout":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                  break;
                case "rotary":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                  break;
                case "roundabout turn":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond point, tourner";
                  break;
                case "notification":
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "";
                  break;
                default:
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += "?" + step.instruction.type + "?";
                  break;
              }
              if (step.instruction.modifier) {
                switch (step.instruction.modifier) {
                  case "uturn":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction = "Faire demi-tour";
                    break;
                  case "sharp right":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " complÃ¨tement Ã  droite";
                    break;
                  case "right":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " Ã  droite";
                    break;
                  case "slight right":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " lÃ©gÃ¨rement Ã  droite";
                    break;
                  case "straight":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction = "Continuer tout droit";
                    break;
                  case "slight left":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " lÃ¨gÃ¨rement Ã  gauche";
                    break;
                  case "left":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " Ã  gauche";
                    break;
                  case "sharp left":
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " complÃ¨tement Ã  gauche";
                    break;
                  default:
                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " ?" + step.instruction.modifier + "?";
                    break;
                }
              }
              if (step.instruction.exit) {
                data.routeInstructions[data.routeInstructions.length - 1].instruction += `${step.instruction.exit}e sortie`;
              }
              if (step.attributes.name) {
                if (step.attributes.name.nom_1_droite || step.attributes.name.toponyme) {
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += " sur";
                }
                if (step.attributes.name.nom_1_droite) {
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.nom_1_droite}`;
                }
                if (step.attributes.name.toponyme) {
                  data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.toponyme}`;
                }
              }
            });
          }
        }
        if (!data) {
          options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE", "json")));
          return;
        }
        if (data.exceptionReport) {
          options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION_2")));
          return;
        }
      }
    } else {
      options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
      return;
    }
    options.onSuccess.call(options.scope, data);
  }
};
var RouteResponseFactory_default = RouteResponseFactory;

// node_modules/geoportal-access-lib/src/Services/Route/Route.js
function Route(options) {
  if (!(this instanceof Route)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "Route"));
  }
  this.CLASSNAME = "Route";
  CommonService_default.apply(this, arguments);
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.Route");
  this.logger.trace("[Constructeur Route (options)]");
  if (!options.startPoint) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "startPoint"));
  }
  if (options.startPoint.x === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "startPoint.x"));
  }
  if (options.startPoint.y === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "startPoint.y"));
  }
  if (!options.endPoint) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "endPoint"));
  }
  if (options.endPoint.x === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "endPoint.x"));
  }
  if (options.endPoint.y === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "endPoint.y"));
  }
  if (options.outputFormat && options.outputFormat !== "json") {
    this.logger.warn("options.outputFormat could only be json");
  }
  this.options.outputFormat = "json";
  this.options.resource = options.resource || "bdtopo-osrm";
  this.options.startPoint = options.startPoint;
  this.options.endPoint = options.endPoint;
  this.options.viaPoints = options.viaPoints || [];
  this.options.routePreference = options.routePreference || "fastest";
  if (options.graph) {
    if (options.graph === "Voiture") {
      this.options.graph = "car";
    }
    if (options.graph === "Pieton") {
      this.options.graph = "pedestrian";
    }
  } else {
    this.options.graph = "car";
  }
  this.options.constraints = [];
  if (options.constraints) {
    if (Array.isArray(options.constraints)) {
      for (var k3 = 0; k3 < options.constraints.length; k3++) {
        this.options.constraints.push(options.constraints[k3]);
      }
    } else {
      throw new Error(MessagesResources_default.getMessage("PARAM_TYPE", "constraints"));
    }
  }
  var constraintTunnel = {};
  var constraintPont = {};
  var constraintAutoroute = {};
  if (options.exclusions) {
    if (options.exclusions.length !== 0) {
      this.logger.warn("options.exclusions is DEPRECATED !!");
      for (var c = 0; c < options.exclusions.length; c++) {
        if (typeof options.exclusions[c] === "string") {
          options.exclusions[c] = options.exclusions[c].toLowerCase();
        } else {
          continue;
        }
        if (options.exclusions[c] === "toll") {
          constraintAutoroute.constraintType = "banned";
          constraintAutoroute.key = "wayType";
          constraintAutoroute.operator = "=";
          constraintAutoroute.value = "autoroute";
          this.options.constraints.push(constraintAutoroute);
        }
        if (options.exclusions[c] === "tunnel") {
          constraintTunnel.constraintType = "banned";
          constraintTunnel.key = "wayType";
          constraintTunnel.operator = "=";
          constraintTunnel.value = "tunnel";
          this.options.constraints.push(constraintTunnel);
        }
        if (options.exclusions[c] === "bridge") {
          constraintPont.constraintType = "banned";
          constraintPont.key = "wayType";
          constraintPont.operator = "=";
          constraintPont.value = "pont";
          this.options.constraints.push(constraintPont);
        }
      }
    }
  }
  this.options.geometryInInstructions = options.geometryInInstructions || false;
  this.options.provideBbox = options.provideBbox || true;
  this.options.distanceUnit = options.distanceUnit || "m";
  this.options.timeUnit = options.timeUnit || "second";
  this.options.expectedStartTime = null;
  this.options.srs = options.srs || "EPSG:4326";
  this.options.waysAttributes = options.waysAttributes || [];
  if (!this.options.serverUrl) {
    var UrlByDefault = DefaultUrlService_default.Route.newUrl();
    if (!UrlByDefault) {
      throw new Error("Url by default not found !");
    }
    this.options.serverUrl = UrlByDefault;
    this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
  }
}
Route.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
Route.prototype.constructor = Route;
Route.prototype.buildRequest = function(error, success) {
  var options = {
    // spÃ©cifique au service
    resource: this.options.resource,
    startPoint: this.options.startPoint,
    endPoint: this.options.endPoint,
    viaPoints: this.options.viaPoints,
    provideBbox: this.options.provideBbox,
    constraints: this.options.constraints,
    distanceUnit: this.options.distanceUnit,
    timeUnit: this.options.timeUnit,
    graph: this.options.graph,
    geometryInInstructions: this.options.geometryInInstructions,
    routePreference: this.options.routePreference,
    srs: this.options.srs,
    waysAttributes: this.options.waysAttributes
  };
  this.request = RouteRequestFactory_default.build(options);
  if (!this.request) {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_REQUEST_BUILD")));
  } else {
    success.call(this, this.request);
  }
};
Route.prototype.analyzeResponse = function(error, success) {
  if (this.response) {
    var options = {
      distanceUnit: this.options.distanceUnit,
      timeUnit: this.options.timeUnit,
      response: this.response,
      outputFormat: this.options.outputFormat,
      // utile pour parser la string en mode XHR : JSON ou XML !
      rawResponse: this.options.rawResponse,
      onError: error,
      onSuccess: success,
      scope: this,
      geometryInInstructions: this.options.geometryInInstructions
    };
    RouteResponseFactory_default.build(options);
  } else {
    error.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
var Route_default = Route;

// node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/model/ProcessIsoCurveParam.js
function ProcessIsoCurveParam(options) {
  if (!(this instanceof ProcessIsoCurveParam)) {
    throw new TypeError("ProcessIsoCurveParam constructor cannot be called as a function.");
  }
  this.logger = LoggerByDefault_default.getLogger();
  this.logger.trace("[Constructeur ProcessIsoCurveParam ()]");
  this.options = options || {};
  this.id = this.options.id;
  this.resource = this.options.resource;
  this.point = this.options.position;
  this.crs = this.options.srs;
  this.profile = this.options.graph;
  this.constraints = this.options.constraints;
  this.reverse = this.options.reverse;
  this.timeUnit = this.options.timeUnit;
  this.distanceUnit = this.options.distanceUnit;
  if (this.options.method === "distance") {
    this.costType = "distance";
    this.costValue = this.options.distance;
    if (this.distanceUnit === "m" && this.costValue >= 5e4) {
      this.distanceUnit = "km";
      this.costValue /= 1e3;
    }
  } else {
    this.costType = "time";
    this.costValue = this.options.time;
  }
}
ProcessIsoCurveParam.CLASSNAME = "ProcessIsoCurveParam";
ProcessIsoCurveParam.prototype = {
  /**
   * @lends module:ProcessIsoCurveParam#
   */
  /**
   * Constructeur (alias)
   */
  constructor: ProcessIsoCurveParam,
  /**
   * Retourne le point
   * @returns {String} x,y
   */
  getLocation: function() {
    return this.point.x + "," + this.point.y;
  },
  /**
   * Retourne l'unitÃ© de la distance
   * @returns {String}
   */
  getDistanceUnit: function() {
    if (this.distanceUnit === "m") {
      return "meter";
    }
    if (this.distanceUnit === "km") {
      return "kilometer";
    }
    return "";
  },
  /**
   * Retourne la liste des contraintes
   * @returns {String}
   */
  getConstraints: function() {
    var constraintArray = [];
    if (this.constraints.length !== 0) {
      for (var k3 = 0; k3 < this.constraints.length; k3++) {
        constraintArray.push(JSON.stringify(this.constraints[k3]));
      }
    }
    return constraintArray.join("|");
  },
  /**
   * Retourne la direction
   * @returns {String}
   */
  getDirection: function() {
    if (this.reverse) {
      return "arrival";
    } else {
      return "departure";
    }
  }
};
ProcessIsoCurveParam.prototype.getParams = function() {
  var map = [];
  map.push({
    k: "resource",
    v: this.resource
  });
  map.push({
    k: "point",
    v: this.getLocation()
  });
  map.push({
    k: "direction",
    v: this.getDirection()
  });
  map.push({
    k: "costType",
    v: this.costType
  });
  map.push({
    k: "costValue",
    v: this.costValue
  });
  map.push({
    k: "profile",
    v: this.profile
  });
  map.push({
    k: "timeUnit",
    v: this.timeUnit
  });
  map.push({
    k: "distanceUnit",
    v: this.getDistanceUnit()
  });
  if (this.crs) {
    map.push({
      k: "crs",
      v: this.crs
    });
  }
  if (this.constraints) {
    map.push({
      k: "constraints",
      v: this.getConstraints()
    });
  }
  return map;
};
var ProcessIsoCurveParam_default = ProcessIsoCurveParam;

// node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/ProcessIsoCurveRequest.js
function ProcessIsoCurveRequest(options) {
  this.logger = LoggerByDefault_default.getLogger("ProcessIsoCurveRequest");
  this.logger.trace("[Constructeur ProcessIsoCurveRequest ()]");
  if (!(this instanceof ProcessIsoCurveRequest)) {
    throw new TypeError("ProcessIsoCurveRequest constructor cannot be called as a function.");
  }
  if (!options) {
    throw new Error(MessagesResources_default.getMessage("PARAM_EMPTY", "options"));
  }
  this.settings = options;
  this.mode = this.settings.httpMethod || "GET";
}
ProcessIsoCurveRequest.prototype = {
  /**
   * @lends module:ProcessIsoCurveRequest#
   */
  /**
   * RequÃªte
   * @type {String}
   */
  requestString: null,
  /**
   * Constructeur (alias)
   */
  constructor: ProcessIsoCurveRequest,
  /**
   * Construction de la requÃªte.
   *
   * @example
   * // GET  out :
   *   //  (http://wxs.ign.fr/KEY/isochrone?)
   *   //  resource=&
   *   //  point=&
   *   //  costValue=&
   *   //  costType=&
   *   //  profile=&
   *   //  constraints=&
   *   //  direction=&
   *   //  crs=
   *
   * // POST out :
   * {
   *  resource: "bduni-idf-pgr",
   *  point: "2.337306,48.849319",
   *  costValue: 100,
   *  costType: "time",
   *  profile: "car",
   *  constraints: [{
   *      constraintType: "banned",
   *      key: "ways_type",
   *      operator: "=",
   *      value: "autoroute"
   *  }]
   * }
   *
   * @returns {String} request
   */
  processRequestString: function() {
    var request = "";
    var i = 0;
    switch (this.mode) {
      case "GET":
        this.logger.trace("Process GET Request");
        var oParams = new ProcessIsoCurveParam_default(this.settings);
        var params2 = oParams.getParams();
        for (i = 0; i < params2.length; i++) {
          var o = params2[i];
          if (request) {
            request += "&";
          }
          request += o.k + "=" + o.v;
        }
        break;
      case "POST":
        this.logger.trace("Process POST Request");
        var postRequest = {};
        postRequest.resource = this.settings.resource;
        postRequest.point = this.settings.position.x + "," + this.settings.position.y;
        if (this.settings.method === "distance") {
          postRequest.costType = "distance";
          postRequest.costValue = this.settings.distance;
        } else {
          postRequest.costType = "time";
          postRequest.costValue = this.settings.time;
        }
        postRequest.profile = this.settings.graph;
        if (this.settings.reverse) {
          postRequest.direction = "arrival";
        } else {
          postRequest.direction = "departure";
        }
        postRequest.constraints = this.settings.constraints;
        postRequest.distanceUnit = this.settings.distanceUnit;
        postRequest.timeUnit = this.settings.timeUnit;
        postRequest.crs = this.settings.srs;
        request = JSON.stringify(postRequest);
        break;
      default:
        this.logger.error("No other HTTP method supported by the service !");
    }
    this.logger.trace(request);
    this.requestString = request;
    return this.requestString;
  }
};
var ProcessIsoCurveRequest_default = ProcessIsoCurveRequest;

// node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse.js
function ProcessIsoCurveResponse() {
  if (!(this instanceof ProcessIsoCurveResponse)) {
    throw new TypeError("ProcessIsoCurveResponse constructor cannot be called as a function.");
  }
  this.message = null;
  this.id = null;
  this.location = {};
  this.location.x = null;
  this.location.y = null;
  this.srs = null;
  this.geometry = null;
  this.time = null;
  this.distance = null;
}
ProcessIsoCurveResponse.prototype = {
  constructor: ProcessIsoCurveResponse
};
var ProcessIsoCurveResponse_default = ProcessIsoCurveResponse;

// node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/ProcessIsoCurveResponseFactory.js
var ProcessIsoCurveResponseFactory = {
  /**
   * interface unique
   *
   * @method build
   * @static
   * @param {Object} options - options definies dans le composant ProcessIsoCurve
   *
   * @example
   *   var options = {
   *      response :
   *      outputFormat :
   *      rawResponse :
   *      scope :
   *      onSuccess :
   *      onError :
   *   };
   *
   */
  build: function(options) {
    var logger50 = LoggerByDefault_default.getLogger("ProcessIsoCurveResponseFactory");
    logger50.trace(["ProcessIsoCurveResponseFactory::build()"]);
    var data = null;
    if (options.response) {
      if (options.rawResponse) {
        logger50.trace("analyze response : raw");
        data = options.response;
      } else {
        logger50.trace("analyze response : json");
        var JSONResponse;
        if (typeof options.response === "string") {
          JSONResponse = JSON.parse(options.response);
        } else {
          JSONResponse = options.response;
        }
        data = new ProcessIsoCurveResponse_default();
        if (JSONResponse) {
          if (JSONResponse.costType === "distance") {
            data.time = "";
            data.distance = JSONResponse.costValue;
          } else {
            data.time = JSONResponse.costValue;
            data.distance = "";
          }
          data.message = "";
          data.id = "";
          data.srs = JSONResponse.crs;
          data.geometry = JSONResponse.geometry;
          var coords = JSONResponse.point.split(",");
          if (data.location) {
            data.location.x = coords[0];
            data.location.y = coords[1];
          }
        } else {
          options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_ANALYSE", options.response)));
          return;
        }
        if (data.exceptionReport) {
          options.onError.call(options.scope, new ErrorService_default({
            message: MessagesResources_default.getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
            type: ErrorService_default.TYPE_SRVERR,
            status: 200
          }));
          return;
        }
      }
    } else {
      options.onError.call(options.scope, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
      return;
    }
    options.onSuccess.call(options.scope, data);
  }
};
var ProcessIsoCurveResponseFactory_default = ProcessIsoCurveResponseFactory;

// node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/ProcessIsoCurve.js
function ProcessIsoCurve(options) {
  if (!(this instanceof ProcessIsoCurve)) {
    throw new TypeError(MessagesResources_default.getMessage("CLASS_CONSTRUCTOR", "ProcessIsoCurve"));
  }
  this.CLASSNAME = "ProcessIsoCurve";
  CommonService_default.apply(this, arguments);
  this.logger = LoggerByDefault_default.getLogger("Gp.Services.ProcessIsoCurve");
  this.logger.trace("[Constructeur ProcessIsoCurve (options)]");
  if (!options.position) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "position"));
  }
  if (options.position.x === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "position.x"));
  }
  if (options.position.y === null) {
    throw new Error(MessagesResources_default.getMessage("PARAM_MISSING", "position.y"));
  }
  if (!options.time && !options.distance) {
    throw new Error("Parameter (s) 'distance' missing. Parameter time to calculate an isochrone, parameter distance for an isodistance");
  }
  if (!options.time && options.distance) {
    this.options.method = "distance";
    if (this.options.time) {
      delete this.options.time;
    }
  }
  if (options.time && !options.distance) {
    this.options.method = "time";
    if (this.options.distance) {
      delete this.options.distance;
    }
  }
  this.options.method = this.options.method || "time";
  this.options.resource = options.resource || "bdtopo-valhalla";
  this.options.exclusions = options.exclusions || [];
  this.options.reverse = options.reverse || false;
  this.options.srs = options.srs || "EPSG:4326";
  this.options.distanceUnit = options.distanceUnit || "m";
  this.options.timeUnit = options.timeUnit || "second";
  if (options.smoothing) {
    this.logger.warn("options.smoothing is DEPRECATED");
  }
  this.options.smoothing = false;
  if (options.holes) {
    this.logger.warn("options.holes is DEPRECATED");
  }
  this.options.holes = false;
  if (options.graph) {
    if (options.graph === "Voiture") {
      this.options.graph = "car";
    }
    if (options.graph === "Pieton") {
      this.options.graph = "pedestrian";
    }
  } else {
    this.options.graph = "car";
  }
  this.options.constraints = [];
  if (options.constraints) {
    if (Array.isArray(options.constraints)) {
      for (var k3 = 0; k3 < options.constraints.length; k3++) {
        this.options.constraints.push(options.constraints[k3]);
      }
    } else {
      throw new Error(MessagesResources_default.getMessage("PARAM_TYPE", "constraints"));
    }
  }
  var constraintTunnel = {};
  var constraintPont = {};
  var constraintAutoroute = {};
  if (options.exclusions) {
    if (options.exclusions.length !== 0) {
      this.logger.warn("options.exclusions is DEPRECATED !!");
      for (var c = 0; c < options.exclusions.length; c++) {
        if (typeof options.exclusions[c] === "string") {
          options.exclusions[c] = options.exclusions[c].toLowerCase();
        } else {
          continue;
        }
        if (options.exclusions[c] === "toll") {
          constraintAutoroute.constraintType = "banned";
          constraintAutoroute.key = "wayType";
          constraintAutoroute.operator = "=";
          constraintAutoroute.value = "autoroute";
          this.options.constraints.push(constraintAutoroute);
        }
        if (options.exclusions[c] === "tunnel") {
          constraintTunnel.constraintType = "banned";
          constraintTunnel.key = "wayType";
          constraintTunnel.operator = "=";
          constraintTunnel.value = "tunnel";
          this.options.constraints.push(constraintTunnel);
        }
        if (options.exclusions[c] === "bridge") {
          constraintPont.constraintType = "banned";
          constraintPont.key = "wayType";
          constraintPont.operator = "=";
          constraintPont.value = "pont";
          this.options.constraints.push(constraintPont);
        }
      }
    }
  }
  this.options.outputFormat = typeof options.outputFormat === "string" ? options.outputFormat.toLowerCase() : "json";
  if (options.outputFormat && options.outputFormat !== "json") {
    throw new Error(MessagesResources_default.getMessage("PARAM_NOT_SUPPORT", "outputFormat"));
  }
  this.options.outputFormat = "json";
  if (!this.options.serverUrl) {
    var urlFound = DefaultUrlService_default.ProcessIsoCurve.newUrl();
    if (!urlFound) {
      throw new Error("Url by default not found !");
    }
    this.options.serverUrl = urlFound;
    this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
  }
}
ProcessIsoCurve.prototype = Object.create(CommonService_default.prototype, {
  // todo
  // getter/setter
});
ProcessIsoCurve.prototype.constructor = ProcessIsoCurve;
ProcessIsoCurve.prototype.buildRequest = function(error, success) {
  try {
    var oIsoCurve = new ProcessIsoCurveRequest_default(this.options);
    if (!oIsoCurve.processRequestString()) {
      throw new Error(MessagesResources_default.getMessage("SERVICE_REQUEST_BUILD"));
    }
    this.request = oIsoCurve.requestString;
  } catch (e) {
    error.call(this, new ErrorService_default(e.message));
    return;
  }
  success.call(this, this.request);
};
ProcessIsoCurve.prototype.analyzeResponse = function(onError, onSuccess) {
  if (this.response) {
    var options = {
      response: this.response,
      outputFormat: this.options.outputFormat,
      rawResponse: this.options.rawResponse,
      onSuccess,
      onError,
      scope: this
    };
    ProcessIsoCurveResponseFactory_default.build(options);
  } else {
    onError.call(this, new ErrorService_default(MessagesResources_default.getMessage("SERVICE_RESPONSE_EMPTY")));
  }
};
var ProcessIsoCurve_default = ProcessIsoCurve;

// node_modules/geoportal-access-lib/src/Services/Services.js
var Services = {
  /**
   * Access to Geoportal resources metadata availables with one ore several keys
   *
   * @method getConfig
   * @param {Object} options - Options for function call.
   * @param {String} [options.apiKey] - Access key(s) ("," as separator, no spaces) to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}
   * @param {String} [options.customConfigFile] - path to a local config file. Overload the apiKey parameter
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GetConfigResponse} object as a parameter except if "rawResponse" parameter is set to true : a String will be returned.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   */
  getConfig: function(options) {
    var configService = new Config_default(options);
    configService.call();
  },
  /**
   * Getting elevations in or along of one or several points on french territories using the [elevation services of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/alti.html}.<br/>
   * Two use cases are availables :<br/>
   * 1. getting elevations of the given points : don't use the options.sampling parameter ;<br/>
   * 2. getting a regular set of elevations along the given points : use the options.sampling parameter.
   *
   * @method getAltitude
   * @param {Object} options - Options for function call.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {Array.<Object>} options.positions - Array of positions ({lon:float, lat:float}) expressed in CRS:84 coordinates system, where to get elevations. 50 positions maximum may be given. 2 positions minimum are required if you use the options.sampling parameter.
   * @param {Number} [options.sampling] - Number of points to use (between 2 and 5000) in order to compute an elevation path. The points given with the options.positions parameter are used to fix the planimetric path along which the elevations will be computed.<br/>
   * If not used, only elevations of these positions will be returned.
   * @param {Boolean} [options.zonly=false] - Set this parameter to true if you only want to have elevations returned without corresponding coordinates.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AltiResponse} object as a parameter, except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.serverUrl=https://data.geopf.fr/altimetrie/1.0/calcul/alti/rest/elevation.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   * @param {String} [options.api='REST'] - What API to use for interacting with underlying web service : 'REST'. Only use if you know what you are doing.
   * @param {String} [options.outputFormat='xml'] - Output format for underlying web service response : 'xml' or 'json'. Only use if you know what you are doing.
   */
  getAltitude: function(options) {
    var altiService = new Alti_default(options);
    altiService.call();
  },
  /**
   * Getting positon of a geographic identifier (places names, address, cadastral parcel, other...) using the [geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage.html}.
   *
   * @example
   * Gp.Services.geocode ({
   *     apiKey : "carte",
   *     location : "73 avenue de Paris, Saint-MandÃ©",
   *     // traitement des resultats
   *     onSuccess  : function (result) {
   *         console.log("found (x:"+result.position.x+", y:"+result.position.y+")") ;
   *     }
   * }) ;
   *
   *
   * @method geocode
   * @param {Object} options - Options for function call.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {String} [options.index="StreetAddress"] - Geographical identifier type to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search, "location" for a multi-index search on "StreetAddress" and "PositionOfInterest". Default is "StreetAddress".
   * @param {String} options.query - Geographic identifier to locate.
   * @param {Object} [options.filters] - Additional filters to apply to search. The following properties may be given.
   *      @param {String} [options.filters.[prop]] - Additionnal properties to filter search. Properties depends on options.index, and values type should be "String".
   *      <br/><br/>
   *      Properties availables for address search :<br/>
   *      "postalCode", "inseeCode" and "city".
   *      <br/><br/>
   *      Properties availables for place names search :<br/>
   *      "postalCode", "inseeCode" and "type".
   *      <br/><br/>
   *      Properties availables for cadastral parcels search :<br/>
   *      "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
   * @param {Number} [options.maximumResponses=20] - Maximum number of responses. Default underlying service value applies (20) if not provided.
   * @param {Boolean} [options.returnTrueGeometry=false] - Set this parameter to true if you wish to have the true geometrie returned.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.serverUrl=http (s)://data.geopf.fr/geocodage/search] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   */
  geocode: function(options) {
    var geocodeService = new Geocode_default(options);
    geocodeService.call();
  },
  /**
   * Retrieving geographical identifiers (place names, address, cadastral parcels, ...) near a given position, using the [reverse geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage-inverse.html}.
   *
   * @method reverseGeocode
   * @param {Object} options - Options for function call.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {String} [options.index="StreetAddress"] - Geographical identifier type to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search, "location" for a multi-index search on "StreetAddress" and "PositionOfInterest". Default is "StreetAddress".
   * @param {Object} options.position - Reference position where to search geographical identifiers.
   *      @param {Float} options.position.lon - Longitude
   *      @param {Float} options.position.lat - Latitude
   * @param {Object} [options.filters] - Additional filters to apply to search. The following properties may be given.
   *      @param {String} [options.filters.[prop]] - Additionnal properties to filter search. Properties depends on options.index, and values type should be "String".
   *      <br/><br/>
   *      Properties availables for address search :<br/>
   *      "postalCode", "inseeCode" and "city".
   *      <br/><br/>
   *      Properties availables for place names search :<br/>
   *      "postalCode", "inseeCode" and "type".
   *      <br/><br/>
   *      Properties availables for cadastral parcels search :<br/>
   *      "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
   * @param {Object} [options.searchGeometry] - Location where to perform the search.
   *      @param {String} options.searchGeometry.type - Geometry type (Point|Circle|Linestring|Polygon)
   *      @param {Array.<Float>|Array.Array.<Float>} options.searchGeometry.coordinates - Coordinates
   *      @param {Float} [options.searchGeometry.radius] - Radius (only for type 'Circle')
   * @param {Number} [options.maximumResponses=20] - Maximum number of responses. Default underlying service value applies (20) if not provided.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.serverUrl=https://data.geopf.fr/geocodage/reverse] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   */
  reverseGeocode: function(options) {
    var reverseGeocodeService = new ReverseGeocode_default(options);
    reverseGeocodeService.call();
  },
  /**
   * Getting suggestions of probable places names or address based on uncomplete texts, using the [autocompletion service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/autocompletion.html}
   *
   * @method autoComplete
   * @param {Object} options - Options for function call.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {String} options.text - Text input to complete.
   * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Suggestion types to provide : address ("StreetAddress") and/or place name ("PositionOfInterest").
   * @param {Array.<String>} [options.filterOptions.territory] - Places where to limit the search of suggestions : "METROPOLE" (Corsica and metropolitan France), "DOMTOM" (French overseas departments and territories), or an INSEE code of a department. No limitation by default. For instance : ['METROPOLE', '31']
   * @param {Number} [options.maximumResponses = 10] - Maximum number of responses.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AutoCompleteResponse} object as a parameter except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.serverUrl=https://data.geopf.fr/geocodage/completion] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   */
  autoComplete: function(options) {
    var autoCompleteService = new AutoComplete_default(options);
    autoCompleteService.call();
  },
  /**
   * Getting a route from one point to another using the [route service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/itineraires.html}.
   *
   * @method route
   * @param {Object} options - Options for function call.
   * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {String} [options.routePreference = "fastest"] - Indicates the way to compute the route : "fastest" (time optimisation) or "shortest" (distance optimisation). Available values are in the GetCapabilities.
   * @param {Gp.Point} options.startPoint - Start point of the route. Expressed in CRS:84 coordinates system (startPoint.x corresponds to longitude, startPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
   * @param {Gp.Point} options.endPoint - End point of the route. Expressed in CRS:84 coordinates system (endPoint.x corresponds to longitude, endPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
   * @param {Array.<Gp.Point>} [options.viaPoints] - Ordered via Points of the route. Expressed in CRS:84 coordinates system (viaPoints[i].x corresponds to longitude, viaPoints[i].y corresponds to latitude). Available bbox are in the GetCapabilities.
   * @param {String} [options.graph = "Voiture"] - User profile to use to compute the route : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads the route may use and the average speed. Available bbox are in the GetCapabilities.
   * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
   * @param {Boolean} [options.geometryInInstructions = false] - Indicates if route geometry has to be also returned with route instructions.
   * @param {Boolean} [options.provideBoundingBox = true] - Indicates if route instructions has to be localised with a BBOX in the response.
   * @param {String} [options.distanceUnit = "m"] - The unit used to provide distances in the response ("meter" or "kilometer").
   * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
   * @param {Array.<String>} [options.waysAttributes] - Way Attributes to add in the response. Available values are in the GetCapabilities.
   * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.RouteResponse} object as a parameter except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.outputFormat='json'] - Output format ("json" or "xml") to use for underlying webService. Only use if you know what you are doing.
   * @param {String} [options.serverUrl=https://data.geopf.fr/navigation/itineraire] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   */
  route: function(options) {
    var routeService = new Route_default(options);
    routeService.call();
  },
  /**
   * Computing a set of places (curve) reachable from a given point (or from where to start to reach a given point) within a time or distance constraint using the [isochrone service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/isochrones.html}.
   *
   * @method isoCurve
   * @param {Object} options - Options for function call.
   * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
   * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
   * @param {Gp.Point} options.position - Start or Arrival (options.reverse===true) Point for the computing. Expressed in CRS:84 coordinates system (position.x corresponds to longitude, position.y corresponds to latitude).
   * @param {String} [options.graph = "Voiture"] - User profile to use to compute the isoCurve : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads to use and the average speed. Available values are in the GetCapabilities.
   * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
   * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
   * @param {String} [options.method = "time"] - Computing method to use : "time" (using a duration as a constraint) or "distance" (using a distance as a constraint). Available values are in the GetCapabilities.
   * @param {Float} options.time - Maximum duration (expressed in seconds) to use when options.method is set to "time".
   * @param {Float} options.distance - Maximum distance (expressed in meters) to use when options.method is set to "distance".
   * @param {Boolean} [options.reverse = false] - Set this parameter to true if you want options.position to be the destination (instead of departure) for the computing.
   * @param {String} [options.distanceUnit = "km"] - The unit used to provide distances in the response ("m" or "km").
   * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
   * @param {Boolean} [options.smoothing = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry to be smoothed.
   * @param {Boolean} [options.holes = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry (polygon) to have holes if pertinent.
   * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.IsoCurveResponse} object as a parameter except if "rawResponse" is set to true.
   * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
   * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
   * @param {String} [options.outputFormat='json'] - Output format ("json") to use for underlying webService. Only use if you know what you are doing.
   * @param {String} [options.serverUrl=https://data.geopf.fr/navigation/isochrone] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
   * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
   * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
   * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
   * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
   * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
   * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
   * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
   */
  isoCurve: function(options) {
    var processIsoCurveService = new ProcessIsoCurve_default(options);
    processIsoCurveService.call();
  }
};
var Services_default = Services;

// node_modules/geoportal-access-lib/src/Gp.js
var servicesVersion = package_default2.version;
var servicesDate = package_default2.date;
var Gp = {};
Gp.servicesVersion = servicesVersion;
Gp.servicesDate = servicesDate;
Gp.Protocols = {};
Gp.Protocols.XHR = XHR_default;
Gp.Services = Services_default;
Gp.Services.DefaultUrl = DefaultUrlService_default;
Gp.Services.AltiResponse = AltiResponse_default;
Gp.Services.Alti = {};
Gp.Services.Alti.Elevation = Elevation_default;
Gp.Services.AutoCompleteResponse = AutoCompleteResponse_default;
Gp.Services.AutoComplete = {};
Gp.Services.AutoComplete.SuggestedLocation = SuggestedLocation_default;
Gp.Services.Config = Config_default;
Gp.Services.IsoCurveResponse = ProcessIsoCurveResponse_default;
Gp.Services.RouteResponse = RouteResponse_default;
Gp.Services.Route = {};
Gp.Services.Route.RouteInstruction = RouteInstruction_default;
Gp.Error = ErrorService_default;
Gp.Helper = Helper_default;
var Gp_default = Gp;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/LoggerByDefault.js
var Log2 = __toESM(require_loglevel());
var LoggerByDefault2 = {
  /**
   * creation d'un logger statique
   *
   * @function getLogger
   * @param {String} [name="default"] - the logger name
   * @returns {Object} logger
   */
  getLogger: function(name) {
    if (typeof process2 === "undefined") {
      var process2 = {};
      process2.env = {
        VERBOSE: false
      };
    }
    process2.env.VERBOSE ? Log2.enableAll() : Log2.disableAll();
    var logname = name || "default";
    return Log2.getLogger(logname);
  },
  /**
   * desactive tous les loggers
   * @function disableAll
   */
  disableAll: function() {
    var loggers = Log2.getLoggers();
    for (const key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        const logger50 = loggers[key];
        logger50.disableAll();
      }
    }
  },
  /**
   * active tous les loggers
   * @function enableAll
   */
  enableAll: function() {
    var loggers = Log2.getLoggers();
    for (const key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        const logger50 = loggers[key];
        logger50.enableAll();
      }
    }
  }
};
var LoggerByDefault_default2 = LoggerByDefault2;
if (window.Gp) {
  window.Gp.Logger = LoggerByDefault2;
}

// node_modules/geopf-extensions-openlayers/src/packages/Utils/ProxyUtils.js
var ProxyUtils = {
  /**
   * Ajoute un proxy aux url des couches vecteurs si besoin.
   *
   * @function proxifyUrl
   * @param {String} url - Url to proxify.
   * @param {Object} [proxyOptions] - Object defining proxy options.
   * @param {String} proxyOptions.proxyUrl - Proxy URL.
   * @param {Array.<String>} [proxyOptions.noProxyDomains] - Proxy will not be used for this list of domain names.
   *
   * @returns {String} proxy url
   */
  proxifyUrl: function(url, proxyOptions) {
    var logger50 = LoggerByDefault_default2.getLogger("proxifyUrl");
    if (!proxyOptions || !proxyOptions.hasOwnProperty("proxyUrl") || proxyOptions.proxyUrl === null || proxyOptions.proxyUrl.trim().length === 0) {
      return url;
    }
    if (proxyOptions.noProxyDomains && Array.isArray(proxyOptions.noProxyDomains) && proxyOptions.noProxyDomains.length > 0) {
      for (var i in proxyOptions.noProxyDomains) {
        logger50.trace("[ProxyUtils] proxifyUrl : analyzing " + proxyOptions.noProxyDomains[i]);
        if (url.indexOf(proxyOptions.noProxyDomains[i]) !== -1) {
          logger50.info("[ProxyUtils] proxifyUrl : " + url + " found in noProxyDomains list (" + proxyOptions.noProxyDomains[i] + ").");
          return url;
        }
      }
    }
    return proxyOptions.proxyUrl + encodeURIComponent(url);
  }
};
var ProxyUtils_default = ProxyUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/Gfi.js
var logger = LoggerByDefault_default2.getLogger("GfiUtils");
var Gfi = {
  /**
   * Return layer format
   *
   * @param {ol.layer.Layer} l - layer openlayers
   *
   * @returns {String} format - layer format can be wms, wmts, vector or unknown
   *
   */
  getLayerFormat: function(l3) {
    var type = typeof l3.getType === "function" ? l3.getType() : null;
    var source = l3.getSource();
    if (type) {
      if (type === "VECTOR" || type === "VECTOR_TILE") {
        return "vector";
      }
      if (type === "TILE") {
        if (source.tileGrid) {
          return "wmts";
        } else {
          return "wms";
        }
      }
      if (type === "IMAGE") {
        return "wms";
      }
    } else {
      if (source instanceof TileWMS_default || source instanceof ImageWMS_default) {
        return "wms";
      }
      if (source instanceof WMTS_default2) {
        return "wmts";
      }
      if (source instanceof Vector_default || source instanceof VectorTile_default) {
        return "vector";
      }
    }
    return "unknown";
  },
  /**
   * Info Popup creation and display
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} coords - coordinates where to anchor popup.
   * @param {String} content - content to display
   * @param {String} [contentType='text/html'] - content mime-type
   * @param {Object} autoPanOptions - Auto-pan pop-up options
   * @param {Boolean|Object} [autoPanOptions.autoPan] - Specifies whether the map should auto-pan if the pop-up is rendered outside of the canvas (See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanIntoViewOptions PanIntoViewOptions})
   * @param {Object} [autoPanOptions.autoPanAnimation] - Used to customize the auto-pan animation. See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanOptions PanOptions}.
   * @param {Number} [autoPanOptions.autoPanMargin] - Margin (in pixels) between the pop-up and the border of the map when autopanning. Default is 20.
   * @returns {Boolean} displayed - indicates if something has been displayed
   */
  displayInfo: function(map, coords, content, contentType, autoPanOptions) {
    logger.trace("[Gfi] : displayInfo...");
    if (!contentType) {
      contentType = "text/html";
    }
    if (content === null) {
      return;
    }
    var _htmlDoc = null;
    var _parser = null;
    var _content = content;
    _content = _content.replace(/\n/g, "");
    _content = _content.replace(/(>)\s*(<)/g, "$1$2");
    var scope = typeof window !== "undefined" ? window : null;
    if (typeof exports === "object" && window === null) {
      var DOMParser2 = require_lib().DOMParser;
      _parser = new DOMParser2();
      _htmlDoc = _parser.parseFromString(_content, contentType);
    } else if (scope.DOMParser) {
      _parser = new scope.DOMParser();
      _htmlDoc = _parser.parseFromString(_content, contentType);
    } else if (scope.ActiveXObject) {
      _htmlDoc = new scope.ActiveXObject("Microsoft.XMLDOM");
      _htmlDoc.async = false;
      _htmlDoc.loadXML(_content);
    } else {
      logger.log("Incompatible environment for DOM Parser !");
      return false;
    }
    var body = _htmlDoc.getElementsByTagName("body");
    if (body && body.length === 1) {
      if (!body[0].hasChildNodes()) {
        return false;
      }
    }
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("button");
    closer.className = "gp-styling-button closer";
    closer.onclick = function() {
      if (map.featuresOverlay) {
        map.removeOverlay(map.featuresOverlay);
        map.featuresOverlay = null;
      }
      return false;
    };
    var contentDiv = document.createElement("div");
    contentDiv.className = "gp-features-content-div";
    contentDiv.innerHTML = content;
    element.appendChild(contentDiv);
    element.appendChild(closer);
    if (map.featuresOverlay) {
      map.removeOverlay(map.featuresOverlay);
      map.featuresOverlay = null;
    }
    map.featuresOverlay = new Overlay_default({
      // id : id,
      element,
      autoPan: autoPanOptions.autoPan,
      autoPanAnimation: autoPanOptions.autoPanAnimation,
      autoPanMargin: autoPanOptions.autoPanMargin,
      positioning: "bottom-center",
      insertFirst: false,
      // popup appears on top of other overlays if any
      stopEvent: true
    });
    map.addOverlay(map.featuresOverlay);
    map.featuresOverlay.setPosition(coords);
    map.featuresOverlay.render();
    return true;
  },
  /**
   * Gets HTML content from features array
   *
   * @param {ol.Map} map - map openlayers
   * @param {Array.<ol.Features>} features - openlayers features Array
   * @returns {HTMLElement} HTML content.
   */
  features2html: function(map, features) {
    var content = document.createElement("div");
    features.forEach(function(f) {
      var props = f.getProperties();
      if (props.hasOwnProperty("render")) {
        content.insertAdjacentHTML("beforeend", props["render"]);
      } else {
        if (props.hasOwnProperty("name")) {
          var nameDiv = document.createElement("div");
          nameDiv.className = "gp-att-name-div";
          nameDiv.insertAdjacentHTML("afterbegin", props["name"]);
          content.appendChild(nameDiv);
        }
        if (props.hasOwnProperty("description")) {
          var descDiv = document.createElement("div");
          descDiv.className = "gp-att-description-div";
          descDiv.insertAdjacentHTML("afterbegin", props["description"]);
          content.appendChild(descDiv);
        }
        var p2 = null;
        var others = false;
        var oDiv = null;
        var ul = null;
        var li = null;
        var listForbidden = [
          // styles
          "fill",
          "fill-opacity",
          "label-stroke",
          "stroke",
          "stroke-opacity",
          "stroke-width",
          "marker-symbol",
          "marker-color",
          "marker-size",
          "geometry",
          // geometrie
          "value",
          "name",
          // dÃ©jÃ  traitÃ©
          "description",
          // dÃ©jÃ  traitÃ©
          "styleUrl",
          "extensionsNode_",
          // extensions GPX
          "icon"
          // ajoutÃ© par la 3D en cas de switch
        ];
        for (p2 in props) {
          if (props[p2] === void 0) {
            continue;
          }
          if (listForbidden.indexOf(p2) !== -1) {
            continue;
          }
          if (!others) {
            oDiv = document.createElement("div");
            oDiv.className = "gp-att-others-div";
            ul = document.createElement("ul");
            others = true;
          }
          li = document.createElement("li");
          var span = document.createElement("span");
          span.className = "gp-attname-others-span";
          span.appendChild(document.createTextNode(p2 + " : "));
          li.appendChild(span);
          li.appendChild(document.createTextNode(props[p2]));
          ul.appendChild(li);
        }
        if (ul) {
          oDiv.appendChild(ul);
          content.appendChild(oDiv);
        }
      }
    }, map);
    if (!content.hasChildNodes()) {
      content = null;
    }
    return content;
  },
  /**
   * Indicates if there is a feature at the given coordinates for the given layer
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.layer.Layer} olLayer - vector layer openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   *
   * @returns {Boolean} has feature
   *
   */
  layerGetFeatureAtCoordinates: function(map, olLayer, olCoordinate) {
    var pixel = map.getPixelFromCoordinate(olCoordinate);
    return map.hasFeatureAtPixel(pixel, function(layer) {
      if (layer === olLayer) {
        return true;
      }
      return false;
    });
  },
  /**
   * Get information from all the features located at the specified coordinates
   * and belonging to the layers list argument. Those information are gathered
   * and displayed in an info popup.
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   * @param {Array.<ol.layer.Layer>} olLayers - layers requested
   * @param {Object} autoPanOptions - autopan options
   *
   * @returns {Boolean} something is displayed
   *
   */
  displayVectorFeatureInfo: function(map, olCoordinate, olLayers, autoPanOptions) {
    var pixel = map.getPixelFromCoordinate(olCoordinate);
    var features = [];
    map.forEachFeatureAtPixel(pixel, function(feature, layer) {
      if (!olLayers || olLayers.indexOf(layer) > -1) {
        features.push(feature);
      }
    });
    if (features.length === 0) {
      return false;
    }
    var content = this.features2html(map, features);
    if (content === null) {
      return false;
    }
    this.displayInfo(map, olCoordinate, content.innerHTML, "text/html", autoPanOptions);
    return true;
  },
  /**
   * Method to manage the request of information from a list of layers already added to the map.
   * Among the given list of layers only the visible ones are requested.
   * The priority is given to the upper layer having a feature at the pointed coordinates.
   * If the first (upper) feature encountered is from a vector layer the info popup will
   * display the information of the features from all visible vector layers and located at
   * the specified coordinates.
   *
   * @param {ol.Map} map - map openlayers
   * @param {ol.Coordinate} olCoordinate - coordinates pointed by user
   * @param {Array.<Object>} gfiLayers - list of layers which can be requested through the control. Each array element is an object, with following properties :
   * @param {ol.layer.Layer} gfiLayers.obj - ol.layer.Layer layer handled by the control (that has been added to map).
   * @param {String} [gfiLayers.event] - name of the mouse event triggering getFeatureInfo on this layer (that has been added to map). allowed values are : 'singleclick', 'dblclick' and 'contextmenu'
   * @param {String} [gfiLayers.infoFormat] - indicates the format mime-type of the response of GetFeatureInfo requests.
   * @param {Object} [proxyOptions] - options for poxy configuration :
   * @param {String} [proxyOptions.proxyUrl] - Proxy URL to avoid cross-domain problems, if not already set in mapOptions. Mandatory to import WMS and WMTS layer.
   * @param {Array.<String>} [proxyOptions.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing (if not already set in mapOptions).
   * @param {Object} [autoPanOptions] - Auto-pan pop-up options
   * @param {Boolean} [autoPanOptions.autoPan = true] - Specifies whether the map should auto-pan if the pop-up is rendered outside of the canvas. Defaults to true.
   * @param {Object} [autoPanOptions.autoPanAnimation] - Used to customize the auto-pan animation. See {@link https://openlayers.org/en/latest/apidoc/module-ol_Overlay.html#~PanOptions PanOptions}.
   * @param {Number} [autoPanOptions.autoPanMargin] - Margin (in pixels) between the pop-up and the border of the map when autopanning. Default is 20.
   *
   */
  displayFeatureInfo: function(map, olCoordinate, gfiLayers, proxyOptions, autoPanOptions) {
    var layersOrdered = {};
    for (var j2 = 0; j2 < gfiLayers.length; j2++) {
      var layer = gfiLayers[j2];
      var position = layer.obj.getZIndex();
      if (!layersOrdered[position]) {
        layersOrdered[position] = [];
      }
      layersOrdered[position].push(layer);
    }
    var requests = [];
    var positions = Object.keys(layersOrdered);
    positions.sort(function(a2, b3) {
      return b3 - a2;
    });
    var foundFeature = false;
    for (var k3 = 0; k3 < positions.length; k3++) {
      var p2 = positions[k3];
      for (var h = 0; h < layersOrdered[p2].length; ++h) {
        var l3 = layersOrdered[p2][h].obj;
        var infoFormat = layersOrdered[p2][h].infoFormat || "text/html";
        var minMaxResolutionOk = true;
        if (l3.minResolution && l3.minResolution > map.getResolution()) {
          minMaxResolutionOk = false;
        }
        if (minMaxResolutionOk && l3.maxResolution && l3.maxResolution < map.getResolution()) {
          minMaxResolutionOk = false;
        }
        if (l3.getVisible() && minMaxResolutionOk) {
          var format = this.getLayerFormat(l3);
          if (format === "vector") {
            if (!foundFeature && this.layerGetFeatureAtCoordinates(map, l3, olCoordinate)) {
              requests.push({
                format,
                scope: this,
                coordinate: olCoordinate
              });
            }
            continue;
          } else if (format !== "wms" && format !== "wmts") {
            logger.log("[ERROR] DisplayFeatureInfo - layer format '" + format + "' not allowed");
            continue;
          }
          var _res = map.getView().getResolution();
          var _url = null;
          if (format === "wmts") {
            _url = l3.getSource().getFeatureInfoUrl.call(
              l3.getSource(),
              olCoordinate,
              _res,
              map.getView().getProjection(),
              {
                INFOFORMAT: infoFormat
              }
            );
          } else {
            _url = l3.getSource().getFeatureInfoUrl.call(
              l3.getSource(),
              olCoordinate,
              _res,
              map.getView().getProjection(),
              {
                INFO_FORMAT: infoFormat
              }
            );
          }
          requests.push({
            // id : _id,
            format: infoFormat,
            url: ProxyUtils_default.proxifyUrl(_url, proxyOptions),
            scope: this,
            coordinate: olCoordinate
          });
        }
      }
    }
    var vectorLayersOrdered = null;
    function requestsSync(list, iterator, callback) {
      if (list.length === 0) {
        return;
      }
      var nextItemIndex = 0;
      function report(displayed) {
        nextItemIndex++;
        if (displayed || nextItemIndex === list.length) {
          callback();
        } else {
          iterator(list[nextItemIndex], report);
        }
      }
      iterator(list[0], report);
    }
    ;
    var context = this;
    requestsSync(
      requests,
      function(data, report) {
        if (data.format === "vector") {
          if (!vectorLayersOrdered) {
            vectorLayersOrdered = [];
            for (var m2 = 0; m2 < positions.length; m2++) {
              var p3 = positions[m2];
              for (var n = 0; n < layersOrdered[p3].length; ++n) {
                vectorLayersOrdered.push(layersOrdered[p3][n].obj);
              }
            }
          }
          report(data.scope.displayVectorFeatureInfo(map, data.coordinate, vectorLayersOrdered, autoPanOptions));
        } else {
          Gp_default.Protocols.XHR.call({
            url: data.url,
            method: "GET",
            scope: data.scope,
            // Handles GFI response
            onResponse: function(resp) {
              var exception = false;
              if (resp.trim().length === 0 || resp.indexOf("ServiceExceptionReport") !== -1 || resp.indexOf("java.lang.NullPointerException") !== -1 || resp.indexOf("java.lang.OutOfMemoryError") !== -1 || resp.indexOf("not queryable") !== -1) {
                exception = true;
              }
              var displayed = !exception && context.displayInfo(map, data.coordinate, resp, "text/html", autoPanOptions);
              report(displayed);
            },
            // Handles GFI response error
            onFailure: function(error) {
              logger.log(error);
              report(false);
            }
          });
        }
      },
      function() {
        logger.trace("Finish sync to GFI !");
      }
    );
  },
  // Function returning the clicked position of an event
  getPosition: function(e, map) {
    if (e.coordinate) {
      return e.coordinate;
    }
    var pixel = [0, 0];
    if (e.offsetX || e.offsetY) {
      pixel[0] = e.offsetX;
      pixel[1] = e.offsetY;
    } else if (e.pointerType === "touch") {
      var p2 = e.pointers[0];
      pixel[0] = p2.pageX;
      pixel[1] = p2.pageY;
    }
    var coordinate = map.getCoordinateFromPixel(pixel);
    return coordinate;
  },
  // onDisplayFeatureInfo
  onDisplayFeatureInfo: function(e, gfiObj) {
    if (!gfiObj.isActive()) {
      return;
    }
    logger.trace(e);
    var map = gfiObj.getMap();
    if (e.type === "contextmenu" || e.type === "dblclick") {
      e.preventDefault();
    } else if (e.type === "singleclick") {
      var interactions = map.getInteractions().getArray();
      for (var i = 0; i < interactions.length; i++) {
        if (interactions[i].getActive() && (interactions[i] instanceof Select_default || interactions[i] instanceof Modify_default || interactions[i] instanceof Draw_default)) {
          return;
        }
      }
    }
    var proxyOptions = {};
    if (gfiObj._proxyUrl) {
      proxyOptions.proxyUrl = gfiObj._proxyUrl;
    }
    if (gfiObj._noProxyDomains) {
      proxyOptions.noProxyDomains = gfiObj._noProxyDomains;
    }
    var autoPanOptions = {};
    if (gfiObj._autoPan) {
      autoPanOptions.autoPan = gfiObj._autoPan;
    }
    if (gfiObj._autoPanAnimation) {
      autoPanOptions.autoPanAnimation = gfiObj._autoPanAnimation;
    }
    if (gfiObj._autoPanMargin) {
      autoPanOptions.autoPanMargin = gfiObj._autoPanMargin;
    }
    var eventLayers = [];
    for (var j2 = 0; j2 < gfiObj._layers.length; ++j2) {
      var event = gfiObj._layers[j2].event ? gfiObj._layers[j2].event : gfiObj._defaultEvent;
      if (event === e.type) {
        var ind = eventLayers.push(gfiObj._layers[j2]) - 1;
        if (!eventLayers[ind].infoFormat) {
          eventLayers[ind].infoFormat = gfiObj._defaultInfoFormat;
        }
      }
    }
    var coords = this.getPosition(e, map);
    this.displayFeatureInfo(map, coords, eventLayers, proxyOptions, autoPanOptions);
  }
};
var Gfi_default = Gfi;
if (window.ol) {
  if (window.ol.gp) {
    window.ol.gp.GfiUtils = Gfi;
  } else {
    window.ol.gp = {
      GfiUtils: Gfi
    };
  }
}

// node_modules/geopf-extensions-openlayers/src/packages/Utils/Helper.js
var Helper2 = {
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @function detectSupport
   * @returns {Boolean} isDesktop - true for desktop userAgent, false for mobile
   */
  detectSupport: function() {
    var isDesktop = true;
    var userAgent2 = window.navigator.userAgent.toLowerCase();
    if (userAgent2.indexOf("iphone") !== -1 || userAgent2.indexOf("ipod") !== -1 || userAgent2.indexOf("ipad") !== -1 || userAgent2.indexOf("android") !== -1 || userAgent2.indexOf("mobile") !== -1 || userAgent2.indexOf("blackberry") !== -1 || userAgent2.indexOf("tablet") !== -1 || userAgent2.indexOf("phone") !== -1 || userAgent2.indexOf("touch") !== -1) {
      isDesktop = false;
    }
    if (userAgent2.indexOf("msie") !== -1 || userAgent2.indexOf("trident") !== -1) {
      isDesktop = true;
    }
    return isDesktop;
  },
  /**
   *  Copies all source object members to dest
   *
   * @function assign
   * @param {Object} dest - destination object where properties and method will be copied
   * @param {Object} source - source object from which properties and method will be copied
   * @returns {Object} dest
   */
  assign: function(dest, source) {
    dest = dest || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  },
  /**
   * Merge two objects parameters (deeper than assign)
   *
   * @function mergeParams
   * @param {Object} dest     - destination object where properties and method will be merge
   * @param {Object} source   - source object from which properties and method will be merge
   * @param {Boolean} replace - replace destination value by source if exists or not (true by default)
   */
  mergeParams: function(dest, source, replace) {
    if (typeof dest === "undefined" || typeof source === "undefined") {
      return;
    }
    if (typeof replace === "undefined") {
      replace = true;
    }
    for (var param in source) {
      if (source.hasOwnProperty(param)) {
        if (typeof source[param] === "object") {
          if (dest.hasOwnProperty(param)) {
            this.mergeParams(dest[param], source[param], replace);
          } else {
            dest[param] = source[param];
          }
        } else {
          if (dest.hasOwnProperty(param)) {
            if (replace) {
              dest[param] = source[param];
            }
          } else {
            dest[param] = source[param];
          }
        }
      }
    }
  }
};
var Helper_default2 = Helper2;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/Interactions.js
var logger2 = LoggerByDefault_default2.getLogger("interactions");
var Interactions = {
  /**
   * Liste des extensions qui utilisent le mÃ©canisme des interactions
   */
  _extensions: [
    "Measures",
    "ElevationPath",
    "Drawing"
  ],
  /**
   * Options par defaut
   * - current : ex. "Drawing"
   *       c'est l'extension qui demande la desactivation des autres interactions.
   *       Par defaut, toutes les interactions sont desactivÃ©es.
   * - clean :
   *       c'est la suppression des interactions, des dessins de la carte,
   *       ainsi que la reinitialisation de l'Ã©tat graphique.
   *       Les extensions doivent implementer la mÃ©thode 'clean()'.
   *       Par defaut, tous les dessins sont supprimÃ©s
   */
  _options: {
    current: null,
    clean: null
  },
  /**
   * Permet de desactive les interactions (Draw) de la carte pour les extensions,
   * sauf l'interaction courrante (si elle est renseignÃ©e avec l'option 'current').
   * Il est possible d'ajouter des fonctionnalitÃ©s via les options.
   * Par defaut, l'option 'clean' est renseignÃ©e...
   *
   * @param {Object} map - the map
   * @param {Object} options - options
   */
  unset: function(map, options) {
    logger2.trace("unset()");
    var opts = {};
    Helper_default2.mergeParams(opts, this._options);
    Helper_default2.mergeParams(opts, options);
    var interactions = map.getInteractions().getArray();
    for (var i = 0; i < interactions.length; i++) {
      if (interactions[i].getActive() && (interactions[i] instanceof Draw_default || interactions[i] instanceof Select_default || interactions[i] instanceof Modify_default)) {
        var prop = interactions[i].getProperties();
        var name = prop.name;
        if (typeof name !== "undefined" && this._extensions.indexOf(name) > -1) {
          if (opts.current && opts.current === name) {
            continue;
          }
          interactions[i].setActive(false);
          var source = prop.source;
          if (typeof source !== "undefined" && source instanceof Control_default) {
            for (var action in opts) {
              if (opts.hasOwnProperty(action)) {
                if (action === "current") {
                  continue;
                }
                if (typeof source[action] === "function") {
                  var args = Array.isArray(opts[action]) ? opts[action] : [opts[action]];
                  source[action].apply(source, args);
                }
              }
            }
          }
        } else {
          interactions[i].setActive(false);
        }
      }
    }
  }
};
var Interactions_default = Interactions;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/Markers.js
var Marker = {
  lightOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAASf3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZpptuO4DYX/cxVZAsEBIJfD8ZzsIMvPB8mvpq5OupN6Xc8uW5Yo4OIOdIfzr3/e8A/+lNo1lGpNu2rkT+mlp8GTFt8/4/ktsTy/nz85f96Tn18P6fN6TLzkB30ObPo5/ut1+XaC92HwrP5worY+b8yf3+jlc/72y4k+F8q+Il/F/pyof06U0/uGfE4w3tuK2pv9eAvzvI/7607a+zf4r/tVE3sffv13Maq3K9fJKZ0sOfL7U6ycsv/NIQ+eVH6nXDhQsj3P31fssxIK8rs6ffvTWdH1pZbfHvRTV749+6Vbnwpwa790q6TPIfmXIuu3x9++HqT+vitP6X+4cmmfZ+nn10eVz4p+qf5T/Lvbfe6ZuxhFKbV+burrFp9nHDe5hF+6BZamdEfBUOPRfzo/jZtfQGHHFSc/S7ok2nWlyJYhV87zuGSxxJJOSMaTlFbKz4stW+ppZe9f8R+5yXLPOze6uJ62l5y+rUWey/a4wnO1xpW3cGgSTiZ85G//hL/7gXt9FES8luOtFetKyYvNMrxz/pvD6IjcT1HrU+Cvn1//eF8zHaxeZR+Rzqnne4r5NvPFVn4anTmw8vjOoNj+nIAScenKYiTTAbomuYpKtJRMhEI2GjRYus/MpANSa9osMpWcld605JfmIybPoakmXg68DpnRiZqVOWt0aNCsUir4sdLA0Ki5llqrVqut9jo0a9GqqqZOisOylWDV1MyadRstt9Jq02attd5GTz1DmhBpt95672NwzcGZB58eHDDGTDPPMmuYOm222edYwGeVVZcuW231NXbaecMfW7fttvseRw5QOuXUo8dOO/2MC9RuDrfcevXabbff8a1rn7b+4edvdE0+XUtPp/xA+9Y1XjX7OoU4nVTvGQ1LoQgdN28BgE7es9iklOSd857FDv3lmlhk9Z5t8Y7RwXIk1StfvQvp7ah37v/qW7DyU9/S/9q54K37m537Y99+17XtJLyejr1T6EWNmenjmJEa/zGtf3wMnycdEnrmgScKh+W2rFIB58FVtiU7CVaLdS1hHXPoPkvVW5b2oXDBZM5kyN7VVS1pzsLdAoljo1+6tE5b+ciweuqaTNwEgrpb3atwvSOzw3Aa7Git98o4VD3nq3Nz/50yiEw9MXMCh+hOfU+a3euZl0IjZX1tW/VQIF0lHO5kjFqF2hvlvCOvrEi+yhlzzHKu6fCXapZzFpUqw+TMUoU1TrM8K8eEt2CcvwpvlcXjErqqEPqJVIoz1cQ7CdQOB0qqW1QrkrCsK6Afva0R7pobdpd7pG47/Z7UpwDkCm4ql9Y8G2Oi4+S0rJ3LiVdtruM9Jb1Ja6ESIbdenfb7pXSsmRIcyTStcG9xoGh7gbLD1W/ra462dTTubFKUsWyMLTThhmZUszvGdgZEZizn7D1Pvb3VmlkuoOsHSOIrxmpt0EbpgB81ynTMBlDt4TB1Vq5U0EsVt3mfgfWpNiTznwumVxaPWHprbym/Svr9MfzZG/QkgrS9IGdlYQ6i4zdpbQ/m9sbCKqv0ZKwrI5D8c+V9b9uzAIzM/Z4lm07xdl/X4aOlTekLNI+orHQcAKRJpdnQM8CoBLRYV9plleJl8yJpa3OPe+a+2ljD2pnF7GnxzrzWZijn2Ke3SytrYTJHl3CK9lQgFlNNC3tc+vJx88VLOxAB9avWjwIU0L+9m61oK7lrkrd4DEFof16knx/5sM6pOzqQ89r9dFase7a2kvXApdQOnAIH5T1mG+BM+ikt1QrNMltZKx0fC2XliVbK2enAuDk5P93TQXSY4nS4IchETYYPGGuNXfPJe8dboIixZ13bJ3mSES4KnZel1RgaaOZA8OcESKbuDaQOmjUXww93t1szsyHSFGynylw7HKfe096ywI75p6qE/1AWLgx4tMx14z2j6kyisec64EDuBCwwy/Hkm8cNzHK6iw7YiNbnVQpjdjOH0neUT9rCo7fozG2DjiOBKQKQC/0ivclYZtIwF7fDPLR2xsKkM0cZc3h3ubjIPgBmOYr3S+fTa5Zz1mfVLToJjbVH2GgN1DhKaQuluyAVe7PRRMRsWBqIgqYBoNC+NuDliY1RKG/iF5V5dztbGlQLAybsk82qaE3fzPS1zo1n5ygmKC4wsUvbiNBGerilBnJoSE4DG6x13BXWzXBv4vYFstG1VoOoC6oGPXX/UIRoN9Ib52D6Juin06jZss0ksVys5ZihjGxtMgDdLmq0EzXjzAC3GYCBXfJmwiQVEFzdurMKcZKkpyctqt0wSD0I04f4UnjXutEEdDzPuPOKKFPiKejaATr81NlRGzDe3HRwNPkVbr8UG4ZhJjM8BolsXMthNArGnMEfadoZhuRvosTdXPLOb6A0JOrIp3/hv06r4ESq1wpWZVzvZn6y/7vgYoE/RL0HgLxUNSFWB62gtiN2hhEcIbWpICkUOvvAoA/4gwScv+C0v8MJXQ+Nhqg1bgvZyqdP8vWsKBV8RUCGpsq1Orzz87Z547iFBkQcRUQrWKA86w2AavJxAguRhd6xoAOTYog6816YrroLXcGYxwUwoyFHxbtxwRY8c6zO2TQAYZkL53DIRQdBfHU1oxhJNzYpyVhcSYrFDSNPjwSTWZx0C7pf0DkOS8j9rA2q42RUpIpREda6Y4OVDMScySKSXydzjIPsENagrkkhcCt4BqZhB/N2onoPdi7ctdN3/3Qrd4qgPo8DCaYdnU9QE0W7h/vF5XGz3/AdFCBL/iqDfzDxQUSMGzfioPgJEvYDInjPyQaugchuEgbt4iCQY5ZDnwpnKTiqgj3mLhg1NCq+QwLyYPY43chRPVrq0WriYlciCNXr9VZ3eICCMIBS4nhvGEAIw0qEhaAkDex6p7qYKmQHB1AbnfAkxigx1QyOzGYXWYL/CubfGEbWGIDhxA3eiL9PpQDHRUgAbReX0ZAINyI0tQyUgcVzKFiDBOCFjXMlQ6QIYkMb7saZZliZxQwEHn7o2G6Dw8gKBXCjW9HZ5/SKXUR+OGGzMloZaAvkmmvAMyBcC4kU4YA7WToAmhlidyGKa0VSxUljYxnPcmeRgXsRbqRzbRBckHloBPPrw4Zr9/nkeMzb5VrMpFf9AdVcbrK+uoGUwtqrX/d3dJMJxvohLt7qvV04IsR7p1zM26eJ1/k1x//g+d/H8D4BAfSL+aSxxKRFa8VwUdeY6QURKy/NDAFrToKxoZTYfM331eZeAgxflY4XBZ69YaDqBP0056yGHyqnI9Rm+K1p4rSSFV9wIQGusB4PwEsdXUP9DnZtZ94jN0xuBSPBvXtoV2+0IasUFkXDKp3lXoDfe5DX9kLTOsqO9cOHgM9dqcdiEIusVMgFQy508wSbpxADbn2mkuCEx6EsXBGIAZaI1QujONgyMWaU1cti1qaQEDl1Vj7vsZFkI2m+A1t7/N49QJhK5OIUe/mWkE5sXwYa+J+lLKYCuDVajRjq3pAsYg3SQnkfQcb5LTz7xuPjv3k+dmCWUDi39Gl2ps4dXcYVJ+59d99wRJHQ9LtAD2XCRjYYkN8YUkIsrfFM5Bua5BDFyIKdxluACNO7zFkGegGi99np8n9j/ehWp2oYY4SOQWj9XHz1WcHWQL0BTYasCIpgkjyEg2C5TjD10bCGFz/PM8b5+O4Qk/m+Q5382uG5+CN3633jvfzjO4W5+TohQ8+pxIiNEfMI6VGFDe3Vd7VByDt4j0ebGrIEM2FxoZRLB0ld8XEkKBgMwyDC7QsJysobUBnjBgjRwxnsynv/tfjqx2VNJC2GPT4rjSDBV4jDl/3nVG6B+hHJ/bY9TyerWAXsIZHtzugCQWRAOXCVZl5Xxtv3fWErmHaDtJp8l2EikIXuKSylj/uCveU2fazmTH53yCEnm+KTd2E8hu4qTrIvHDJGlUkZS4IXFcPl7A8fAbrNqGf3Qh0xQTZ0SOsbIwDBLK/x9DWhsopPIiRsgHCMYjfP9wzMjbM37G0lr8B9aaI3NOogBL6Xs2HMOSH289KUQKo/Buvw+9qVTK6UUwqBuBPJFVPro5AfXk+Hn4zJjMj3RBR5J8BC2PqEG63CIG16OTfx+pr5fu30UWcS0DFuDuKHtdFjnLuM6psYkD2+oF5CjVvhS0CnoHwa/WNusfqXim5qQpjM1ZuFIjyYKi4vxKw4DZoiVeu6o4ZKaXzoURuq4nOHt6Fa9ATnU7ncxo7g6UE+0kYg8fExDzwLcq3ErIGXRo5wH+cRiu336mjg3/3hG2IT6ohLvVXuTCXB0dhTZ+++gRgyV/xAITch2WCqEVVrzPAxLgXRI1voOfSbmnM3/CXgYh8rPhxfDFL225b2jePCd7J7H2GzAwgjZgFyJj8SfsUItFBpFvCwUUQDA4ArY0Ch61SNvFZ8rw4vVhHyw5p9f3bEFDt1PjrID05RjBzVgqbJUJXSLARoRkQCNSZf5olAkobc12LqI73yrQJsCI4mLYS/rubukwKjPDlOFkPFgSrnRyNwuAcbiRm94aPI9zdmLUkujYQqcYLjaGRIFnZ9jYRcLJlv/hX30BiQgE6j5A+dU2RwwDKwGdzTAYnH2f2ctN0O7I1HTtBURMBcroAlYgjM8GYBFvPdA+imolWmjWHi4gzYfRqHKRuMrUQIsUDygBhBxs1jo+CJ/IRoNDEAuvemMJCC/Xg00L/U+v7I1Ly3qnhB/Jnv36SmOB4fM0A35hihOAcqHpM4x/zAdUx8e02G/BVzGxEpEBsqKathzVgltlb3EfNtLcNVGPPt0TpvbA+eMs3SfMcK04ln8fXDhgIiSOwUm4lj8jugXZhmRg6AHMb9gijciwnTDnNhKBXDI9m3iD38ciZ0YLpbxWho2ISpAY66Q2ZZgwv9YyzHM2QkASaOBrCM9OP4q+8xXnvSaycEuDbB4cHeJeEM08EstvvA765nu7r4RjF5YxNiO742DawE9XUMghITWK87c1sOWHBLFCdbxFqYR1wcoI8cBOX6jFuFBLCGvrO4QGX1bQxLMyX1IOX6X7bSfq7geCNzFbDeFfsL4sAm9acvxwtCFjQCGbaQ5SXYzrfVaxzOdTr6hCG35oVdOc2NjGrlX48wehxksic+UH1zZFGbgTZ0K7g4w03xafwEKo3qmAT1ovmmWMLjkxQfaNJsfbCSfP/Bjam3D72Oor77aumCQix5g05JlNJPOM40mKCcXes2BgAqwbwjX9C6YD5GLvF1Btsafh9ONbfSezJDaSKHSLBCtccxqI9oQpBKdPOW8ElM6cLAUEp480Jj9F8ZWZlutjwrw34IF3Ru/nXGEPVdmdKGfy3h2xPSckwZ++JVZyTNxYgPu4Xr7t9dEwC884PvdGPaUoDyS8JT24R1WOfECBGsahPUmDtm+cTW6WDpaAjUzlyS1kncYJEIDAiZyxN0E5/siGdvg+9mUv9KxWpkpJZHQvPvaxZnxBcgaAiXh+X94PwInyIy3xvwy/LG3eRYB/K+3Rv/0tbkr5t1/t2Cf/2ywR63xthCV3sBUwghIvm+R2nAiiQx9m1ALsHxHN59A48pBKgBad+otn9vQ+k4H3eDprO46VGMaI8i2WtEMWRIDaGfMTZn+VEuSgW8+gwAObmZIcwd38EfjH/1vT7fEMfSUMtuvYNP3y02Lp8384OnnB5SE3yl2JVLXkupN8SeLMR0edpWPOdiYAzEoLsnU06ADN0M4jS0g3qw/pl6ie/3qbB8IAwhZKSSWdYi2UeyRcdX7oYRIJHqRg3ohnS35cvNC0hB48rizpKbfgIpJ4K8UTXsMyPJS8f3molSYALLgj3yJXXfIQUczfMrnTGm9vXmbqT9Cxm1gL0Av0xdB/GsoGePVRtqwDiU7NkOC5OoSHUj2313k5QM26h2luk7Bj3ZCNe/pU0Qy4KK4CUIssMEE7uGyWV2uHjb+uw+wh8kX2daUJevGzUyICdt1kJizKnhNN9fJdvgDiNkP/wLw3jTrngRHBUjR54lJbBuOeAjo47O6yybKKQ1+BYN9E7SdXSh7kg7fhkCp+XcFTAgpvpIdDeDnincsPl3LFAaQHpywRwhptNoKXGKHlun1+/eKorKDU6M+vPdy4TRM3hBqOByFyqMtsOze740DPsC8pAEAoG/Lv5/CMA8eARSjpFJ/D3fpm7bv13y/1/gYgKdVn1LkvDNrMDBe5OOZLrnE6TOLjSDqjEAmIBNMzyKH+RuFd8whbrQq0Eg9sSGkBz/Ho6Yxe0G6mANNHo8de/ikteZX99WyNEZrVJf5T6opO+8RJLMjhgqGLMdsOXbSlqCutkhdPhvUMPc/H7Tgqm9nnHDvwF6YngoNZcUVAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNAHMVfU0tFKh3sUMUhQ3WyICriqFUoQoVSK7TqYHLpFzRpSFJcHAXXgoMfi1UHF2ddHVwFQfADxNXFSdFFSvxfUmgR48FxP97de9y9A4RmlalmzzigapaRSSbEXH5VDL4igCjCGERIYqY+l06n4Dm+7uHj612cZ3mf+3P0KwWTAT6ReJbphkW8QTy9aemc94kjrCwpxOfEYwZdkPiR67LLb5xLDgs8M2JkM/PEEWKx1MVyF7OyoRJPEccUVaN8IeeywnmLs1qts/Y9+QtDBW1lmes0h5HEIpaQhggZdVRQhYU4rRopJjK0n/DwDzn+NLlkclXAyLGAGlRIjh/8D353axYnJ9ykUAIIvNj2xwgQ3AVaDdv+Prbt1gngfwautI6/1gRmPklvdLTYERDeBi6uO5q8B1zuANEnXTIkR/LTFIpF4P2MvikPDNwCfWtub+19nD4AWeoqdQMcHAKjJcpe93h3b3dv/55p9/cDPGdykYtTXU4AAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjkyYWVkNjM2LWY3MDMtNDAzOC1hNzM4LWZiYzYxYzZlMTljNCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5NWMzZWI3NC0zYWRmLTRkYzUtOWZjZS1iODQ4NTc3Nzg4ODQiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0NjI3ZDg3NC1lZDIyLTRiZTUtYTlkNS00NDlmMzVhZDIxYzgiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5Mjc4OTUzMDYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphM2U3ZWQ1MS0xNTI4LTRhYjAtODVjOS0zNzNkNzgxZGM2ZmMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjI3KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PofUkY4AAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGRuA4VZTAAAFcElEQVRYw82YW2xbVRaGv7XP8bHjXByHQkNhWigdVX1AikRBMBoQ8wASl4fRqPDAAxIPKAVxeRqQRohHBEVCaoGKUBCl4qHcNKCZVKMRRQxtgTaACLRKqlwB14NzM2ni2D2XvXjgBFXQOnFiA1uy/HB89u9/7bX+vf4l1HnpK57hTNCE0AzqAS5gAAuEID5KiWSiLPf4tp7YUjcSu4yLZzdi2IJyNXANcBlwAdAKzAHTwDhwDKEPywC+GZWHbPi7IKOvZIWguAnlr8BtwJ+AxDJeDYCPgF6Ed0hkh+Weov5mZLTHJMDeBjwYk0itYJtKTOpZML3SbYNfnYz2SBr0buARYENcFytdFvga2AGyT7p14Vcjoz3ShOgdKDuAi+pUewpMIDyCypvSreWGk9HdroOEV2F4A1hfTxGJCX2D5U7U/UzuD6NaXq49NRJhBsOjwMVLEtE4gaL4W5cV3IsxPEoizDT0ZLTHcSH6M/BWLLlVwpQKuPzhb+i8sRkv04Y/e5rvPigxtnM9trKU2k0D28A5LN3RsmXbrbFOU8DtQLpqfJqu97nh6TydmzvwWpOI8VDbxqbrkmz62yk+/Ps6yoe8KkeV/hHHfgrMNyrNEkBX1SAktgRs3T7ApV1rSWayiEkDLmLSJDNZLu1ay9btAyS2BEsEuWuZ99WKyRhgHeCcn8wGw/qbOnAS3jmfOwmP9Td1kNhQDduJcUwjyciS0RJXMMkWkPPUo/z4XFxZRhZII8mEwFCsT+f5xXTE7FAOteduItVaZodyhNPVZDeKccJGkxmsChIMOvTt6aRSzIP+7A9rRKWYp29PJ8GgsyqcVauZSADaj+IDTecWvBlD4e01HKjM07XtOOuuy+A2X0BYmib/8SxfvLWRYm8LdqZaCvkI/SDBci6nld0ze7KCLa4F3gSurR4MB5x1FnMhiCeor9hJiPKmWpbGp3EU2IbJFuTe5XfStbczLxgP7K0IPcCFDWhnJoFuMAek2/oNbWdku/WxHATejT1JPZcPvINysFYiK+gAFkXTK6H+MyhXADeseJ9fmrVDM6X080/+p1M2/yFsD1zjEIauEeMAqNpQE16oaKiqwfjYeLk+fuYl10HDq7DsBTavxs8o6FzFKez/dM3rLx9LjUyVxcb7yVkfzmpXFbACJURHIxgyxkyu1ml6qL0Z4YX4xl7Jfrrgm9Ov9bX/e++x1tHCgkQ11lgELGA4sBp3iHRbH5GDwJPAFLXo6KJnDmTh/aG2w2/3t47VSGQxs1zAE9U2s9pEjx3hXuBloCa7G1rxv8o3f/7SkUz/UFFWMqGRWMpHAqsDbl00KGotIXM7MawF7gKSS5oJJRospI7v+rD96Ikp8aV2EgrkVPW4OnIy6SVL9ZubvZgyaOVyYDfwl2oNqVWiXNEb231oTe+/BrzvK9Gy01MFyoiOKzIEmqsEfjGf/39U1yHgosJFUXhlFMl+z9E/nkvhVNHZsjux+9Caf77RnyzMBaJLmW4RrWAlB3Y4Uh13HLOA4wQjo6O2IRPNxVV4JuG5Et2SSelzjtFLzsZQ0NIZ8/2rx7K9+/paxqbKvyh4Bc4AFQxzau23Dow7FS+nHmfEUz05OqINH8+evXJPJVOuE93XkY4eSziaXcQpB2b+vZNt7+/8IPPl2OxPRMJ4dDsLzIho3hpzamJ6aqJ0ei6qtZAasmZ2OS1RyOMd6egBIzSFVoKj4y1Hnvhv+8cD02ZOkEmgIKITVnXKWDs1ksvNrgbTbRSZ46cypY50aWcllIsyKXvr8GTyi9f6WvePFGVQhO8EPW2NzI+OfV2pF2bDTgbg8D/aJeVUspd1BK3/G24u7/skO3+iYP3h3LdhI/B+AGodUpo8WKwoAAAAAElFTkSuQmCC",
  darkOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAAStXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZpplmO5boT/cxVeAkeQWA4H8BzvwMv3B0pV7qou26/tyk5JeXXFAQgEIqgO9h//fsO/8a/2KKG2PkRFIv+qVs2TFyN+/s33mGJ9j+9fKd/30q/XQ/5ej5lLftP3xiHf+39cTz8H+DxNXrW/DDT294316xtav+OP3wb6TlR8Rb6K8x1IvwOV/HkjfQeYn21F0dH/uoVln+fzYyfj8xv84f6ISf88/f537UTvNOYpOVtJJfL4DVbJxX9LKJMXjcdcKjem0t/r9q7/2BIB+VOcfv5TVnR9qfWPN/2SlZ+vfsvWNwJs7bds1fy9pfwWZPn5/MfrIbU/Z+WF/i8z1/F9lX+9nkpKnxX9Fv0X/HvGfXtmF7MKoZbvpn5s8b3ivsUUPvUILE3IjoChwbP/KD+DzW+gcOKOi5+dNGXSdVNNJ810k73nnTZLrNlC7rzIeefyLo7Ss+ZdPH/Vf9LNvWg5ZZDL/dJeS/65lvSm1bjDm20w80ncmhODJT7yj3/CP/3AvV4KBHi81KdPfnP2YLMMz5w/chsZSfcb1PYC/OPn93+e10IGm0fZS0QZen2GWC39FxOUl+jCjY3nTw2mfr4DECKmbiwGBNRE1lJpSVLsOfeUCOQgQZOle80sMpBay4dF5lqKkJuRfWo+0tO7NbfM5cB1yIxMtCLU2SBDk2TV2sBPrwMMzVZaba1J6200bVOKVGki0sVJcfbSa+itS+99dO1zlFFHGzL6GEPH1KwF0mwq2nWo6pzMORl58unJDXOuvMqqq4Ulq6+xdM0NfHbdbcvue2zd8+RTDvxx5PQzjp5pyYCSVWsm1m2Y2rxA7ZZw621Xbr/j6p0/s/ZN699+/kHW0jdr+WXKb+w/s8bV3n8MkZxOmueMhOVQExnvngIAnT1ncaRas2fOcxYV+ists8jmOTvJM0YGq6XcbvqRu5A/GfXM/b/yFnr9JW/5/5q54Kn7h5n7e97+lLXjJLxfxj5V+BiwUH3cM/PgP6r178/h+2IWNXr3IZDKnG1YHtrtFtaVWu1ilevx7tYtr7VXOy3nSum0NHSeHSC4lcbIFUozk32J9iFdrXthMcaFq0z0Wlp6+qg7HfZer+Z0+zpjlQ5fRmKkS8fOua1j1CP7llovW7E816hHdHtUrZ5+oz0IDLDFuIMOT2Rma2CHreke6c5TYFqCY9puXmPuPRcL6KvoarLOvlBpNrRL37lJbySs733aav2UesPNIHA2O7WlZr3tW+ML4QSvXKsuLPpsgL0u/mbyXnZpdPGZjOttnz2khypsW2Jt5Fozqdl8qnedcofdunR20BHbANt15T1WAltjrZ53p6nfQqC6rqBWe6l0nMIi9+69RD0LYHu7WZT7SBuQzttKZNQmaIJGvHZZtrsC2T07siMATFvb7ja2C4/eLpMY6Y3jssO25l3SrxyZyBE7R4kTA+Zia60CIJVPnhkqFFtZ7lbmX7OMuH2OHEEBv42VEN66HZf+st21L32sSZIpaVIuvZie0Ge0B9BFHxzfMMd/8DzkZjNwFFdW4zWFApTWlpP3vCOzxUm1FWKkBtHMW+zI2iReZFFt7DcKsCld21qB8OQjdRDXQhXmKB1CEcC+q2c0bT7SjLbfG228GPk7hRnhmQNmEQOdQj6htHgI3AZ5KV/KSy5Qvz4ukCY1hWWM0YhnSa3Uk9dmzdAdoeYHkiPXuQbNHUoZk0+U1KEXyZnw7UUCFyAmnmlQI1tjE1u3fEp+abX5p+r/Iz2QS1Kc9umzQg1lt3Lhw1NuHXclsLDiGHcfUBnKZe/sIx0kz6JICFA+2cTpDpqVDFCytG0wMyxRxibwdjZ7Il4ytbdVoBED6TSBNCbLX7lBnKTOUXZxF2o2nAngN2KboX6uU13NKlAVjWsOwqVSAwGjKo22ARgudUtcr3jbr7JqqgS73qGbknEAGrMVbrKz7oxe06mx+Z3Ct8DT//JMvxjD+NC4EX461F1OUiEZ9Fo6PQak4+Q9cFXp/RXYwfqdetl701wUChFKMN42b+9HHuVV8vC2TBo2vXVGDSCqz6sQl2sSK9HIcSu0Boa7ZhMwb2bxhfVtCl19V/kBwlpSpmxq7XRkqEtPSbqTM/gr6VupkEZLO4fWYHXTxiKN58CCXNsCME6+O0Pc7LgEgroA87HqGzRqHg7g1iwoZdilXwZ1KQgjzcFdjZZAWs+iOv16vVkgmkBYdJF2PuA6s/DJnibdlxZzJwDhCu6LAGRQmeH6TpWowl4bxmBRWhagC2iAc05T0HOmEgY2Au9Qj3bpoMwJCCe7bsTXYPTvhMNbNy35wNACBQfebVUHW6cb07j9jtu4NhM6gGYFw2/BSEz7shWMncc+X1RAvc6jEiaCB4r2pC2MMTlBMZVELQMZ8sm87CGvc2yZLlbHzL5AGkM370hIm3UtpL4vKf2U9EEeSP1X6XGmaf1u5kU+BYRD0+6xqOhky2zr/PWGv79/S1EEBfVpo592XV3EGVjeB2AddoXuX/mwwVzp5WiI5K2oRm6nfGNeDSKS00DeGClvsFMQXpYCssEzwwNTL5wNayGwm/Z/EJA80jz7ukpsB3THWulMHV13IAfym+m+VAleRFOX4kRD6SEbCCQl4mKfAWCOJhC9AtoeUZMtbl7SD8aBayBoffyKhlwj0/zovihoCM2J6cwrkAYIoUEAvaO8n82lBUATNBjkBuFAz2jX69Gii1xgw/YFTl9mr6KFjXbxEih0lDTYKeQDaGlYWEA21FAdcME9yQnMc3hDivcvCX9w+QmbsVAVDI0MBeQQnLNu/lxhFsL3+SBgK+Gf4ebcDyzS32AR/jFu+gc3v8IG6fcDNwhHF3qHHr2JKxWOxa4GvSBc5MDZFQxAfgK1S3NJHLvz9aTBQRjBdTjkIZooUtwD+YcX9bWmaXD04mOOlQcfkghzo2hSvcz6GCkT/9bCKBEhhWrfyE6KFNm7EVoFtQCBILKAYro1Ge9EBFtVWGDZhCwaHNAQyAnJH8MtiKZVBxYBAYpEVEJZkQkoCMNQb2xFRX4AJ8iqpu7AqLZ9YXR/yB6mA/BBYR6iTfPcvZZ4yvTwcA3VjiY/9MkL6fVUNBu690BZQJXyQOShufFPKAW2dg6qJaPqaRfwIi2p+/pxEpdcokQK3RHJqILUAfKsNV1uRStfGq4e8Or4COhH4vE/IvJ3PCqY/hWNgDH8y2hcU3c+NAb0VY2If0FNd5zlrVtbph0h75BRgNL7LH/ePtT7LAouIZ6E5v/6rFs9Yo8NQaluBzGOrKGMHVkrFJe+bVOGy7B/GAhBBjJg75Wx8G/e6RgXkjmsCy14jXxw+63UNLEr04kNyoc4BNw3rJ0r0a7S3L/ebkgoIU3XOR/oYyHZFn+IkR8FYWQQfYgUa8hjrIJMUtkPsgHxr191N/JPtdzzIlqomkJs0dZIJ0rB1wCVQlNSLeBzyAw6N4vEM1B34oIfH5zBSOXNT4Mp+a8iHItfoMZdELWsAuILvO7QH/VNQo6rWzx9o4niuNx/Alw25XGqqBW8GS0x0TSN1TcuirqCbick1OFedZ+IZm00BUGeI6Iw5+7wwDNekAElOjrPoEAQ7vlaLndsJwZlnb25zTqYKdmUHgoVoW/TbQoQRyzdJ6egYhzH0x7R4sddUrh0GdT7wJTo0UAhkp5zgScViyGnkayJFFkIPW9+h05xySh/5Sdw8JFU/JvgRGjuWkxoyPeWx5SFsobrf+Nz3o0uOrgyBhFBfZHXtly3UTF9g4+Bw4iobQRTCahTcObjlt7co60nhwsZBdPNRKhMbYcFF39nVRsJk77A2qiMd8yPxDQUc8qtLjMhaH6n4s/cxkTEKvwwky/eF/Bx3lD7/INVCN8X0LRRg/vNekelk+FYGNfdY8IvYHUQXnZN7B5cyj2zAWqmX/idg86erDH7wYsiP5GtFcqPFEfCn70MQZ7AFbbod2La6ap4VgiTKoVgGoaku4ZMKOzW+TVv1V7KG4HMipBvtHCASd/Jxc+astMWOkDIOk0ZW1vOVZT5PrWESpfBRY423JcjvphjR0FHIPgorIt1VCrZGzjsbhQQ5EDFYudxaui3LJk1YPxw5fQVGo1+Gp47uF9F+R+dGKUKbcEHMIR1Cdk7Iu02D0X1WK4R4+7apqMdkDdMookuMgfea/phsvh3H8go/AOWFZZiQWWFjHhGiqSCUySO9FC6wXN41dWxHwSYPTG2l6cpDTYLzeNgMRqHoqKfdoJN53Syk04No6vmpGJKrscZchpwv8fe+U9EdomvwN1Pxh3Mi6LVtAFtaQitxVbBbSWOWKFnwA4suZPO5n+75os4exayDhZ83KN+ZnjdpGdaHAvut4Y5n/LGW7RKye3E/CiA5Qt87ANeWC14hAhGfLUIVEg+1oduAjaf1Apo9P/W9KFvcN2jEGpgDBoLPJz/puvRFGyNlWOhEhtxu9DRKNV0ozFB9xP1Y3WUTfFGRM+1om4xKgHeKeGMB2oEFje6CDRa0cBIJz/FchGAmHATTihQBojPgf5160WbqQpsN1IgDWFfup1Yd4KzMXjXpZQlbpWOIE+U1UkKqT+bTyXjre0dZ1U/Tft64hr/65nghzq2nw+q0zs0kw+2aMCBLR3UZZ2IMJQz0sUD0Zz9E5YS4vfmQTy2lwziI7RSITFofBE5qbGwBD/NOE8rUi/gqnk3AjzIJef0w/4+X58ISyh8hDQEQu1npzAGoCHoSE8IzskbcY76Wl9z/8HWH/JLInx7oUFd7APzRdOjJQgM7vYYyUTSucMPiunOIMij04t9FLqfV/81VuGXoH0VLjIL+d/84G/gxPMp3vAuQo6OFxH+Ha5Cd7k5Ue8bNUtwn1txU2cWDOIUJOeC7JSST8MPjXZVVAP9TEmddbQdoQX64PA08TZsxi82SzY2G95A/0CUbjSKwxIiq610mIy9IJmmH7AOQFE9KJQe8pgxyi4EAM6mC1HLSsshbMJO1Pzgjj6DWb906nvgnn7xBgoPQENyHul725zomKKEDXMMs0A/AitvQzdvNDVvmDMo5BCJd6e14c2Vhr4GmYGAzVHUq3+TMEv207ca/HAPoda7Vcyklg77X+9nFfXgehp7dyraEC1HyG8FTlOyOsSRlbGgWSjAFHCnAnfDZ2jq/NqAkGzsQETfUyaHlZXL6ogHrTopSECq09eoP4llyTvWC24H4NTNJhpcpAhXq09Wt+GYbnul7vb+nbF/TL0r9NcFqh8PrYoK2OHRb3QHiysgU2DERaHhACp967hQTKgmcN2JWUreSXNZHUshBZOCLnI7GlCFKArV+U7Vp94l5xB9MgRbH2gYGQOZOj46DQeF3tG9hrDU9mQOThdP8mTNfCrnwJwISKQPnT0uR7VNigXpWiEFP0Lxr98KaVRvvbFK9W99yFLG00LSEBRM6N9hdpSdn1v1xajAaNI5aoM1RvOvbtFmReiHev0we/lXd/QOdgDhk35za4XWdq2Kq0CLNKSaZSMmiFa3b52utEkcBgkaBtPuvCgUnUfhvWgjBioKqFKmzXuYpxTl/eQshPPO2ShJRza2dD8dmfb8nMrEf/mI9cczhuFgqAQhsyhVlS50UbeZhXJw12E90H4zEaXeyEpzm1hL9S8p8IDmB3Uoe0SMkyiamhaFiUZRkxc/jhjIoYNyQNaQfNBIVzUIyF2vZUKndnGxeMRUKB8atHpXwjJENI834Aua3xE9HrDApxJwLZAABnp544Cu6gTzDanTXSRBCgWnZa1TIFQX/aCR3IJnEahlwKxX5PoZ2xzJv1FDSTHR2I/yJ5bIE+PfISQqkGpHdqMYFqq1uu8F/1n8izQPIr5lhztexUKSUDfKYvHn8KA6E7wzR1wtru04SeGJVKUgRZzL9yofVU7H6QEpk7p/0zasYFQpSSG90K2fcl64K5m79bFoTBb91AYHjv+/uSLhYRe6bvajej/vvKkVHJ0TPF4buZAoev8WpEDemJctMADcTzd4GkafL0juiyEKwG0XETEBfR4bioCLBmZlDprvZuGtR/zHJPHinE9Ok5/YQ3yYCfrV8iOC1oAVOgDBDksbjH9wOmwIuBPo5icdgiwS1wbND9YU/UHbRZBMgo0IV1jpSUKhQlaYrnkehdAkrI/jgs7JwVWXutTfHbKGdLO6gSFyCyp2j738tB41BgTSDRFYZZQCTKx0bOZkVEiuHFbhtecqYjkv107p0VeeJ6GFqZ+UMrS5tr5BQKz3toOfxbe3a1dtvW+oRnvdOiOWQK+fRFWJgk9hWwgNBvX6peddODKw713i8VM+1Bw+zzXE80FMMd0LY9XoxN0P/Nty75bP4xRkTPHvFMwzuwKeBW3l38aB4uaPlBEG8s8HGwhv/x9y/hPOIdIfHx3GqQAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNQFIVPU0tFKh3sUMQhQ3WyIFrEUatQhAqhVmjVweSlf9CkJUlxcRRcCw7+LFYdXJx1dXAVBMEfEFcXJ0UXKfG+pNAixgeX93HeO4f77gOEVpVpZt8EoOmWkUklxVx+VQy+IoAowlQJmZn1OUlKw3N93cPH97s4z/K+9+caVAsmA3wi8SyrGxbxBvH0plXnvE8cYWVZJT4nHjeoQeJHrisuv3EuOSzwzIiRzcwTR4jFUg8rPczKhkacII6pmk75Qs5llfMWZ63aYJ0++QtDBX1lmetUI0hhEUuQIEJBAxVUYSFOu06KiQydJz38w45fIpdCrgoYORZQgwbZ8YP/we/ZmsWpSTcplAQCL7b9MQoEd4F207a/j227fQL4n4ErveuvtYCZT9KbXS12BIS3gYvrrqbsAZc7QPSpLhuyI/mphGIReD+jb8oDQ7fAwJo7t845Th+ALM0qfQMcHAJjJcpe93h3f+/c/r3Tmd8PnXByuOaabnkAAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjIxNDZjMzUzLWIxZjItNGVjOC04NzQ3LTIwMGEyYWExM2ViMyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NGViNmI2Ni03Y2I2LTRkZGUtYTI3OS01MGY0ZWFiZGFhODAiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1ODRhM2VjZC1kNGFmLTQ3NjItYjA1ZS04ODk2MGQ4ZTk0Y2MiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5MDM3ODI2MTQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoxYzNjOGRkZi1kMjVkLTQ4YzQtYTAwYS0yMmU3ZDYwMzg1YjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjAzKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PuhCAHgAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGQOTjc4FAAAFdklEQVRYw82YW2gcZRTHf+eb2dlkc9lsrFYr2notfSgWxKKiog8VvIFI9UFQEaWtYPFJfREfRRSEeqlttViLD/WGisYXrShWpfWC1WpSN5eN3cZumkuTzWY3c/mOD9lI0WSTTXbVA8M8zMz3n//5zvl/5xyhxqb3ewYvaERpAvUAFzCABUIQH6GAHyvKa76tJbbUjMRW4+LbC7GsQbgCWA+sAs4AWoA8MAxkgEMo32LoxDO98oIN/xdk9IGUYEYvRrgduAW4Gogt4NMA+BroQHkfm+qW3aP6n5HRTSYG9hZga5lEwyKWKZVJvQCmQ3bZ4F8no5skAXov8BiwspwXizUL9APPgOyVXTr5r5HRzdKI1TsRngHOqlHuKTCI8hhG3padWqw7GX3IddDwcixvAefXUkTKhH7HcBfifi8vh1E1H1cfGkGYxPI4cM68RGw5zf3y3S7IuedgeZwgTNZ1Z3Sz46LRNcA7Zcmd25yGgPWP/M7q65toTLZSHBvn6OcFDm07n6g0n9oNAxsR54DsjBYs2251QWAbgFuBREX/tF3rc9+zA6xa3U5jSxwxHmpbueyqOOvvOM7rj67g1JfedFTNagngVtR+B0zUK8xiwLqKTmhcE3Dblk4uXbecRDKFmATgIiZBIpni0nXLuW1LJ41rgnmcvG6B59WiyRhgBeDM+UZipWHthnbcmDf7b8Y81m5oJ7GyErZTxjH1JCPzesu4ghtvBpkjH2X6uXFlAVEg9SMjhEAamFsyp4Yjcuks1s6uXdZacuksU8OVZDcC0mW8OpFRQqBruvqdwwpdDh+9cjaF0QHQv/2wRhRGB6afdzkVkKZxtDoyVaqZBKCHEXygcXafjhi63l3G9tIEGzYe4ZKrksSbzmCqMEz6mzE+eedC+juaiUYqhZCPchgkqKB4SzxntqQEO7oceBu4srIzHIitsMTOBOMJ1leCkxAMmEpRWt6Vg8BGTConOxZeSVdfzmwxHmpvRtkJnFmHcuYksBkxH8tO69e1nJEd1sdhP/BBuUippfnA+3jsr5ZI9TnzV33mFcB/DuEi4LpFr/PPZu3LkanES08fOltWnxe2Ba5xCEPXiHEAVG2oMS9UNFTVINOXKdamn3nQdSC8HMMeYPVS+hkFzQdObl9m2Zu7+xt6hkKx5fXktGumdNXyZQUKiPZGkDbGnFxqp+kh9kaUHeUTezHr6WRkxt/oa/toT39Lby6QqMoci4BJDB8vpTtEdlkflf3A08AQ1ejoTM8cyeRnudYD72Zb+qokMhNZLuCJaqtZaqDLLi0i7EHYDVTV7oZW/J9PNf3wanfycLoki5nQSFnKewKrnW5NNMhtKRDlt6EsB+4G4vM2/UrUNd5w5Pl028FfiuJL9SQUyKrqEXXkaNyLF2o3N9vUYKB0AbAduKFSQWqVKFv0+rYfXdbx4aB3qqQLDk8VKCKaUSQNmi0F/ujAwB9RTYeAMwoXabg2QvZ5jl4ym8Ip6FjgDm7/bdl7bw3Ec/lItEJyWyAS0RJWsmC7I9WM45hJHCfo6e21dZlozlju3pjnSnRT0tMXHdFzT8dQ0EJoTr2eSXXs7W/uG/pnwiswBZQw5NXaYw5knJKXVY8p8VSP9vZo3cezp1v2nniDK9FD7V70RMxoaganGJmJT0+0frbtt+RPfVN/EQnLo9sxYEREB6wxxweHhwYL4/mo2kSqi43c5zRH8GS7Fz1shMZQJTg41PzVU7+2fdNZNHlBTgI5ER20qkPG2qGebHZsSTpULzJH8slCe6ywrWTlrGTM3tw9Ef/xjUzLvp6idIlwQtBxa2Sit6+/VCvMuu0MwIE726RBSqlViaDli6Gm4t6e1MQveet3Z4+F9cD7Ewo4WRJBbaaSAAAAAElFTkSuQmCC",
  red: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAATbHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZppchuxEUb/4xQ5AvYGjgOgG1W5QY6f10NKtmW5EieiTVLDIQbo5VswCvavf97wD37qyD3UJqPP3iM/ddaZF29GfP2s5znF+jw/P6W8P0u/Hg/5fTxmDvlJ7xNHf5//cTx9DvB6WbxrPw00zvuD/esHs77HH18Gel+o+Ix8FvoeaL4HKvn1QXoPsF7Lin0O+XkJ216v+rGS8fof/Ol+xEReL19/r0L0tHGdkrOVVCLP72CVXPx/CWXxpvGcS+XEVOR5H3mu5SMmBOS7OH3+TGZ0far125N+ycrnuy/ZekeApX3JVs3vU8qXIPfP12+Ph9S+z8oT+p+uXMf7Xf71+NgpvWb0JfpP8K+O+6yZVazaCXV/L+ozak9Srm4u4Zcegal1stOpocGrPyaPweIPpaDxxM3jpJky6bqpJk0r3WTP60mHKdZsIQtvcj65PAdHkTzzKZ6/6o90s5RZtAxyeZ6015I/55Key854wnO1wZU1cWpODJb4yl8/wt9+4V5vBQI8ntSnV35z9mAzDc+cP3MaGUn3HdT2BPjj8fXH81rIYPMoe4tMht6vIXZLP5CgPIkunNh4ffVgEn0PQIi4dGMyqZABspZKSz1FyVlSIpCDBC2m7j2zyUBqLSuTzLWUTm5G9kvzFUnPqbllDgeOA2ZkopVOnw0ytEhWrY36kTqoodVKq6213qSNNtvqpdfeeu/SHRSXFKlBmnQRGTJljTLqaKMPGWPMsWaeBdBss0+ZY865FtdcjLz49uKEtXbeZdfdwu5b9thzr0P5nHra6UfOOPMszVoU/NCuokOnLktGKVm1Zt3Ehk1bl1K7Jdx62+1X7rjzrs+svdP62+MvspbeWctPpvxE+cwaR0U+hkgOJ81zRsJyqImMi6eAgs6eszhSrdkz5zmLE/grLTPJ5jnT5Bkjg9VSbjd95C7kV0Y9c/9X3oLUX/KW/9fMBU/dX2bu97x9lzV1ED5Pxl5d6EGNhe7jnJUH/+jW31/D+83KPiEmlrd0ZremEblUT7eZm0BzexaimmXYgubnuEPvkbQGa9wthiOWrraVZNfSbR0D3dM5e18pXeZJJmnLWKdvldHSuKUOsxOt3bbTboUw2gyslJWdOaVdy9qByFHOHqbkHGo8yhf7pMzaZaS57phW01Jel0mrG5SmjUNddDez7oydWuXyM2lNdiFWXboPJVg7FGLzCt/lNwpH8zahiOZobe1kVcJOl4zlA+HOkZfx6ZCqda7d110dOqk5j555J51FiWZST5Qtdd1klCVRBYFSJPLQBhVUm0uIVsH9rLkAPGR3mNdLnms6F9jxCstcglo/til6U1v7hJm27l3rQ7HE7SzZVqiFqgKlzQ0BSa17KIOX6mWnnHzLOfToTkNLH9lgkXjuufNIsdmoM5nGyaSbACl51ihnS4t7TBrI9uikqdFIpLPGdaGkO4e2QBHMZEe8Ls6U6DWk+dBZ9VLGu98lM11aIjXjakwmrUP6KF24IvLlTbBSMKXAz7ibZFg6JtIZFqmoicKJlpnItETwSSfBphrjGTYkkzzqgArxS9wA7/o/amHMG4VpUQ4naZO6llRb63b19J1i3g9Lqy/ptx4Jf2yej95JmyqnPp40nD1FZ6eEE5GkmCLLXyizGgweEiqMDJ59WrKiWnajjLNcFMFdh/WCApcKnDU3Ymiqex46z4jy0O5rCny1U8sU44naDrlFlpBoiqK2FSlQEkHj0YlVtbmq2OSJIt9n3XKPnkuWEFrHx1cmu67wCdWWb26RPgIq6cbWQSCh7ae1mavXCLiYj//UCeia5L5SWHfOUy1nmsah0qgDFAnlMSvhAGM7iEUB9aZX4xO7Zb2Agc/b+D4UPt78/jq64wBC6Jaup8vuDiT7JCo/slSKKILbA1xMusPOqh2o3McIKmivFJLa3bxx2ChgFek5k49tFcrJazxJPZAlqmxVaMSQfstACssdyhDQIDJr+rfDSzfXCzFsBrte200pvE5xAkmDNjbIohNm5klmgx9YnSeanMqY5A/FTwObIRibOeDRqguEXKfVlYUsDBao9WTlykDd1C2A/6v6HDLrn8L19fWACeBm7jfSqwkmzehsIIaOBraQNtfrp43aAEzqpEvhK1NPFeC4qG2jkWBXunMnuOISRcCYsAdsF3O7fUNnujpInQp4DZ8KwV2FmvtIOsh0MU0/t5EmSrcCsRpAyod4KFVKDYGfrdIxkSyVp42oJ1W+RLmRdmi0Esc0V7UIzJJ//A+4FBq6GJDSNahvqK0ceqdOtLOlCY7I3aUpxTsUdtOZL6m/rVwjKAPk2qwfngswTfY1DlqXBA1y3zIyIc/qRPHoW5SIy37KpWFJjHxD3I6/c2bOA3y2hQ4pYTZgbjokXWhk5NuoOmZiZwI/XVUnUEJFcawCmm1Ta/tw3ZnakHNtNGbUWEmVz6sXlxuq5lNV4lOqIJuQU5QHEMeyooAIrnXphlkdMea0QBdhgMjIKxu4ijyOJsAkNkSA4nW3zegoRhLwGvsiwsZFjaA+vJ+Pgl41LFqKTBzKJzeY4y4K5XoNc7nis0wgQnLKo12glDFaehPgz6/h64EaExPNTwJAe1DE3wFUMBxd4DV7naTKl3PCl5MMxeG/EgQoy39r+w5UIWwAZ7wmNqNo/ZhYKgiEmkMjJViEcWAN4ggPgzAdfloCgu4iHEgRDTcRcXnedsSBlODF7lLlgOpER4KNup9IZKHakS9TXDhct95PHzZaH3cFI3KsEcHSDhw4pxZUZEFXqYrF0L1DQXjKGS3CVVwx8nDWQ8lEU9eXCBiEat99LPSlgWplOVQDS2NDg3WSNSQYde+YyYCuVZNkYNUgND126YEyidh4loQEG2DBs/cx8KWQNz0yTgqCTkMLmclevB/oQSuswMNCWvYAHh277jmLiswGO2w9Q1IplD35KTr5Hkwr71QA1z9KYTfXDe9ie6JJUVGMgMsSH6YhBvcTN5Z+bw/6BkhdiOf4X0Pk+Qpv4YVvn/BmtOy3CPg+A8gw+v/J82EJl0ikfsma0i508WtNQFu6GJ5nsZ7sTacCgBfB1FmObYVEFLW3GkrRWXPP3mc5A+7fEinK4mqRU5D8gGpdNjZaTx7lfU3nAo5S7q6ZuzncQWjEbqGSyCJeBLuCbu5dB2B0NAvwQyBz0dO4KqIKUmzL6q2DRavRClhgVIC4xaAFJtpuxYBysKndvZhDL1fAUIGdSPVI1pj/IDsdOKzaO8oQp+O6V3E/4NI4XnZr1TBg9+zyic6BWbfzLUlOLB6VgvGd9dJlG2R3DQsnLrRb6tTGFEK3xB7SD1RT3S59Z7c2jisR42rokoQEIGggP4WMs4k1IYD3cOfVdnNjhiKwU8dM8YaSfVVYkKt2aOTuqsgBZY7jUazQPnqrocQgNSYPRF9E+SvLGIzVnyRDRzT5U7xUMb2wAFgAhqoHIja8Y7WQRurG2vHdnqeq6N53vShmnb5r4SmYj8L506vjGsLOMErgHKOchXNdCpdq3QKvrjCj24kXD1E11zUiyyQP1MMjC1GiLD4NtFbhbGXGdkY8i7TXDL5BETfhadPCzeugxtwL4lmKYfiQ+XpIzLxwA9hIky+ggMIqYFfDmiPa8AX7XMRUP+GAPciSQmZh4Q3ckRH3wIhZAsCijAbKl3J+pBtLw3pYK7n4IYHuIwk8Qdyjb+veV3i3lQFXjE95i470ifEZ34URpc53BJVKlIXJwbJgCB41Ag71DFpSqxtLXgf2MW3cvBmvhAaOZEiIFY4AVBNM8UITXn7AS1iF7J6pAoWAjmh4y5Wmx51o7qBVgkfol4MYBDQ6qnu60cLlwDyLZYLAnBUqs8u49IqKPjh1RKKDN4iOh8DC90kXJ3xR8Z3IXSKZY8wTHxaiwMkIazyh4r9Gh4PQgzQ5mi1l/HgDodGAEMOgPtzPUKjxDvqs3BfQ2QO0J2IC73XMhu3pL5h3OK0uF1GF9tgFiBzAEbEjPTfS0cXuhVAaV2toiWcgvopYcMpGI0r0rdl00vNRBbx+vXb6+do4CCDx7s8BhYZKAbGVsYEF33o6xfVwbB6PDhm42oxaeA0Pis6BgJjTlTqIdcdjI5CuK9YAEKmrYea3ZUCxeBgkMLVzXT48dD4WLX4TigKZ1x4yfWTZoIw5Yfj9Abj/j9QD9LCQRHR8r8ZAtosh4YsTZzwE6+t04rsoc2+g1h5gIHF4+O1J7Vg+NGbz7SfwOlPzvqVFhJCQ4mnAXHYqSrG5AGNBbEqAGmFR7CdXyA2PXUBbZDh04fz6OMUM3MHoVfGpA62Ch3LlCzVgC7l8h8oDzdHdYxXflJvm2zGM3fYpvodExdcdIZQVxzzLN/gLhzHDXBEgfgFpqgumRYc6Z2AyvCqVChakJ3UFShQaws6WkvrLRGBZ2vdBDT8fmO5ZrS1WV7AY6aEvuGNBCy6dENU+H7cj+IjURXxTlPiK5oBpiACdbw2ydEwhPeXgVeb0ZnPzCSk4aFIe3c7D+pQqdIRsEnklqk/0kTRiCrR5Cwx7NlvcKcK/+C842Hscz4SUBV8uHsfcFaHWDgNiVHyPq2tg2I0GwSGsCArBXY9aaonlIA/89/xSTMxu0YksrZC3USmjxhTd1OydAjy7HAWjs35LiSTJJGK+1fLY/jYha/Vtoc6KLD7NAwjBqov6ivQQKv+1N5Lit2LeX0kyrAOWwx4Y324Y6Ta1Pfe28KB+o20SyxGKged8rR68DLyOIPFZ8CylJuyKu1OIFtC7cUjNvv1wXNFyGgVX0BpryQgwPEYaTYyRPB4XzBaiaPdjDIqGRRW4knDdjsiAkxdzpWuOpxqgQMMzl0uLjOmW/UD7ziKzeymC3sVo9mXbwe1RmQix8c2+EFYJ2pqhsAx6apOdEn2fGXY9rvHJmE1Ae+fyqD0sH6o6dwh1wtUz6c6+XccvEf4MCg1gEJAu+DwazG+DVNf1RCkDYkgs37VXmFBbf21t9YRme7YS1HcXi284Q9kfNGWse323t0VlvTrImQsPsQe6oMLeHd2EbPNN6ub3aUuCjRDEcgcWHxX+kvCkf/xHvW1E1jcoJZxauvcKydiCv48V37kWZQxtw4qJNODPVsIU+R44zQtroi0Be+hQX63ZyRriAqWJJEBGzKI6HJPsdjpG3Vc3onja7pSJW3QaDu/lW8PjGISJQeEi9QZyj2GseK/BcVrkzo6CmB6a4tMCg2mQY5Ir7qkXBGGv51Yy496L2SD5l4UJHQG9D4NFJC5gLAA8HHMB1ULcWPqjb/FcfCK03wHQM64NAO9+x/lQNAHAAX2YIPJ5gjLOmy259gcgyvU7L8idDkJ2yr1iWAUkKo7aIk9uF+QrKQAFiq4u8yDdIZJNQ+Ts+x2oKKSDb5VtVDdyAHQi/ANtRPG4NK/Z8W1ilCdNK4egJtQD80GKITglgrcAvDm7GAgUvenMrdOOvrlEwcpEut/RfSe/eJeHm6vvwhdX3gi1lwnEsNAm/jZX13mIJM+UrhGdBlhhvig38IwcJ8W9zsAUzqpRN4VOZ6jfC6b+sS/Y0+VtHOmH6PwKZYMjbnwus9HtO0/IURgRkxFYTHJapCqYIzWFN4BpySEpeKAeD6PzeaflxfmdVkq7ynBzOtqlqAW/BkrR0Y7mINvwbWv4iO6GSDPJHdmbG+xH+UW+DEnHia4hqdQ2ohfBna6CR8CN+u0CFILsuJOLZ99dv72NlBM1hBDGM8IP5TFZ/QAQhDXKyVAIySckQWg/67gP6hDcqVNQlTt3Z3Bp5Ksj2JAxfs+OKrZqmi8nKzhDDVK6ie+cEli83+7BM4qzhKseI23xey7482t4xHg1VjMBA+zFo89895p+Rfr4Ni6Ek+j4+ayNAovkBd00m7iCQrQSvXB97wCkxqsPopP00DnR7zRQIHs2uowUsjA8dPG/jrjS/UYoEgyM9Xs/FSUpLaAjORmgMNyebyyd3G82egkJ4rfESLTf/Lfie7SAK4GFZyh/GrsDyRW3gxoNiJjVkPK++Ygp9T1h3BB4xirxqpZXj7YAtoUcBcCwBRv9j0xh9EFhGOyOMwoO4rmNW/1GTWx0/FnUAZN0P19SxougYiS7BzkOfe63MH3Nd29lMhC6UvG0g7Pwn4sCXag3v1t6XXfn5RrBnc4hwNv3CiYVAk75nhTtZy6QhgFusIEE1Gf1sTiISULf0Q1Ukd8PtZuzAzk1bA2fbRAJUoZT0iWiKGNFpKKLerkngI3DN5P83tEsCCValn5tCSSoAFZ8NE5iZCGOFvnI2+fc0hSMyOP6hgheBC/JqM0XtzPY4ff3CcRZGFPQp+eT9FGVEXZAx5l6MPfTxBAh6p9mAdsCes1v4slb46vGhDSdrI7iP3whocfnC9FXoxzU/6gk3T51NDqRmqXEDBZpfvMByw0xUJeUSzQ5viPcMHg1uzxlzOnc9szCN1b5NBH44/uD8eVHwoMzBAdw5t/eZ7uSp4CG3yd2DETwEdbr9O8QEP3Wg28roCeRYRkHdKL6HzKxMGDwGRf0vRjBi75j7X6nFNW/ckp20Z7t7ZL6fRp0CBMDCbLfwU4hteMuyDWR35qZvpvj1ZDwnfkxnjWhUnmmRRqK67v2d+On/kdI/wa+GQTprDiGjAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNAHMVfU0tFKh0MUsQhQ3WyICriqFUoQoVQK7TqYD76BU0akhQXR8G14ODHYtXBxVlXB1dBEPwAcXVxUnSREv+XFFrEeHDcj3f3HnfvAK5ZVTSrZxzQdNvMpJJCLr8qhF8RQgxR8BiUFMuYE8U0fMfXPQJsvUuwLP9zf45+tWApQEAgnlUM0ybeIJ7etA3G+8S8UpZU4nPiMZMuSPzIdNnjN8YllzmWyZvZzDwxTyyUuljuYqVsasRTxHFV0ymfy3msMt5irFXrSvue7IWRgr6yzHSaw0hhEUsQIUBGHRVUYSNBq06KhQztJ338Q65fJJdMrgoUciygBg2S6wf7g9/dWsXJCS8pkgRCL47zMQKEd4FWw3G+jx2ndQIEn4ErveOvNYGZT9IbHS1+BES3gYvrjibvAZc7QOzJkEzJlYI0uWIReD+jb8oDA7dA35rXW3sfpw9AlrpK3wAHh8BoibLXfd7d293bv2fa/f0ASM5yljz/NiUAAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmI5YjA2YTAwLWZkOTQtNDc5MC1hNzIzLTlkMGUwNGRiNTRlNyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MTQ3ZGU5Yi1kOTA0LTRlNWYtYjIyYy0wZmMzOGRmMWI3ZGEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4YzBjNTI2YS1lYTkyLTQxYWItODM5Yy05OWFhYTM0YjdlYzciCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE2NDAxNTU0MjYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowMjQ4MDc5ZS1kMTYyLTQxZmItOGViYS1lMzY2NTRiNGRjMjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjIwOjQwKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PkaovgIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPFCiKn0kIAAAFfUlEQVRYw82YTWxc1RXHf+e+N2/GH+Px2IEEV02AgqIsIkwgoYS2ahepVGCBUOiCRRdsAAnECthErBBCICGFj4gqRQqBRSABUrVm1URtCSATJ5ASZCPHH0kGgx1/xJl5nvH7uIcFY4iIM/GzZyhHenqL994993/u+f/fOUeos+nNnkHCJoQWRD0UFzCARYhQCVB8NFWWTwNbT99SNxC3GZfIXg9sADYDWxCuRekEskARYQplFPgEOAr045ph6bXRzwKM3pEX5mduQLkHuAvYCqSW8GkIfAT0IBwknT8lH87o/w2M3mpSqL0LeLQKIrOMZSpVUC8hpkf6bPiTg9FbpBn0L8ATwLoqL5ZrFjgNPAeyV47p3E8GRjdLE6r3oTwHXF0n7ikwgfAEIvvlqJYbDkY3uw4a3YLyNrC2niJSBXQG4c+Ie0yORnGSj5OnRhzlUJ4ErrkikBAoAjPVe7ik4F6D8iRxlGvoyegmx4X4NwgHgM6a8fUyIfc8doZbf99Ca66N0uwF+v7tc3DnWoJK6gqep1C2g3NEjsdLlm03GXSbAe4GmmvGZ91vA3Y8P8aN6ztoyaYxxsPaNrbcnmbbvV/x9ONdnPnA+w71otaMcDfYPqDUmDQTUgjdNYPQsSHkgYf62di9mmwujzHNgIsxzWRzeTZ2r+aBh/rp2BDWDLLQjSzpf7VMMIpB6QKcy77Tuc6wdVsHbspbfJspj63bOuhcV8u3g9KFJtufWQbHakfLdQUv3YrI4qwQ+e65616Jr6mknE4KJgIGgctLZnEq5vRgAWsXLyKttZweLFCcqiW7cdVP1DgwQoQwUNPJxIDDG7vXMDszBvqjDWvM7MwYb+xew8SAUzNowgCSDEwyNVMJQU8AAdC06DvBtOG/76xirlLi3u0nufn2HJmWTir+FJ9+PMu7B66nr6eVYLpWCgUoJ0DCGoq3wv/MbXkhmlkN7Ad+XTMY4kBTl6XlKnA8IQ4U/xyUx8wlB3ZpKvcC23Hz49K79Ep6GeWM8VB7J8pfgasaUM6cAx5EzPvSZ4OGljNy1AYIh4C/L6lASWYBcBCHQ0mBJOfM94rk+WjwAsKvgN8te51LK7kPpm3zK89OrZH1v4zaQ9c4RJFrxDgAqjbSlBcpGqlqODoyWq5TP1OtnoU9wPqV9DMKWlRnfJ+/6q3XKpmhSRVbXU8uuhb6Hq1eVsBHdDiGQWPMuZV1mpuMB/aPCK8CXcsMjs6pufCm3/7PPZXs8LhKnJBjMTCH4f2VdIfIcRsgcgh4FpgkiY4u9Mwqc4fn2468M58dSQhkIbNcwBPVNrPSRJdjWgb2AK8BidrdSCX4PGw5/re53IlBK8uZ0EhVyodCq/1uXTTIzfrExZ0oq4H7gfQSmv54IMqcfNFv7/0ilkCSg1CgoKon1ZEv017ar9/cbEvGEFeuQ9mF8IdaBamFuBB7I7tKq3r+EXjnK0tPTxUoIzqqyCBooRIGM2NjX8d1HQIuKFys0cYY2eeJ3riYwinorHUndvmr3nt7Pj1eVNEa5LZALKIVrBTAnopVRx3HzOE44dDwsG3IRHPBxrtTnkv8p5yjLzvoLy72oaC+mvOvz+V79pZbRyYvJbwC80AFQ1GtPevAqFPxCuoxL57ql8ND2vDx7MVW2JTOuMQPdxDvSInmF/yU1ZT+Nd92eGcp97+RH4BE1XHHLDAtomPWmK8mpiYn/AvFOCmRGmLTm53WOOKpDhM/YqApQsLe+dYPnym1f9xvTVGQc8C4iE5Y1Ulj7eRQoTC7Ih1qFJiTQc7vwN9ZUbk6Z+ydp6L0Z2+Ws/uGrAyI8I2gF6yR0vDI6Uq9fDbsZACO3NQuGa3kr3XC7H+ClvJeP1/6IrbBqbNno0b4+xbMlmARngcRbAAAAABJRU5ErkJggg==",
  turquoiseBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAAQDHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZlrciO5joX/cxWzhCRB8LEckiAjZgez/PnAlD1drrpxu+/YUZJKSmWSwMF5pMP+n/8+4b/4yTHmkLW20kt5+Mk99zR40Z73Z9zH+OT7eH9EPp/FX98P6fP+k3jLD/oc2Mrn+K/34/cJ3qfBK/3Lidr6fDB//aDnz/nbjxN9LiS+Il+FfU7UPyeS9H4QPycY77ae0lv96xbmfp/tayft/Rf84XzVpL5PP/+fK9Uz5TqS0pYoD4+fYkkS/ydBBi+UxySZA6PU9/V9LJ+VUJA/1en7p7Oi40vNfzzol658v/rRrU8F2NqPbuX0OUR+FLl8P//x/RD1z125pf/LlXP7vEq/vr/k2e+KflT/Fv9YO3fP7GLkQqnLZ1NfW7yvOG5yCb90Cyyt0J0ChhrP/tv5bWx+AQV71jP5XbHHRLtOzNHiiCfu+7ziYok57ZAqL1JaSe6bTWrqifXSv+y/8aQqXUwaXVy37VnS91rivWx/VrhXa1zZIoemyMkiX/nHv+GffuEcH4UYvZbjrRXrSsmLzTK8c/7IYXQknk9R9Rb46/fnj/dV6KB6lX1EOqee7ymmxv9jArmNFg5Unt8ZjNU+J6BEXFpZTBQ6QNeiaCzxqSlVCEpSo0GDpfvMTDoQVZOxyJRFCr1pyS/NV2q8hyZNvB14HzKjEyqFOWt0aNCsnBX81NzA0FDRrKpFqzbtOoqUXLSUUouT4qhSc6haS6211V5Hk5abttJqa6230VMXSFN76bW33vsYXHNw5sG3BweMMdOUmaeGWWadbfY5FvBZeekqq662+hqWTAz+sGLVmnUbO26gtPPWXXbdbfc9DlA7Ek4+esqpp51+xnfXPm397fcfdC1+upZup/zA+t013q316xTR6US9ZzQshRzpePUWAOjkPXtazDl557xnT4f+RBOLVO+ZRe8YHcw7Jj3xq3chvR31zv2/+hZq/qVv6T/tXPDW/cPO/d63P3XNnITX7dg7hV7UR5g+Pt9tpDZc7H57Dl8vmBBZjQJKZuNivLe6qJ0KRa10Ri3sSNYUdlTSNhm2fHrW3q2WHUz5Uoy2+qhR1zpd42Kfqyg8pnJK5+GxtfY5jWIPR8pZTsbIJJvx55WD1SrglQsUYzWZesXZ6EkvyWy2BWNz5ii8eI4Oy0Oimkb6skc7bSy6pxpOdJYYfF/3mc9YVbJGen163LX5y4iCvNVAAtgR2sr6lTeca5byylbY04Zy0lkYmkRfF1ReNGUqriVaiyxjp7FhRh2DtvV1qia+03tuAKqzuDlD4XICE9HCqRXrsGVorgIPmcFOOteac6Su7GnsGruyokw9o4BjmR0ARLQ/jwP6BpXm2fXsKYML5BPnaTWtkxc79oIWNTBfe9+FB/A3Oe2s0XJfVYMAPuF6JY3l7goPEzen6iXzT9eoNnwSlc5YYkriFIq5D4N668YUQbg5qBuit6R/55niMfQdTow+0WNvrlaf1sLs3mChUH0c5PChozp06pmlnrJKn4+UbX1r7SOmvPuc0vZs2/wMjDgk0VtYqxjIM1dYscoJtGQYvTb2n5n30Tkf6BursV16Av77ZMB90ucZjDxYsOCHFZuw/1vDvlhJ2YKlPEbd6M9gX8Of00jJTeEY176YG8UDIkBnDqWu7YSyZCM+pjMmOzPXqic9Xsw0s7SV/vW4vs+h3T69/xsRhPcJA/Sdzz51OUPUep69F73eWyzNJidiM5NDYiJEZ04GNnB1WcvGinPN48iEv549+ZStTUt7SN8AY5cIG9bWk7bOPPaUgcRz+LSVmWDI8kBTtZh2O42TplnioNGx7n0YJGe0/MGpMZq1AeLCRxkQIcHZWtMZWkOYa88AP85ZhWvSFmu7zEatE3LewfssC3ZnGhI96iseCHaPafkLlUH/LhpjPVm8LgypZPNX44wGO2V4BWJzCQCLcAzitjMDL/VsLue27FlaJ3tjC3UIVH0aX20MX/5u6a6/UK2/lR05de6JOMTWtzzmBhEZYzQ5Tc+QRtkKC9YEqcF9A/RZKmUGwysy8sNYYWlXNWiILrihT3uAes1rQlP7OTTjHJGzo8IDA+YjV1BReKcFo2UGWgBGbZy/l2nQtwGauIVsUNEpOtFTNdaky7kYApqIyuqMhM7HAEsYYApVU0e+i1uMrCdDT3PpQT+o20OXgEPZwBKiy8REeBwv22wNhA5Bw0S4okzNG35mqDMMaVTl0jZunyl6QV/5IMFkSB8EhX0DGTOBi1E3FHh6YICd/fbZ4/06lbX8tzHBVIELRJmYhTI5dvUigxWcYq4Df0CDx70vPGi03hkp6OEsbTWM9+TQzpH22dKT0T0MjdSiEHJh5OJZggTYdLMzQTrDW3BGMmGpBZcF9X0z4AtKWwK71Mlw8mpfgj5HYVNo7UEJEzPBtxjkTEBt6xiDdAYsVyTggptVFBK7tJCwXhycUQBHmk9VZ/3J+pb3qKMXk1kDsJQHfRGmOO1mD64WS8OJ0Eeqv1D4zfekuw8Alrkkx9LjBMkc3TpyalBHtw5Xm1+VDScVdJByj0tUsFq2crIXUjrAbSZdLdHUDWjevuKdTvvuH+xOA8I2f1EAKCEsU6bqJ4QXzzao7UMTENho75h6mPnDc/jLGx7P0oco6u9EYdiMpB/YXNQAhxc37C0AG5j2d1zgmN99oAv7G39lrE2WwVFQSAFzbnfZdi/BBwI23hOlS9XNbWHOC2yaHOWQ9oTRCrS1eQCsRiZNyb0OeIoHcMQ9FRzlZgfXBoPgG/YqcPO5y4YO8EsTN94fJ4UOxYCqOfjFF1d8ImG042Oa7BbE+CgSfPkaACzizdHSzO8HQQSivWFjk/uYPAm08ML0Oxlj5EZNYNeJky5h4/oWxdnIP68xUhgQCmDb/TYGDPUfczW4nmnWYhgam4adQQ9nq24MODXIPlg1aQgIBmG4KYBBB/XDdGW3ZoYLVazkgYAIVFTlwK4oWesYQAwzSyS9Bwwc9beJo2LIKe9nhuPWn5j7E+S+ARf+NuJ+AI5xvnBboOjArMH78+INjoT6cnMQWNkJokBBi1tjvoBTcpOw0GLGKTvF6zLyB5RSqzEiWyhCQviNkiMvIpQOx4LrwlWnOuDTzs49wpNvcMOgHkfsdhrCByEJeJQAQAYxI/9cPgrQYWbsg7iGRgjlDKlb4Xckeidy0ioTqwt/kXRC58hFGsNjt4ovxYBjL5W8R/hT7XnW99wkrPYXxgYc+FmK293mkftBSbYluHaDfDay1ODagSwdcVET7CMc1zkXWy7L8wYA5IChD6II2pNLesCUUOmHHDST05V6iKiQq8PmoDmMeNcbZK6FWBVCpawscajPgdd3bJw/1UBI8UH1ysPGVCYlDDnj6tmki5t/5Jb7oL554rFh39P35a524lgrMIZUxqLORIcNkO7x/RXcZPyxGhIwZcMpmacKIm3vHoF2AEv6TCwP0XopjZ/uAeBiPC7ChlawzcowIPcoBGrObFFLl9TmbeE0fk8y/Abey4xQX2OPm2TjWefgu434eMCaE7EJlhrXcpAJ5sr1MLB+qkP21oEJngtlRWw20WXjJTHJfIOMRjlLYYc7ERNIxcL2ngjaKRDb3zm4D0JVkQ76ZejoBgasfHm8w+27PrWH/0ZoMvZ9PDrgEzzjEkOQzDnJbkQI1HJBrBNpg1bh54gCP57oSZoZzBG/1hJscm+5OwOcymQAn3kqafWSBWYU7/MR/H/57Gk5ne7UuGEn0+RqeW0SRBrZ8rM2bkQBoHtdbCbaCiHS3GevBXYqChEHkZM98k4io4Fq0ihehV0el5yi7vcsRCzHvmBbM4Oo4a4x9YohJUqwb6FgdoRVVSNIMP8kIi3drSHjMD0erTpCd1qn2+IAyR4Xn+OxoVV4EW9CcmBAS3FzARHEKOWgUXZ3TSn9Bpt/xqxBOeJI1a6CyMAwjRiF3/e/JahO+ALcwOUv1OKf3VvwF9jMhkhgPI3gb9uQQhJJzbXjfvMaxLbtaRxOwNgCb3X4uRYOiz7osgKpTT2ZiC2mA9JthP7l4XQXDvNIZH6Nx/1KvNcgGfl9pfVeY7x3uIN7qsn6VckwqA/DCE/hAwWjS0bT5PMFh6KIU2K5UgGJ/Ix+4YFxAUUpGO0Me16HlBLJ7N7AQusY3EcIWpSY/uKmPCBwIAFCvQYH4Sq0P7IYOMwnxzWcdIWHncQITB62vKWGnQbwwIIh89FHLkkihUyJojCjWwnCoSMnqNp+Ch1HL15exsqP9K8hT6ZgXSU7pmveB8AGGhsxIxlEyHRUR3cGFd8hfjvtNrz92ygnOfjoHMkd29zd1JwEFSO/SCM5lh17sqkGRs7usAhuExZRQktLhdkDmdiGOJg1RK3xBb/1jrvVxQA0D7/QbBloVoU3K/pM/Ohk1Qaj8QVcNmkrI0FV3QSH6Dcw8A5GhK24M4zXqUJ92Tk05ARIVVudK89Xbcltox5yHiNKxriMivWDmO/UTi/bMKIGLoOeM0TEp1z9htwS1HXZ5c5l8EYb+G+mFgEnw/UmWgJenLHN08Coma6DCSK7em/xWlxCM3XiubnDtT08jiIgBFVwljwbIIS6gjMmRtygIiwfowtA/G9kD21jsjGMrXa/fSBQYuxsTByznPXeSirOK3q7VisGrAOqjgQwRMAcYSSn5ERQfKN0QqVcZ5YyKPgX9sls0HlmaeJ8KromfhsYSNjoiZHmlExMo4iwUqrYCl+y3HtnfmNQi9f5yJWlV4OH5YUc0dd7/39TXvB8ovgND7Sdo/e9twbhx/fmZU7YeMcrEsCM0TDfzGyM9AxM+IgMBLI9JsPKaY+TeInkhPeW30IgFsQJbPrUODmW2UTFoTGuACs4sW1K0akJGvg1Cf/+ZtHnmbX67RbAU2uwXvYoDS8GzzKM5LRNYql+H/NQs4gJEjDb88GPp/sXRsyH39RdW+vohMhra6bf0T0EU4pL1EBKRvV8yMCw/e5BHtJwrJAeico3PhZTupL9jk71O511WcC+53vPadEifNmqD/6+Ca1a+B57arkpfxFk/S4oBApPH1aOizMC7lK/D7cCm8Gpmdv8LMsTKPbUoy1mXBbBt/uYUu7kt8X4iEBJVtkKezRr12rliBml/GgfMnphhinBrj0+tkwZfgmFOlagbcwpjomMXOgZY+i+WTBVpb6OMbB3ZnOgIMktAhxTMxLpZXCJvwYdgJdOAiLLEXEflQefJrV5ANNaUX5MRN1kPYPqoWe/TcPEkUmoDPyNRmNehZrh+bo7Yohe/P4KKbNMwW7XxCDD7hYmLI3RhiJ8hjBiC6vitzy3/9nFcwD2X+tecsqjzW1bh3oWs0z623xJIO5TgydMFMUaXh1X4RiCLcheaIZHJKDKqm4NMcBcTmjxGP3GAdIIVtIepjocEsqDaI07Tyi2npk9YovfGDpzY4E8CST/O91aOT5FPS24MRIS9Ze+hF+Ehmaa/4H7fwGCg3GYVGiblAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNQFIVPW0tFKx3sUMQhQ3WyICriqFUoQoVQK7TqYPLSP2jSkKS4OAquBQd/FqsOLs66OrgKguAPiKuLk6KLlHhfUmgR44PL+zjvncN99wH+ZpWpZs84oGqWkUklhVx+VQi9IogYIlT9EjP1OVFMw3N93cPH97sEz/K+9+caUAomA3wC8SzTDYt4g3h609I57xNHWVlSiM+JxwxqkPiR67LLb5xLDvt5ZtTIZuaJo8RCqYvlLmZlQyWeIo4rqkb5/pzLCuctzmq1ztp98heGC9rKMtephpHCIpYgQoCMOiqowkKCdo0UExk6T3r4hxy/SC6ZXBUwciygBhWS4wf/g9+zNYuTE25SOAkEX2z7YwQI7QKthm1/H9t26wQIPANXWsdfawIzn6Q3Olr8CIhsAxfXHU3eAy53gNiTLhmSIwWo/MUi8H5G35QHBm+BvjV3bu1znD4AWZpV+gY4OARGS5S97vHu3u65/XunPb8fN2tyj8UDOK0AAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjEwNGNlNWFhLTE1YzctNGI4Yi1iOGU1LTFmYWQyNWFiYzBhZCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkNDMyZTY1Zi0xOThhLTQxM2EtYWYyMy1jNzhlNzczNGRlN2QiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyNzExODVkMi03MWZiLTRhZDMtYTJmMi1iNjM3OWU3MDc1OTEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE4NjYyMzgzMjQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1NGFiYzNkYS1lZWJiLTRlZjctYjdjNS04ZDRjODY5OGVjODMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI0OjI2KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pj0tlUwAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGBru/VeEAAAABmJLR0QA/wD/AP+gvaeTAAAFO0lEQVRYw9WYe2xTVRzHTx97dYS5B1UHa+/tY12dDoOKWyIGlfgHkCkSNTHGwHxA3NiAP/A5x4CMKEzdYL29YyAyBxKQZbI+NvYIaowaH9Ogi2GRbGjcFrbBNrq2a2/9nq5LCFnbbfSOeZJPTs/t6Tm/7/39zu+cU0IiXc7WSImNX0BsZiVYAhigmah5tHklsZrjSYtJSuZtaeSiiJU3gHUwfC9oARfBIHBP1DzaPH1eRuzmp0E6aTgSNX9EWMwSvOkMGPgG+CpguG8a0H7nA78zkMYqye0V0lYXDSHrYUw7cE5TxM04/b+38+vJ+RPRt0eIjVeAAhhyCQizFDKJEBjndaCY49Di4+CRlzFxfwSE3Ciol9i4DSBujoRUy7HIszFxdwSF3CioBy8qm1g5ufhirHwyJqwHrrDGWTlg8hFL1URN2+EF0XFPkyYuSWwhUVgnT2CygXBG3dFcM7bz1/au1u7OK9/93eWidUlHe1dCc810EsUAsXOPQZCI3rGZ6Wb4EXAEM0SCUFnZduz6T/09l4bHXYOCz+f0+XxeWg+7XYM/4vnKtlqHJHSIOrAHlYMFYmawRNCKycaDGZLVfMRdf/nPDpfXM+abotDnpy93dtzXfNgdZg+im2uimJ6h66UTeIMZsrat1jvkdPRRb/imLt4hl6N3DfqFEIPvOMzDJYspJsWfbUKEyFNttcKoyzkKo4UgYoRRt3OE9guT1br984nsmQ7gCWbIipaj4xeu9v/hFQTPlG7B89+u9v9O+4UQQ8f/BSlaVM8kgBOhji4p9mpvwQ+Wfwddjp6bQw2u8g44HT3535/tTUa/0Eccvg4sFDE1m2PBZkx2LVRqVcLQvG/PDDX1/tVxze38x+UZH6O1He28b764qgwtxOcf327eBGLFE9NikiD3qzDZhVBJgCJH3KubDnkfbD4s5Jw74qM1bcvDnxq8/vHt1SrS9InIJ2m7OQ4UYsKhCB9lJqHj0gPsHJzPvsS9w8rRRPDptI40M8PlH9fOJ5M5K008rsZmIwi5gc4QN9Zja8zn+5epch9PTFepU1iGuVunVqeyS9g0iv8zy96l0WiSjIsXx28iJEJhaONkMGB5YP14bkmI1SzIz1T0pRa9VKnNzCjUMcwWUAS2BtgWYLJN+xTo1OyrOhW7xsAwqnSGkd3i+uGjkT5Xw6DLt3AdEKQNB4YXbdtwQpuVuRtG7pwhxWA7vJgRib0nDuSDvtkIkjYcHE3aVWjRLL9/zyyETPK2Vq3OidAaOhiPDLcbxo3MRIik0eReWPnO15pHHiqbpYhS6hkNw7wAz0To6GM5hAzH3wkDa6b7x4bEwnkUfMnP6idX7Nex7GxElIDNerV6hU6jSdbp9RHck2w0w/FaGGoJm7KtnCfmWNlF1fOrK3Q6bekMRFABO7QM8yxewFLUi+5JSxPpAmcxy0gjt1Rytir4NcHKCfJTH/al5j1j1hr0pWEML55YD+x2GP6cVqNZZjQYEvUsG4vP4v8jKju5L1p6qnytxGKa6qogyOorBpVbXvxMe69xdxABb9I0DAGvIIRWp7NsBsJIoWVZKfaXuf+jMKp2b6z8+Adb4aErNwpCCh5J2pnfoH0ga08g7invBfaQjXjjuQifhyEgLdNolJP5UqR17y+QnSwvk1i565OZK6F8RzubvWwvDH8LvKZnmHXY8HKws+sNLJtI5muJ/7hYElOzJ1V+fN9R7CVDClPJOVXuqo06vS4HQjTwgDKDZRXk/1JiD7wrieFLk6T1lczCXUVK7aPZinS9XrTw+Q+Tql7SUmvGuQAAAABJRU5ErkJggg==",
  defaultOffset: [-25.5, -32]
};
var Markers_default = Marker;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/ColorUtils.js
var ColorUtils = {
  /**
   * Number to hex conversion
   *
   * @param {Number} number - 0-255
   * @returns {String} hex value
   */
  hex: function(number) {
    if (number > 255) {
      throw new Error("'" + number + "'' is greater than 255(0xff);");
    }
    var str = Number(number).toString(16);
    return ("0" + str).slice(-2);
  },
  /**
   * Hexa to number conversion
   *
   * @param {*} hexa 00-FF
   * @returns {Number} number value
   */
  num: function(hexa) {
    return parseInt(hexa, 16);
  },
  /**
   * Converts an array ([255,255,255,1]) to rgba string
   *
   * @function arrayToRgba
   * @param {Array} values - array of values
   * @returns {String} A color of RGB or RGBA format
   */
  arrayToRgba: function(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3] || 1;
    var result = "rgba(" + red + ", " + green + ", " + blue + ", " + parseFloat(alpha) + ")";
    return result;
  },
  /**
   * Converts an array ([255,255,255,1]) to #RRGGBBAA
   *
   * @function arrayToHex
   * @param {Array} values - array of values
   * @returns {Object}  hex and opacity formated values
   */
  arrayToHex: function(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts rgba string to #RRGGBBAA
   * (Code adapted from : https://gist.github.com/mstssk/afda4ce9e5c335fd79cd)
   *
   * @function rgbaToHex
   * @param {String} rgba - A color of RGB or RGBA format.
   * @returns {Object} hex and opacity formated values
   */
  rgbaToHex: function(rgba) {
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(rgba);
    if (!parsed) {
      throw new Error("Invalid format: " + rgba);
    }
    var red = parsed[1];
    var green = parsed[2];
    var blue = parsed[3];
    var alpha = parsed[4];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts hex color and opacity value to rgba string.
   * (Code adapted from : http://stackoverflow.com/a/5624139)
   *
   * @function hexToRgba
   * @param {String} hex - A color value on RGB format (hexa).
   * @param {Number} opacity - A opacity value.
   * @returns {String} A color of RGB or RGBA format
   */
  hexToRgba: function(hex, opacity) {
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (!hex) {
      throw new Error("Invalid format");
    }
    hex = hex.replace(shorthandRegex, function(m2, r2, g, b3) {
      return r2 + r2 + g + g + b3 + b3;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    rgb = rgb ? {
      r: parseInt(rgb[1], 16),
      g: parseInt(rgb[2], 16),
      b: parseInt(rgb[3], 16)
    } : null;
    var result = rgb ? "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + opacity + ")" : null;
    return result;
  },
  /**
   * Determine if value is a correct hexa color.
   * @param {*} value - hex color (#FFFFFF)
   * @returns {Boolean} True if value is a hexa color
   */
  isHex: function(value2) {
    if (!value2) {
      return false;
    }
    if (value2.charAt(0) !== "#") {
      return false;
    }
    var regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var parsed = regex.exec(value2);
    if (!parsed) {
      return false;
    }
    return true;
  },
  /**
   * Determine if value is a correct rgba color.
   * @param {*} value - rgba color (rgba(125,125,125,1))
   * @returns {Boolean} True if value is a rgba color
   */
  isRGB: function(value2) {
    if (!value2) {
      return false;
    }
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(value2);
    if (!parsed) {
      return false;
    }
    return true;
  }
};
var ColorUtils_default = ColorUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Formats/Styling.js
var logger3 = LoggerByDefault_default2.getLogger("styling");
Feature_default.prototype.setPropertyFill = function() {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var fill = style.getFill();
  if (fill) {
    var colorFill = fill.getColor();
    if (Array.isArray(colorFill)) {
      var cf = "rgba(";
      cf += colorFill[0] + ",";
      cf += colorFill[1] + ",";
      cf += colorFill[2] + ",";
      cf += colorFill[3] + ")";
      colorFill = cf;
    }
    if (ColorUtils_default.isRGB(colorFill)) {
      var oColorFill = ColorUtils_default.rgbaToHex(colorFill);
      this.set("fill", oColorFill.hex);
      this.set("fill-opacity", oColorFill.opacity);
    } else {
      this.set("fill", colorFill);
      this.set("fill-opacity", 1);
    }
  }
};
Feature_default.prototype.setPropertyStroke = function() {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var stroke = style.getStroke();
  if (stroke) {
    var colorStroke = stroke.getColor();
    if (Array.isArray(colorStroke)) {
      var cs = "rgba(";
      cs += colorStroke[0] + ",";
      cs += colorStroke[1] + ",";
      cs += colorStroke[2] + ",";
      cs += colorStroke[3] + ")";
      colorStroke = cs;
    }
    if (ColorUtils_default.isRGB(colorStroke)) {
      var oColorStroke = ColorUtils_default.rgbaToHex(colorStroke);
      this.set("stroke", oColorStroke.hex);
      this.set("stroke-opacity", oColorStroke.opacity);
    } else {
      this.set("stroke", colorStroke);
      this.set("stroke-opacity", 1);
    }
    this.set("stroke-width", stroke.getWidth());
  }
};
Feature_default.prototype.setPropertyLabel = function() {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var isName = this.get("name") !== void 0;
  var label = style.getText();
  if (label && isName) {
    var fill = style.getText().getFill();
    if (fill) {
      var colorFill = fill.getColor();
      if (Array.isArray(colorFill)) {
        var cf = "rgba(";
        cf += colorFill[0] + ",";
        cf += colorFill[1] + ",";
        cf += colorFill[2] + ",";
        cf += colorFill[3] + ")";
        colorFill = cf;
      }
      if (ColorUtils_default.isRGB(colorFill)) {
        var oColorFill = ColorUtils_default.rgbaToHex(colorFill);
        this.set("label-fill", oColorFill.hex);
        this.set("label-fill-opacity", oColorFill.opacity);
      } else {
        this.set("label-fill", colorFill);
        this.set("label-fill-opacity", 1);
      }
    }
    var stroke = style.getText().getStroke();
    if (stroke) {
      var colorStroke = stroke.getColor();
      if (Array.isArray(colorStroke)) {
        var cs = "rgba(";
        cs += colorStroke[0] + ",";
        cs += colorStroke[1] + ",";
        cs += colorStroke[2] + ",";
        cs += colorStroke[3] + ")";
        colorStroke = cs;
      }
      if (ColorUtils_default.isRGB(colorStroke)) {
        var oColorStroke = ColorUtils_default.rgbaToHex(colorStroke);
        this.set("label-stroke", oColorStroke.hex);
        this.set("label-stroke-opacity", oColorStroke.opacity);
      } else {
        this.set("label-stroke", colorStroke);
        this.set("label-stroke-opacity", 1);
      }
      this.set("label-stroke-width", stroke.getWidth());
    }
    this.set("label-font", style.getText().getFont() || Styling.DEFAULT_TEXT.font);
    this.set("label-textAlign", style.getText().getTextAlign() || Styling.DEFAULT_TEXT.textAlign);
  }
};
Feature_default.prototype.setPropertyMarker = function() {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var image = style.getImage();
  if (image) {
    if (image instanceof Icon_default) {
      var color = image.getColor();
      if (Array.isArray(color)) {
        var c = "rgba(";
        c += color[0] + ",";
        c += color[1] + ",";
        c += color[2] + ",";
        c += color[3] + ")";
        color = c;
      }
      if (color) {
        var colorIcon = ColorUtils_default.rgbaToHex(color);
        this.set("marker-color", colorIcon.hex);
      }
      var scaleIcon = image.getScale();
      switch (Math.round(scaleIcon * 2) / 2) {
        case 0:
        case 0.5:
          this.set("marker-size", "small");
          break;
        case 1:
          this.set("marker-size", "medium");
          break;
        case 1.5:
        case 2:
          this.set("marker-size", "large");
          break;
        default:
          break;
      }
      var srcImage = image.getSrc();
      if (srcImage) {
        this.set("marker-symbol", srcImage);
      }
      this.unset("circle-fill");
      this.unset("circle-fill-opacity");
      this.unset("circle-stroke");
      this.unset("circle-stroke-width");
      this.unset("circle-stroke-opacity");
      this.unset("circle-radius");
    } else {
      var fillImg = image.getFill();
      if (fillImg) {
        var colorFillImg = fillImg.getColor();
        if (Array.isArray(colorFillImg)) {
          var cfi = "rgba(";
          cfi += colorFillImg[0] + ",";
          cfi += colorFillImg[1] + ",";
          cfi += colorFillImg[2] + ",";
          cfi += colorFillImg[3] + ")";
          colorFillImg = cfi;
        }
        if (ColorUtils_default.isRGB(colorFillImg)) {
          var oColorFillImg = ColorUtils_default.rgbaToHex(colorFillImg);
          this.set("circle-fill", oColorFillImg.hex);
          this.set("circle-fill-opacity", oColorFillImg.opacity);
        } else {
          this.set("circle-fill", colorFillImg);
          this.set("circle-fill-opacity", 1);
        }
      }
      var strokeImg = image.getStroke();
      if (strokeImg) {
        var colorStrokeImg = strokeImg.getColor();
        if (Array.isArray(colorStrokeImg)) {
          var csi = "rgba(";
          csi += colorStrokeImg[0] + ",";
          csi += colorStrokeImg[1] + ",";
          csi += colorStrokeImg[2] + ",";
          csi += colorStrokeImg[3] + ")";
          colorStrokeImg = csi;
        }
        if (ColorUtils_default.isRGB(colorStrokeImg)) {
          var oColorStrokeImg = ColorUtils_default.rgbaToHex(colorStrokeImg);
          this.set("circle-stroke", oColorStrokeImg.hex);
          this.set("circle-stroke-opacity", oColorStrokeImg.opacity);
        } else {
          this.set("circle-stroke", colorStrokeImg);
          this.set("circle-stroke-opacity", 1);
        }
        this.set("circle-stroke-width", strokeImg.getWidth());
      }
      var radius = image.getRadius();
      this.set("circle-radius", radius);
    }
  }
};
var Styling = {
  /**
   * Options to convert geometry
   */
  APPLY_CONVERT_GEOM_GPX: true,
  /**
   * Default icon style options
   */
  DEFAULT_ICON: {
    src: Markers_default["lightOrange"],
    anchor: [0.5, 1],
    scale: 1
  },
  /**
   * Default circle style options
   */
  DEFAULT_CIRCLE: {
    radius: 10,
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    },
    stroke: {
      width: 1,
      opacity: 1,
      color: [0, 0, 0, 1]
    }
  },
  /**
   * Default stroke style options
   */
  DEFAULT_STROKE: {
    width: 5,
    opacity: 1,
    color: [250, 250, 250, 1]
  },
  /**
   * Default fill style options
   */
  DEFAULT_FILL: {
    opacity: 1,
    color: [0, 0, 0, 1]
  },
  /**
   * Default text style options
   * @see https://openlayers.org/en/v6.15.1/apidoc/module-ol_style_Text-Text.html
   */
  DEFAULT_TEXT: {
    font: "16px sans",
    textAlign: "left",
    stroke: {
      color: [250, 250, 250, 1],
      width: 5,
      opactity: 1
    },
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    }
    // offsetX
    // offsetY
    // placement
    // scale
    // rotation
    // justify
    // padding
  },
  /**
   * All styling tags
   * @function getListTags
   * @returns {Array} all styling tags
   * @example
   * "type", // type de geometrie
   * "fill",
   * "fill-opacity",
   * "stroke",
   * "stroke-opacity",
   * "stroke-width",
   * "circle-fill",
   * "circle-fill-opacity",
   * "circle-stroke",
   * "circle-stroke-opacity",
   * "circle-stroke-width",
   * "circle-radius",
   * "marker-symbol",
   * "marker-color",
   * "marker-size"
   */
  getListTags: function() {
    return [
      "type",
      "fill",
      "fill-opacity",
      "stroke",
      "stroke-opacity",
      "stroke-width",
      "circle-fill",
      "circle-fill-opacity",
      "circle-stroke",
      "circle-stroke-opacity",
      "circle-stroke-width",
      "circle-radius",
      "marker-symbol",
      "marker-color",
      "marker-size",
      "label-fill",
      "label-fill-opacity",
      "label-stroke",
      "label-stroke-width",
      "label-stroke-opacity",
      "label-font",
      "label-textAlign"
    ];
  },
  /**
   * Transform feature properties to a native style
   *
   * @function defineStyleFromProperties
   * @param {*} feature - ...
   * @returns {*} style - ...
   * @public
   *
   * @description
   * A la lecture du format :
   * > tag styling ---> feature properties ---> feature style
   *
   * Les balises de 'styling' du fichier sont ajoutÃ©es dans les properties de chaque features
   * (opÃ©ration native sous OpenLayers):
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",      -> feature.get("stroke");
   *    "stroke-width": 13,       -> feature.get("stroke-width");
   *    "stroke-opacity": 0.8,    -> feature.get("stroke-opacity");
   *    "fill": "#a03737",        -> feature.get("fill");
   *    "fill-opacity": 0.5       -> feature.get("fill-opacity");
   * }
   * ```
   *
   * Ensuite, les properties des features sont transformÃ©es dans le style natif :
   *
   * ```js
   * // Ex.
   * feature.setStyle(new Style({
   *  fill : new FillStyle({
   *      color : Color.hexToRgba(feature.get("fill"), feature.get("fill-opacity") || 1)
   *  }),
   *  stroke : new StrokeStyle({
   *      color : Color.hexToRgba(feature.get("stroke"), feature.get("stroke-opacity"))
   *      width : feature.get("stroke-width")
   *  })
   * }));
   * ```
   */
  defineStyleFromProperties: function(feature) {
    var style = null;
    var options = {};
    var marker = null;
    if (feature.get("marker-color") || feature.get("marker-size") || feature.get("marker-symbol")) {
      marker = {};
      marker["src"] = this.DEFAULT_ICON.src;
      marker["anchor"] = this.DEFAULT_ICON.anchor;
      var symbolMarker = feature.get("marker-symbol");
      if (symbolMarker) {
        if (symbolMarker.search("data:image/png;base64") !== -1) {
          marker["src"] = symbolMarker;
        } else {
        }
      }
      var colorMarker = feature.get("marker-color");
      if (ColorUtils_default.isHex(colorMarker)) {
        marker["color"] = ColorUtils_default.hexToRgba(colorMarker, 1);
      }
      var size = feature.get("marker-size");
      if (size) {
        switch (size) {
          case "small":
            marker["scale"] = 0.5;
            break;
          case "medium":
            marker["scale"] = 1;
            break;
          case "large":
            marker["scale"] = 1.5;
            break;
          default:
            marker["scale"] = this.DEFAULT_ICON.scale;
            break;
        }
      }
    }
    var stroke = null;
    if (feature.get("stroke") || feature.get("stroke-opacity") || feature.get("stroke-width")) {
      stroke = {};
      stroke["color"] = ColorUtils_default.hexToRgba(feature.get("stroke"), +feature.get("stroke-opacity") || this.DEFAULT_STROKE.opacity);
      stroke["width"] = +feature.get("stroke-width") || this.DEFAULT_STROKE.width;
    }
    var fill = null;
    if (feature.get("fill") || feature.get("fill-opacity")) {
      fill = {};
      fill["color"] = ColorUtils_default.hexToRgba(feature.get("fill"), +feature.get("fill-opacity") || this.DEFAULT_FILL.opacity);
    }
    var labelStroke = null;
    var labelFill = null;
    var isLabel = feature.get("name") !== "";
    if (isLabel) {
      if (feature.get("label-fill") || feature.get("label-fill-opacity")) {
        labelFill = {};
        labelFill["color"] = ColorUtils_default.hexToRgba(feature.get("label-fill"), +feature.get("label-fill-opacity") || this.DEFAULT_TEXT.fill.opacity);
      }
      if (feature.get("label-stroke") || feature.get("label-stroke-opacity") || feature.get("label-stroke-width")) {
        labelStroke = {};
        labelStroke["color"] = ColorUtils_default.hexToRgba(feature.get("label-stroke"), +feature.get("label-stroke-opacity") || this.DEFAULT_TEXT.stroke.opacity);
        labelStroke["width"] = +feature.get("label-stroke-width") || this.DEFAULT_TEXT.stroke.width;
      }
    }
    var circleRadius = feature.get("circle-radius") || this.DEFAULT_CIRCLE.radius;
    var circleStroke = null;
    if (feature.get("circle-stroke") || feature.get("circle-stroke-opacity") || feature.get("circle-stroke-width")) {
      circleStroke = {};
      circleStroke["color"] = ColorUtils_default.hexToRgba(feature.get("circle-stroke"), +feature.get("circle-stroke-opacity") || this.DEFAULT_CIRCLE.stroke.opacity);
      circleStroke["width"] = +feature.get("circle-stroke-width") || this.DEFAULT_CIRCLE.stroke.width;
    }
    var circleFill = null;
    if (feature.get("circle-fill") || feature.get("circle-fill-opacity")) {
      circleFill = {};
      circleFill["color"] = ColorUtils_default.hexToRgba(feature.get("circle-fill"), +feature.get("circle-fill-opacity") || this.DEFAULT_CIRCLE.fill.opacity);
    }
    if (feature.getGeometry()) {
      var type = feature.getGeometry().getType();
      switch (type) {
        case "Circle":
        case "Point":
        case "MultiPoint":
          var isCircle = false;
          var optionsCircle = {};
          if (circleStroke) {
            optionsCircle["stroke"] = new Stroke_default(circleStroke);
          }
          if (circleFill) {
            optionsCircle["fill"] = new Fill_default(circleFill);
          }
          if (Object.keys(optionsCircle).length !== 0) {
            isCircle = true;
            optionsCircle["radius"] = +circleRadius;
            options["image"] = new Circle_default2(optionsCircle);
          }
          if (marker) {
            options["image"] = new Icon_default(marker);
          }
          if (isLabel) {
            var optionsText = {};
            if (labelStroke) {
              optionsText["stroke"] = new Stroke_default(labelStroke);
            }
            if (labelFill) {
              optionsText["fill"] = new Fill_default(labelFill);
            }
            if (Object.keys(optionsText).length !== 0) {
              optionsText["text"] = feature.get("name");
              optionsText["textAlign"] = feature.get("label-textAlign") || this.DEFAULT_TEXT.textAlign;
              optionsText["font"] = feature.get("label-font") || this.DEFAULT_TEXT.font;
              options["text"] = new Text_default(
                Object.assign(
                  {},
                  this.DEFAULT_TEXT,
                  optionsText
                )
              );
            } else {
              if (marker || isCircle) {
                var styleText = new Text_default(
                  Object.assign(
                    {},
                    this.DEFAULT_TEXT,
                    {
                      fill: new Fill_default(this.DEFAULT_TEXT.fill),
                      stroke: new Stroke_default(this.DEFAULT_TEXT.stroke)
                    }
                  )
                );
                if (styleText) {
                  var cloneStyleText = styleText.clone();
                  cloneStyleText.setText(feature.get("name"));
                  options["text"] = cloneStyleText;
                }
              }
            }
          }
          break;
        case "Polygon":
        case "MultiPolygon":
          if (stroke) {
            options["stroke"] = new Stroke_default(stroke);
          }
          if (fill) {
            options["fill"] = new Fill_default(fill);
          }
          break;
        case "LineString":
        case "MultiLineString":
          if (stroke) {
            options["stroke"] = new Stroke_default(stroke);
          }
          if (this.APPLY_CONVERT_GEOM_GPX && fill) {
            var initType = feature.get("type");
            if (initType && (initType === "Polygon" || initType === "MultiPolygon")) {
              options["fill"] = new Fill_default(fill);
              var f = feature.clone();
              var ClassPoly = type === "LineString" ? Polygon_default : MultiPolygon_default;
              feature.setGeometry(new ClassPoly([f.getGeometry().getCoordinates()]));
            }
          }
          break;
        default:
          break;
      }
    }
    if (Object.keys(options).length !== 0) {
      style = new Style_default(options);
    }
    return style;
  },
  /**
   * Define a default style function to apply to a feature
   *
   * @function defineStyleFunctionByDefault
   * @param {Object} defaultStyle - ...
   * @returns {Function} style function
   * @public
   *
   * @description
   * ...
   */
  defineStyleFunctionByDefault: function(defaultStyle) {
    if (!defaultStyle) {
      return [];
    }
    if (Object.keys(defaultStyle).length === 0) {
      return [];
    }
    var styleFunction = (feature, resolution) => {
      if (feature.getGeometry()) {
        var style = null;
        var type = feature.getGeometry().getType();
        switch (type) {
          case "Point":
          case "MultiPoint":
            var opts = {};
            if (defaultStyle.getImage()) {
              opts["image"] = defaultStyle.getImage();
            }
            if (defaultStyle.getText() && feature.get("name")) {
              var styleText = defaultStyle.getText().clone();
              styleText.setText(feature.get("name"));
              opts["text"] = styleText;
            }
            style = new Style_default(opts);
            break;
          case "Circle":
            var optsc = {};
            var optsCircle = {};
            if (defaultStyle.getFill()) {
              optsCircle.fill = defaultStyle.getFill();
            }
            if (defaultStyle.getStroke()) {
              optsCircle.stroke = defaultStyle.getStroke();
            }
            if (defaultStyle.getText() && feature.get("name")) {
              var styleTextCircle = defaultStyle.getText().clone();
              styleTextCircle.setText(feature.get("name"));
              optsc.text = styleTextCircle;
            }
            if (Object.keys(optsCircle).length !== 0) {
              optsCircle.radius = 3;
              optsc.image = new Circle_default2(optsCircle);
            }
            style = new Style_default(optsc);
            break;
          case "Polygon":
          case "MultiPolygon":
            var optsp = {};
            if (defaultStyle.getFill()) {
              optsp.fill = defaultStyle.getFill();
            }
            if (defaultStyle.getStroke()) {
              optsp.stroke = defaultStyle.getStroke();
            }
            style = new Style_default(optsp);
            break;
          case "LineString":
          case "LinearRing":
          case "MultiLineString":
            var optsl = {};
            if (defaultStyle.getStroke()) {
              optsl.stroke = defaultStyle.getStroke();
            }
            style = new Style_default(optsl);
            break;
        }
        return [style];
      }
    };
    return styleFunction;
  },
  /**
   * Transform a native style to feature properties by type of geometry
   *
   * @todo not yet implemented !
   * @param {*} feature - feature
   */
  definePropertiesFromStyleByType: function(feature) {
    if (feature.getGeometry()) {
      var geomType = feature.getGeometry().getType();
      switch (geomType) {
        case "Point":
        case "MultiPoint":
          feature.setPropertyMarker();
          feature.setPropertyLabel();
          break;
        case "LineString":
        case "MultiLineString":
          feature.setPropertyStroke();
          break;
        case "Polygon":
        case "MultiPolygon":
          feature.setPropertyStroke();
          feature.setPropertyFill();
          break;
        default:
          break;
      }
    }
  },
  /**
   * Transform a native style to feature properties
   *
   * @function definePropertiesFromStyle
   * @param {*} feature - ...
   * @public
   *
   * @description
   * A l'Ã©criture du format.
   * > feature style --> feature properties --> tag styling
   *
   * Le style natif est rÃ©cupÃ©rÃ© pour chaque feature :
   *
   * ```js
   * // Ex.
   * var style = feature.getStyle();
   * ```
   *
   * Ensuite, le style natif est transformÃ© en properties pour chaque feature :
   *
   * ```js
   * // Ex.
   * var stroke = style.getStroke();
   * var oColorStroke = Color.rgbaToHex(stroke.getColor());
   * feature.set("stroke", oColorStroke.hex); // #000000
   * feature.set("stroke-opacity", oColorStroke.opacity); // 0.8
   * ```
   *
   * Et, chaque properties des features sont ecrites dans le format du fichier
   * (opÃ©ration native sous OpenLayers) :
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",
   *    "stroke-opacity": 0.8
   * }
   * ```
   */
  definePropertiesFromStyle: function(feature) {
    var style = feature.getStyle() || feature.getStyleFunction();
    if (style) {
      if (typeof style === "function") {
        var styles = style.call(this, feature, 0);
        if (styles && styles.length !== 0) {
          style = Array.isArray(styles) ? styles[0] : styles;
          feature.setStyle(style);
        } else {
          return;
        }
      }
      this.definePropertiesFromStyleByType(feature);
    }
  },
  /**
   * Transform a native style to tags 'styling' into the format
   *
   * @function defineTagFromStyle
   * @param {*} style - ...
   * @param {String} format - ...
   * @returns {String} tags stringify into the format (json / xml)
   * @todo
   * @public
   *
   * @description
   * A partir d'un style natif, on le transforme en balise de 'styling' dans le format demandÃ©,
   * que l'on peut ensuite inserer dans le fichier.
   * > style ---> tag styling
   *
   */
  defineTagFromStyle: function(style, format) {
    logger3.trace("todo...");
    return null;
  }
};
var Styling_default = Styling;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/Parser.js
var logger4 = LoggerByDefault_default2.getLogger("parser");
var Parser = {
  /**
   * ...
   *
   * @param {String} xml - XML string
   * @returns {HTMLElement} doc
   */
  parse: function(xml) {
    var doc = null;
    var parser = null;
    var scope = typeof window !== "undefined" ? window : null;
    if (typeof exports === "object" && window === null) {
      var DOMParser2 = require_lib().DOMParser;
      parser = new DOMParser2();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.DOMParser) {
      parser = new scope.DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.ActiveXObject) {
      doc = new scope.ActiveXObject("Microsoft.XMLDOM");
      doc.async = false;
      doc.loadXML(xml);
    } else {
      logger4.log("Incompatible environment for DOM Parser !");
    }
    var errorNode = doc.querySelector("parsererror");
    if (errorNode) {
      console.error(errorNode);
      return null;
    }
    logger4.trace(doc);
    return doc;
  },
  /**
   * ...
   *
   * @param {HTMLElement} doc - doc
   * @returns {String} XML string
   */
  toString: function(doc) {
    var oSerializer = new XMLSerializer();
    var xml = oSerializer.serializeToString(doc);
    logger4.trace(xml);
    return xml;
  },
  /**
   * ...
   * cf. https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript/
   *
   * @param {String} xml - XML string
   * @returns {String} XML string formatted
   */
  format: function(xml) {
    var reg = /(>)\s*(<)(\/*)/g;
    var wsexp = / *(.*) +\n/g;
    var contexp = /(<.+>)(.+\n)/g;
    xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
    var formatted = "";
    var lines = xml.split("\n");
    var indent = 0;
    var lastType = "other";
    var transitions = {
      "single->single": 0,
      "single->closing": -1,
      "single->opening": 0,
      "single->other": 0,
      "closing->single": 0,
      "closing->closing": -1,
      "closing->opening": 0,
      "closing->other": 0,
      "opening->single": 1,
      "opening->closing": 0,
      "opening->opening": 1,
      "opening->other": 1,
      "other->single": 0,
      "other->closing": -1,
      "other->opening": 0,
      "other->other": 0
    };
    for (var i = 0; i < lines.length; i++) {
      var ln = lines[i];
      var single = Boolean(ln.match(/<.+\/>/));
      var closing = Boolean(ln.match(/<\/.+>/));
      var opening = Boolean(ln.match(/<[^!].*>/));
      var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
      var fromTo = lastType + "->" + type;
      lastType = type;
      var padding = "";
      indent += transitions[fromTo];
      for (var j2 = 0; j2 < indent; j2++) {
        padding += "	";
      }
      if (fromTo === "opening->closing") {
        formatted = formatted.substr(0, formatted.length - 1) + ln + "\n";
      } else {
        formatted += padding + ln + "\n";
      }
    }
    logger4.trace(formatted);
    return formatted;
  }
};
var Parser_default = Parser;

// node_modules/geopf-extensions-openlayers/src/packages/Formats/KML.js
var logger5 = LoggerByDefault_default2.getLogger("extended KML format");
var KML = class _KML extends KML_default {
  /**
   * @constructor
   * @param {Object} options - Options
   * @param {Object} [options.extensions] - Add properties to file root
   */
  constructor(options) {
    super(options);
    if (!(this instanceof _KML)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    options = options || {};
    this.source = null;
    this.extensions = options.extensions || null;
    if (options.defaultStyle && !Array.isArray(options.defaultStyle)) {
      options.defaultStyle = [options.defaultStyle];
    }
    if (options.defaultStyle === null || typeof options.defaultStyle === "undefined") {
      options.defaultStyle = [];
    }
    return this;
  }
  /**
   *
   * En lecture, on surcharge la mÃ©thode readFeatures.
   * âœ”ï¸ In : kml string + features du format original
   * âœ”ï¸ Out : features Ã©tendus avec des styles, et des metadatas (name ou extendData)
   * > on modifie les features du format original avec les fonctionnalitÃ©s non gÃ©rÃ©es.
   *
   * En Ã©criture, on surcharge la mÃ©thode writeFearures.
   * âœ”ï¸ In : kml du format original + features Ã©tendus
   * âœ”ï¸ Out : kml Ã©tendu avec des styles, et des metadatas (name ou extendData)
   * > on modifie le kml gÃ©nÃ©rÃ© par le format original avec les fonctionnalitÃ©s que nous avons ajoutÃ©es aux features.
   *
   * Le principe
   * On parse le kml, et on lit (get) ou on ajoute (set) des fonctionnalitÃ©s.
   *
   * Les getters vont lire le kml (ex. LabelExtendStyle), et ajouter le style ainsi que le nom du label dans le feature original.
   * getLabelIconStyle (appel des 2 fonctions suivantes)
   * getLabelExtendStyle (New)
   * getHotSpotIconStyle (Bug sur la lecture du  hotspot)
   * getExtendData (New)
   *
   * Les setters vont Ã©crire dans le dom du kml original les fonctionnalitÃ©s ajoutÃ©es dans les features.
   * setLabelExtendStyle (New)
   * setHotSpotIconStyle (Bug sur l'Ã©criture du hotspot)
   * setNameData (Bug suppression de cette balise du format par dÃ©faut).
   *
   */
  /**
   * Fonction de lecture du KML avec fonction de traitement en fonction du type
   * PlaceMark (Label ou Marker).
   * Les traitements sont de 2 types :
   *  - creation de styles Ã©tendus ou correctifs sur le KML
   *  - ajout de styles Ã©tendus sur les features
   *
   * @param {HTMLElement} kmlNode - kml nodes
   * @param {Feature[]} features - features
   * @param {Object} process - process
   *
   * @example
   * // ajoute des fonctionnalitÃ©s dans le KML
   * _processKml(kmlDoc, {
   *   labelStyle : createStyleLabel,
   *   iconStyle  : createStyleIcon
   * });
   *
   * // lit des fonctionnalitÃ©s du KML non impl. par OpenLayers
   * _processKml(kmlNode, {
   *   labelStyle : getStyleToFeatureLabel,
   *   iconStyle  : getStyleToFeatureIcon,
   *   extendedData : getExtendedData
   * });
   */
  _processKml(kmlNode, features, process2) {
    var firstNodeLevel = kmlNode.nodeName === "#document" ? kmlNode.childNodes[0].childNodes : kmlNode.childNodes;
    var nodes = firstNodeLevel;
    for (var ik = 0; ik < firstNodeLevel.length; ik++) {
      const element = firstNodeLevel[ik];
      if (element.nodeName === "Document") {
        nodes = element.childNodes;
        break;
      }
      if (element.nodeName === "Placemark") {
        nodes = [element];
        break;
      }
    }
    var stylesUrl = {};
    var index2 = -1;
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      switch (node.nodeName) {
        case "Style":
          var id = node.attributes[0];
          if (id && id.nodeName === "id") {
            var _k = id.nodeValue;
            var _v = node;
            stylesUrl[_k] = _v;
          }
          break;
        case "Placemark":
          index2++;
          var types = node.childNodes;
          var point = false;
          var line = false;
          var poly = false;
          var domStyles = null;
          var hdlDomStyle = null;
          var domExtendedData = null;
          var domNameTag = node;
          for (var j2 = 0; j2 < types.length; j2++) {
            switch (types[j2].nodeName) {
              case "Polygon":
                poly = true;
                break;
              case "LineString":
                line = true;
                break;
              case "Point":
                point = true;
                break;
              case "Style":
                hdlDomStyle = types[j2];
                domStyles = types[j2].childNodes;
                break;
              case "styleUrl":
                var _idStyle = types[j2].textContent.slice(1);
                if (stylesUrl[_idStyle]) {
                  domStyles = stylesUrl[_idStyle].childNodes;
                }
                break;
              case "ExtendedData":
                domExtendedData = types[j2].childNodes;
                break;
              case "name":
                domNameTag = null;
                break;
              default:
            }
          }
          if (domExtendedData) {
            logger5.log("ExtendedData :", domExtendedData);
            var fctExtend = process2.extendedData;
            if (fctExtend && typeof fctExtend === "function") {
              fctExtend(features[index2], domExtendedData);
            }
          }
          if (domNameTag) {
            logger5.log("Name :", domNameTag);
            var fctName = process2.nameData;
            if (fctName && typeof fctName === "function") {
              fctName(features[index2], domNameTag);
            }
          }
          if (point && domStyles && domStyles.length !== 0) {
            var labelStyleDom = null;
            var iconStyleDom = null;
            for (var k3 = 0; k3 < domStyles.length; k3++) {
              switch (domStyles[k3].nodeName) {
                case "LabelStyle":
                  labelStyleDom = domStyles[k3];
                  break;
                case "IconStyle":
                  iconStyleDom = domStyles[k3];
                  break;
                default:
              }
            }
            var labelName = features[index2].getProperties().name;
            var labelDescription = features[index2].getProperties().description;
            var value2 = labelName || labelDescription;
            logger5.trace(value2);
            if (!iconStyleDom && labelStyleDom) {
              var fctLabel = process2.labelStyle;
              if (fctLabel && typeof fctLabel === "function") {
                fctLabel(features[index2], labelStyleDom);
              }
            } else if (iconStyleDom && !labelStyleDom) {
              var fctIcon = process2.iconStyle;
              if (fctIcon && typeof fctIcon === "function") {
                fctIcon(features[index2], iconStyleDom);
              }
            } else if (iconStyleDom && labelStyleDom) {
              var fctIconLabel = process2.iconLabelStyle;
              if (fctIconLabel && typeof fctIconLabel === "function") {
                fctIconLabel(features[index2], iconStyleDom, labelStyleDom);
              }
            } else {
            }
          } else {
            var feature = features[index2];
            var style = feature.getStyle();
            if (style && typeof style === "function") {
              var fstyles = style.call(this, feature, 0);
              if (fstyles && fstyles.length !== 0) {
                style = fstyles[0];
              }
            }
            if (poly) {
              var fctPoly = process2.polygonStyle;
              if (fctPoly && typeof fctPoly === "function") {
                fctPoly(features[index2], domStyles);
              }
            }
            if (line) {
              var fctLine = process2.lineStringStyle;
              if (fctLine && typeof fctLine === "function") {
                fctLine(features[index2], domStyles);
              }
            }
            if (point && style) {
              var image = style.getImage();
              if (image && image instanceof Circle_default2) {
                var fctCircle = process2.circleStyle;
                if (fctCircle && typeof fctCircle === "function") {
                  fctCircle(features[index2], hdlDomStyle);
                }
              } else if (image && image instanceof Icon_default) {
                var fctPoint = process2.pointStyle;
                if (fctPoint && typeof fctPoint === "function") {
                  fctPoint(features[index2], hdlDomStyle);
                }
              } else {
              }
            }
          }
          break;
        default:
          logger5.trace("tag is not processing !");
      }
    }
  }
  /**
   * Write Extend for Features.
   * This function overloads ol.format.KML.writeFeatures ...
   *
   * @see olKML#writeFeatures
   * @param {Feature[]} features - Features.
   * @param {Object} options - Options.
   *
   * @returns {String} kml string formatted
   */
  writeFeatures(features, options) {
    logger5.log("overload : ol.format.KML.writeFeatures");
    var kmlNode = super.writeFeaturesNode(features, options);
    if (kmlNode === null) {
      return null;
    }
    if (this.hasOwnProperty("extensions")) {
      this._writeRootExtensions(kmlNode, this.extensions);
    }
    var kmlStringExtended = this._writeExtendStylesFeatures(kmlNode, features, options);
    var kmlStringFormatted = Parser_default.format(kmlStringExtended);
    if (kmlStringFormatted === "") {
      return null;
    }
    return kmlStringFormatted;
  }
  /**
   * Write Extended Styles for each features
   *
   * @param {HTMLElement} kmlNode - kml nodes
   * @param {Feature[]} features - features
   * @param {Object} options - options
   *
   * @returns {String} kml string extended
   *
   * @private
   */
  _writeExtendStylesFeatures(kmlNode, features, options) {
    function __convertRGBColorsToKML(data, opacity) {
      var strColor = data.toString(16);
      if (strColor.charAt(0) === "#") {
        strColor = strColor.slice(1);
      }
      opacity = opacity || 1;
      opacity = parseInt(opacity * 255, 10);
      opacity = opacity.toString(16);
      var color = opacity;
      color = color + strColor.substr(4, 2);
      color = color + strColor.substr(2, 2);
      color = color + strColor.substr(0, 2);
      return color.toLowerCase();
    }
    var __createExtendedStyleLabel = function(feature, node) {
      logger5.trace("label with style :", node);
      if (!feature) {
        return;
      }
      if (feature.getStyle() instanceof Style_default) {
        var textStyle = feature.getStyle().getText();
        if (!textStyle) {
          return;
        }
        var _fontFamily = "Sans";
        var _fontSize = "16px";
        var _font = textStyle.getFont();
        if (_font) {
          var splits = _font.split(" ", 2);
          _fontSize = splits[0];
          _fontFamily = splits[1];
        }
        var strokeTextStyle = feature.getStyle().getText().getStroke();
        if (!strokeTextStyle) {
          return;
        }
        if (strokeTextStyle instanceof Stroke_default) {
          var _haloColor = __convertRGBColorsToKML("#FFFFFF");
          var color = strokeTextStyle.getColor();
          if (Array.isArray(color)) {
            var cf = "rgba(";
            cf += color[0] + ",";
            cf += color[1] + ",";
            cf += color[2] + ",";
            cf += color[3] + ")";
            color = cf;
          }
          if (ColorUtils_default.isRGB(color)) {
            var colorHex = ColorUtils_default.rgbaToHex(color);
            _haloColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
          } else {
            _haloColor = __convertRGBColorsToKML(color);
          }
          var _haloRadius = strokeTextStyle.getWidth() || "0";
          var _haloOpacity = "1";
          if (node && node.getElementsByTagName("LabelStyleSimpleExtensionGroup").length === 0) {
            var labelExtended = document.createElementNS(kmlNode.namespaceURI, "LabelStyleSimpleExtensionGroup");
            labelExtended.setAttribute("fontSize", _fontSize);
            labelExtended.setAttribute("fontFamily", _fontFamily);
            labelExtended.setAttribute("haloColor", _haloColor);
            labelExtended.setAttribute("haloRadius", _haloRadius);
            labelExtended.setAttribute("haloOpacity", _haloOpacity);
            node.appendChild(labelExtended);
          }
        }
        var fImageStyle = feature.getStyle().getImage();
        if (!fImageStyle) {
          return;
        }
        if (fImageStyle instanceof Circle_default2) {
          var strokeColor = null;
          var strokeWidth = null;
          if (fImageStyle.getStroke()) {
            strokeWidth = fImageStyle.getStroke().getWidth();
            strokeColor = fImageStyle.getStroke().getColor();
            if (Array.isArray(strokeColor)) {
              var cfs = "rgba(";
              cfs += strokeColor[0] + ",";
              cfs += strokeColor[1] + ",";
              cfs += strokeColor[2] + ",";
              cfs += strokeColor[3] + ")";
              strokeColor = cfs;
            }
            if (ColorUtils_default.isRGB(strokeColor)) {
              var strokeColorHex = ColorUtils_default.rgbaToHex(strokeColor);
              strokeColor = __convertRGBColorsToKML(strokeColorHex.hex, strokeColorHex.opacity);
            } else {
              strokeColor = __convertRGBColorsToKML(strokeColor);
            }
          }
          var fillColor = null;
          if (fImageStyle.getFill()) {
            fillColor = fImageStyle.getFill().getColor();
            if (Array.isArray(fillColor)) {
              var cff = "rgba(";
              cff += fillColor[0] + ",";
              cff += fillColor[1] + ",";
              cff += fillColor[2] + ",";
              cff += fillColor[3] + ")";
              fillColor = cff;
            }
            if (ColorUtils_default.isRGB(fillColor)) {
              var fillColorHex = ColorUtils_default.rgbaToHex(fillColor);
              fillColor = __convertRGBColorsToKML(fillColorHex.hex, fillColorHex.opacity);
            } else {
              fillColor = __convertRGBColorsToKML(fillColor);
            }
          }
          if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
            var iconExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
            iconExtended.setAttribute("type", "circle");
            iconExtended.setAttribute("radius", fImageStyle.getRadius());
            iconExtended.setAttribute("fillColor", fillColor);
            iconExtended.setAttribute("strokeColor", strokeColor);
            iconExtended.setAttribute("strokeWidth", strokeWidth);
            node.appendChild(iconExtended);
          }
        }
      }
    };
    var __createExtendedStyleIcon = function(feature, node) {
      logger5.trace("marker with style (hotspot):", node);
      if (!feature) {
        return;
      }
      if (feature.getStyle() instanceof Style_default) {
        var fImageStyle = feature.getStyle().getImage();
        if (!fImageStyle) {
          return;
        }
        if (fImageStyle instanceof Icon_default) {
          var x3 = 0;
          var y3 = 0;
          var xunits = "pixels";
          var yunits = "pixels";
          var size = fImageStyle.getSize();
          var anchor = fImageStyle.getAnchor();
          if (anchor.length) {
            x3 = anchor[0];
            y3 = anchor[1];
            if (yunits === "fraction") {
              y3 = y3 === 1 ? 0 : 1 - y3;
            } else {
              y3 = yunits === "pixels" && y3 === size[1] ? 0 : size[1] - y3;
            }
          }
          if (node && node.getElementsByTagName("hotSpot").length === 0) {
            var hotspot = document.createElementNS(kmlNode.namespaceURI, "hotSpot");
            hotspot.setAttribute("x", x3);
            hotspot.setAttribute("y", y3);
            hotspot.setAttribute("xunits", xunits);
            hotspot.setAttribute("yunits", yunits);
            node.appendChild(hotspot);
          }
        }
      }
    };
    var __createExtendedStyleToCircle = function(feature, node) {
      if (!feature) {
        return;
      }
      if (feature.getStyle() instanceof Style_default) {
        var fImageStyle = feature.getStyle().getImage();
        if (!fImageStyle) {
          return;
        }
        if (fImageStyle instanceof Circle_default2) {
          var strokeColor = null;
          var strokeWidth = null;
          if (fImageStyle.getStroke()) {
            strokeWidth = fImageStyle.getStroke().getWidth();
            strokeColor = fImageStyle.getStroke().getColor();
            if (Array.isArray(strokeColor)) {
              var cf = "rgba(";
              cf += strokeColor[0] + ",";
              cf += strokeColor[1] + ",";
              cf += strokeColor[2] + ",";
              cf += strokeColor[3] + ")";
              strokeColor = cf;
            }
            if (ColorUtils_default.isRGB(strokeColor)) {
              var colorHex = ColorUtils_default.rgbaToHex(strokeColor);
              strokeColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
            } else {
              strokeColor = __convertRGBColorsToKML(strokeColor);
            }
          }
          var fillColor = null;
          if (fImageStyle.getFill()) {
            fillColor = fImageStyle.getFill().getColor();
            if (Array.isArray(fillColor)) {
              var cfi = "rgba(";
              cfi += fillColor[0] + ",";
              cfi += fillColor[1] + ",";
              cfi += fillColor[2] + ",";
              cfi += fillColor[3] + ")";
              fillColor = cfi;
            }
            if (ColorUtils_default.isRGB(fillColor)) {
              var fillColorImgHex = ColorUtils_default.rgbaToHex(fillColor);
              fillColor = __convertRGBColorsToKML(fillColorImgHex.hex, fillColorImgHex.opacity);
            } else {
              fillColor = __convertRGBColorsToKML(fillColor);
            }
          }
          if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
            var labelStyle = document.createElementNS(kmlNode.namespaceURI, "LabelStyle");
            var circleExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
            circleExtended.setAttribute("type", "circle");
            circleExtended.setAttribute("radius", fImageStyle.getRadius());
            circleExtended.setAttribute("fillColor", fillColor);
            circleExtended.setAttribute("strokeColor", strokeColor);
            circleExtended.setAttribute("strokeWidth", strokeWidth);
            labelStyle.appendChild(circleExtended);
            node.appendChild(labelStyle);
          }
        }
      }
    };
    var __createExtendedStyleToPoint = function(feature, node) {
    };
    var __createExtendedStyleToIconLabel = function(feature, nodeIconStyle, nodeLabelStyle) {
      logger5.trace("write an icon with a label");
      __createExtendedStyleIcon(feature, nodeIconStyle);
      __createExtendedStyleLabel(feature, nodeLabelStyle);
    };
    var __setNameData = function(feature, tags) {
      for (var i = 0; i < tags.length; i++) {
        var tag = tags[i];
        if (tag.nodeName === "name") {
          return;
        }
      }
      var labelName = feature.getProperties().name;
      if (labelName) {
        var name = document.createElement("name");
        name.innerHTML = labelName;
        tags.appendChild(name);
      }
    };
    var _setExtendedDataStyle = function(feature, node) {
      if (node && node.length) {
        var removeNodes = [];
        for (var k3 = 0; k3 < node.length; k3++) {
          const element = node[k3];
          if (element.nodeName === "Data") {
            var key = element.getAttribute("name");
            if (Styling_default.getListTags().includes(key)) {
              removeNodes.push(element);
            }
          }
        }
        if (removeNodes && removeNodes.length) {
          removeNodes.forEach((e) => {
            e.remove();
          });
        }
      }
    };
    this._processKml(kmlNode, features, {
      labelStyle: __createExtendedStyleLabel,
      iconStyle: __createExtendedStyleIcon,
      iconLabelStyle: __createExtendedStyleToIconLabel,
      circleStyle: __createExtendedStyleToCircle,
      pointStyle: __createExtendedStyleToPoint,
      nameData: __setNameData,
      extendedData: _setExtendedDataStyle
    });
    var kmlStringExtended = Parser_default.toString(kmlNode);
    if (!kmlStringExtended) {
      return null;
    }
    return kmlStringExtended;
  }
  /**
   * ...
   *
   * @param {*} kmlNode - ...
   * @param {*} extensions - ...
   */
  _writeRootExtensions(kmlNode, extensions) {
    var extendDataElement = document.createElementNS(kmlNode.namespaceURI, "ExtendedData");
    for (const key in extensions) {
      if (Object.hasOwnProperty.call(extensions, key)) {
        const value2 = extensions[key];
        var dataElement = document.createElementNS(kmlNode.namespaceURI, "Data");
        dataElement.setAttribute("name", key);
        var data = document.createTextNode(JSON.stringify(value2));
        dataElement.appendChild(data);
        extendDataElement.appendChild(dataElement);
      }
    }
    var firstChild = kmlNode.firstChild;
    kmlNode.insertBefore(extendDataElement, firstChild);
  }
  /**
   * Read Extend for Features.
   * This function overloads ol.format.KML.readFeatures ...
   *
   * @see olKML#readFeatures
   * @param {Document|Node} source - Source.
   * @param {Object} options - options. see olx.format.ReadOptions
   * @returns {Feature[]} Features.
   */
  readFeatures(source, options) {
    logger5.log("overload : ol.format.KML.readFeatures");
    if (typeof source === "string") {
      this.source = Parser_default.parse(source);
    } else if (source !== null) {
      this.source = source;
    }
    var features = this._readExtendStylesFeatures(source, options);
    logger5.trace("Styles Ã©tendus", features);
    features.forEach((feature) => {
      Styling_default.definePropertiesFromStyle(feature);
    });
    return features;
  }
  /**
   * Read Extended Styles for each features
   *
   * @param {(Document|Node|ArrayBuffer|Object|String)} source - source
   * @param {Object} options - options see olx.format.ReadOptions
   *
   * @returns {Feature[]} features
   *
   * @private
   */
  _readExtendStylesFeatures(source, options) {
    var features = super.readFeatures(source, options);
    var kmlDoc = null;
    var kmlString = "";
    if (typeof source === "string") {
      kmlString = source;
    } else {
      kmlString = source.documentElement.outerHTML;
    }
    kmlString = kmlString.replace(/\n/g, "");
    kmlString = kmlString.replace(/(>)\s*(<)/g, "$1$2");
    kmlDoc = Parser_default.parse(kmlString);
    if (kmlDoc === null) {
      return features;
    }
    function __convertKMLColorsToRGB(data) {
      var color = "";
      color = color + data.substr(6, 2);
      color = color + data.substr(4, 2);
      color = color + data.substr(2, 2);
      var hex = parseInt(color, 16).toString(16);
      var comp = "";
      var len = hex.length || 0;
      for (var i = 0; i < 6 - len; i++) {
        comp += "0";
      }
      hex = "#" + comp + hex;
      return hex;
    }
    var __getExtendedStyleToFeatureLabel = function(feature, node) {
      logger5.trace("label with style :", node);
      if (!feature) {
        return;
      }
      var _text = feature.getProperties().name;
      var _color = __convertKMLColorsToRGB("ff000000");
      var _colorHalo = "#FFFFFF";
      var _radiusHalo = 0;
      var _font = "Sans";
      var _fontSize = "16px";
      var _circleType = null;
      var _circleRadius = 5;
      var _circleFillColor = "#000000";
      var _circleStrokeColor = "#ffffff";
      var _circleStrokeWidth = 1;
      var bLabelStyleSimpleExtensionGroup = false;
      var bObjectSimpleExtensionGroup = false;
      var nodeStyles = node.childNodes;
      for (var k3 = 0; k3 < nodeStyles.length; k3++) {
        switch (nodeStyles[k3].nodeName) {
          case "scale":
            break;
          case "colorMode":
            break;
          case "color":
            _color = __convertKMLColorsToRGB(nodeStyles[k3].textContent);
            break;
          case "LabelStyleSimpleExtensionGroup":
            bLabelStyleSimpleExtensionGroup = true;
            var attributs = nodeStyles[k3].attributes;
            for (var l3 = 0; l3 < attributs.length; l3++) {
              switch (attributs[l3].nodeName) {
                case "fontFamily":
                  _font = attributs[l3].nodeValue;
                  break;
                case "fontSize":
                  _fontSize = attributs[l3].nodeValue;
                  break;
                case "haloColor":
                  _colorHalo = __convertKMLColorsToRGB(attributs[l3].nodeValue);
                  break;
                case "haloRadius":
                  _radiusHalo = parseInt(attributs[l3].nodeValue, 10);
                  break;
                case "haloOpacity":
                  break;
                default:
              }
            }
            break;
          case "ObjectSimpleExtensionGroup":
            bObjectSimpleExtensionGroup = true;
            var attributsExt = nodeStyles[k3].attributes;
            for (var ll = 0; ll < attributsExt.length; ll++) {
              switch (attributsExt[ll].nodeName) {
                case "type":
                  _circleType = attributsExt[ll].nodeValue;
                  break;
                case "radius":
                  _circleRadius = parseInt(attributsExt[ll].nodeValue, 10);
                  break;
                case "fillColor":
                  var fillColorValue = attributsExt[ll].nodeValue;
                  var fillOpacity = Math.round(ColorUtils_default.num(fillColorValue.substr(0, 2)) / 255 * 10) / 10;
                  var fillColorHexa = __convertKMLColorsToRGB(fillColorValue);
                  _circleFillColor = ColorUtils_default.hexToRgba(fillColorHexa, fillOpacity);
                  break;
                case "strokeColor":
                  var strokeColorValue = attributsExt[ll].nodeValue;
                  var strokeOpacity = Math.round(ColorUtils_default.num(strokeColorValue.substr(0, 2)) / 255 * 10) / 10;
                  var strokeColorHexa = __convertKMLColorsToRGB(strokeColorValue);
                  _circleStrokeColor = ColorUtils_default.hexToRgba(strokeColorHexa, strokeOpacity);
                  break;
                case "strokeWidth":
                  _circleStrokeWidth = parseInt(attributsExt[ll].nodeValue, 10);
                  break;
                default:
              }
            }
            break;
          default:
        }
      }
      var StyleInstance = null;
      if (bObjectSimpleExtensionGroup && _circleType === "circle") {
        StyleInstance = new Circle_default2({
          radius: _circleRadius,
          fill: new Fill_default({
            color: _circleFillColor
          }),
          stroke: new Stroke_default({
            color: _circleStrokeColor,
            width: _circleStrokeWidth
          })
        });
      } else if (bLabelStyleSimpleExtensionGroup) {
        StyleInstance = new Icon_default({
          src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
          size: [51, 38],
          anchor: [25.5, 38],
          anchorOrigin: "top-left",
          anchorXUnits: "pixels",
          anchorYUnits: "pixels"
        });
      } else {
      }
      feature.setStyle(new Style_default({
        image: StyleInstance,
        text: new Text_default({
          font: _fontSize + " " + _font,
          textAlign: "left",
          text: _text,
          // offsetX : 5, // FIXME valeur arbitraire MAIS esthÃ©tique !
          fill: new Fill_default({
            color: _color
          }),
          stroke: new Stroke_default({
            color: _colorHalo,
            width: _radiusHalo
          })
        })
      }));
    };
    var __getExtendedStyleToFeatureIcon = function(feature, node) {
      logger5.trace("hotspot :", node);
      var _src = null;
      var _scale = null;
      var _color = __convertKMLColorsToRGB("ffffffff");
      var _bSizeIcon = false;
      var _sizeW = 51;
      var _sizeH = 38;
      var _bHotSpot = false;
      var _anchorX = 25.5;
      var _anchorXUnits = "pixels";
      var _anchorY = 38;
      var _anchorYUnits = "pixels";
      var nodeStyles = node.childNodes;
      var bIconStyle = false;
      for (var k3 = 0; k3 < nodeStyles.length; k3++) {
        switch (nodeStyles[k3].nodeName) {
          case "Icon":
            bIconStyle = true;
            var nodes = nodeStyles[k3].childNodes;
            for (var i = 0; i < nodes.length; i++) {
              switch (nodes[i].nodeName) {
                case "href":
                  _src = nodes[i].textContent;
                  break;
                case "gx:w":
                  _bSizeIcon = true;
                  _sizeW = parseFloat(nodes[i].textContent);
                  break;
                case "gx:h":
                  _bSizeIcon = true;
                  _sizeH = parseFloat(nodes[i].textContent);
                  break;
                default:
              }
            }
            break;
          case "hotSpot":
            _bHotSpot = true;
            var attributs = nodeStyles[k3].attributes;
            for (var l3 = 0; l3 < attributs.length; l3++) {
              switch (attributs[l3].nodeName) {
                case "x":
                  _anchorX = parseFloat(attributs[l3].nodeValue);
                  break;
                case "y":
                  _anchorY = parseFloat(attributs[l3].nodeValue);
                  break;
                case "yunits":
                  _anchorXUnits = attributs[l3].nodeValue;
                  break;
                case "xunits":
                  _anchorYUnits = attributs[l3].nodeValue;
                  break;
                default:
              }
            }
            break;
          case "scale":
            _scale = parseFloat(nodeStyles[k3].textContent);
            break;
          case "color":
            _color = __convertKMLColorsToRGB(nodeStyles[k3].textContent);
            break;
          default:
        }
      }
      var StyleInstance = null;
      if (bIconStyle) {
        var optionsIcon = {
          src: _src || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
          color: _color,
          crossOrigin: "anonymous",
          // cf. https://gis.stackexchange.com/questions/121555/wms-server-with-cors-enabled/147403#147403
          scale: _scale || 1
        };
        if (_bSizeIcon) {
          Helper_default2.mergeParams(optionsIcon, {
            size: [_sizeW, _sizeH]
          });
        }
        if (_bHotSpot) {
          Helper_default2.mergeParams(optionsIcon, {
            anchor: [_anchorX, _anchorY],
            anchorOrigin: "bottom-left",
            anchorXUnits: _anchorXUnits || "pixels",
            anchorYUnits: _anchorYUnits || "pixels"
          });
        }
        StyleInstance = new Icon_default(optionsIcon);
      }
      var featureStyleFunction = feature.getStyleFunction();
      if (featureStyleFunction) {
        var _styles = featureStyleFunction(feature, 0);
        if (_styles && !Array.isArray(_styles)) {
          _styles = [_styles];
        }
        if (_styles && _styles.length !== 0) {
          var _style = _styles.length === 1 ? _styles[0] : _styles[_styles.length - 1];
          feature.setStyle(new Style_default({
            image: StyleInstance,
            text: _style.getText()
          }));
        }
      }
    };
    var __getExtendedData = function(feature, extend3) {
      logger5.trace("extendData :", extend3);
      if (!feature) {
        return;
      }
      var props = {};
      var _fname = feature.get("name") || "";
      var _fdescription = feature.get("description") || "";
      var _ftitle = null;
      for (var i = 0; i < extend3.length; i++) {
        var data = extend3[i];
        var name = data.attributes[0];
        var nodes = data.childNodes;
        if (name.nodeName === "name") {
          switch (name.nodeValue) {
            // compatibilitÃ© ancien geoportail !
            case "label":
              _fname = data.textContent;
              props.name = _fname;
              break;
            // compatibilitÃ© ancien geoportail !
            case "title":
            case "attributetitle":
              for (var j2 = 0; j2 < nodes.length; j2++) {
                if (nodes[j2].nodeName === "value") {
                  _ftitle = nodes[j2].textContent;
                }
              }
              break;
            default:
              props[name.nodeValue] = data.textContent;
              break;
          }
        }
      }
      if (_ftitle) {
        _fdescription = _fdescription ? _ftitle + " : " + _fdescription : _ftitle;
        props.description = _fdescription;
      }
      if (Object.keys(props).length) {
        feature.setProperties(props, true);
      }
    };
    var __getExtendedStyleToFeatureIconLabel = function(feature, nodeIconStyle, nodeLabelStyle) {
      logger5.trace("display icon and label");
      __getExtendedStyleToFeatureLabel(feature, nodeLabelStyle);
      __getExtendedStyleToFeatureIcon(feature, nodeIconStyle);
    };
    var __getStyleToDefaultFeature = function(feature, node) {
    };
    this._processKml(kmlDoc, features, {
      lineStringStyle: __getStyleToDefaultFeature,
      polygonStyle: __getStyleToDefaultFeature,
      pointStyle: __getStyleToDefaultFeature,
      labelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureLabel : null,
      iconStyle: __getExtendedStyleToFeatureIcon,
      iconLabelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureIconLabel : __getExtendedStyleToFeatureIcon,
      extendedData: __getExtendedData
    });
    return features;
  }
  /**
   * ...
   * @param {*} key ...
   * @returns {Object} json
   */
  readRootExtensions(key) {
    var value2 = {};
    var firstNodeLevelKml = this.source.nodeName === "#document" ? this.source.childNodes[0] : this.source;
    var childNodesLevel = firstNodeLevelKml.childNodes;
    for (var i = 0; i < childNodesLevel.length; i++) {
      var node1 = childNodesLevel[i];
      if (node1.nodeName === "ExtendedData") {
        var childNodesExtended = node1.childNodes;
        for (var j2 = 0; j2 < childNodesExtended.length; j2++) {
          var node2 = childNodesExtended[j2];
          if (node2.nodeName === "Data") {
            var name = node2.attributes[0];
            if (name && name.nodeName === "name") {
              if (name.nodeValue === key) {
                value2 = JSON.parse(node2.textContent);
                break;
              }
            }
          }
        }
      }
    }
    return value2;
  }
};
var KML_default2 = KML;
if (window.ol && window.ol.format) {
  window.ol.format.KMLExtended = KML;
}

// node_modules/geopf-extensions-openlayers/src/packages/Formats/GPX.js
var GPX = class _GPX extends GPX_default {
  /**
   * @constructor
   * @param {Object} options - Options
   * @param {Object} [options.defaultStyle] - Styles by default
   * @param {String} [options.orderBy] - Sort by key the feature before writing. By default, no sorting
   * @param {Object} [options.extensions] - Add properties to file root
   * @param {function} [options.readExtensions] - Reading extensions (native)
   */
  constructor(options) {
    super(options);
    if (!(this instanceof _GPX)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.options = options || {};
    if (this.options.readExtensions && typeof this.options.readExtensions === "function") {
      var clbk = this.options.readExtensions;
      this.options.readExtensions = function(feature, node) {
        this.readExtensions(feature, node);
        clbk.call(this, feature, node);
      };
    } else {
      this.options.readExtensions = this.readExtensions;
    }
    if (this.options.defaultStyle === null || typeof this.options.defaultStyle === "undefined") {
      this.options.defaultStyle = {};
    }
    this.source = null;
    return this;
  }
  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GPX.readFeatures ...
   *
   * @see olGPX#readFeatures
   * @param {Document|Node} source - Source.
   * @param {Object} options - options. see olx.format.ReadOptions
   * @returns {Feature[]} Features.
   */
  readFeatures(source, options) {
    var features = super.readFeatures(source, options);
    if (typeof source === "string") {
      this.source = Parser_default.parse(source);
    } else if (source !== null) {
      this.source = source;
    }
    var self2 = this;
    features.forEach(function(feature, index2, array) {
      feature.setId(index2 + 1);
      var value2 = feature.getProperties().desc;
      if (value2) {
        feature.setProperties({
          description: value2
        });
      }
      var featureStyleFunction = feature.getStyleFunction();
      if (!featureStyleFunction) {
        var styleFunction = Styling_default.defineStyleFunctionByDefault(self2.options.defaultStyle);
        if (styleFunction) {
          feature.setStyle(styleFunction);
        }
      }
    });
    return features;
  }
  /**
   * Write Extend Styles for Features.
   * This function overloads ol.format.GPX.writeFeatures ...
   *
   * @see olGPX#writeFeatures
   * @param {Features[]} features - Features.
   * @param {Object} options - Options.
   *
   * @returns {String} Result or null.
   */
  writeFeatures(features, options) {
    features.forEach(function(feature, index2, array) {
      var value2 = feature.getProperties().description;
      if (value2) {
        feature.setProperties({
          desc: value2
        });
      }
      Styling_default.definePropertiesFromStyle(feature);
      var type = feature.getGeometry().getType();
      if (type === "Polygon") {
        var fp = feature.clone();
        fp.set("type", type);
        fp.setGeometry(new LineString_default(feature.getGeometry().getCoordinates()));
        features.push(fp);
        array.splice(index2, 1);
      } else if (type === "MultiPolygon") {
        var fm = feature.clone();
        fm.set("type", type);
        fm.setGeometry(new MultiLineString_default(feature.getGeometry().getCoordinates()));
        features.push(fm);
        array.splice(index2, 1);
      }
    });
    if (this.options.orderBy !== void 0) {
      var key = this.options.orderBy;
      if (key) {
        var sortFct = function(a2, b3) {
          var cmpA = a2.get(key) || 0;
          var cmpB = b3.get(key) || 0;
          return cmpA.toString().localeCompare(cmpB.toString(), void 0, { numeric: true });
        };
        features.sort(sortFct);
      }
    }
    var gpxNode = super.writeFeaturesNode(features, options);
    if (gpxNode === null) {
      return null;
    }
    if (this.options.hasOwnProperty("extensions")) {
      this.writeRootExtensions_(gpxNode, this.options.extensions);
    }
    this.processExtensions_(gpxNode, features, {
      extensions: this.writeExtensions_
    });
    var gpxStringExtended = Parser_default.toString(gpxNode);
    if (!gpxStringExtended) {
      return null;
    }
    var gpxStringFormatted = Parser_default.format(gpxStringExtended);
    if (gpxStringFormatted === "") {
      return null;
    }
    return gpxStringFormatted;
  }
  /**
   * Callback to read extensions from options : readExtensions
   *
   * @param {Feature} feature - ...
   * @param {*} node - ...
   */
  readExtensions(feature, node) {
    var _node = node;
    if (!node) {
      var props = feature.getProperties();
      for (const key in props) {
        if (Object.hasOwnProperty.call(props, key)) {
          const element2 = props[key];
          if (element2 instanceof Node) {
            _node = element2;
            break;
          }
        }
      }
    }
    if (!_node) {
      console.warn("node not found !");
      return;
    }
    for (var index2 = 0; index2 < _node.childNodes.length; index2++) {
      var element = _node.childNodes[index2];
      if (element.nodeType === 1) {
        feature.set(element.nodeName, element.textContent);
      }
    }
    Styling_default.APPLY_CONVERT_GEOM_GPX = true;
    var style = Styling_default.defineStyleFromProperties(feature);
    if (style) {
      feature.setStyle(style);
    }
  }
  /**
   * ...
   * @param {*} key ...
   * @returns {Object} json
   * @todo
   */
  readRootExtensions(key) {
    var value2 = {};
    var firstNodeLevelGpx = this.source.childNodes[0];
    var searchChildNodesMeta = firstNodeLevelGpx.childNodes;
    for (var k3 = 0; k3 < searchChildNodesMeta.length; k3++) {
      var nodeMeta = searchChildNodesMeta[k3];
      if (nodeMeta.nodeName === "metadata") {
        var searchChildNodesExt = nodeMeta.childNodes;
        for (var i = 0; i < searchChildNodesExt.length; i++) {
          var nodeExt = searchChildNodesExt[i];
          if (nodeExt.nodeName === "extensions") {
            var searchChildNodesData = nodeExt.childNodes;
            for (var j2 = 0; j2 < searchChildNodesData.length; j2++) {
              var nodeData = searchChildNodesData[j2];
              if (nodeData.nodeName === "data") {
                var name = nodeData.attributes[0];
                if (name && name.nodeName === "name") {
                  if (name.nodeValue === key) {
                    value2 = JSON.parse(nodeData.textContent);
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    return value2;
  }
  /**
   * ...
   *
   * @param {*} doc - ...
   * @param {*} extensions - ...
   * @param {Boolean} [xml=false] - write tag xml or json
   */
  writeRootExtensions_(doc, extensions, xml) {
    var metadata = document.createElement("metadata");
    var extensionsRoot = document.createElement("extensions");
    function toDOM(node, json) {
      for (const key in json) {
        if (Object.hasOwnProperty.call(json, key)) {
          var element = json[key] || "";
          var tag = document.createElement(key);
          if (typeof element === "string" || typeof element === "number") {
            tag.innerHTML = element;
            node.appendChild(tag);
          } else if (element instanceof Array) {
            tag.setAttribute("type", "array");
            tag.setAttribute("index", element.length);
            for (let index2 = 0; index2 < element.length; index2++) {
              var item = element[index2] || "";
              var n = document.createElement("value");
              if (typeof item === "string" || typeof item === "number") {
                n.innerHTML = item;
                tag.appendChild(n);
              } else if (item instanceof Array) {
                n.setAttribute("type", "array");
                n.setAttribute("index", item.length);
                for (let i = 0; i < item.length; i++) {
                  var value2 = item[i] || "";
                  var k3 = document.createElement("value");
                  if (typeof value2 === "string" || typeof value2 === "number") {
                    k3.innerHTML = value2;
                    n.appendChild(k3);
                  }
                }
                tag.appendChild(n);
              } else if (item instanceof Object) {
                tag.appendChild(toDOM(n, item));
              } else {
              }
            }
            node.appendChild(tag);
          } else if (element instanceof Object) {
            node.appendChild(toDOM(tag, element));
          } else {
          }
        }
      }
      return node;
    }
    if (xml) {
      toDOM(extensionsRoot, extensions);
    } else {
      for (const key in extensions) {
        if (Object.hasOwnProperty.call(extensions, key)) {
          const value2 = extensions[key];
          var dataElement = document.createElement("data");
          dataElement.setAttribute("name", key);
          var data = document.createTextNode(JSON.stringify(value2));
          dataElement.appendChild(data);
          extensionsRoot.appendChild(dataElement);
        }
      }
    }
    metadata.appendChild(extensionsRoot);
    var firstChild = doc.firstChild;
    doc.insertBefore(metadata, firstChild);
  }
  /**
   * ...
   *
   * @param {Feature} feature - ...
   * @param {HTMLElement} node - ...
   * @private
   */
  writeExtensions_(feature, node) {
    var extensionsNode = document.createElementNS(node.parentNode.namespaceURI, "extensions");
    Styling_default.getListTags().forEach((key) => {
      if (feature.get(key)) {
        var extension = document.createElementNS(node.parentNode.namespaceURI, key);
        extension.innerHTML = feature.get(key);
        extensionsNode.appendChild(extension);
      }
    });
    node.appendChild(extensionsNode);
  }
  /**
   * ...
   *
   * @param {HTMLElement} doc - ...
   * @param {Feature[]} features - ...
   * @param {Object} actions - ...
   * @private
   */
  processExtensions_(doc, features, actions) {
    var index2 = -1;
    var nodes = doc.childNodes;
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      switch (node.nodeName) {
        case "wpt":
        case "rte":
        case "trk":
          index2++;
          var feature = features[index2];
          var style = feature.getStyle();
          if (style) {
            var fct = actions.extensions;
            if (fct && typeof fct === "function") {
              fct(feature, node);
            }
          }
          break;
        case "metadata":
          break;
        default:
          console.warn("nodename unknown :", node.nodeName);
          break;
      }
    }
  }
};
var GPX_default2 = GPX;
if (window.ol && window.ol.format) {
  window.ol.format.GPXExtended = GPX;
}

// node_modules/geopf-extensions-openlayers/src/packages/Formats/GeoJSON.js
var GeoJSON = class _GeoJSON extends GeoJSON_default {
  /**
   * @constructor
   * @param {Object} options - Options
   * @param {Object} [options.defaultStyle] - Styles by default
   * @param {Object} [options.extensions] - Add properties to file root
   */
  constructor(options) {
    super(options);
    if (!(this instanceof _GeoJSON)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.options = options || {};
    if (this.options.defaultStyle === null || typeof this.options.defaultStyle === "undefined") {
      this.options.defaultStyle = {};
    }
    this.source = null;
    return this;
  }
  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.readFeatures ...
   *
   * @see olGeoJSON#readFeatures
   * @param {Object|String} source - Source.
   * @param {Object} [options] - Options. see olx.format.ReadOptions
   * @returns {Feature[]} Features.
   */
  readFeatures(source, options) {
    var features = super.readFeatures(source, options);
    if (typeof source === "string") {
      this.source = JSON.parse(source);
    } else if (source !== null) {
      this.source = source;
    }
    features.forEach((feature) => {
      var featureStyleFunction = feature.getStyleFunction();
      if (featureStyleFunction) {
        var styles = featureStyleFunction.call(this, feature, 0);
        if (styles && styles.length !== 0) {
          feature.setStyle(styles[0]);
        }
      } else {
        var style = Styling_default.defineStyleFromProperties(feature);
        if (style) {
          feature.setStyle(style);
        } else {
          var styleFunction = Styling_default.defineStyleFunctionByDefault(this.options.defaultStyle);
          if (styleFunction) {
            feature.setStyle(styleFunction);
            Styling_default.definePropertiesFromStyle(feature);
          }
        }
      }
    });
    return features;
  }
  /**
   * Write Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.writeFeatures ...
   *
   * @see olGeoJSON#writeFeatures
   * @param {Feature[]} features - Features.
   * @param {Object} [options] - Options.
   *
   * @returns {String} Result.
   */
  writeFeatures(features, options) {
    features.forEach(function(feature) {
      Styling_default.definePropertiesFromStyle(feature);
    });
    var geoJSONObject = this.writeFeaturesObject(features, options);
    if (this.options.hasOwnProperty("extensions")) {
      Object.assign(geoJSONObject, this.options.extensions);
    }
    return JSON.stringify(geoJSONObject);
  }
  /**
   * ...
   * @param {*} key ...
   * @returns {Object} json
   */
  readRootExtensions(key) {
    return this.source[key];
  }
};
var GeoJSON_default2 = GeoJSON;
if (window.ol && window.ol.format) {
  window.ol.format.GeoJSONExtended = GeoJSON;
}

// node_modules/geopf-extensions-openlayers/src/packages/Sources/WMTS.js
var WMTS = class extends WMTS_default2 {
  constructor(options) {
    super(options);
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {ol.Coordinate} coordinate - Coordinate.
   * @param {Number} resolution - Resolution.
   * @param {ol.proj.Projection} projection - Projection.
   * @param {!Object} params - GetFeatureInfo params. `INFOFORMAT` at least should
   *     be provided.
   * @returns {String|undefined} GetFeatureInfo URL.
   */
  getFeatureInfoUrl(coordinate, resolution, projection, params2) {
    var pixelRatio = this.options && this.options.tilePixelRatio ? this.options.tilePixelRatio : 1;
    var tileGrid = this.tileGrid;
    var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
    var getTransformedTileCoord = function(tileCoord2, tileGrid2, projection2) {
      var tmpTileCoord = [0, 0, 0];
      var tmpExtent = createEmpty();
      var x4 = tileCoord2[1];
      var y4 = tileCoord2[2];
      var tileExtent2 = tileGrid2.getTileCoordExtent(tileCoord2);
      var extent = projection2.getExtent();
      if (extent != null && projection2.isGlobal()) {
        var numCols = Math.ceil(getWidth(extent) / getWidth(tileExtent2));
        x4 = x4 % numCols;
        tmpTileCoord[0] = tileCoord2[0];
        tmpTileCoord[1] = x4;
        tmpTileCoord[2] = tileCoord2[2];
        tileExtent2 = tileGrid2.getTileCoordExtent(tmpTileCoord, tmpExtent);
      }
      if (!intersects(tileExtent2, extent)) {
        return null;
      }
      return [tileCoord2[0], x4, y4];
    };
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
    var transformedTileCoord = getTransformedTileCoord(tileCoord, tileGrid, projection);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileMatrix = tileGrid.getMatrixIds()[tileCoord[0]];
    var baseParams = {
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      REQUEST: "GetFeatureInfo",
      LAYER: this.getLayer(),
      TILECOL: transformedTileCoord[1],
      TILEROW: transformedTileCoord[2],
      TILEMATRIX: tileMatrix,
      TILEMATRIXSET: this.getMatrixSet(),
      FORMAT: this.getFormat() || "image/png",
      STYLE: this.getStyle() || "normal"
    };
    Helper_default2.assign(baseParams, params2);
    var x3 = Math.floor((coordinate[0] - tileExtent[0]) / (tileResolution / pixelRatio));
    var y3 = Math.floor((tileExtent[3] - coordinate[1]) / (tileResolution / pixelRatio));
    var tileSize = tileGrid.getTileSize(tileCoord[0]);
    x3 = Math.min(x3, (tileSize[0] | tileSize) - 1);
    y3 = Math.max(y3, 0);
    baseParams["I"] = x3;
    baseParams["J"] = y3;
    var url = this.urls[0];
    var featureInfoUrl = Gp_default.Helper.normalyzeUrl(url, baseParams);
    return featureInfoUrl;
  }
};
var WMTS_default3 = WMTS;
if (window.ol && window.ol.source) {
  window.ol.source.WMTSExtended = WMTS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Utils/LayerUtils.js
var LayerUtils = {
  /**
   * Obtenir le ZoomLevel Ã  partir du ScaleDenominator
   * @function getZoomLevelFromScaleDenominator
   * @param {Number} scaleDenominator - the scale denominator
   * @param {String} crs - the crs
   *
   * @returns {Integer} zoom level
   */
  getZoomLevelFromScaleDenominator: function(scaleDenominator, crs) {
    var resolutionsNatives = {};
    switch (crs) {
      case "EPSG:2154":
        resolutionsNatives = {
          0: 104579.224549894,
          1: 52277.5323537905,
          2: 26135.4870785954,
          3: 13066.8913818,
          4: 6533.2286041135,
          5: 3266.5595244627,
          6: 1633.2660045974,
          7: 816.629554986,
          8: 408.3139146768,
          9: 204.1567415109,
          10: 102.0783167832,
          11: 51.0391448966,
          12: 25.5195690743,
          13: 12.7597836936,
          14: 6.379891636,
          15: 3.1899457653,
          16: 1.5949728695,
          17: 0.7974864315,
          18: 0.3987432149,
          19: 0.1993716073,
          20: 0.0996858037,
          21: 0.0498429018
        };
        break;
      default:
        resolutionsNatives = {
          0: 156543.033928041,
          1: 78271.51696402048,
          2: 39135.758482010235,
          3: 19567.87924100512,
          4: 9783.93962050256,
          5: 4891.96981025128,
          6: 2445.98490512564,
          7: 1222.99245256282,
          8: 611.49622628141,
          9: 305.7481131407048,
          10: 152.8740565703525,
          11: 76.43702828517624,
          12: 38.21851414258813,
          13: 19.10925707129406,
          14: 9.554628535647032,
          15: 4.777314267823516,
          16: 2.388657133911758,
          17: 1.194328566955879,
          18: 0.5971642834779395,
          19: 0.2985821417389697,
          20: 0.1492910708694849,
          21: 0.0746455354347424
        };
        break;
    }
    var resolution = scaleDenominator * 28e-5;
    for (var index2 in resolutionsNatives) {
      if (resolutionsNatives.hasOwnProperty(index2)) {
        if (resolutionsNatives[index2] <= resolution) {
          index2 = parseInt(index2, 10);
          return index2;
        }
      }
    }
    return 0;
  },
  /**
   * Get attributions list for a layer, based on current zoom and extent
   *
   * @function getAttributions
   * @param {Object} params - function params
   * @param {Array.<Float>} params.extent - map current geographical extent (EPSG:4326) : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @param {Number} params.zoom - map current zoom
   * @param {String} params.crs - map current projection code (ex "EPSG:2154")
   * @param {Boolean} params.visibility - layer visibility
   * @param {Gp.Services.Config.Originator} params.originators - resource originators (from Gp.Config.layers[].originators)
   * @returns {Object} attributions - associative array, mapping originators url (keys) with their properties : html attributions elements
   */
  getAttributions: function(params2) {
    var zoom = params2.zoom;
    var attributions = [];
    if (params2.originators != null && params2.visibility) {
      var drawLogo;
      for (var j2 = 0, jl = params2.originators.length; j2 < jl; j2++) {
        drawLogo = true;
        var originator = params2.originators[j2];
        var constraints = params2.originators[j2].constraints || [];
        for (var k3 = 0, kl = constraints.length; k3 < kl; k3++) {
          var constraint = constraints[k3];
          drawLogo = true;
          var minZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.maxScaleDenominator, params2.crs);
          var maxZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.minScaleDenominator, params2.crs) || 21;
          if (minZoomLevel && minZoomLevel > zoom) {
            drawLogo = false;
          }
          if (drawLogo && maxZoomLevel && maxZoomLevel < zoom) {
            drawLogo = false;
          }
          var bbox = constraint.bbox;
          if (drawLogo && bbox) {
            drawLogo = false;
            var viewExtent = params2.extent;
            if (viewExtent) {
              var bounds = [bbox.top, bbox.left, bbox.bottom, bbox.right];
              if (this.intersects(viewExtent, bounds)) {
                drawLogo = true;
                break;
              }
            }
          }
        }
        if (drawLogo) {
          var logo = originator.logo;
          var url = originator.url;
          var name = originator.name ? originator.name : "";
          var text = originator.attribution;
          var container = document.createElement("div");
          container.className = "gp-control-attribution";
          var link = null;
          link = document.createElement("a");
          link.className = "gp-control-attribution-link";
          link.target = "_blank";
          container.appendChild(link);
          if (url) {
            link.href = url;
          }
          var bImage = !!logo;
          var image = null;
          if (bImage) {
            image = document.createElement("img");
            if (link) {
              image.className = "gp-control-attribution-image";
              link.appendChild(image);
            } else {
              image.className = "";
              container.appendChild(image);
            }
            image.src = logo;
            image.title = text || name;
            image.style.height = "30px";
            image.style.width = "30px";
          } else {
            if (name) {
              link.textContent = name;
            } else if (text) {
              link.textContent = text;
            } else if (url) {
              link.textContent = url;
            } else {
              link.textContent = "";
            }
          }
          attributions.push(container.innerHTML + " ");
        }
      }
    }
    return attributions;
  },
  /**
   * Determines if one extent (extent1) intersects another (extent2)
   *
   * @function intersects
   * @param {Array.<Float>} extent1 - First extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @param {Array.<Float>} extent2 - Second extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]
   * @returns {Boolean} intersects - True if the two extents intersect, false otherwise.
   */
  intersects: function(extent1, extent2) {
    var intersectsX = extent1[1] <= extent2[3] && extent2[1] <= extent1[3];
    var intersectsY = extent1[2] <= extent2[0] && extent2[2] <= extent1[0];
    return intersectsX && intersectsY;
  }
};
var LayerUtils_default = LayerUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/Config.js
var Config2 = {
  /**
   * Config
   *
   * @public
   * @type {Object}
   */
  configuration: {},
  /**
   * Check if the configuration is loaded
   *
   * @returns {Boolean} True if Config is loaded, false otherwise
   */
  isConfigLoaded: function() {
    if (this.configuration && Object.keys(this.configuration).length !== 0) {
      return true;
    }
    var scope = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
    if (scope.Gp && scope.Gp.Config && scope.Gp.Config.layers && Object.keys(scope.Gp.Config.layers).length !== 0) {
      this.configuration = scope.Gp.Config;
      return true;
    }
    return false;
  }
};
var Config_default2 = Config2;

// node_modules/geopf-extensions-openlayers/src/packages/Layers/SourceWMTS.js
var logger6 = LoggerByDefault_default2.getLogger("sourcewmts");
var SourceWMTS = class extends WMTS_default3 {
  /**
   * 
   * @constructor
  * @param {Object} options            - options for function call.
  * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
  * @param {Object} [options.configuration] - configuration (cf. example) 
  * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
  * @param {String} [options.apiKey]   - Access key to Geoportal platform
  * @param {Array} [options.legends]   - Legends objects associated to the layer
  * @param {Array} [options.metadata]   - Metadata objects associated to the layer
  * @param {String} [options.title]   - title of the layer
  * @param {String} [options.description]   - description of the layer
  * @param {String} [options.quicklookUrl]   - quicklookUrl of the layer
  * @param {Object} [options.olParams] - other options for ol.source.WMTS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.WMTS.html ol.source.WMTS})
  * @example
  * var sourceWMTS = new ol.source.GeoportalWMTS({
  *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
  * });
   */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    var wmtsParams = layerCfg ? layerCfg.params : null;
    var apiKey = options.apiKey;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WMTS");
      if (!layerId) {
        throw new Error(`ERROR : WMTS Layer ID ${options.layer} cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.`);
      }
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : WMTS Layer configuration cannot be found in Geoportal.");
      }
      apiKey = Config_default2.configuration.getLayerKey(layerId)[0];
      wmtsParams = Config_default2.configuration.getLayerParams(options.layer, "WMTS");
    }
    var protocol = options.ssl === false ? "http://" : "https://";
    var urlParams = {
      "gp-ol-ext": package_default.olExtVersion || package_default.version
    };
    if (wmtsParams.url.includes("/private/")) {
      var key = options.apiKey || apiKey;
      if (!key) {
        throw new Error("ERROR : WMS Layer apiKey cannot be found in Geoportal Configuration.");
      }
      urlParams["apikey"] = key;
    }
    var wmtsSourceOptions = {
      // tracker extension openlayers
      // FIXME : gp-ext version en mode AMD
      url: Gp_default.Helper.normalyzeUrl(wmtsParams.url.replace(/(http|https):\/\//, protocol), urlParams, false),
      version: wmtsParams.version,
      style: wmtsParams.styles,
      format: wmtsParams.format,
      projection: wmtsParams.projection,
      maxZoom: LayerUtils_default.getZoomLevelFromScaleDenominator(wmtsParams.minScale),
      layer: options.layer,
      matrixSet: wmtsParams.TMSLink,
      tileGrid: new WMTS_default({
        resolutions: wmtsParams.nativeResolutions,
        matrixIds: wmtsParams.matrixIds,
        origin: [Object.values(wmtsParams.tileMatrices)[0].topLeftCorner.x, Object.values(wmtsParams.tileMatrices)[0].topLeftCorner.y]
      }),
      crossOrigin: "anonymous"
    };
    Helper_default2.mergeParams(wmtsSourceOptions, options.olParams);
    if (options.olParams && !wmtsParams.originators) {
      wmtsParams.originators = options.olParams.attributions;
    }
    super(wmtsSourceOptions);
    this._originators = wmtsParams.originators;
    this._legends = options.legends || wmtsParams.legends;
    this._metadata = options.metadata || wmtsParams.metadata;
    this._description = options.description || wmtsParams.description;
    this._title = options.title || wmtsParams.title;
    this._quicklookUrl = options.quicklookUrl || wmtsParams.quicklookUrl;
    this.name = options.layer;
    this.service = "WMTS";
    return this;
  }
};
var SourceWMTS_default = SourceWMTS;
if (window.ol && window.ol.source) {
  window.ol.source.GeoportalWMTS = SourceWMTS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/SourceWMS.js
var logger7 = LoggerByDefault_default2.getLogger("sourcewms");
var SourceWMS = class extends TileWMS_default {
  /**
   * @constructor
   * @param {Object} options            - options for function call.
   * @param {String} options.layer      - Layer name (e.g. "ORTHOIMAGERY.ORTHOPHOTOS")
   * @param {Object} [options.configuration] - configuration (cf. example) 
   * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
   * @param {String} [options.apiKey]   - Access key to Geoportal platform
   * @param {Array} [options.legends]   - Legends objects associated to the layer
   * @param {Array} [options.metadata]   - Metadata objects associated to the layer
   * @param {String} [options.title]   - title of the layer
   * @param {String} [options.description]   - description of the layer
   * @param {String} [options.quicklookUrl]   - quicklookUrl of the layer
   * @param {Object} [options.olParams] - other options for ol.source.TileWMS function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.TileWMS.html ol.source.TileWMS})
   * @example
   * var sourceWMS = new ol.source.GeoportalWMS({
   *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
   * });
   * 
   */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    var wmsParams = layerCfg ? layerCfg.params : null;
    var apiKey = options.apiKey;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WMS");
      if (!layerId) {
        throw new Error(`ERROR : WMS Layer ID ${options.layer} cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.`);
      }
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : WMS Layer configuration cannot be found in Geoportal.");
      }
      apiKey = Config_default2.configuration.getLayerKey(layerId)[0];
      wmsParams = Config_default2.configuration.getLayerParams(options.layer, "WMS");
    }
    var protocol = options.ssl === false ? "http://" : "https://";
    var urlParams = {
      "gp-ol-ext": package_default.olExtVersion || package_default.version
    };
    if (wmsParams.url.includes("/private/")) {
      var key = options.apiKey || apiKey;
      if (!key) {
        throw new Error("ERROR : WMS Layer apiKey cannot be found in Geoportal Configuration.");
      }
      urlParams["apikey"] = key;
    }
    var wmsSourceOptions = {
      // tracker extension openlayers
      url: Gp_default.Helper.normalyzeUrl(wmsParams.url.replace(/(http|https):\/\//, protocol), urlParams, false),
      params: {
        SERVICE: "WMS",
        LAYERS: options.layer,
        VERSION: wmsParams.version,
        STYLES: wmsParams.styles,
        FORMAT: wmsParams.format
      },
      crossOrigin: "anonymous"
      // ,
      // attributions : [
      //     new ol.Attribution({
      //         html : "<a class='gp-control-attribution-link' target='_blank' href='http://www.ign.fr'><img class='gp-control-attribution-image' src='http://wxs.ign.fr/static/logos/IGN/IGN.gif' title='Institut national de l\'information gÃ©ographique et forestiÃ¨re' style='height: 30px; width: 30px;'></a>"
      //     })
      // ]
    };
    Helper_default2.mergeParams(wmsSourceOptions, options.olParams);
    if (options.olParams && !wmsParams.originators) {
      wmsParams.originators = options.olParams.attributions;
    }
    super(wmsSourceOptions);
    this._originators = wmsParams.originators;
    this._legends = options.legends || wmsParams.legends;
    this._metadata = options.metadata || wmsParams.metadata;
    this._title = options.title || wmsParams.title;
    this._description = options.description || wmsParams.description;
    this._quicklookUrl = options.quicklookUrl || wmsParams.quicklookUrl;
    this.name = options.layer;
    this.service = "WMS";
    return this;
  }
};
var SourceWMS_default = SourceWMS;
if (window.ol && window.ol.source) {
  window.ol.source.GeoportalWMS = SourceWMS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/SourceWFS.js
var logger8 = LoggerByDefault_default2.getLogger("sourcewfs");
var SourceWFS = class extends Vector_default {
  /**
  * @constructor
  * @param {Object} options            - options for function call.
  * @param {String} options.layer      - Layer name (e.g. "")
  * @param {Number} [options.maxFeatures] - maximum features (max: 5000) 
  * @param {Object} [options.configuration] - configuration (cf. example) 
  * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
  * @param {String} [options.apiKey]   - Access key to Geoportal platform
  * @param {Array} [options.legends]   - Legends objects associated to the layer
  * @param {Array} [options.metadata]   - Metadata objects associated to the layer
  * @param {String} [options.title]   - title of the layer
  * @param {String} [options.description]   - description of the layer
  * @param {String} [options.quicklookUrl]   - quicklookUrl of the layer
  * @param {Object} [options.olParams] - other options for ol.source.Vector function (see {@link http://openlayers.org/en/latest/apidoc/ol.source.Vector.html ol.source.Vector})
  * @example
  * var sourceWFS = new ol.source.GeoportalWFS({
  *      layer: "",
  *      maxFeatures: 500,
  *      olParams: {}
  * });
  */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    var wfsParams = layerCfg ? layerCfg.params : null;
    var apiKey = options.apiKey;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WFS");
      if (!layerId) {
        throw new Error(`ERROR : WFS Layer ID ${options.layer} cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.`);
      }
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : WFS Layer configuration cannot be found in Geoportal.");
      }
      apiKey = Config_default2.configuration.getLayerKey(layerId)[0];
      wfsParams = Config_default2.configuration.getLayerParams(options.layer, "WFS");
    }
    var protocol = options.ssl === false ? "http://" : "https://";
    var urlParams = {
      "gp-ol-ext": package_default.olExtVersion || package_default.version
    };
    if (wfsParams.url.includes("/private/")) {
      var key = options.apiKey || apiKey;
      if (!key) {
        throw new Error("ERROR : WFS Layer apiKey cannot be found in Geoportal Configuration.");
      }
      urlParams["apikey"] = key;
    }
    var loadFeatures = (self2, url, extent, success, failure) => {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", url);
      const onError = function() {
        self2.removeLoadedExtent(extent);
        failure();
      };
      xhr.onerror = onError;
      xhr.onload = function() {
        if (xhr.status == 200) {
          var response = JSON.parse(xhr.responseText);
          const features = self2.getFormat().readFeatures(response);
          self2.addFeatures(features);
          success(features);
          if (response.links) {
            for (let i = 0; i < response.links.length; i++) {
              const link = response.links[i];
              if (link.rel === "next") {
                loadFeatures(self2, link.href, extent, success, failure);
              }
            }
          }
        } else {
          onError();
        }
      };
      xhr.send();
    };
    var wfsSourceOptions = {
      format: new GeoJSON_default(),
      loader: function(extent, resolution, projection, success, failure) {
        var self2 = this;
        const maxFeatures = options.maxFeatures;
        const layerName = options.layer;
        const proj = projection.getCode();
        const url = Gp_default.Helper.normalyzeUrl(wfsParams.url.replace(/(http|https):\/\//, protocol), urlParams, false) + "&SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature&typename=" + layerName + "&outputFormat=application/json&srsname=" + proj + "&bbox=" + extent.join(",") + "," + proj + "&maxFeatures=" + maxFeatures + "&count=" + maxFeatures + "&startIndex=0";
        loadFeatures(self2, url, extent, success, failure);
      },
      strategy: tile(createXYZ({
        minZoom: options.olParams.minZoom || 15,
        maxZoom: options.olParams.maxZoom || 21,
        tileSize: 512
      })),
      crossOrigin: "anonymous"
    };
    Helper_default2.mergeParams(wfsSourceOptions, options.olParams);
    if (options.olParams && !wfsParams.originators) {
      wfsParams.originators = options.olParams.attributions;
    }
    super(wfsSourceOptions);
    this._originators = wfsParams.originators;
    this._legends = options.legends || wfsParams.legends;
    this._metadata = options.metadata || wfsParams.metadata;
    this._title = options.title || wfsParams.title;
    this._description = options.description || wfsParams.description;
    this._quicklookUrl = options.quicklookUrl || wfsParams.quicklookUrl;
    this.name = options.layer;
    this.service = "WFS";
    return this;
  }
};
var SourceWFS_default = SourceWFS;
if (window.ol && window.ol.source) {
  window.ol.source.GeoportalWFS = SourceWFS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/LayerWMTS.js
var LayerWMTS = class extends Tile_default {
  /**
   * @constructor
   * @param {LayerWMTSOptions} options - options for function call.
   * @example
   * var layerWMTS = new ol.layer.GeoportalWMTS({
   *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
   * });
   * layerWMTS.getLegends();
   * layerWMTS.getMetadata();
   * layerWMTS.getTitle();
   * layerWMTS.getDescription();
   * layerWMTS.getQuicklookUrl();
   * layerWMTS.getOriginators();
   * 
   * // Ex. configuration object for WMTS Layer
   * {
   * "name" : "GEOGRAPHICALGRIDSYSTEMS.MAPS.OVERVIEW",
   * "globalConstraint" : {
   *     "maxScaleDenominator" : 279541132.01435894,
   *     "minScaleDenominator" : 2183915.0938621787,
   *     "bbox" : {
   *         "left" : -179.5,
   *         "right" : 179.5,
   *         "top" : 75,
   *         "bottom" : -75
   *     }
   * },
   * "params" : {
   *     "url" : "https://data.geopf.fr/wmts",
   *     "styles" : "normal",
   *     "version" : "1.0.0",
   *     "format" : "image/jpeg",
   *     "projection" : "EPSG:3857",
   *     "minScale" : 2183915.0938621787,
   *     "maxScale" : 279541132.01435894,
   *     "extent" : {
   *         "left" : -179.5,
   *         "right" : 179.5,
   *         "top" : 75,
   *         "bottom" : -75
   *     },
   *     "legends" : [
   *         {
   *             "format" : "image/jpeg",
   *             "url" : "https:*data.geopf.fr/annexes/ressources/legendes/LEGEND.jpg",
   *             "minScaleDenominator" : "200"
   *         }
   *     ],
   *     "title" : "Carte Mondiale pour la mini-vue",
   *     "description" : "Carte Mondiale pour la mini-vue",
   *     "tileMatrixSetLimits" : {
   *         "1" : {
   *             "minTileRow" : "0",
   *             "maxTileRow" : "1",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "1"
   *         },
   *         "2" : {
   *             "minTileRow" : "0",
   *             "maxTileRow" : "3",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "3"
   *         },
   *         "3" : {
   *             "minTileRow" : "1",
   *             "maxTileRow" : "6",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "7"
   *         },
   *         "4" : {
   *             "minTileRow" : "2",
   *             "maxTileRow" : "13",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "15"
   *         },
   *         "5" : {
   *             "minTileRow" : "5",
   *             "maxTileRow" : "26",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "31"
   *         },
   *         "6" : {
   *             "minTileRow" : "11",
   *             "maxTileRow" : "52",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "63"
   *         },
   *         "7" : {
   *             "minTileRow" : "22",
   *             "maxTileRow" : "105",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "127"
   *         },
   *         "8" : {
   *             "minTileRow" : "45",
   *             "maxTileRow" : "210",
   *             "minTileCol" : "0",
   *             "maxTileCol" : "255"
   *         }
   *     },
   *     "TMSLink" : "PM_1_8",
   *     "matrixIds" : [
   *         "1",
   *         "2",
   *         "3",
   *         "4",
   *         "5",
   *         "6",
   *         "7",
   *         "8"
   *     ],
   *     "tileMatrices" : {
   *         "1" : {
   *             "matrixId" : "1",
   *             "matrixHeight" : 2,
   *             "matrixWidth" : 2,
   *             "scaleDenominator" : 279541132.01435894,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "2" : {
   *             "matrixId" : "2",
   *             "matrixHeight" : 4,
   *             "matrixWidth" : 4,
   *             "scaleDenominator" : 139770566.0071793,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "3" : {
   *             "matrixId" : "3",
   *             "matrixHeight" : 8,
   *             "matrixWidth" : 8,
   *             "scaleDenominator" : 69885283.00358965,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "4" : {
   *             "matrixId" : "4",
   *             "matrixHeight" : 16,
   *             "matrixWidth" : 16,
   *             "scaleDenominator" : 34942641.50179486,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "5" : {
   *             "matrixId" : "5",
   *             "matrixHeight" : 32,
   *             "matrixWidth" : 32,
   *             "scaleDenominator" : 17471320.75089743,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "6" : {
   *             "matrixId" : "6",
   *             "matrixHeight" : 64,
   *             "matrixWidth" : 64,
   *             "scaleDenominator" : 8735660.375448715,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "7" : {
   *             "matrixId" : "7",
   *             "matrixHeight" : 128,
   *             "matrixWidth" : 128,
   *             "scaleDenominator" : 4367830.1877243575,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         },
   *         "8" : {
   *             "matrixId" : "8",
   *             "matrixHeight" : 256,
   *             "matrixWidth" : 256,
   *             "scaleDenominator" : 2183915.0938621787,
   *             "tileHeight" : 256,
   *             "tileWidth" : 256,
   *             "topLeftCorner" : {
   *                 "x" : -20037508.3427892,
   *                 "y" : 20037508.3427892
   *             }
   *         }
   *     },
   *     "nativeResolutions" : [
   *         "78271.51696402048",
   *         "39135.75848201023",
   *         "19567.87924100512",
   *         "9783.939620502561",
   *         "4891.969810251280",
   *         "2445.984905125640",
   *         "1222.992452562820",
   *         "611.4962262814100"
   *     ]
   * }
  */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WMTS");
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : Layer ID not found into the catalogue !?");
      }
    }
    var olSourceParams;
    if (options.olParams && options.olParams.sourceParams) {
      olSourceParams = options.olParams.sourceParams;
    }
    var wmtsSource = new SourceWMTS_default({
      layer: options.layer,
      configuration: options.configuration,
      ssl: options.ssl,
      apiKey: options.apiKey,
      olParams: olSourceParams
    });
    var layerTileOptions = {
      source: wmtsSource
    };
    if (wmtsSource.getLayer() !== void 0) {
      if (layerCfg.globalConstraint) {
        var geobbox = [
          layerCfg.globalConstraint.bbox.left,
          layerCfg.globalConstraint.bbox.bottom,
          layerCfg.globalConstraint.bbox.right,
          layerCfg.globalConstraint.bbox.top
        ];
        layerTileOptions.extent = transformExtent(geobbox, "EPSG:4326", layerCfg.globalConstraint.projection || "EPSG:3857");
        var p2;
        if (typeof layerCfg.globalConstraint.projection === "string") {
          p2 = get2(layerCfg.globalConstraint.projection);
        } else {
          p2 = get2("EPSG:3857");
        }
        if (p2 && p2.getUnits()) {
          if (p2.getUnits() === "m") {
            layerTileOptions.minResolution = (layerCfg.globalConstraint.minScaleDenominator - 1) * 28e-5;
            layerTileOptions.maxResolution = (layerCfg.globalConstraint.maxScaleDenominator + 1) * 28e-5;
          } else if (p2.getUnits() === "degrees") {
            layerTileOptions.minResolution = (layerCfg.globalConstraint.minScaleDenominator - 1) * 28e-5 * 180 / (Math.PI * 6378137);
            layerTileOptions.maxResolution = (layerCfg.globalConstraint.maxScaleDenominator + 1) * 28e-5 * 180 / (Math.PI * 6378137);
          }
        }
      }
    }
    Helper_default2.mergeParams(layerTileOptions, options.olParams);
    super(layerTileOptions);
    this.name = options.layer;
    this.service = "WMTS";
    this.config = layerCfg;
    return this;
  }
  /**
   * Get configuration
   * @returns {Object} - configuration
   */
  getConfiguration() {
    return this.config;
  }
  /**
   * Get legends
   * @returns {Array} - legends
   */
  getLegends() {
    return this.getSource()._legends;
  }
  /**
   * Get metadata
   * @returns {Array} - metadata
   */
  getMetadata() {
    return this.getSource()._metadata;
  }
  /**
   * Get description
   * @returns {String} - description
   */
  getDescription() {
    return this.getSource()._description;
  }
  /**
   * Get title
   * @returns {String} - title
   */
  getTitle() {
    return this.getSource()._title;
  }
  /**
   * Get quicklook url
   * @returns {String} - quicklook
   */
  getQuicklookUrl() {
    return this.getSource()._quicklookUrl;
  }
  /**
   * Get originators
   * @returns {Array} - originators
   */
  getOriginators() {
    return this.getSource()._originators;
  }
};
var LayerWMTS_default = LayerWMTS;
if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalWMTS = LayerWMTS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/LayerWMS.js
var LayerWMS = class extends Tile_default {
  /**
   * @constructor
   * @param {LayerWMSOptions} options - options for function call.
   * @example
   * var layerWMS = new ol.layer.GeoportalWMS({
   *      layer  : "ORTHOIMAGERY.ORTHOPHOTOS"
   * });
   * 
   * layerWMS.getLegends();
   * layerWMS.getMetadata();
   * layerWMS.getTitle();
   * layerWMS.getDescription();
   * layerWMS.getQuicklookUrl();
   * layerWMS.getOriginators();
   */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WMS");
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : Layer ID not found into the catalogue !?");
      }
    }
    var olSourceParams;
    if (options.olParams && options.olParams.sourceParams) {
      olSourceParams = options.olParams.sourceParams;
    }
    var wmsSource = new SourceWMS_default({
      layer: options.layer,
      configuration: options.configuration,
      ssl: options.ssl,
      apiKey: options.apiKey,
      olParams: olSourceParams
    });
    var layerTileOptions = {
      source: wmsSource
    };
    if (wmsSource.getParams().LAYERS !== void 0) {
      if (olSourceParams && olSourceParams.projection) {
        var geobbox = [
          layerCfg.globalConstraint.bbox.left,
          layerCfg.globalConstraint.bbox.bottom,
          layerCfg.globalConstraint.bbox.right,
          layerCfg.globalConstraint.bbox.top
        ];
        layerTileOptions.extent = transformExtent(geobbox, "EPSG:4326", olSourceParams.projection);
        var p2;
        if (typeof olSourceParams.projection === "string") {
          p2 = get2(olSourceParams.projection);
        } else if (typeof olSourceParams.projection === "object" && olSourceParams.projection.getCode()) {
          p2 = get2(olSourceParams.projection.getCode());
        }
        if (p2 && p2.getUnits()) {
          if (p2.getUnits() === "m") {
            layerTileOptions.minResolution = (layerCfg.globalConstraint.minScaleDenominator - 1) * 28e-5;
            layerTileOptions.maxResolution = (layerCfg.globalConstraint.maxScaleDenominator + 1) * 28e-5;
          } else if (p2.getUnits() === "degrees") {
            layerTileOptions.minResolution = (layerCfg.globalConstraint.minScaleDenominator - 1) * 28e-5 * 180 / (Math.PI * 6378137);
            layerTileOptions.maxResolution = (layerCfg.globalConstraint.maxScaleDenominator + 1) * 28e-5 * 180 / (Math.PI * 6378137);
          }
        }
      }
    }
    Helper_default2.mergeParams(layerTileOptions, options.olParams);
    super(layerTileOptions);
    this.name = options.layer;
    this.service = "WMS";
    this.config = layerCfg;
    return this;
  }
  /**
   * Get configuration
   * @returns {Object} - configuration
   */
  getConfiguration() {
    return this.config;
  }
  /**
   * Get legends
   * @returns  {Array} - legends
   */
  getLegends() {
    return this.getSource()._legends;
  }
  /**
   * Get metadata
   * @returns  {Array} - metadata
   */
  getMetadata() {
    return this.getSource()._metadata;
  }
  /**
   * Get description
   * @returns {String} - description
   */
  getDescription() {
    return this.getSource()._description;
  }
  /**
   * Get title
   * @returns {String} - title
   */
  getTitle() {
    return this.getSource()._title;
  }
  /**
   * Get quicklook url
   * @returns {String} - quicklook
   */
  getQuicklookUrl() {
    return this.getSource()._quicklookUrl;
  }
  /**
   * Get originators
   * @returns {Array} - originators
   */
  getOriginators() {
    return this.getSource()._originators;
  }
};
var LayerWMS_default = LayerWMS;
if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalWMS = LayerWMS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/LayerWFS.js
var MAXFEATURES = 500;
var MINZOOMDEFAULT = 15;
var MAXZOOMDEFAULT = 21;
var STYLEBYDEFAULT = new Style_default({
  stroke: new Stroke_default({
    color: "rgba(0, 0, 255, 1.0)",
    width: 2
  }),
  fill: new Fill_default({
    color: "rgba(0, 0, 255, 0.5)"
  })
});
var LayerWFS = class extends Vector_default2 {
  /**
   * @constructor
   * @param {LayerWFSOptions} options            - options for function call.
   * @example
   * var layerWFS = new ol.layer.GeoportalWFS({
   *      layer  : "BDTOPO_V3:batiment",
   *      maxFeatures: 500,
   *      olParams : {
   *          minZoom: 15,
   *          maxZoom: 21,
   *          style: new ol.style.Style(...),
   *          sourceParams: {}
   *      }
   * });
   * 
   * layerWFS.getLegends();
   * layerWFS.getMetadata();
   * layerWFS.getTitle();
   * layerWFS.getDescription();
   * layerWFS.getQuicklookUrl();
   * layerWFS.getOriginators();
   */
  constructor(options) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var layerCfg = options.configuration;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = Config_default2.configuration.getLayerId(options.layer, "WFS");
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : Layer ID not found into the catalogue !?");
      }
    }
    var olSourceParams;
    if (options.olParams && options.olParams.sourceParams) {
      olSourceParams = options.olParams.sourceParams;
    }
    var wfsSource = new SourceWFS_default({
      layer: options.layer,
      configuration: options.configuration,
      maxFeatures: options.maxFeatures || MAXFEATURES,
      ssl: options.ssl,
      apiKey: options.apiKey,
      olParams: olSourceParams || {
        minZoom: MINZOOMDEFAULT,
        maxZoom: MAXZOOMDEFAULT
      }
    });
    var layerVectorOptions = {
      source: wfsSource
    };
    if (!options.olParams) {
      options.olParams = {
        minZoom: MINZOOMDEFAULT,
        maxZoom: MAXZOOMDEFAULT,
        style: STYLEBYDEFAULT
      };
    } else {
      Helper_default2.mergeParams({
        minZoom: MINZOOMDEFAULT,
        maxZoom: MAXZOOMDEFAULT,
        style: STYLEBYDEFAULT
      }, options.olParams);
    }
    Helper_default2.mergeParams(layerVectorOptions, options.olParams);
    super(layerVectorOptions);
    this.name = options.layer;
    this.service = "WFS";
    this.config = layerCfg;
    return this;
  }
  /**
   * Get configuration
   * @returns {Object} - configuration
   */
  getConfiguration() {
    return this.config;
  }
  /**
   * Get legends
   * @returns  {Array} - legends
   */
  getLegends() {
    return this.getSource()._legends;
  }
  /**
   * Get metadata
   * @returns  {Array} - metadata
   */
  getMetadata() {
    return this.getSource()._metadata;
  }
  /**
   * Get description
   * @returns {String} - description
   */
  getDescription() {
    return this.getSource()._description;
  }
  /**
   * Get title
   * @returns {String} - title
   */
  getTitle() {
    return this.getSource()._title;
  }
  /**
   * Get quicklook url
   * @returns {String} - quicklook
   */
  getQuicklookUrl() {
    return this.getSource()._quicklookUrl;
  }
  /**
   * Get originators
   * @returns {Array} - originators
   */
  getOriginators() {
    return this.getSource()._originators;
  }
};
var LayerWFS_default = LayerWFS;
if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalWFS = LayerWFS;
}

// node_modules/geopf-extensions-openlayers/src/packages/Layers/LayerMapBox.js
var LayerMapBox = class extends VectorTile_default2 {
  /**
   * @module GeoportalMapBox
   * @constructor
   * @param {Object} options            - options for function call.
   * @param {String} options.layer      - Layer name (e.g. "PLAN.IGN")
   * @param {Object} [options.configuration] - configuration (cf. example) 
   * @param {String} [options.style]    - Style name (e.g. "classique")
   * @param {String} [options.source]   - Source name (e.g. "plan_ign")
   * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)
   * @param {Object} [settings] - other options for ol.layer.VectorTile function (see {@link https://openlayers.org/en/latest/apidoc/module-ol_layer_VectorTile-VectorTileLayer.html ol.layer.VectorTile})
   * @fires mapbox:style:loaded
   * @example
   * var LayerMapBox = new ol.layer.GeoportalMapBox({
   *      layer  : "PLAN.IGN",
   *      [style  : "classique",]
   *      [source : "plan_ign",]
   *      [ssl: true]
   * }, {
   *      opacity
   *      visible
   *      extent
   *      declutter
   *      ...
   * });
   * 
   * // Ex. configuration object for TMS Layer
   * "PLAN.IGN$GEOPORTAIL:GPP:TMS": {
   *   "hidden": true,
   *   "queryable": false,
   *   "serviceParams": {
   *     "id": "GPP:TMS",
   *     "version": "1.0.0",
   *     "serverUrl": {
   *       "cartes": "https://wxs.ign.fr/cartes/geoportail/tms/1.0.0/"
   *     }
   *   },
   *   "name": "PLAN.IGN",
   *   "title": "Plan IGN",
   *   "description": "BDUni tuilÃ©e",
   *   "formats": [
   *     {
   *       "current": true,
   *       "name": "application/x-protobuf"
   *     }
   *   ],
   *   "styles": [
   *     {
   *       "name": "standard",
   *       "title": "Style standard",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/standard.json"
   *     },
   *     {
   *       "name": "classique",
   *       "title": "Style classique",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/classique.json"
   *     },
   *     {
   *       "name": "transparent",
   *       "title": "Style transparent",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/transparent.json"
   *     },
   *     {
   *       "name": "accentue",
   *       "title": "Style accentue",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/accentue.json"
   *     },
   *     {
   *       "name": "attenue",
   *       "title": "Style attenue",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/attenue.json"
   *     },
   *     {
   *       "name": "gris",
   *       "title": "Style en noir et blanc",
   *       "current": false,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/gris.json"
   *     },
   *     {
   *       "name": "epure",
   *       "title": "Style epure",
   *       "current": true,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/epure.json"
   *     },
   *     {
   *       "name": "sans_toponymes",
   *       "title": "Style sans toponymes",
   *       "current": false,
   *       "url": "https://wxs.ign.fr/static/vectorTiles/styles/PLAN.IGN/essentiels/sans_toponymes.json"
   *     }
   *   ],
   *   "globalConstraint": {
   *     "crs": null,
   *     "bbox": {
   *       "left": -724011.531917197,
   *       "right": 1095801.237496279,
   *       "top": 6672646.821182753,
   *       "bottom": 5009377.0856973175
   *     },
   *     "minScaleDenominator": null,
   *     "maxScaleDenominator": null
   *   },
   *   "quicklookUrl": "https://wxs.ign.fr/static/pictures/ign_carte2.jpg",
   *   "layerId": "PLAN.IGN$GEOPORTAIL:GPP:TMS",
   *   "defaultProjection": "EPSG:3857"
   * }
  */
  constructor(options, settings) {
    if (!options.layer) {
      throw new Error("ERROR PARAM_MISSING : layer");
    }
    if (typeof options.layer !== "string") {
      throw new Error("ERROR WRONG TYPE : layer");
    }
    if (typeof options.ssl === "undefined") {
      options.ssl = true;
    }
    var protocol = options.ssl === false ? "http://" : "https://";
    var layerCfg = options.configuration;
    if (!layerCfg) {
      if (!Config_default2.isConfigLoaded()) {
        throw new Error("ERROR : contract key configuration has to be loaded to load Geoportal layers.");
      }
      var layerId = options.layer + "$GEOPORTAIL:GPP:TMS";
      layerCfg = Config_default2.configuration.getLayerConf(layerId);
      if (!layerCfg) {
        throw new Error("ERROR : Layer ID not found into the catalogue !?");
      }
    }
    var styleUrl = null;
    var styleTitle = "";
    var styleName = options.style;
    for (var i = 0; i < layerCfg.styles.length; i++) {
      var style = layerCfg.styles[i];
      if (styleName && style.name === styleName) {
        styleUrl = style.url;
        styleTitle = style.title;
        break;
      } else {
        if (!styleName && style.current) {
          styleName = style.name;
          styleUrl = style.url;
          styleTitle = style.title;
          break;
        }
      }
    }
    if (!styleUrl) {
      throw new Error("ERROR : Style URL not found !?");
    }
    styleUrl.replace(/(http|https):\/\//, protocol);
    var source = new VectorTile_default({
      state: "loading",
      // statut
      format: new MVT_default()
    });
    source._originators = layerCfg.originators;
    source._legends = layerCfg.legends;
    source._metadata = layerCfg.metadata;
    source._description = layerCfg.description;
    source._title = layerCfg.title + " (" + styleTitle + ")";
    source._quicklookUrl = layerCfg.quicklookUrl;
    var layerVectorTileOptions = {
      source
    };
    Helper_default2.mergeParams(layerVectorTileOptions, settings);
    if (options.olParams && !layerCfg.originators) {
      source._originators = options.olParams.attributions;
    }
    super(layerVectorTileOptions);
    this.name = options.layer;
    this.service = "TMS";
    this.protocol = protocol;
    this.sourceId = options.source;
    this.styleUrl = styleUrl;
    this.styleName = styleName;
    this.config = layerCfg;
    this.setStyleMapBox();
    return this;
  }
  /**
   * Get Style MapBox
   * @private
   */
  setStyleMapBox() {
    var self2 = this;
    fetch(this.styleUrl, {
      credentials: "same-origin"
    }).then(function(response) {
      if (response.ok) {
        response.json().then(function(style) {
          self2.onStyleMapBoxLoad(style);
        });
      }
    }).catch(function(e) {
      self2.onStyleMapBoxError(e);
    });
  }
  /**
   * Add Style
   * @param {*} style - json style
   */
  onStyleMapBoxLoad(style) {
    if (!this.sourceId) {
      this.sourceId = Object.keys(style.sources)[0];
    }
    var styleSource = style.sources[this.sourceId];
    if (!styleSource) {
      this.onStyleMapBoxError({
        message: "ERROR : Source ID not found !? !"
      });
      return;
    }
    if (styleSource.type !== "vector") {
      this.onStyleMapBoxError({
        message: "ERROR : Source TYPE not permitted !"
      });
      return;
    }
    var source = this.getSource();
    if (styleSource.url) {
      styleSource.url.replace(/(http|https):\/\//, this.protocol);
      var vectorTileJson = new TileJSON_default({
        url: styleSource.url
      });
      var self2 = this;
      var key = vectorTileJson.on("change", function() {
        if (vectorTileJson.getState() === "ready") {
          var doc = vectorTileJson.getTileJSON();
          if (!doc) {
            return;
          }
          self2.set("mapbox-extensions", doc);
          var tiles = Array.isArray(doc.tiles) ? doc.tiles : [doc.tiles];
          for (var i = 0; i < styleSource.tiles.length; i++) {
            tiles[i].replace(/(http|https):\/\//, this.protocol);
          }
          source.setUrls(tiles);
          unByKey(key);
        }
      });
    }
    if (styleSource.tiles) {
      for (var j2 = 0; j2 < styleSource.tiles.length; j2++) {
        styleSource.tiles[j2].replace(/(http|https):\/\//, this.protocol);
      }
      source.setUrls(styleSource.tiles);
    }
    applyStyle(this, style, this.sourceId).then(() => {
      source.setState("ready");
      this.set("mapbox-styles", style);
    }).then(() => {
      this.dispatchEvent({
        type: "mapbox:style:loaded",
        style: this.styleUrl,
        name: this.styleName
      });
    }).catch((error) => {
      this.onStyleMapBoxError(error);
    });
  }
  /**
   * Error
   * @param {*} error - message
   */
  onStyleMapBoxError(error) {
    var source = this.getSource();
    source.setState("error");
    console.error(error.message);
  }
  /**
   * Get configuration
   * @returns {Object} - configuration
   */
  getConfiguration() {
    return this.config;
  }
  /**
   * Get legends
   * @returns  {Array} - legends
   */
  getLegends() {
    return this.getSource()._legends;
  }
  /**
   * Get metadata
   * @returns  {Array} - metadata
   */
  getMetadata() {
    return this.getSource()._metadata;
  }
  /**
   * Get description
   * @returns {String} - description
   */
  getDescription() {
    return this.getSource()._description;
  }
  /**
   * Get title
   * @returns {String} - title
   */
  getTitle() {
    return this.getSource()._title;
  }
  /**
   * Get quicklook url
   * @returns {String} - quicklook
   */
  getQuicklookUrl() {
    return this.getSource()._quicklookUrl;
  }
  /**
   * Get originators
   * @returns {Array} - originators
   */
  getOriginators() {
    return this.getSource()._originators;
  }
};
var LayerMapBox_default = LayerMapBox;
if (window.ol && window.ol.layer) {
  window.ol.layer.GeoportalMapBox = LayerMapBox;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerSwitcher/LayerSwitcher.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/LayerSwitcher/GPFlayerSwitcher.css";

// node_modules/geopf-extensions-openlayers/src/packages/Utils/PanelManager.js
var exceptions = ["GPoverviewMap", "GPfullScreen"];
function getSameSideOpenedPanel(position, openedPanelID) {
  var exceptionPanel = [...exceptions, openedPanelID];
  var controlPanels = [];
  if (position && position.includes("left")) {
    var bottomLeft = document.getElementById("position-container-bottom-left");
    var topLeft = document.getElementById("position-container-top-left");
    controlPanels = [...bottomLeft.children, ...topLeft.children];
  }
  if (position && position.includes("right")) {
    var bottomRight = document.getElementById("position-container-bottom-right");
    var topRight = document.getElementById("position-container-top-right");
    controlPanels = [...bottomRight.children, ...topRight.children];
  }
  return controlPanels.filter((p2) => {
    var panelID = p2.id.match(/(\w+)-[0-9]+/)[1];
    var isException = exceptionPanel.includes(panelID);
    var isOpened = p2.getElementsByTagName("button")[0].getAttribute("aria-pressed");
    if (isOpened === "true" && !isException) {
      return p2;
    }
  });
}
var PanelManager = function(position, openedPanelID) {
  var openedPanel = getSameSideOpenedPanel(position, openedPanelID);
  if (openedPanel.length > 0) {
    openedPanel[0].getElementsByTagName("button")[0].click();
  }
};
var PanelManager_default = PanelManager;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Widget.js
var Widget = {
  /**
   * This method is called when a widget opens a panel
   * It calls the panelManager to automatically close other panels
   */
  onPanelOpen: function() {
    PanelManager_default(this.options.position, this.element.id.match(/(\w+)-[0-9]+/)[1]);
  }
};
var Widget_default = Widget;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/CheckDsfr.js
var checkDsfr = function() {
  var style = getComputedStyle(document.documentElement);
  var color = style.getPropertyValue("--blue-france-sun-113-625");
  if (color === "") {
    return false;
  }
  return true;
};
var CheckDsfr_default = checkDsfr;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Control.js
var ControlExtended = class extends Control_default {
  constructor(options) {
    options = options || {};
    super({
      element: options.element,
      target: options.target,
      render: options.render
    });
    if (options && options.listable) {
      this.listable = true;
    } else {
      this.listable = false;
    }
    if (options && options.description) {
      this.description = options.description;
    } else {
      this.description = "";
    }
  }
  setPosition(pos) {
    if (this.getMap()) {
      var instance = new PositionFactory(this);
      instance.set(pos);
    }
  }
  updatePosition(pos) {
    if (this.getMap()) {
      var instance = new PositionFactory(this);
      instance.update(pos);
    }
  }
};
var Control_default2 = ControlExtended;
var ANCHORS = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
];
var _PositionFactory_instances, existContainer_fn, createContainer_fn, setAnchor_fn;
var PositionFactory = class {
  /**
   * constructor
   * @param {*} caller - ...
   */
  constructor(caller) {
    __privateAdd(this, _PositionFactory_instances);
    this.caller = caller;
    this.container = null;
    __privateMethod(this, _PositionFactory_instances, createContainer_fn).call(this, "top-left");
    __privateMethod(this, _PositionFactory_instances, createContainer_fn).call(this, "top-right");
    __privateMethod(this, _PositionFactory_instances, createContainer_fn).call(this, "bottom-left");
    __privateMethod(this, _PositionFactory_instances, createContainer_fn).call(this, "bottom-right");
    return this;
  }
  /**
   * ...
   * @param {*} pos - ...
   * @public
   */
  set(pos) {
    if (!ANCHORS.includes(pos.toLowerCase())) {
      return;
    }
    __privateMethod(this, _PositionFactory_instances, setAnchor_fn).call(this, pos, false);
    if (pos.includes("bottom")) {
      this.container.children["position-container-" + pos].prepend(this.caller.element);
    } else {
      this.container.children["position-container-" + pos].appendChild(this.caller.element);
    }
  }
  /**
   * ...
   * @param {*} pos - ...
   * @public
   */
  update(pos) {
    if (!ANCHORS.includes(pos.toLowerCase())) {
      return;
    }
    __privateMethod(this, _PositionFactory_instances, setAnchor_fn).call(this, pos, true);
  }
};
_PositionFactory_instances = new WeakSet();
/**
 * ...
 * @param {*} name  - ...
 * @returns {Boolean} ...
 */
existContainer_fn = function(name) {
  var div = this.container.children["position-container-" + name];
  if (div) {
    return true;
  }
  return false;
};
/**
 * ...
 * @param {*} name - ...
 * @private
 */
createContainer_fn = function(name) {
  this.container = this.caller.getMap().getOverlayContainerStopEvent();
  if (__privateMethod(this, _PositionFactory_instances, existContainer_fn).call(this, name)) {
    return;
  }
  var div = document.createElement("div");
  div.id = "position-container-" + name;
  div.className = "position position-container-" + name;
  this.container.appendChild(div);
};
/**
 * ...
 * @param {*} pos - ...
 * @param {*} update - ...
 * @todo fonctionnement Ã  tester !
 */
setAnchor_fn = function(pos, update) {
  var self2 = this;
  const position = (pos2) => {
    var element = self2.container.children["position-container-" + pos2];
    return element.children.length;
  };
  const sizeW = (pos2) => {
    var element = self2.container.children["position-container-" + pos2];
    var width = element.offsetWidth;
    return width;
  };
  const sizeH = (pos2) => {
    var element = self2.container.children["position-container-" + pos2];
    var height = element.offsetHeight;
    if (update) {
      if (pos2.includes("top")) {
        height = 0;
      }
      for (let index2 = 0; index2 < element.children.length; index2++) {
        const id = element.children[index2].id;
        if (id === self2.caller.element.id) {
          height = pos2.includes("bottom") ? height - self2.caller.element.offsetHeight : height * -1;
          break;
        }
        height -= element.children[index2].offsetHeight;
      }
    }
    return height;
  };
  const clear2 = (element) => {
    element.style.top = "unset";
    element.style.bottom = "unset";
    element.style.left = "unset";
    element.style.right = "unset";
  };
  clear2(this.caller.element);
  this.caller.element.style.position = "unset";
  var panels = Array.from(this.caller.element.getElementsByClassName("GPpanel"));
  if (panels.length === 0) {
    return;
  }
  var offset = 0;
  panels.forEach((panel) => {
    if (panel.nodeName.toLowerCase() !== "dialog") {
      return;
    }
    clear2(panel);
    switch (pos.toLowerCase()) {
      case "top-left":
        if (CheckDsfr_default()) {
          panel.style.top = "0px";
        } else {
          panel.style.top = position(pos) ? sizeH(pos) + "px" : "0px";
        }
        panel.style.left = sizeW(pos) + offset + "px";
        break;
      case "bottom-left":
        if (CheckDsfr_default()) {
          panel.style.top = "0px";
        } else {
          panel.style.bottom = position(pos) ? sizeH(pos) + "px" : "0px";
        }
        panel.style.left = sizeW(pos) + offset + "px";
        break;
      case "top-right":
        if (CheckDsfr_default()) {
          panel.style.top = "0px";
        } else {
          panel.style.top = position(pos) ? sizeH(pos) + "px" : "0px";
        }
        panel.style.right = sizeW(pos) + offset + "px";
        break;
      case "bottom-right":
        if (CheckDsfr_default()) {
          panel.style.top = "0px";
        } else {
          panel.style.bottom = position(pos) ? sizeH(pos) + "px" : "0px";
        }
        panel.style.right = sizeW(pos) + offset + "px";
        break;
      default:
        break;
    }
    offset += panel.offsetWidth;
  });
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/SelectorID.js
var SelectorID = {
  /**
   * Construction d'un identifiant statique basÃ© sur le timestamp,
   * et qui s'incremente de +1 Ã  chaque appel
   * @function generate
   */
  generate: (function() {
    var timestamp = Math.floor(Date.now());
    return function() {
      return timestamp++;
    };
  })(),
  /**
   * nom du tag
   * @function name
   * @param {String} id - the id
   * @returns {String} index
   */
  name: function(id) {
    var name = null;
    var i = id.lastIndexOf("-");
    if (i === -1) {
      name = id;
    } else {
      name = id.substring(0, i);
    }
    return name;
  },
  /**
   * numero d'identifiant du tag
   *
   * @function index
   * @param {String} id - the id
   * @returns {String} index
   */
  index: function(id) {
    var index2 = null;
    var name = this.name(id);
    var i = name.lastIndexOf("_");
    if (i !== -1) {
      index2 = name.substring(i + 1);
    }
    return index2;
  },
  /**
   * uuid du tag
   *
   * @function uuid
   * @param {String} id - the id
   * @returns {String} uuid
   */
  uuid: function(id) {
    var uuid = null;
    var i = id.lastIndexOf("-");
    if (i !== -1) {
      uuid = parseInt(id.substring(i + 1), 10);
    }
    return uuid;
  }
};
var SelectorID_default = SelectorID;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/ToolTips.js
var ToolTips = {
  /** 
   * ID du container 
   */
  id: "gpf-tooltips-html",
  /** 
   * Initialisation du container de tooltips
   * @param {Object} style - style css
   */
  init: function(style = {}) {
    if (document.getElementById(this.id)) {
      return;
    }
    const tooltip = document.createElement("div");
    tooltip.id = this.id;
    Object.assign(tooltip.style, style);
    document.body.appendChild(tooltip);
  },
  /**
   * Active les evenements sur le tooltip pour un element
   * 
   * Le contenu du tooltip est rÃ©cuperÃ© dans l'attribut 'data-tooltip'
   * de l'element.
   * 
   * @param {*} element - ...
   */
  active: function(element) {
    var self2 = this;
    var content = element.getAttribute("data-tooltip");
    if (!content) {
      return;
    }
    element.addEventListener("mouseenter", (e) => {
      var tooltip = document.getElementById(self2.id);
      if (!tooltip) {
        return;
      }
      tooltip.innerHTML = content;
      const rect = element.getBoundingClientRect();
      tooltip.style.top = `${rect.top - tooltip.offsetHeight - 10}px`;
      tooltip.style.left = `${rect.left + rect.width / 2}px`;
      tooltip.style.transform = "translateX(-50%)";
      tooltip.style.opacity = "1";
    });
    element.addEventListener("mouseleave", () => {
      var tooltip = document.getElementById(self2.id);
      if (!tooltip) {
        return;
      }
      tooltip.style.opacity = "0";
    });
  }
};
var ToolTips_default = ToolTips;

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target2 = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
var version = "1.15.3";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector) return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_3) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform3 = css(el, "transform");
      if (transform3 && transform3 !== "none") {
        appliedTransforms = transform3 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend2(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x3, y3) {
  el.scrollLeft += x3;
  el.scrollTop += y3;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target2) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target2
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function") callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target2 = state.target, fromRect = target2.fromRect, toRect = getRect(target2), prevFromRect = target2.prevFromRect, prevToRect = target2.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target2, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target2.toRect = toRect;
        if (target2.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target2.prevFromRect = fromRect;
          target2.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target2, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target2.animationResetTimer);
          target2.animationResetTimer = setTimeout(function() {
            target2.animationTime = 0;
            target2.prevFromRect = null;
            target2.fromRect = null;
            target2.prevToRect = null;
            target2.thisAnimationDuration = null;
          }, time);
          target2.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function") callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function") callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target2, currentRect, toRect, duration) {
      if (duration) {
        css(target2, "transition", "");
        css(target2, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target2.animatingX = !!translateX;
        target2.animatingY = !!translateY;
        css(target2, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target2);
        css(target2, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target2, "transform", "translate3d(0,0,0)");
        typeof target2.animated === "number" && clearTimeout(target2.animated);
        target2.animated = setTimeout(function() {
          css(target2, "transition", "");
          css(target2, "transform", "");
          target2.animated = false;
          target2.animatingX = false;
          target2.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target2) {
  return target2.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2)) continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function") return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value2) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value2);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable) return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = (function() {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
})();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x3, y3) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable), insideHorizontally = x3 >= rect.left - threshold && x3 <= rect.right + threshold, insideVertically = y3 >= rect.top - threshold && y3 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value2, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value2 == null && (pull || sameGroup)) {
        return true;
      } else if (value2 == null || value2 === false) {
        return false;
      } else if (pull && value2 === "clone") {
        return value2;
      } else if (typeof value2 === "function") {
        return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target2) {
    if (!this.el.contains(target2) && target2 !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target2) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target2, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable) return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target2 = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target2, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target2 && target2.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target2 = closest(target2, options.draggable, el, false);
    if (target2 && target2.animated) {
      return;
    }
    if (lastDownEl === target2) {
      return;
    }
    oldIndex = index(target2);
    oldDraggableIndex = index(target2, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target2, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target2,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target2,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target2);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target2) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target2 && !dragEl && target2.parentNode === el) {
      var dragRect = getRect(target2);
      rootEl = el;
      dragEl = target2;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target2;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target2 = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target2;
      while (target2 && target2.shadowRoot) {
        target2 = target2.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target2 === parent) break;
        parent = target2;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target2);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target2,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target2 = parent;
        } while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target2 = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target: target2,
        completed,
        onMove: function onMove(target3, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target3, getRect(target3), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target2;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target2 === dragEl && !dragEl.animated || target2 === el && !target2.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target2 !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target2 = closest(target2, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target2.animated && target2.animatingX && target2.animatingY || _this._ignoreWhileAnimating === target2) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target2) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target2 = elLastChild;
        }
        if (target2) {
          targetRect = getRect(target2);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, !!target2) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target2 = firstChild;
        targetRect = getRect(target2);
        if (_onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target2.parentNode === el) {
        targetRect = getRect(target2);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target2.animated && target2.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target2, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target2) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target2, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target2);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target2) {
          return completed(false);
        }
        lastTarget = target2;
        lastDirection = direction;
        var nextSibling = target2.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target2.parentNode.insertBefore(dragEl, after ? nextSibling : target2);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target2)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value2) {
    var options = this.options;
    if (value2 === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value2);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value2;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target2, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target2);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target2) {
  if (index(dragEl) < index(target2)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend2,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x3, y3);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x3 !== lastAutoScrollX || y3 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x3, y3), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x3;
          lastAutoScrollY = y3;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll) return;
  var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x3) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y3) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target2 = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target2)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerSwitcher/LayerSwitcherDOM.js
var import_loglevel = __toESM(require_loglevel());
var LayerSwitcherDOM = {
  /**
   * Creation du drag and drop
   *
   * @param {Object} elementDraggable - Element HTML (DOM) Container
   * @param {Object} context - this
   */
  _createDraggableElement: function(elementDraggable, context) {
    let handleClass = [".GPtitle"];
    if (CheckDsfr_default()) {
      handleClass.push(".GPlayerDragNDrop");
    }
    const forceFallback = !!navigator.userAgent.match(/chrome|chromium|crios/i);
    context._sortables = [];
    handleClass.forEach((handle) => {
      const sortable = sortable_esm_default.create(elementDraggable, {
        handle,
        dataIdAttr: "data-sortable-id",
        // required to calculate the custom sort
        draggable: ".draggable-layer",
        ghostClass: "GPghostLayer",
        animation: 200,
        // Call event function on drag and drop
        onEnd: function(e) {
          context._onEndDragAndDropLayerClick(e);
        }
      });
      context._sortables.push(sortable);
    });
  },
  /**
   * Fonction permettant de bouger une couche au clavier
   * @param {HTMLElement} element Ã‰lÃ©ment Ã  bouger
   * @param {up|down} direction Direction dans laquelle dÃ©placer la couche
   * @returns {Boolean} Vrai si l'opÃ©ration a fonctionnÃ©e.
   */
  _moveElement: function(element, direction) {
    const sortable_list = this._sortables[0];
    if (["up", "down"].includes(direction) == false) {
      return false;
    }
    if (typeof element.dataset.sortableId == "undefined") {
      return false;
    }
    let sortableId = element.dataset.sortableId;
    let order = sortable_list.toArray();
    let index2 = order.indexOf(sortableId);
    order.splice(index2, 1);
    if (direction == "down") {
      order.splice(index2 + 1, 0, sortableId);
    } else if (direction == "up") {
      order.splice(index2 - 1, 0, sortableId);
    }
    sortable_list.sort(order, true);
    this._onEndDragAndDropLayerClick({
      newIndex: order.indexOf(sortableId)
    });
    return true;
  },
  /**
   * Ã‰couteur d'Ã©vÃ©nement pour modifier le z-index
   * @param {Boolean} up Vrai si c'est up. Faux si down.
   * @param {KeyboardEvent} event Ã‰vÃ©nement du clavier
   */
  _onMoveElement: function(up, event) {
    if (["Enter", "Space"].includes(event.code)) {
      const direction = up ? "up" : "down";
      const oppositeDirection = up ? "down" : "up";
      event.stopPropagation();
      event.preventDefault();
      this._moveElement(event.currentTarget.closest(".draggable-layer"), direction);
      if (window.getComputedStyle(event.currentTarget).visibility == "hidden") {
        event.currentTarget.parentNode.querySelector(`[data-direction=${oppositeDirection}]`).focus();
      } else {
        event.currentTarget.focus();
      }
    }
  },
  // ################################################################### //
  // ######################### Main container ########################## //
  // ################################################################### //
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Creation du container principal (DOM)
   *
   * @returns {HTMLElement} container - layer switcher DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher");
    container.className = "GPwidget gpf-widget gpf-mobile-fullscreen gpf-widget-button";
    return container;
  },
  /**
   * Creation du container principal d"affichage des layers (DOM)
   *
   * @returns {HTMLElement} input - element for minimizing/maximizing the layer switcher
   */
  _createMainLayersShowElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GPshowLayersList");
    input.type = "checkbox";
    return input;
  },
  /**
   * Creation du container principal des layers (DOM)
   *
   * @returns {HTMLElement} container - layers list container
   */
  _createMainLayersElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPlayersList");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createMainLayersDivElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelBody gpf-panel__body_ls fr-modal__body";
    return div;
  },
  _createMainLayerListElement: function() {
    var div = document.createElement("div");
    div.className = "GPLayerListBody";
    div.setAttribute("role", "list");
    return div;
  },
  /**
   * Creation du container du picto du controle (DOM)
   *
   * @returns {HTMLElement} label
   */
  _createMainPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowLayersListPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowLayersListPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-layerswitcher");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.htmlFor = this._addUID("GPshowLayersList");
    button.setAttribute("aria-label", "Afficher/masquer le gestionnaire de couches");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        document.getElementById(self2._addUID("GPshowLayersList")).checked = status;
        if (document.getElementById(self2._addUID("GPshowLayersList")).checked) {
          document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.remove("GPlayerInfoPanelOpened", "gpf-visible");
          document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
          document.getElementById(self2._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
          document.getElementById(self2._addUID("GPlayerStylePanel")).classList.remove("GPlayerStylePanelOpened", "gpf-visible");
        }
        self2.onShowLayerSwitcherClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        if (document.getElementById(self2._addUID("GPshowLayersList")).checked) {
          document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.remove("GPlayerInfoPanelOpened", "gpf-visible");
          document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
          document.getElementById(self2._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
          document.getElementById(self2._addUID("GPlayerStylePanel")).classList.remove("GPlayerStylePanelOpened", "gpf-visible");
        }
        self2.onShowLayerSwitcherClick(e);
      });
    }
    return button;
  },
  _createMainCounterLayersElement: function() {
    var span = document.createElement("span");
    span.id = this._addUID("GPlayerCounter");
    span.className = "GPlayerCounter";
    span.innerHTML = "0";
    return span;
  },
  /**
   * Creation du container du panneau d"information (DOM)
   *
   * @returns {HTMLElement} container
   */
  _createMainInfoElement: function() {
    var divP = document.createElement("dialog");
    divP.id = this._addUID("GPlayerInfoPanel");
    divP.className = "GPpanel GPlayerInfoPanelClosed gpf-panel fr-modal";
    return divP;
  },
  _createMainInfoDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Creation du container du panneau des styles (DOM)
   *
   * @returns {HTMLElement} container
   */
  _createMainStyleElement: function() {
    var divP = document.createElement("dialog");
    divP.id = this._addUID("GPlayerStylePanel");
    divP.className = "GPpanel GPlayerStylePanelClosed gpf-panel fr-modal";
    return divP;
  },
  _createMainStyleDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  // ################################################################### //
  // ######################### Layer container ######################### //
  // ################################################################### //
  _createLayersPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header_ls";
    return container;
  },
  _createLayersPanelIconElement: function() {
    var label = document.createElement("label");
    label.className = "GPpanelIcon gpf-btn-header gpf-btn-icon-layers";
    label.title = "Couches";
    return label;
  },
  _createLayersPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title_ls";
    div.id = this._addUID("GPlayersHeaderTitle");
    div.innerHTML = "Couches";
    return div;
  },
  _createLayersPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.id = this._addUID("GPlayersPanelClose");
    btnClose.className = "GPpanelClose GPlayersPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    btnClose.title = "Fermer le panneau";
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible fr-mx-1w";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowLayersListPicto")).click();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowLayersListPicto")).click();
      });
    }
    return btnClose;
  },
  /**
   * CrÃ©Ã© le conteneur du header
   * @returns {HTMLDivElement} Conteneur
   */
  _createHeaderButtonsDivElement: function() {
    var div = document.createElement("div");
    div.className = "GPbodyHeader";
    div.id = this._addUID("GPbodyHeader");
    return div;
  },
  /**
   * CrÃ©Ã© le conteneur des boutons du header
   * @param {Object} options Options
   * @param {String} [options.className] ClassName de l'Ã©lÃ©ment
   * @param {Boolean} [options.left] Optionnel. Place les boutons Ã  gauche si vrai.
   * @param {Boolean} [options.size] Optionnel. Taille des boutons. Par dÃ©faut, 'md'.
   * @param {String} [options.id] ClassName de l'Ã©lÃ©ment (utilisÃ© pour l'id aussi)
   * @returns {HTMLDivElement} Contenur de bouton
   */
  _createButtonsGroupElement: function(options) {
    options = options ? options : {};
    let customClass = options.className ? options.className : "";
    let position = options.left ? "left" : "right";
    let classSize = "";
    options.size = options.size ? options.size : "";
    switch (options.size.toLowerCase()) {
      case "sm":
        classSize = "fr-btns-group--sm";
        break;
      case "lg":
        classSize = "fr-btns-group--lg";
        break;
    }
    var div = document.createElement("div");
    div.className = `${customClass} GPbtnsGroup GPbtnsGroup--${position} fr-btns-group fr-btns-group--${position} fr-btns-group--inline-reverse fr-btns-group--inline ${classSize} fr-btns-group--icon-left`;
    let id = options.id !== null ? `${customClass}_ID_${options.id}` : customClass;
    div.id = this._addUID(id);
    return div;
  },
  /**
   * CrÃ©Ã© un bouton
   * @param {Object} options Options du bouton (de type LayerSwitcher.HeaderButton)
   * @returns {HTMLButtonElement} Bouton
   */
  _createButtonHeaderElement: function(options) {
    let btn = document.createElement("button");
    btn.className = "fr-btn fr-btn--tertiary gpf-btn ";
    if (options.className) {
      btn.className += options.className;
    }
    if (options.icon) {
      btn.className += options.icon;
    }
    if (options.label) {
      btn.innerHTML = options.label;
    }
    if (options.title) {
      btn.title = options.title;
      btn.ariaLabel = options.title;
    }
    btn.id = options.id ? options.id : this._addUID("GPtools-" + options.label.toLowerCase());
    if (options.attributes) {
      for (const attribute in options.attributes) {
        if (!Object.hasOwn(options.attributes, attribute)) {
          continue;
        }
        const element = options.attributes[attribute];
        btn.setAttribute(attribute, element);
      }
    }
    let self2 = this;
    btn.addEventListener("click", (e) => {
      self2._onClickHeaderButtons(e, options.label, options.cb);
    });
    return btn;
  },
  /**
   * Creation du container du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Object} obj.layer - couche (ol ou leaflet)
   * @param {String} obj.id - identifiant de la couche (pour ol ou leaflet)
   * @param {String} obj.title - nom de la couche Ã  afficher dans le controle
   * @param {String} obj.description - description de la couche Ã  afficher
   * @param {Boolean} obj.visibility - visibilitÃ© de la couche dans la carte (true or false)
   * @param {Float} obj.opacity - opacitÃ© de la couche
   * @param {String} obj.type - feature or vector
   * @param {Boolean} tooltips - active ou non les tooltips HTML
   *
   * @returns {HTMLElement} container
   */
  _createContainerLayerElement: function(obj, tooltips) {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher_ID_" + obj.id);
    container.className = "GPlayerSwitcher_layer gpf-panel__content fr-modal__content draggable-layer";
    container.appendChild(this._createBasicToolElement(obj, tooltips));
    container.appendChild(this._createAdvancedToolDivElement(obj));
    container.setAttribute("tabindex", 0);
    container.setAttribute("role", "listitem");
    ["click", "keydown"].forEach((type) => {
      container.addEventListener(type, (e) => {
        this._onSelectLayer(e);
      });
    });
    return container;
  },
  // ################################################################### //
  // ############################ Layer tool ########################### //
  // ################################################################### //
  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} tooltips - autoriser ou non les tooltips HTML
   * @returns {HTMLElement} container
   */
  _createBasicToolElement: function(obj, tooltips) {
    var div = document.createElement("div");
    div.id = this._addUID("GPbasicTools_ID_" + obj.id);
    div.className = "GPlayerBasicTools";
    div.appendChild(this._createBasicToolButtons(obj));
    div.appendChild(this._createBasicToolTitleElement(obj, tooltips));
    if (obj.draggable) {
      div.appendChild(this._createDragNDropElement(obj));
    }
    return div;
  },
  /**
   * Creation du groupe de bouton basiques
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @returns {HTMLElement} container
   */
  _createBasicToolButtons: function(obj) {
    let div = document.createElement("div");
    div.id = this._addUID("GPbasicToolButtons_ID_" + obj.id);
    div.className = "GPbasicToolButtons";
    div.appendChild(this._createAdvancedToolShowElement(obj));
    div.appendChild(this._createVisibilityElement(obj));
    if (obj.deletable) {
      div.appendChild(this._createDeleteElement(obj.id));
    }
    return div;
  },
  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} tooltips - autoriser ou non les tooltips HTML
   * @returns {HTMLElement} container
   */
  _createBasicToolTitleElement: function(obj, tooltips) {
    let div = document.createElement("div");
    div.id = this._addUID("GPtitle_ID_" + obj.id);
    div.className = "GPtitle";
    div.appendChild(this._createLayerThumbnailElement(obj));
    div.appendChild(this._createLayerNameDivElement(obj, tooltips));
    return div;
  },
  /**
   * Creation du container du nom de la couche.
   * Ajoute le nom du producteur de donnÃ©e s'il y'en a un.
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} tooltips - autoriser ou non les tooltips HTML
   * @returns {HTMLElement} container
   */
  _createLayerNameDivElement: function(obj, tooltips) {
    let div = document.createElement("div");
    div.id = this._addUID("GPlayerTitle_ID_" + obj.id);
    div.className = "GPlayerTitle";
    div.appendChild(this._createLayerNameElement(obj, tooltips));
    div.appendChild(this._createLayerProducerElement(obj, tooltips));
    return div;
  },
  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {String} obj.thumbnail - Pictogramme de la couche (url ou fichier statique)
   * @returns {HTMLElement} container
   */
  _createLayerThumbnailElement: function(obj) {
    let img = document.createElement("img");
    img.id = this._addUID("GPtitleImage_ID_" + obj.id);
    img.className = "GPtitleImage GPtitleDefaultImage";
    img.alt = "";
    if (obj.thumbnail && typeof obj.thumbnail === "string" && obj.thumbnail !== "default") {
      img.classList.remove("GPtitleDefaultImage");
      img.src = obj.thumbnail;
    }
    return img;
  },
  /**
   * Creation du nom du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} tooltips - active ou non les tooltips
   * @returns {HTMLElement} container
   */
  _createLayerNameElement: function(obj, tooltips) {
    var label = document.createElement("div");
    label.id = this._addUID("GPname_ID_" + obj.id);
    label.className = "GPlayerName";
    label.title = obj.description || obj.title;
    if (tooltips) {
      label.dataset.tooltip = obj.description || obj.title;
      ToolTips_default.active(label);
      label.title = obj.name;
    }
    label.innerHTML = obj.title;
    if (obj.layer.config && obj.layer.config.serviceParams.id === "GPP:TMS") {
      label.innerHTML = obj.description;
    }
    return label;
  },
  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} tooltips - autoriser ou non les tooltips HTML
   * @returns {HTMLElement} container
   */
  _createLayerProducerElement: function(obj, tooltips) {
    let div = document.createElement("div");
    div.id = this._addUID("GPlayerProducer_ID_" + obj.id);
    div.className = "GPlayerProducer";
    div.innerHTML = obj.producer;
    if (tooltips) {
      div.dataset.tooltip = obj.producer;
      ToolTips_default.active(div);
    }
    return div;
  },
  _createDragNDropElement: function(obj) {
    let button = document.createElement("div");
    button.id = this._addUID("GPdragndropPicto_ID_" + obj.id);
    button.className = "GPelementHidden GPlayerDragNDrop gpf-btn gpf-btn-icon-ls-draggable gpf-btn--tertiary";
    button.title = "Deplacer la couche";
    let self2 = this;
    let divKeyboard = document.createElement("div");
    divKeyboard.className = "keyboard-navigation";
    let spanUp = document.createElement("span");
    spanUp.tabIndex = 0;
    spanUp.dataset.direction = "up";
    spanUp.title = spanUp.ariaLabel = "DÃ©placer la couche vers le haut";
    spanUp.className = "fr-icon-arrow-up-line fr-icon--sm";
    spanUp.onkeydown = this._onMoveElement.bind(this, true);
    let spanDown = document.createElement("span");
    spanDown.tabIndex = 0;
    spanDown.dataset.direction = "down";
    spanDown.title = spanDown.ariaLabel = "DÃ©placer la couche vers le bas";
    spanDown.className = "fr-icon-arrow-down-line fr-icon--sm";
    spanDown.onkeydown = this._onMoveElement.bind(this, false);
    divKeyboard.appendChild(spanDown);
    divKeyboard.appendChild(spanUp);
    button.appendChild(divKeyboard);
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        self2._onStartDragAndDropLayerClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        self2._onStartDragAndDropLayerClick(e);
      });
    }
    return button;
  },
  /**
       * Creation de l'icone de visibilitÃ© du layer (DOM)
       *
       * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
  
       * @returns {HTMLElement[]} array containing input and label elements
       */
  _createVisibilityElement: function(obj) {
    var visible = typeof obj.visibility !== "undefined" ? obj.visibility : true;
    let button = document.createElement("button");
    button.id = this._addUID("GPvisibilityPicto_ID_" + obj.id);
    let className = "gpf-btn-icon-ls-visibility gpf-btn-icon";
    if (CheckDsfr_default()) {
      className = visible ? "fr-icon-eye-line" : "fr-icon-eye-off-line";
    }
    button.className = `GPlayerVisibility gpf-btn ${className} fr-btn fr-btn--sm gpf-btn--tertiary fr-btn--tertiary-no-outline`;
    button.title = "Afficher/masquer la couche";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", visible);
    button.setAttribute("type", "button");
    var context = this;
    let onClick = function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      if (CheckDsfr_default()) {
        button.classList.toggle("fr-icon-eye-off-line", status);
        button.classList.toggle("fr-icon-eye-line", !status);
      }
      context._onVisibilityLayerClick(e);
    };
    if (button.addEventListener) {
      button.addEventListener("click", onClick);
    } else if (button.attachEvent) {
      button.attachEvent("onclick", onClick);
    }
    return button;
  },
  /**
   * Creation de l'affichage du menu des outils avancÃ©s du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   *
   * @returns {HTMLElement[]} array containing input and label elements
   */
  _createAdvancedToolShowElement: function(obj) {
    let button = document.createElement("button");
    button.id = this._addUID("GPshowAdvancedTools_ID_" + obj.id);
    button.className = "GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowLayerAdvancedTools gpf-btn fr-icon-arrow-down-s-line fr-btn--sm fr-btn--tertiary-no-outline";
    button.title = "Plus d'outils";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    let self2 = this;
    const fn = (e) => {
      let status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      let element = document.getElementById(self2._addUID("GPadvancedTools_ID_" + obj.id));
      if (status) {
        element.classList.replace("GPelementVisible", "GPelementHidden");
        element.classList.replace("gpf-visible", "gpf-hidden");
      } else {
        element.classList.replace("GPelementHidden", "GPelementVisible");
        element.classList.replace("gpf-hidden", "gpf-visible");
      }
    };
    if (button.addEventListener) {
      button.addEventListener("click", fn);
    } else if (button.attachEvent) {
      button.attachEvent("onclick", fn);
    }
    return button;
  },
  /**
   * Creation du container des outils avancÃ©s du layer (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   *
   * @returns {HTMLElement} container
   */
  _createAdvancedToolDivElement: function(obj) {
    let container = document.createElement("div");
    container.id = this._addUID("GPadvancedTools_ID_" + obj.id);
    container.className = "GPelementHidden GPlayerAdvancedTools gpf-hidden";
    let opacity = document.createElement("div");
    opacity.id = this._addUID("GPopacityContainer_ID_" + obj.id);
    opacity.className = "GPopacityContainer";
    let array = this._createOpacityElement(obj.id, obj.opacity);
    for (let i = 0; i < array.length; i++) {
      opacity.appendChild(array[i]);
    }
    container.appendChild(opacity);
    let btnGroups = this._createButtonsGroupElement({
      className: "GPAdvancedToolBtnsGroup",
      id: obj.id,
      left: true,
      size: "sm"
    });
    if (obj.advancedTools && obj.advancedTools instanceof Array) {
      const switcherButtons = this.constructor.switcherButtons;
      if (!obj.advancedTools.length) {
        return;
      }
      obj.advancedTools.forEach((tool) => {
        const key = tool.key;
        if (key && Object.values(switcherButtons).includes(key)) {
          let fn;
          switch (key) {
            case switcherButtons.INFO:
              fn = this._createInformationElement;
              break;
            case switcherButtons.EDIT:
              fn = this._createEditionElement;
              break;
            case switcherButtons.GREYSCALE:
              fn = this._createGreyscaleElement;
              break;
            case switcherButtons.EXTENT:
              fn = this._createExtentElement;
              break;
          }
          if (typeof fn === "function") {
            btnGroups.appendChild(fn.call(this, obj, tool));
          }
        } else if (tool) {
          btnGroups.appendChild(this._createAdvancedToolElement(obj, tool));
        }
      });
      container.appendChild(btnGroups);
    } else {
      if (CheckDsfr_default()) {
        btnGroups.appendChild(this._createInformationElement(obj, {}));
        btnGroups.appendChild(this._createEditionElement(obj, {}));
        btnGroups.appendChild(this._createGreyscaleElement(obj, {}));
        btnGroups.appendChild(this._createExtentElement(obj, {}));
      } else {
        btnGroups.appendChild(this._createInformationElement(obj, {}));
        btnGroups.appendChild(this._createGreyscaleElement(obj, {}));
      }
      container.appendChild(btnGroups);
    }
    return container;
  },
  /**
   * Configure le bouton selon les options du bouton.
   * 
   * @param {HTMLButtonElement} button Bouton Ã  configurer
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   * @param {Boolean} [setClick] Optionnel. Indique si une fonction au clic doit Ãªtre ajoutÃ©e.
   * Vrai par dÃ©faut.
   * @returns {HTMLButtonElement} Bouton donnÃ© en paramÃ¨tre
   */
  _setAdvancedToolOptions: function(button, tool, setClick = true) {
    if (!button) {
      return;
    }
    let label;
    if (tool.label) {
      label = tool.label.toLowerCase().replaceAll(" ", "-");
    } else {
      label = tool.icon;
    }
    const iconClass = `gpf-btn-icon-ls-tools-${label}`;
    if (tool.className) {
      button.className += ` ${tool.className} `;
    }
    if (tool.icon) {
      this._setButtonIconStyle(button, iconClass, tool.icon);
    }
    if (tool.label) {
      button.innerHTML = tool.label;
    }
    if (tool.title) {
      button.title = tool.title;
      button.ariaLabel = tool.title;
    }
    if (tool.attributes) {
      for (const attribute in tool.attributes) {
        if (!Object.hasOwn(tool.attributes, attribute)) {
          continue;
        }
        const element = tool.attributes[attribute];
        button.setAttribute(attribute, element);
      }
    }
    button.setAttribute("tabindex", "0");
    button.setAttribute("type", "button");
    let self2 = this;
    if (setClick) {
      button.addEventListener("click", (e) => {
        self2._onClickAdvancedToolsMore(e, tool.label, tool.cb);
      });
    }
    return button;
  },
  /**
   * Ajoute une icÃ´ne personnalisÃ©e au bouton
   * 
   * @param {HTMLButtonElement} button Bouton Ã  modifier
   * @param {String} iconClass Classe de l'icÃ´ne. Peut Ãªtre une balise svg ou une classe.
   * @param {String} icon IcÃ´ne en paramÃ¨tre de l'option avancÃ©e
   */
  _setButtonIconStyle: function(button, iconClass, icon) {
    let svg = false;
    const regex = /(\.|\\)/;
    if (icon) {
      if (icon.startsWith("<svg")) {
        icon = "data:image/svg+xml;base64," + btoa(icon);
        svg = true;
      } else if (!regex.test(icon)) {
        button.className += icon;
      } else {
        svg = true;
      }
    }
    if (svg) {
      button.classList.add(iconClass);
      if (!document.querySelector(`style[data-injected="${iconClass.toLowerCase()}"]`)) {
        const style = document.createElement("style");
        style.dataset.injected = iconClass.toLowerCase();
        style.textContent = `
                    .${iconClass.toLowerCase()}::before {
                        width: 100%;
                        height: 100%;
                        -webkit-mask-image: url('${icon}');
                        -webkit-mask-repeat: no-repeat;
                        -webkit-mask-position: center;

                        mask-image: url('${icon}');
                        mask-repeat: no-repeat;
                        mask-position: center;
                    }
                `;
        document.head.appendChild(style);
      }
    }
  },
  /**
   * Creation de l'icone de suppression du layer (DOM)
   *
   * @param {String} id - ID de la couche Ã  ajouter dans le layer switcher
   *
   * @returns {HTMLElement} container
   */
  _createDeleteElement: function(id) {
    let button = document.createElement("button");
    button.id = this._addUID("GPremove_ID_" + id);
    let className = "gpf-btn-icon-ls-remove gpf-btn-icon";
    if (CheckDsfr_default()) {
      className = "fr-icon-delete-line";
    }
    button.className = `GPlayerRemove gpf-btn ${className} fr-btn fr-btn--sm gpf-btn--tertiary fr-btn--tertiary-no-outline`;
    button.title = "Supprimer la couche";
    button.layerId = id;
    button.setAttribute("tabindex", "0");
    button.setAttribute("type", "button");
    var context = this;
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        context._onDropLayerClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        context._onDropLayerClick(e);
      });
    }
    return button;
  },
  /**
   * Creation de l'icone d'edition du layer (DOM)
   *
   * @param {Object} obj - Objet de la couche Ã  configurer
   * @param {String} obj.id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} obj.editable - mode editable
   * @param {Boolean} obj.tms - tms ou non
   * @param {Array} obj.styles - styles des tms
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   * 
   * @returns {HTMLElement} container
   */
  _createEditionElement: function(obj, tool) {
    let id = obj.id;
    let editable = obj.editable;
    let tms = obj.layer.config && obj.layer.config.serviceParams.id === "GPP:TMS";
    let styles = tms ? obj.layer.config.styles : null;
    let button = document.createElement("button");
    button.id = this._addUID("GPedit_ID_" + id);
    button.layerId = id;
    let icon = "gpf-btn-icon-ls-edit gpf-btn-icon";
    let label;
    if (CheckDsfr_default()) {
      icon = "fr-icon-pencil-line";
      label = "Style";
    }
    let className = `GPlayerEdit gpf-btn gpf-btn--tertiary fr-btn fr-btn--tertiary-no-outline`;
    const options = {
      icon,
      label
    };
    const toolOptions = Helper_default2.assign(options, tool);
    toolOptions.className = className;
    if (tool && tool.className) {
      toolOptions.className += ` ${tool.className}`;
    }
    this._setAdvancedToolOptions(button, toolOptions, false);
    if (!editable || tms && styles.length === 1) {
      button.disabled = true;
    }
    let context = this;
    if (tms && styles.length > 1) {
      if (button.addEventListener) {
        button.addEventListener("click", function(e) {
          context._onEditLayerStyleClick(e, styles);
        });
      } else if (button.attachEvent) {
        button.attachEvent("onclick", function(e) {
          context._onEditLayerStyleClick(e, styles);
        });
      }
    } else {
      if (button.addEventListener) {
        button.addEventListener("click", function(e) {
          context._onEditLayerClick(e);
        });
      } else if (button.attachEvent) {
        button.attachEvent("onclick", function(e) {
          context._onEditLayerClick(e);
        });
      }
    }
    return button;
  },
  /**
   * Creation de l'icone d'information du layer (DOM)
   *
   * @param {Object} obj - Objet de la couche Ã  configurer
   * @param {String} obj.id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {String} obj.title - titre
   * @param {String} obj.description - description
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   * 
   * @returns {HTMLElement} container
   */
  _createInformationElement: function(obj, tool) {
    let id = obj.id;
    let title3 = obj.title;
    let description = obj.description;
    let button = document.createElement("button");
    button.id = this._addUID("GPinfo_ID_" + id);
    button.layerId = id;
    let icon = "gpf-btn-icon-ls-info gpf-btn-icon";
    let label;
    if (CheckDsfr_default()) {
      icon = "fr-icon-information-line";
      label = "Infos";
    }
    let className = `GPlayerInfo GPlayerInfoClosed gpf-btn gpf-btn--tertiary fr-btn fr-btn--tertiary-no-outline`;
    const options = {
      icon,
      label
    };
    const toolOptions = Helper_default2.assign(options, tool);
    toolOptions.className = className;
    if (tool && tool.className) {
      toolOptions.className += ` ${tool.className}`;
    }
    this._setAdvancedToolOptions(button, toolOptions, false);
    if (!title3 || !description) {
      button.disabled = true;
    }
    var context = this;
    if (button.addEventListener) {
      button.addEventListener(
        "click",
        function(e) {
          context._onOpenLayerInfoClick(e);
        }
      );
    } else if (button.attachEvent) {
      button.attachEvent(
        "onclick",
        function(e) {
          context._onOpenLayerInfoClick(e);
        }
      );
    }
    return button;
  },
  /**
   * Creation de l'icone de n&b du layer (DOM)
   *
   * @param {Object} obj - Objet de la couche Ã  configurer
   * @param {String} obj.id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {Boolean} obj.grayable - le mode grisable est il  possible pour ce type de couche
   * @param {Boolean} obj.grayscale - option grisÃ©e de la couche
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   *
   * @returns {HTMLElement} container
   */
  _createGreyscaleElement: function(obj, tool) {
    let id = obj.id;
    let grayable = obj.grayable;
    let grayscale = obj.grayscale;
    tool = tool ? tool : {};
    var _grayscale = typeof grayscale !== "undefined" ? grayscale : false;
    let button = document.createElement("button");
    button.id = this._addUID("GPgreyscale_ID_" + id);
    button.layerId = id;
    let icon = "gpf-btn-icon-ls-greyscale gpf-btn-icon";
    let label;
    if (CheckDsfr_default()) {
      icon = "fr-icon-contrast-line";
      label = "Noir et blanc";
    }
    let className = `GPlayerGreyscale GPlayerGreyscaleOff gpf-btn gpf-btn--tertiary fr-btn fr-btn--tertiary-no-outline`;
    const options = {
      icon,
      label
    };
    const toolOptions = Helper_default2.assign(options, tool);
    toolOptions.className = className;
    if (tool && tool.className) {
      toolOptions.className += ` ${tool.className}`;
    }
    this._setAdvancedToolOptions(button, toolOptions, false);
    if (_grayscale) {
      button.classList.replace("GPlayerGreyscaleOff", "GPlayerGreyscaleOn");
    }
    button.setAttribute("aria-pressed", _grayscale);
    if (!grayable) {
      button.disabled = true;
    }
    var context = this;
    if (button.addEventListener) {
      button.addEventListener(
        "click",
        function(e) {
          var status = e.target.ariaPressed === "true";
          e.target.setAttribute("aria-pressed", !status);
          context._onToggleLayerGreyscaleClick(e);
        }
      );
    } else if (button.attachEvent) {
      button.attachEvent(
        "onclick",
        function(e) {
          var status = e.target.ariaPressed === "true";
          e.target.setAttribute("aria-pressed", !status);
          context._onToggleLayerGreyscaleClick(e);
        }
      );
    }
    return button;
  },
  /**
   * Creation de l'icone de gestion de l'opacitÃ© du layer (DOM)
   *
   * @param {String} id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {Number} opacity - Valeur de l'opacitÃ©
   * 
   * @returns {HTMLElement[]} Tableau de 2 containers
   */
  _createOpacityElement: function(id, opacity) {
    var list = [];
    var divO = document.createElement("div");
    divO.id = this._addUID("GPopacity_ID_" + id);
    divO.className = "GPlayerOpacity fr-range fr-range--sm";
    divO.dataset.frJsRange = "true";
    divO.title = "OpacitÃ©";
    var _opacity = typeof opacity !== "undefined" ? opacity : 1;
    _opacity = Math.round(_opacity * 100);
    divO.style.setProperty("--progress-right", _opacity + "%");
    var input = document.createElement("input");
    input.id = this._addUID("GPopacityValueDiv_ID_" + id);
    input.type = "range";
    input.value = _opacity;
    input.ariaLabel = "OpacitÃ©";
    var context = this;
    if (input.addEventListener) {
      input.addEventListener(
        "change",
        function(e) {
          context._onChangeLayerOpacity(e);
        }
      );
    } else if (input.attachEvent) {
      input.attachEvent(
        "onchange",
        function(e) {
          context._onChangeLayerOpacity(e);
        }
      );
    }
    if (input.addEventListener) {
      input.addEventListener(
        "input",
        function(e) {
          context._onChangeLayerOpacity(e);
        }
      );
    } else if (input.attachEvent) {
      input.attachEvent(
        "oninput",
        function(e) {
          context._onChangeLayerOpacity(e);
        }
      );
    }
    divO.appendChild(input);
    var divC = document.createElement("div");
    divC.id = this._addUID("GPopacityValueDiv_ID_" + id);
    divC.className = "GPlayerOpacityValue";
    var span = document.createElement("span");
    span.id = this._addUID("GPopacityValue_ID_" + id);
    span.className = "gpf-range__output fr-range__output gpf-visible";
    span.innerHTML = _opacity + "%";
    divC.appendChild(span);
    list.push(divO);
    list.push(divC);
    return list;
  },
  /**
   * Creation de l'icone de zoom sur extent (DOM)
   * 
   * @param {Object} obj - Objet de la couche Ã  configurer
   * @param {String} obj.id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   *
   * @returns {HTMLElement} container
   */
  _createExtentElement: function(obj, tool) {
    let id = obj.id;
    let button = document.createElement("button");
    button.id = this._addUID("GPextent_ID_" + id);
    button.layerId = id;
    tool = tool ? tool : {};
    let icon = "gpf-btn-icon-ls-extent gpf-btn-icon";
    let label;
    if (CheckDsfr_default()) {
      icon = "fr-icon-zoom-in-line";
      label = "Recentrer";
    }
    let className = `GPelementHidden GPlayerExtent gpf-btn--tertiary gpf-btn fr-btn fr-btn--tertiary-no-outline`;
    const options = {
      icon,
      label
    };
    const toolOptions = Helper_default2.assign(options, tool);
    toolOptions.className = className;
    if (tool && tool.className) {
      toolOptions.className += ` ${tool.className}`;
    }
    this._setAdvancedToolOptions(button, toolOptions, false);
    button.setAttribute("aria-pressed", true);
    var context = this;
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context._onZoomToExtentClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context._onZoomToExtentClick(e);
      });
    }
    return button;
  },
  /**
   * CrÃ©ation d'un bouton d'outil externe
   * 
   * @param {Object} obj - Objet de la couche Ã  configurer
   * @param {String} obj.id - ID de la couche Ã  ajouter dans le layer switcher
   * @param {Object} tool Option du bouton (override les valeurs par dÃ©faut)
   * (Objet de type AdvancedToolOption)
   *
   * @returns {HTMLElement} container
   */
  _createAdvancedToolElement: function(obj, tool) {
    let id = obj.id;
    let button = document.createElement("button");
    const idLabel = tool.label.toLowerCase().replaceAll(" ", "-");
    button.id = this._addUID("GPtools-" + idLabel + "_ID_" + id);
    button.layerId = id;
    tool = tool ? tool : {};
    let icon = tool.icon;
    let label;
    if (CheckDsfr_default()) {
      label = tool.label;
    }
    let className = `GPlayerTools gpf-btn gpf-btn--tertiary fr-btn fr-btn--tertiary-no-outline`;
    const options = {
      icon,
      label
    };
    const toolOptions = Helper_default2.assign(options, tool);
    toolOptions.className = className;
    if (tool && tool.className) {
      toolOptions.className += ` ${tool.className}`;
    }
    this._setAdvancedToolOptions(button, toolOptions, false);
    Object.assign(button.style, tool.styles);
    if (tool.accepted && tool.accepted.length) {
      const layer = obj.layer;
      const layerTypeName = layer.constructor.name;
      let disabled = true;
      for (const type of tool.accepted) {
        if (typeof type === "string" && type === layerTypeName || type.prototype instanceof Base_default && layer instanceof type) {
          disabled = false;
          break;
        }
      }
      button.disabled = disabled;
    }
    var self2 = this;
    if (button.addEventListener) {
      button.addEventListener("click", (e) => {
        self2._onClickAdvancedToolsMore(e, tool.label, tool.cb);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", (e) => {
        self2._onClickAdvancedToolsMore(e, tool.label, tool.cb);
      });
    }
    return button;
  },
  // ################################################################### //
  // ############################ Layer info ########################### //
  // ################################################################### //
  /**
   * Creation du container du layer info (DOM)
   *
   * TODO GPlayerInfoPopup : ???
   * TODO GPlayerInfoLink  : mettre en forme les Ã©chelles !
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   *
   * @returns {HTMLElement} container
   */
  _createContainerLayerInfoElement: function(obj) {
    var container = document.createElement("div");
    var header = document.createElement("div");
    header.className = "gpf-panel__header_ls";
    container.appendChild(header);
    var label = document.createElement("label");
    label.className = "GPlayerInfo gpf-btn-header gpf-btn-icon-ls-info";
    label.title = "Informations";
    header.appendChild(label);
    var title3 = document.createElement("div");
    title3.id = this._addUID("GPlayerInfoTitle");
    title3.innerHTML = obj.title;
    title3.className = "gpf-panel__title_ls";
    header.appendChild(title3);
    var btnClose = document.createElement("button");
    btnClose.id = this._addUID("GPlayerInfoClose");
    btnClose.className = "GPpanelClose GPlayersPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    btnClose.title = "Fermer la fenÃªtre";
    var self2 = this;
    var onCloseClick = function() {
      document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
      document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.remove("GPlayerInfoPanelOpened", "gpf-visible");
      document.getElementById(obj.id).classList.add("GPlayerInfoClosed");
      document.getElementById(obj.id).classList.remove("GPlayerInfoOpened");
    };
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", onCloseClick);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", onCloseClick);
    }
    this.addEventListener("layerswitcher:remove", (e) => {
      if (parseInt(obj.id.split("-")[0].split("GPinfo_ID_")[1]) === e.layer.id) {
        document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
        document.getElementById(self2._addUID("GPlayerInfoPanel")).classList.remove("GPlayerInfoPanelOpened", "gpf-visible");
      }
    });
    header.appendChild(btnClose);
    container.appendChild(header);
    var content = document.createElement("div");
    content.id = this._addUID("GPlayerInfoContent");
    content.className = "gpf-panel__content fr-modal__content";
    container.appendChild(content);
    if (obj.quicklookUrl) {
      var quick = document.createElement("div");
      quick.id = this._addUID("GPlayerInfoQuicklook");
      quick.title = "Afficher un aperÃ§u de la couche";
      var refquick = document.createElement("a");
      refquick.href = obj.quicklookUrl;
      refquick.appendChild(quick);
      content.appendChild(refquick);
    }
    var desc = document.createElement("div");
    desc.id = this._addUID("GPlayerInfoDescription");
    desc.innerHTML = obj.description;
    content.appendChild(desc);
    if (obj.metadata) {
      var mtd = document.createElement("div");
      mtd.id = this._addUID("GPlayerInfoMetadata");
      var mtdtitle = document.createElement("div");
      mtdtitle.className = "GPlayerInfoSubtitle";
      mtdtitle.innerHTML = "MÃ©tadonnÃ©es";
      mtd.appendChild(mtdtitle);
      for (var i = 0; i < obj.metadata.length; i++) {
        var urlmtd = obj.metadata[i].url;
        var mtdlink = document.createElement("div");
        mtdlink.className = "GPlayerInfoLink";
        var refmtd = document.createElement("a");
        refmtd.href = urlmtd;
        refmtd.innerHTML = urlmtd;
        mtdlink.appendChild(refmtd);
        mtd.appendChild(mtdlink);
      }
      if (obj.metadata.length !== 0) {
        content.appendChild(mtd);
      }
    }
    if (obj.legends) {
      var lgd = document.createElement("div");
      lgd.id = this._addUID("GPlayerInfoLegend");
      var lgdtitle = document.createElement("div");
      lgdtitle.className = "GPlayerInfoSubtitle";
      lgdtitle.innerHTML = "LÃ©gende";
      lgd.appendChild(lgdtitle);
      var legends = {};
      var maxScale = obj.maxScaleDenominator || 56e7;
      for (var k3 = 0; k3 < obj.legends.length; k3++) {
        var minScale = obj.legends[k3].minScaleDenominator;
        if (minScale) {
          var s = minScale.toString();
          minScale = Math.round(parseInt(s.substring(0, 3), 10) / 10) * Math.pow(10, s.length - 2);
        } else {
          minScale = 270;
        }
        legends[minScale] = obj.legends[k3];
      }
      for (var scale in legends) {
        if (legends.hasOwnProperty(scale)) {
          var urllgd = legends[scale].url;
          if (typeof urllgd === "string" && urllgd.toLowerCase().indexOf("nolegend.jpg") === -1) {
            var lgdlink = document.createElement("div");
            lgdlink.className = "GPlayerInfoLink";
            maxScale = legends[scale].maxScaleDenominator || maxScale;
            var reflgd = document.createElement("a");
            reflgd.className = "fr-link";
            reflgd.href = urllgd;
            reflgd.target = "_blank";
            reflgd.innerHTML = "Du 1/" + scale + " au 1/" + maxScale;
            lgdlink.appendChild(reflgd);
            lgd.appendChild(lgdlink);
          } else {
            delete legends[scale];
          }
        }
      }
      if (Object.keys(legends).length !== 0) {
        content.appendChild(lgd);
      }
    }
    return container;
  },
  // ################################################################### //
  // ############################ Layer style ########################### //
  // ################################################################### //
  /**
   * Creation du container du layer style (DOM)
   *
   * @param {Object} obj - options de la couche Ã  ajouter dans le layer switcher
   *
   * @returns {HTMLElement} container
   */
  _createContainerLayerStyleElement: function(obj) {
    var container = document.createElement("div");
    var header = document.createElement("div");
    header.className = "gpf-panel__header_ls";
    container.appendChild(header);
    var label = document.createElement("label");
    label.className = "GPlayerStyle gpf-btn-header gpf-btn-icon-ls-info";
    label.title = "Informations";
    header.appendChild(label);
    var title3 = document.createElement("div");
    title3.id = this._addUID("GPlayerStyleTitle");
    title3.innerHTML = "Options de style";
    title3.className = "gpf-panel__title_ls";
    header.appendChild(title3);
    var btnClose = document.createElement("button");
    btnClose.id = this._addUID("GPlayerStyleClose");
    btnClose.className = "GPpanelClose GPlayersPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    btnClose.title = "Fermer la fenÃªtre";
    var self2 = this;
    var onCloseClick = function() {
      document.getElementById(self2._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
      document.getElementById(self2._addUID("GPlayerStylePanel")).classList.remove("GPlayerStylePanelOpened", "gpf-visible");
      document.getElementById(obj.div).classList.add("GPlayerStyleClosed");
      document.getElementById(obj.div).classList.remove("GPlayerStyleOpened");
    };
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", onCloseClick);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", onCloseClick);
    }
    this.addEventListener("layerswitcher:remove", (e) => {
      if (parseInt(obj.id.split("-")[0].split("GPinfo_ID_")[1]) === e.layer.id) {
        document.getElementById(self2._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
        document.getElementById(self2._addUID("GPlayerStylePanel")).classList.remove("GPlayerStylePanelOpened", "gpf-visible");
      }
    });
    header.appendChild(btnClose);
    container.appendChild(header);
    var content = document.createElement("div");
    content.id = this._addUID("GPlayerStyleContent");
    content.className = "gpf-panel__content fr-modal__content";
    container.appendChild(content);
    var list = document.createElement("div");
    list.id = this._addUID("GPlayerStyleList");
    const uuidRegex = /^([0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}_)/i;
    for (let i = 0; i < obj.styles.length; i++) {
      var style = obj.styles[i];
      var title3 = style.title ? style.title : style.name;
      title3 = title3.replace(uuidRegex, "");
      var elem = document.createElement("div");
      elem.className = "gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
      var input = document.createElement("input");
      input.type = "radio";
      input.name = this._addUID("styleradio_ID_" + obj.id);
      input.id = this._addUID("styleradio_" + style.name + "_ID_" + obj.id);
      input.value = style.url;
      input.dataset.name = style.name;
      var label = document.createElement("label");
      label.className = "gpf-label fr-label";
      label.innerText = title3;
      label.htmlFor = this._addUID("styleradio_" + style.name + "_ID_" + obj.id);
      elem.appendChild(input);
      elem.appendChild(label);
      list.appendChild(elem);
      if (obj.layerInfo.layer.styleUrl === style.url) {
        input.checked = true;
      }
      input.addEventListener("change", (e) => {
        self2._onChangeStyleLayerClick(e);
      });
    }
    content.appendChild(list);
    return container;
  }
};
var LayerSwitcherDOM_default = LayerSwitcherDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerSwitcher/LayerSwitcher.js
var logger9 = LoggerByDefault_default2.getLogger("layerswitcher");
var _LayerSwitcher = class _LayerSwitcher extends Control_default2 {
  /*
  * @param {Layer} [options.layers.layer] - ol.layer.Layer layer to be configured (that has been added to map)
  * @param {Object} [options.layers.config] - custom configuration object for layer information (title, description, legends, metadata, quicklook url), with following properties :
  * @param {String} [options.layers.config.title] - layer alias, to be displayed in widget layer list. E.g. : "Cartes IGN"
  * @param {String} [options.layers.config.description] - layer description, to be displayed on title hover, or in layer information panel.
  * @param {String} [options.layers.config.quicklookUrl] - link to a quick look image for this layer.
  * @param {Array} [options.layers.config.legends] - array of layer legends. Each array element is an object, with following properties :
  *      - url (String, mandatory) : link to a legend
  *      - minScaleDenominator (Number, optional) : min scale denominator for legend validity.
  * @param {Array} [options.layers.config.metadata] - array of layer metadata. Each array element is an object, with property url (String, mandatory) : link to a metadata
  */
  /*
  * @param {Number} [options.options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {Boolean} [options.options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
  * @param {Boolean} [options.options.panel = false] - Specify if widget has to have a panel header. Default is false.
  * @param {Boolean} [options.options.counter = false] - Specify if widget has to have a counter. Default is false.
  * @param {Boolean} [options.options.allowEdit = true] - Specify if widget has to have an edit button (available only for vector layers). Default is true.
  * @param {Boolean} [options.options.allowGrayScale = true] - Specify if widget has to have an grayscale button (not available for vector layers). Default is true.
  * @param {Array} [options.options.advancedTools] - ...
  * @param {String} [options.options.advancedTools.label] - Specify the label name of the button
  * @param {String} [options.options.advancedTools.icon] - icon (optionnal)
  * @param {Function} [options.options.advancedTools.cb] - callback (optionnal)
  * @param {Object} [options.options.advancedTools.styles] - styles (optionnal)
  */
  /**
  * @constructor
  * @param {Object} options - control options
  * @param {Array<LayerSwitcherLayersConfig>} [options.layers] - list of layers to be configured. Each array element is an object, with following properties :
  * @param {LayerSwitcherOptions} [options.options] - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
  * @fires layerswitcher:add
  * @fires layerswitcher:remove
  * @fires layerswitcher:lock
  * @fires layerswitcher:extent
  * @fires layerswitcher:edit
  * @fires layerswitcher:changeproperty
  * @fires layerswitcher:change:selected
  * @fires layerswitcher:change:opacity
  * @fires layerswitcher:change:visibility
  * @fires layerswitcher:change:position
  * @fires layerswitcher:change:grayscale
  * @fires layerswitcher:change:style
  * @fires layerswitcher:change:locked
  * @fires layerswitcher:custom
  * @fires layerswitcher:header:button
  * @example
  * map.addControl(new ol.control.LayerSwitcher(
  *  [
  *      {
  *          layer : wms1,
  *          config : {
  *              title : "test layer name 1",
  *              description : "test layer desc 1",
  *          }
  *      }
  *  ],
  *  {
  *      collapsed : true,
  *      panel : false,
  *      counter : false,
  *      position : "top-left",
  *      allowEdit : true,
  *      allowGrayScale : true,
  *      headerButtons : [
  *          {
  *              label: 'Ajouter',
  *              title: 'Ajouter une couche',
  *              icon: "svg | http",
  *              cb: (e, switcher) => {},
  *          },
  *      ],
  *      advancedTools : [
  *          {
  *              label = 'Bouton',
  *              icon = "svg | http",
  *              cb = (e, LayerSwitcher, layer, options) => {},
  *              styles = {},
  *          }
  *      ]
  *  }
  * ));
  *
  * LayerSwitcher.on("layerswitcher:add", function (e) {
  *    console.warn("layer", e.layer);
  * });
  * LayerSwitcher.on("layerswitcher:remove", function (e) {
  *    console.warn("layer", e.layer);
  * });
  * LayerSwitcher.on("layerswitcher:extent", function (e) {
  *    console.warn("layer", e.layer);
  * });
  * LayerSwitcher.on("layerswitcher:edit", function (e) {
  *    console.warn("layer", e.layer);
  * });
  * LayerSwitcher.on("layerswitcher:change:selected", function (e) {
  *    console.warn("layer", e.layer, e.previous);
  * });
  * LayerSwitcher.on("layerswitcher:change:opacity", function (e) {
  *    console.warn("layer", e.layer, e.opacity);
  * });
  * LayerSwitcher.on("layerswitcher:change:visibility", function (e) {
  *    console.warn("layer", e.layer, e.visibility);
  * });
  * LayerSwitcher.on("layerswitcher:change:position", function (e) {
  *    console.warn("layer", e.layer, e.position);
  * });
  * LayerSwitcher.on("layerswitcher:change:grayscale", function (e) {
  *    console.warn("layer", e.layer, e.grayscale);
  * });
  * LayerSwitcher.on("layerswitcher:change:style", function (e) {
  *    console.warn("layer", e.layer, e.name, e.url);
  * });
  * LayerSwitcher.on("layerswitcher:change:locked", function (e) {
  *    console.warn("layer", e.layer, e.locked);
  * });
  * LayerSwitcher.on("layerswitcher:custom", function (e) {
  *   console.warn("layer", e.action, e.layer);
  * })
  * LayerSwitcher.on("layerswitcher:header:button", function (e) {
  *   console.warn("Action", e.action, e.target);
  * })
  * LayerSwitcher.on("layerswitcher:propertychange", function (e) {
  *    console.warn("layer", e.layer, e.key, e.value);
  * });
  */
  constructor(options) {
    options = options || {};
    var _options = options.options || {};
    var _layers = options.layers || [];
    super(_options);
    if (!(this instanceof _LayerSwitcher)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    if (!Array.isArray(_layers)) {
      throw new Error("ERROR WRONG_TYPE : layers should be an array");
    }
    if (typeof _options !== "object") {
      throw new Error("ERROR WRONG_TYPE : options should be an object");
    }
    this.CLASSNAME = "LayerSwitcher";
    this._initialize(_options, _layers);
    this.container = this._initContainer(_options);
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //
  /**
   * Overload setMap function, that enables to catch map events, such as movend events.
   * @inheritdoc {@link https://openlayers.org/en/latest/apidoc/module-ol_control_Control-Control.html#setMap}
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._addMapLayers(map);
      if (!this.collapsed) {
        this._showLayerSwitcherButton.setAttribute("aria-pressed", true);
      }
      this._listeners.onMoveListener = map.on(
        "moveend",
        () => this._onMapMoveEnd(map)
      );
      this._listeners.onAddListener = map.getLayers().on(
        "add",
        (evt) => {
          logger9.debug("LayerSwitcher:onAddListener", evt);
          var layer = evt.element;
          var id;
          if (!layer.hasOwnProperty("gpLayerId")) {
            id = this._layerId;
            layer.gpLayerId = id;
            this._layerId++;
          } else {
            id = layer.gpLayerId;
          }
          if (!this._layers[id]) {
            this.addLayer(layer);
          }
        }
      );
      this._listeners.onRemoveListener = map.getLayers().on(
        "remove",
        (evt) => {
          logger9.debug("LayerSwitcher:onRemoveListener", evt);
          var layer = evt.element;
          var id = layer.gpLayerId;
          if (this._layers[id]) {
            this.removeLayer(layer);
          }
        }
      );
    } else {
      unByKey(this._listeners.onMoveListener);
      unByKey(this._listeners.onAddListener);
      unByKey(this._listeners.onRemoveListener);
      for (var i = this._layersOrder.length - 1; i >= 0; i--) {
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
    if (this.options.allowTooltips) {
      ToolTips_default.init();
    }
  }
  /**
   * Add a new layer to control (when added to map) or add new layer configuration
   *
   * @param {Layer} layer - layer to add to layer switcher
   * @param {Object} [config] - additional options for layer configuration
   * @param {Object} [config.title] - layer title (default is layer identifier)
   * @param {Object} [config.description] - layer description (default is null)
   * @param {Object} [config.legends] - layer legends (default is an empty array)
   * @param {Object} [config.metadata] - layer metadata (default is an empty array)
   * @param {Object} [config.quicklookUrl] - layer quicklookUrl (default is null)
   * @fires layerswitcher:add {@link LayerSwitcher#ADD_LAYER_EVENT}
   * @example
   *   layerSwitcher.addLayer(
   *       gpParcels,
   *       {
   *           title : "Parcelles cadastrales",
   *           description : "description de la couche",
   *           quicklookUrl : "http://quicklookUrl.fr"
   *       }
   *   )
   */
  addLayer(layer, config) {
    var map = this.getMap();
    config = config || layer.config || {};
    if (!layer) {
      logger9.log("[ERROR] LayerSwitcher:addLayer - missing layer parameter");
      return;
    }
    var id = layer.gpLayerId;
    if (typeof id === "undefined") {
      logger9.trace("[WARN] LayerSwitcher:addLayer - configuration cannot be set for this layer (layer id not found)", layer);
      return;
    }
    var isLayerInMap = false;
    map.getLayers().forEach(
      (lyr) => {
        if (lyr.gpLayerId === id) {
          isLayerInMap = true;
        }
      }
    );
    if (!isLayerInMap) {
      logger9.log("[ERROR] LayerSwitcher:addLayer - configuration cannot be set for ", layer, " layer (layer is not in map.getLayers() )");
      return;
    }
    if (!this._layers[id]) {
      var layerInfos = this.getLayerInfo(layer) || {};
      var opacity = layer.getOpacity();
      var visibility = layer.getVisible();
      var grayscale = layer.get("grayscale");
      var locked = layer.get("locked");
      var isInRange = this.isInRange(layer, map);
      var layerOptions = {
        layer,
        id,
        name: layer.name,
        // only geoportal layers
        service: layer.service,
        // only geoportal layers
        type: "",
        // only geoportal website : ie 'feature'
        opacity: opacity != null ? opacity : 1,
        visibility: visibility != null ? visibility : true,
        grayscale,
        locked,
        inRange: isInRange != null ? isInRange : true,
        producer: config.producer != null ? config.producer : layerInfos._producer || null,
        title: config.title != null ? config.title : layerInfos._title || id,
        thumbnail: config.thumbnail != null ? config.thumbnail : layerInfos._thumbnail || null,
        description: config.description || layerInfos._description || null,
        legends: config.legends || layerInfos._legends || [],
        metadata: config.metadata || layerInfos._metadata || [],
        quicklookUrl: config.quicklookUrl || layerInfos._quicklookUrl || null
      };
      this._layers[id] = layerOptions;
      var layerDiv = this._createLayerDiv(layerOptions);
      this._layers[id].div = layerDiv;
      if (layer.getZIndex && layer.getZIndex() !== 0 && typeof layer.getZIndex() !== "undefined" || layer._forceNullzIndex) {
        this._updateLayersOrder();
      } else {
        this._layersOrder.unshift(layerOptions);
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
        layerDiv.dataset.sortableId = this._layerId;
        this._layerListContainer.insertBefore(layerDiv, this._layerListContainer.firstChild);
      }
      this._listeners.updateLayerOpacity = layer.on(
        "change:opacity",
        (e) => this._updateLayerOpacity(e)
      );
      this._listeners.updateLayerVisibility = layer.on(
        "change:visible",
        (e) => this._updateLayerVisibility(e)
      );
      this._listeners.updateLayerGrayScale = layer.on(
        "change:grayscale",
        (e) => this._updateLayerGrayScale(e)
      );
      this._listeners.updateLayerLocked = layer.on(
        "change:locked",
        (e) => this._updateLayerLocked(e)
      );
      this._listeners.updateProperties = layer.on(
        "propertychange",
        (e) => this._updateGenericProperty(e)
      );
      if (this._layers[id].onZIndexChangeEvent == null) {
        this._layers[id].onZIndexChangeEvent = layer.on(
          "change:zIndex",
          () => this._updateLayersOrder()
        );
      }
    } else {
      for (var prop in config) {
        if (config.hasOwnProperty(prop)) {
          this._layers[id][prop] = config[prop];
        }
      }
      if (config.title) {
        var nameDiv = document.getElementById(this._addUID("GPname_ID_" + id));
        if (nameDiv) {
          nameDiv.innerHTML = config.title;
          nameDiv.title = config.description || config.title;
        }
      }
      if (config.producer) {
        let producerDiv = document.getElementById(this._addUID("GPlayerProducer_ID_" + id));
        if (producerDiv) {
          producerDiv.innerHTML = config.producer;
        } else {
          this.setLayerProducer(id, config.producer);
        }
      }
      var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + id));
      if (!document.getElementById(this._addUID("GPinfo_ID_" + id)) && config.description) {
        var advancedTools = document.getElementById(this._addUID("GPadvancedTools_ID_" + id));
        if (advancedTools) {
          advancedTools.appendChild(
            this._createInformationElement({
              id
            })
          );
        }
      }
      if (infodiv && infodiv.className === "GPlayerInfoOpened") {
        document.getElementById(this._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
      }
    }
    this._updateLayerCounter();
    var self2 = this;
    setTimeout(() => {
      self2._updateLayerGrayScale({
        target: {
          gpLayerId: id
        }
      });
    }, 0);
    this.dispatchEvent({
      type: this.ADD_LAYER_EVENT,
      layer: this._layers[id]
    });
  }
  /**
   * Remove a layer from control
   *
   * @param {Layer} layer - layer.
   * @fires layerswitcher:remove {@link LayerSwitcher#REMOVE_LAYER_EVENT}
   * @deprecated on the future version ...
   */
  removeLayer(layer) {
    if (!layer) {
      return;
    }
    unByKey(this._listeners.updateLayerOpacity);
    unByKey(this._listeners.updateLayerVisibility);
    unByKey(this._listeners.updateLayerGrayScale);
    unByKey(this._listeners.updateLayerLocked);
    unByKey(this._listeners.updateProperties);
    logger9.trace(layer);
    var layerID = layer.gpLayerId;
    var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + layerID));
    if (infodiv && infodiv.className === "GPlayerInfoOpened") {
      document.getElementById(this._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
    }
    var stylediv = document.getElementById(this._addUID("GPedit_ID_" + layerID));
    if (stylediv && stylediv.classList.contains("GPlayerStyleOpened")) {
      document.getElementById(this._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
    }
    var layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + layerID));
    if (layerDiv) {
      this._layerListContainer.removeChild(layerDiv);
    }
    var layerIndex = Math.abs(layer.getZIndex() - this._lastZIndex);
    this._layersOrder.splice(layerIndex, 1);
    this._lastZIndex--;
    var layerOrderTemp = this._layersOrder;
    for (var i = 0; i < layerOrderTemp.length; i++) {
      layerOrderTemp[i].layer.setZIndex(this._lastZIndex - i);
    }
    this.dispatchEvent({
      type: this.REMOVE_LAYER_EVENT,
      layer: this._layers[layerID]
    });
    if (layer === this.getSelectedLayer()) {
      this.setSelectedLayer();
    }
    delete this._layers[layerID];
    this._updateLayerCounter();
  }
  /**
   * Lock a layer, so it cannot be removed or modified from layerSwitcher
   * @param {Layer} layer - layer to be locked
   * @param {Boolean} locked - true if locked
   * @fires layerswitcher:lock {@link LayerSwitcher#LOCK_LAYER_EVENT}
   */
  lockLayer(layer, locked) {
    if (!layer) {
      return;
    }
    var layerID = layer.gpLayerId;
    var layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + layerID));
    if (layerDiv) {
      locked ? layerDiv.setAttribute("disabled", true) : layerDiv.removeAttribute("disabled");
    }
    layer.set("locked", locked);
    this.dispatchEvent({
      type: this.LOCK_LAYER_EVENT,
      layer: this._layers[layerID],
      locked
    });
  }
  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger9.log("[ERROR] LayerSwitcher:setCollapsed - missing collapsed parameter");
      return;
    }
    var isCollapsed = !document.getElementById(this._addUID("GPshowLayersList")).checked;
    if (collapsed && isCollapsed || !collapsed && !isCollapsed) {
      return;
    }
    if (!isCollapsed) {
      document.getElementById(this._addUID("GPlayerInfoPanel")).classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
      document.getElementById(this._addUID("GPlayerStylePanel")).classList.add("GPlayerStylePanelClosed", "gpf-hidden");
    }
    document.getElementById(this._addUID("GPshowLayersList")).checked = !collapsed;
  }
  /**
   * Returns true if widget is collapsed (minimize), false otherwise
   * @returns {Boolean} is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Display or hide removeLayerPicto from layerSwitcher for this layer
   *
   * @param {Layer} layer - ol.layer to be configured
   * @param {Boolean} removable - specify if layer can be remove from layerSwitcher (true) or not (false). Default is true
   */
  setRemovable(layer, removable) {
    if (!layer) {
      return;
    }
    var layerID = layer.gpLayerId;
    if (layerID == null) {
      logger9.log("[LayerSwitcher:setRemovable] layer should be added to map before calling setRemovable method");
      return;
    }
    var removalDiv = document.getElementById(this._addUID("GPremove_ID_" + layerID));
    if (removalDiv) {
      if (removable === false) {
        removalDiv.style.display = "none";
      } else if (removable === true) {
        removalDiv.style.display = "block";
      } else {
      }
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  /**
   * Forget add listener added to the control
   */
  forget() {
    unByKey(this._listeners.onAddListener);
  }
  /**
   * Add listeners to catch map layers addition
   */
  listen() {
    var map = this.getMap();
    if (map) {
      this._listeners.onAddListener = map.getLayers().on(
        "add",
        (evt) => {
          logger9.debug("LayerSwitcher:onAddListener", evt);
          var layer = evt.element;
          var id;
          if (!layer.hasOwnProperty("gpLayerId")) {
            id = this._layerId;
            layer.gpLayerId = id;
            this._layerId++;
          } else {
            id = layer.gpLayerId;
          }
          if (!this._layers[id]) {
            this.addLayer(layer);
          }
        }
      );
    }
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize LayerSwitcher control (called by constructor)
   *
   * @param {Object} options - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
   * @param {Array} layers - list of layers to be configured. Each array element is an object, with following properties :
   * @private
   */
  _initialize(options, layers) {
    this.options = {
      id: "",
      collapsed: true,
      draggable: false,
      counter: false,
      panel: false,
      gutter: false,
      allowEdit: true,
      allowGrayScale: true,
      allowDraggable: true,
      allowDelete: true,
      allowTooltips: false,
      headerButtons: [],
      advancedTools: null
    };
    Helper_default2.assign(this.options, options);
    this.options.layers = layers;
    this._uid = this.options.id || SelectorID_default.generate();
    this._layers = {};
    this._layersOrder = [];
    this._layersIndex = {};
    this._lastZIndex = 0;
    this._layerId = 0;
    this.collapsed = this.options.collapsed !== void 0 ? this.options.collapsed : true;
    this._layerListContainer = null;
    this._listeners = {};
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i].layer;
      if (layer) {
        var id;
        if (!layer.hasOwnProperty("gpLayerId")) {
          id = this._layerId;
          layer.gpLayerId = id;
          this._layerId++;
        } else {
          id = layer.gpLayerId;
        }
        var conf = layers[i].config || {};
        var layerInfo = this.getLayerInfo(layer);
        var opacity = layer.getOpacity();
        var visibility = layer.getVisible();
        var grayscale = layer.get("grayscale");
        var layerOptions = {
          layer,
          // la couche ol.layer concernÃ©e
          id,
          name: layer.name,
          // only geoportal layers
          service: layer.service,
          // only geoportal layers
          opacity: opacity != null ? opacity : 1,
          visibility: visibility != null ? visibility : true,
          grayscale,
          title: conf.title || layerInfo._title,
          description: conf.description || layerInfo._description,
          legends: conf.legends || layerInfo._legends,
          metadata: conf.metadata || layerInfo._metadata,
          quicklookUrl: conf.quicklookUrl || layerInfo._quicklookUrl,
          thumbnail: conf.thumbnail || layerInfo._thumbnail,
          producer: conf.producer || layerInfo._producer
        };
        this._layers[id] = layerOptions;
      }
    }
    this._layerListContainer = null;
    this._layerSwitcherCounter = null;
    this._showLayerSwitcherButton = null;
    this.PROPERTY_CHANGE_EVENT = "layerswitcher:propertychange";
    this.ADD_LAYER_EVENT = "layerswitcher:add";
    this.REMOVE_LAYER_EVENT = "layerswitcher:remove";
    this.LOCK_LAYER_EVENT = "layerswitcher:lock";
    this.EXTENT_LAYER_EVENT = "layerswitcher:extent";
    this.EDIT_LAYER_EVENT = "layerswitcher:edit";
    this.CUSTOM_LAYER_EVENT = "layerswitcher:custom";
    this.HEADER_BUTTON_EVENT = "layerswitcher:header:button";
    this.CHANGE_LAYER_OPACITY_EVENT = "layerswitcher:change:opacity";
    this.CHANGE_LAYER_VISIBILITY_EVENT = "layerswitcher:change:visibility";
    this.CHANGE_LAYER_GRAYSCALE_EVENT = "layerswitcher:change:grayscale";
    this.CHANGE_LAYER_LOCKED_EVENT = "layerswitcher:change:locked";
    this.CHANGE_LAYER_SELECTED_EVENT = "layerswitcher:change:selected";
  }
  /**
   * Create control main container (called by constructor)
   *
   * @returns {HTMLElement} container - control container
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var input = this._createMainLayersShowElement();
    container.appendChild(input);
    if (!this.collapsed) {
      input.checked = "checked";
      this.collapsed = false;
    } else {
      this.collapsed = true;
    }
    var context = this;
    var changeCollapsed = function(e) {
      this.collapsed = !e.target.checked;
      this.dispatchEvent("change:collapsed");
    };
    input.addEventListener(
      "click",
      function(e) {
        changeCollapsed.call(context, e);
      }
    );
    var picto = this._showLayerSwitcherButton = this._createMainPictoElement();
    container.appendChild(picto);
    container.classList.add("GplayerSwitcher-counterRemoved");
    if (this.options.counter) {
      container.classList.remove("GplayerSwitcher-counterRemoved");
      container.classList.add("GplayerSwitcher-counterAdded");
      var counter = this._layerSwitcherCounter = this._createMainCounterLayersElement();
      picto.appendChild(counter);
    }
    var divL = this._createMainLayersElement();
    container.appendChild(divL);
    if (this.options.panel) {
      var panelHeader = this._createLayersPanelHeaderElement();
      divL.appendChild(panelHeader);
      var panelIcon = this._createLayersPanelIconElement();
      panelHeader.appendChild(panelIcon);
      var panelTitle = this._createLayersPanelTitleElement();
      panelHeader.appendChild(panelTitle);
      var panelClose = this._createLayersPanelCloseElement();
      panelHeader.appendChild(panelClose);
    }
    var div = this._createMainLayersDivElement();
    divL.appendChild(div);
    if (this.options.headerButtons.length) {
      let bodyHeader = this._createHeaderButtonsDivElement();
      let btnsGroup = this._createButtonsGroupElement({
        className: "GPbodyHeaderBtnsGroup",
        size: "sm"
      });
      this.options.headerButtons.forEach((opt) => {
        let btn = this._createButtonHeaderElement(opt);
        btnsGroup.appendChild(btn);
      });
      bodyHeader.appendChild(btnsGroup);
      div.appendChild(bodyHeader);
    }
    var layerList = this._layerListContainer = this._createMainLayerListElement();
    div.appendChild(layerList);
    this._createDraggableElement(layerList, this);
    var divI = this._createMainInfoElement();
    var divD = this._createMainInfoDivElement();
    divI.appendChild(divD);
    container.appendChild(divI);
    var divS = this._createMainStyleElement();
    var divSd = this._createMainStyleDivElement();
    divS.appendChild(divSd);
    container.appendChild(divS);
    return container;
  }
  /**
   * Add all map layers to control main container
   *
   * @param {Map} map - Map object, to which control is added
   * @private
   */
  _addMapLayers(map) {
    this._layersIndex = {};
    map.getLayers().forEach((layer) => {
      var id = null;
      if (!layer.hasOwnProperty("gpLayerId")) {
        id = this._layerId;
        layer.gpLayerId = id;
        this._layerId++;
      } else {
        id = layer.gpLayerId;
      }
      var layerInfos = this.getLayerInfo(layer) || {};
      if (!this._layers[id]) {
        var opacity = layer.getOpacity();
        var visibility = layer.getVisible();
        var grayscale = layer.get("grayscale");
        var locked = layer.get("locked");
        var isInRange = this.isInRange(layer, map);
        var layerOptions2 = {
          layer,
          id,
          name: layer.name,
          // only geoportal layers
          service: layer.service,
          // only geoportal layers
          opacity: opacity != null ? opacity : 1,
          visibility: visibility != null ? visibility : true,
          grayscale,
          locked,
          inRange: isInRange != null ? isInRange : true,
          producer: layerInfos._producer || null,
          thumbnail: layerInfos._thumbnail || null,
          title: layerInfos._title || id,
          description: layerInfos._description || null,
          legends: layerInfos._legends || [],
          metadata: layerInfos._metadata || [],
          quicklookUrl: layerInfos._quicklookUrl || null
        };
        this._layers[id] = layerOptions2;
      } else {
        this._layers[id].opacity = layer.getOpacity();
        this._layers[id].visibility = layer.getVisible();
        this._layers[id].grayscale = layer.get("grayscale");
        this._layers[id].locked = layer.get("locked");
        this._layers[id].inRange = this.isInRange(layer, map);
      }
      this._updateLayerCounter();
      this._listeners.updateLayerOpacity = layer.on(
        "change:opacity",
        (e) => this._updateLayerOpacity(e)
      );
      this._listeners.updateLayerVisibility = layer.on(
        "change:visible",
        (e) => this._updateLayerVisibility(e)
      );
      this._listeners.updateLayerGrayScale = layer.on(
        "change:grayscale",
        (e) => this._updateLayerGrayScale(e)
      );
      this._listeners.updateLayerLocked = layer.on(
        "change:locked",
        (e) => this._updateLayerLocked(e)
      );
      this._listeners.updateProperties = layer.on(
        "propertychange",
        (e) => this._updateGenericProperty(e)
      );
      var self2 = this;
      setTimeout(() => {
        self2._updateLayerGrayScale({
          target: {
            gpLayerId: id
          }
        });
      }, 0);
      if (layer.getZIndex !== void 0) {
        var layerIndex = layer.getZIndex() || 0;
        if (!this._layersIndex[layerIndex] || !Array.isArray(this._layersIndex[layerIndex])) {
          this._layersIndex[layerIndex] = [];
        }
        this._layersIndex[layerIndex].push(this._layers[id]);
      }
      ;
    });
    for (var zindex in this._layersIndex) {
      if (this._layersIndex.hasOwnProperty(zindex)) {
        var layers = this._layersIndex[zindex];
        for (var l3 = 0; l3 < layers.length; l3++) {
          this._layersOrder.unshift(layers[l3]);
          this._lastZIndex++;
          layers[l3].layer.setZIndex(this._lastZIndex);
          if (this._layers[layers[l3].layer.gpLayerId].onZIndexChangeEvent == null) {
            this._layers[layers[l3].layer.gpLayerId].onZIndexChangeEvent = layers[l3].layer.on(
              "change:zIndex",
              () => this._updateLayersOrder()
            );
          }
        }
      }
    }
    for (var j2 = 0; j2 < this._layersOrder.length; j2++) {
      var layerOptions = this._layersOrder[j2];
      var layerDiv = this._createLayerDiv(layerOptions);
      layerDiv.dataset.sortableId = layerOptions.id;
      if (!this._layerListContainer.querySelector("#" + layerDiv.id)) {
        this._layerListContainer.appendChild(layerDiv);
      }
      this._layers[layerOptions.id].div = layerDiv;
    }
  }
  /**
   * create layer div (to append to control DOM element).
   *
   * @param {Object} layerOptions - layer options (id, title, description, legends, metadata, quicklookUrl ...)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _createLayerDiv(layerOptions) {
    var isLegends = layerOptions.legends && layerOptions.legends.length !== 0;
    var isMetadata = layerOptions.metadata && layerOptions.metadata.length !== 0;
    var isQuicklookUrl = layerOptions.quicklookUrl;
    if (isLegends || isMetadata || isQuicklookUrl) {
      layerOptions.displayInformationElement = true;
    }
    layerOptions.editable = false;
    if (this.options.allowEdit) {
      if (layerOptions.layer instanceof Vector_default2 || layerOptions.layer instanceof VectorTile_default2) {
        layerOptions.editable = true;
      }
    }
    layerOptions.grayable = false;
    if (this.options.allowGrayScale) {
      if (layerOptions.layer instanceof Tile_default || layerOptions.layer instanceof VectorTile_default2) {
        layerOptions.grayable = true;
      }
    }
    layerOptions.draggable = false;
    if (this.options.allowDraggable) {
      layerOptions.draggable = true;
    }
    layerOptions.deletable = false;
    if (this.options.allowDelete) {
      layerOptions.deletable = true;
    }
    layerOptions.advancedTools = this.options.advancedTools;
    var layerDiv = this._createContainerLayerElement(layerOptions, this.options.allowTooltips);
    if (!layerOptions.inRange) {
      layerDiv.classList.add("outOfRange");
    }
    return layerDiv;
  }
  // ################################################################### //
  // ######################### DOM events ############################## //
  // ################################################################### //
  /**
   * ...
   *
   * @method onShowLayerSwitcherClick
   * @param { event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowLayerSwitcherClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var opened = this._showLayerSwitcherButton.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
  /**
   * update layer counter
   * @private
   */
  _updateLayerCounter() {
    if (this._layerSwitcherCounter) {
      this._layerSwitcherCounter.innerHTML = Object.keys(this._layers).length;
    }
  }
  /**
   * Change layer opacity on layer opacity picto click
   *
   * @param {Object} e - event
   * @private
   */
  _onChangeLayerOpacity(e) {
    e.target.parentNode.style.setProperty("--progress-right", e.target.value + "%");
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var layer = this._layers[layerID].layer;
    var opacityValue = e.target.value;
    var opacityId = document.getElementById(this._addUID("GPopacityValue_ID_" + layerID));
    opacityId.innerHTML = opacityValue + "%";
    layer.setOpacity(opacityValue / 100);
  }
  /**
   * Update picto opacity value on layer opacity change
   *
   * @param {Object} e - event
   * @fires layerswitcher:change:opacity {@link LayerSwitcher#CHANGE_LAYER_OPACITY_EVENT}
   * @private
   */
  _updateLayerOpacity(e) {
    var opacity = e.target.getOpacity();
    if (opacity > 1) {
      opacity = 1;
    }
    if (opacity < 0) {
      opacity = 0;
    }
    var id = e.target.gpLayerId;
    var layerOpacityInput = document.getElementById(this._addUID("GPopacityValueDiv_ID_" + id));
    if (layerOpacityInput) {
      layerOpacityInput.value = Math.round(opacity * 100);
    }
    var layerOpacitySpan = document.getElementById(this._addUID("GPopacityValue_ID_" + id));
    if (layerOpacitySpan) {
      layerOpacitySpan.innerHTML = Math.round(opacity * 100) + "%";
    }
    this.dispatchEvent({
      type: this.CHANGE_LAYER_OPACITY_EVENT,
      opacity,
      layer: this._layers[id]
    });
  }
  /**
   * Change layer visibility on layer visibility picto click
   *
   * @param {Object} e - event
   * @private
   */
  _onVisibilityLayerClick(e) {
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var layer = this._layers[layerID].layer;
    layer.setVisible(e.target.ariaPressed === "true");
  }
  /**
   * Change picto visibility on layer visibility change
   *
   * @param {Object} e - event
   * @fires layerswitcher:change:visibility {@link LayerSwitcher#CHANGE_LAYER_VISIBILITY_EVENT}
   * @private
   */
  _updateLayerVisibility(e) {
    var visible = e.target.getVisible();
    var id = e.target.gpLayerId;
    var layerVisibility = document.getElementById(this._addUID("GPvisibilityPicto_ID_" + id));
    if (layerVisibility) {
      layerVisibility.ariaPressed = visible;
    }
    this.dispatchEvent({
      type: this.CHANGE_LAYER_VISIBILITY_EVENT,
      visibility: visible,
      layer: this._layers[id]
    });
  }
  /**
   * Change layer style on mapbox layer dialog
   *
   * @param {Object} e - event
   * @private
   */
  _onChangeStyleLayerClick(e) {
    var id = e.target.id;
    var layerID = SelectorID_default.index(id);
    var layer = this._layers[layerID].layer;
    layer.set("grayscale", false);
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var greyscaleBtn = document.getElementById(this._addUID("GPgreyscale_ID_" + layerID));
    if (greyscaleBtn) {
      greyscaleBtn.classList.add("GPlayerGreyscaleOff");
      greyscaleBtn.classList.remove("GPlayerGreyscaleOn");
    }
    layer.styleUrl = e.target.value;
    layer.styleName = e.target.dataset.name;
    layer.setStyleMapBox();
    this.dispatchEvent({
      type: "layerswitcher:change:style",
      name: layer.styleName,
      url: layer.styleUrl,
      layer: this._layers[layerID]
    });
  }
  /**
   * Change layers order in layerswitcher (control container) on a layer index change (on map) or when a layer is added to a specific zindex
   * @todo fires layerswitcher:change:zindex
   * @private
   */
  _updateLayersOrder() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    this._layersIndex = {};
    var layerIndex;
    var id;
    map.getLayers().forEach(
      (layer) => {
        id = layer.gpLayerId;
        unByKey(this._layers[id].onZIndexChangeEvent);
        this._layers[id].onZIndexChangeEvent = null;
        layerIndex = null;
        if (layer.getZIndex !== void 0) {
          layerIndex = layer.getZIndex();
          if (!this._layersIndex[layerIndex] || !Array.isArray(this._layersIndex[layerIndex])) {
            this._layersIndex[layerIndex] = [];
          }
          this._layersIndex[layerIndex].push(this._layers[id]);
        }
        ;
      }
    );
    this._lastZIndex = 0;
    this._layersOrder = [];
    for (var zindex in this._layersIndex) {
      if (this._layersIndex.hasOwnProperty(zindex)) {
        var layers = this._layersIndex[zindex];
        for (var l3 = 0; l3 < layers.length; l3++) {
          this._layersOrder.unshift(layers[l3]);
          this._lastZIndex++;
          if (this._layers[layers[l3].layer.gpLayerId].onZIndexChangeEvent == null) {
            this._layers[layers[l3].layer.gpLayerId].onZIndexChangeEvent = layers[l3].layer.on(
              "change:zIndex",
              () => this._updateLayersOrder()
            );
          }
        }
      }
    }
    if (this._layerListContainer) {
      for (let index2 = 0; index2 < this._layerListContainer.childNodes.length; index2++) {
        const element = this._layerListContainer.childNodes[index2];
        if (element.id === "") {
          continue;
        }
        element.remove();
      }
      for (var j2 = 0; j2 < this._layersOrder.length; j2++) {
        var layerOptions = this._layersOrder[j2];
        this._layerListContainer.appendChild(layerOptions.div);
      }
    } else {
      logger9.log("[ol.control.LayerSwitcher] _updateLayersOrder : layer list container not found to update layers order ?!");
    }
  }
  /**
   * Open layer information panel on picto click
   *
   * @param {Event} e - MouseEvent
   * @private
   */
  _onOpenLayerInfoClick(e) {
    var id = e.target.id;
    var layerID = SelectorID_default.index(id);
    var layerOptions = this._layers[layerID];
    var panel;
    var info;
    var divId = document.getElementById(e.target.id);
    if (divId.classList.contains("GPlayerInfoOpened")) {
      divId.classList.remove("GPlayerInfoOpened");
      divId.classList.add("GPlayerInfoClosed");
      panel = document.getElementById(this._addUID("GPlayerInfoPanel"));
      panel.classList.remove("GPlayerInfoPanelOpened", "gpf-visible");
      panel.classList.add("GPlayerInfoPanelClosed", "gpf-hidden");
      info = document.getElementById(this._addUID("GPlayerInfoContent"));
      if (info) {
        info.parentNode.remove();
      }
      return;
    }
    if (divId.classList.contains("GPlayerInfoClosed")) {
      divId.classList.remove("GPlayerInfoClosed");
      divId.classList.add("GPlayerInfoOpened");
    }
    panel = document.getElementById(this._addUID("GPlayerInfoPanel"));
    panel.classList.remove("GPlayerInfoPanelClosed", "gpf-hidden");
    panel.classList.add("GPlayerInfoPanelOpened", "gpf-visible");
    info = document.getElementById(this._addUID("GPlayerInfoContent"));
    if (info) {
      info.parentNode.remove();
    }
    var obj = {
      id,
      title: layerOptions.title,
      description: layerOptions.description,
      quicklookUrl: layerOptions.quicklookUrl,
      metadata: layerOptions.metadata,
      legends: layerOptions.legends
    };
    var maxResolution = layerOptions.layer.getMaxResolution();
    if (maxResolution === Infinity) {
      obj._maxScaleDenominator = 56e7;
    } else {
      obj._maxScaleDenominator = Math.round(maxResolution / 28e-5);
    }
    var infoLayer = this._createContainerLayerInfoElement(obj);
    panel.firstChild.appendChild(infoLayer);
  }
  /**
   * Open layer style select panel on picto click
   *
   * @param {Event} e - MouseEvent
   * @param {Array} styles - List of styles
   * @private
   */
  _onEditLayerStyleClick(e, styles) {
    var id = e.target.id;
    var layerID = SelectorID_default.index(id);
    var layerOptions = this._layers[layerID];
    var panel;
    var style;
    var divId = document.getElementById(e.target.id);
    if (divId.classList.contains("GPlayerStyleOpened")) {
      divId.classList.remove("GPlayerStyleOpened");
      divId.classList.add("GPlayerStyleClosed");
      panel = document.getElementById(this._addUID("GPlayerStylePanel"));
      panel.classList.remove("GPlayerStylePanelOpened", "gpf-visible");
      panel.classList.add("GPlayerStylePanelClosed", "gpf-hidden");
      style = document.getElementById(this._addUID("GPlayerStyleContent"));
      if (style) {
        style.parentNode.remove();
      }
      return;
    }
    if (divId.classList.contains("GPlayerStyleClosed")) {
      divId.classList.remove("GPlayerStyleClosed");
      divId.classList.add("GPlayerStyleOpened");
    }
    panel = document.getElementById(this._addUID("GPlayerStylePanel"));
    panel.classList.remove("GPlayerStylePanelClosed", "gpf-hidden");
    panel.classList.add("GPlayerStylePanelOpened", "gpf-visible");
    style = document.getElementById(this._addUID("GPlayerStyleContent"));
    if (style) {
      style.parentNode.remove();
    }
    var obj = {
      id: layerID,
      div: id,
      styles,
      layerInfo: layerOptions
    };
    var maxResolution = layerOptions.layer.getMaxResolution();
    if (maxResolution === Infinity) {
      obj._maxScaleDenominator = 56e7;
    } else {
      obj._maxScaleDenominator = Math.round(maxResolution / 28e-5);
    }
    var styleLayer = this._createContainerLayerStyleElement(obj);
    panel.firstChild.appendChild(styleLayer);
  }
  /**
   * remove layer from layer switcher and map on picto click
   *
   * @param {Event} e - MouseEvent
   * @private
   */
  _onDropLayerClick(e) {
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var layer = this._layers[layerID].layer;
    this.getMap().getLayers().remove(layer);
  }
  /**
   * edit layer
   *
   * @param {Event} e - MouseEvent
   * @fires layerswitcher:edit {@link LayerSwitcher#EDIT_LAYER_EVENT}
   * @private
   */
  _onEditLayerClick(e) {
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var options = this._layers[layerID];
    var layer = this._layers[layerID].layer;
    this.dispatchEvent({
      type: this.EDIT_LAYER_EVENT,
      layer,
      options
    });
  }
  /**
   * change layers order (on map) on drag and drop (on control container)
   *
   * @param {Event} e - CustomEvent
   * @private
   */
  _onEndDragAndDropLayerClick(e) {
    logger9.trace(e);
    var map = this.getMap();
    var matchesLayers = document.querySelectorAll("div.GPlayerSwitcher_layer");
    var maxZIndex = matchesLayers.length;
    this._layersOrder = [];
    for (var i = 0; i < matchesLayers.length; i++) {
      var tag = matchesLayers[i].id;
      var id = SelectorID_default.index(tag);
      var layer = this._layers[id].layer;
      unByKey(this._layers[id].onZIndexChangeEvent);
      this._layers[id].onZIndexChangeEvent = null;
      if (layer.setZIndex) {
        layer.setZIndex(maxZIndex);
        this._layersOrder.push(this._layers[id]);
        maxZIndex--;
      }
      if (this._layers[id].onZIndexChangeEvent == null) {
        this._layers[id].onZIndexChangeEvent = layer.on(
          "change:zIndex",
          () => this._updateLayersOrder()
        );
      }
    }
    map.updateSize();
    this.dispatchEvent({
      type: "layerswitcher:change:position",
      position: e.newIndex,
      layer: this._layersOrder[e.newIndex],
      layers: this._layersOrder
    });
  }
  /**
   * change layers order (on map) on drag and drop (on control container)
   *
   * @param {Event} e - DragNDrop Event
   * @private
   */
  _onStartDragAndDropLayerClick(e) {
    logger9.debug(e);
  }
  /**
   * update greyscale
   * @param {Event} e - Event
   * @fires layerswitcher:change:grayscale {@link LayerSwitcher#CHANGE_LAYER_GRAYSCALE_EVENT}
   * @private
   */
  _updateLayerGrayScale(e) {
    function getGreyScaledDataUrl(img) {
      img.crossOrigin = "anonymous";
      var canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      img.width = img.width || 256;
      img.height = img.height || 256;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      var imageData = ctx.getImageData(0, 0, img.width, img.height);
      var data = imageData.data;
      for (var i = 0; i < data.length; i += 4) {
        var avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = avg;
        data[i + 1] = avg;
        data[i + 2] = avg;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL();
    }
    ;
    function convertImagetoGreyScale(image, context) {
      var dataUrl = getGreyScaledDataUrl(image);
      image.src = "";
      image.src = dataUrl;
    }
    function imageloadstartHandler(evt) {
      evt.image.getImage().crossOrigin = "Anonymous";
    }
    ;
    function tileloadstartHandler(evt) {
      evt.tile.getImage().crossOrigin = "Anonymous";
    }
    ;
    function imageloadendHandler(evt) {
      convertImagetoGreyScale(evt.image.getImage(), evt.target);
    }
    ;
    function tileloadendHandler(evt) {
      convertImagetoGreyScale(evt.tile.getImage(), evt.target);
    }
    ;
    function toGrayscale(color) {
      if (!color || typeof color !== "string" || !color.startsWith("#")) {
        return color;
      }
      const r2 = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b3 = parseInt(color.slice(5, 7), 16);
      const gray = Math.round(0.3 * r2 + 0.59 * g + 0.11 * b3);
      const grayHex = gray.toString(16).padStart(2, "0");
      return `#${grayHex}${grayHex}${grayHex}`;
    }
    async function applyGrayscaleStyle(layer2) {
      var styleJson = await getStyle(layer2);
      styleJson.layers.forEach((lyr) => {
        if (lyr.paint) {
          Object.keys(lyr.paint).forEach((prop) => {
            let value2 = lyr.paint[prop];
            if (Array.isArray(value2) && value2[0] === "interpolate" && value2[2] === "zoom") {
              for (let i = 4; i < value2.length; i += 2) {
                value2[i] = toGrayscale(value2[i]);
              }
            } else if (Array.isArray(value2) && value2[0] === "step") {
              for (let i = 2; i < value2.length; i += 2) {
                value2[i] = toGrayscale(value2[i]);
              }
            } else if (value2 instanceof Object && value2.stops) {
              for (let i = 0; i < value2.stops.length; i += 1) {
                value2.stops[i][1] = toGrayscale(value2.stops[i][1]);
              }
            } else {
              lyr.paint[prop] = toGrayscale(value2);
            }
          });
        }
      });
      applyStyle(layer2, styleJson);
    }
    async function applyOriginalStyle(layer2) {
      var styleJson = await getStyle(layer2);
      applyStyle(layer2, styleJson);
    }
    async function getStyle(layer2) {
      const response = await fetch(layer2.styleUrl);
      const styleJson = await response.json();
      return styleJson;
    }
    var id = e.target.gpLayerId;
    var layer = this._layers[id].layer;
    var source = layer.getSource();
    if (!(source instanceof Image_default || source instanceof TileWMS_default || source instanceof WMTS_default2 || source instanceof VectorTile_default)) {
      console.warn("Greyscale only implemented for raster and vector tiles");
      return;
    }
    var toGreyScale = layer.get("grayscale");
    if (toGreyScale) {
      if (source instanceof VectorTile_default) {
        applyGrayscaleStyle(layer);
      } else if (source instanceof Image_default) {
        source.loadstartListenerKey = source.on("imageloadstart", imageloadstartHandler);
        source.loadendListenerKey = source.on("imageloadend", imageloadendHandler);
      } else {
        source.loadstartListenerKey = source.on("tileloadstart", tileloadstartHandler);
        source.loadendListenerKey = source.on("tileloadend", tileloadendHandler);
      }
    } else {
      if (source instanceof VectorTile_default) {
        applyOriginalStyle(layer);
      } else {
        unByKey(source.loadstartListenerKey);
        unByKey(source.loadendListenerKey);
        source.loadstartListenerKey = null;
        source.loadendListenerKey = null;
      }
    }
    if (!(source instanceof VectorTile_default)) {
      source.refresh();
    }
    this.dispatchEvent({
      type: this.CHANGE_LAYER_GRAYSCALE_EVENT,
      grayscale: toGreyScale,
      layer: this._layers[id]
    });
  }
  /**
   * toggle greyscale layer
   * @param {Event} e - Event
   * @private
   */
  _onToggleLayerGreyscaleClick(e) {
    console.trace(e);
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var layer = this._layers[layerID].layer;
    var toGreyScale = true;
    if (e.target.classList.contains("GPlayerGreyscaleOff")) {
      e.target.classList.remove("GPlayerGreyscaleOff");
      e.target.classList.add("GPlayerGreyscaleOn");
    } else {
      e.target.classList.add("GPlayerGreyscaleOff");
      e.target.classList.remove("GPlayerGreyscaleOn");
      toGreyScale = false;
    }
    layer.set("grayscale", toGreyScale);
  }
  /**
   * update locked layer
   * @param {Event} e - Event
   * @fires layerswitcher:change:locked {@link LayerSwitcher#CHANGE_LAYER_LOCKED_EVENT}
   * @private
   */
  _updateLayerLocked(e) {
    var id = e.target.gpLayerId;
    var layer = this._layers[id].layer;
    var locked = layer.get("locked");
    var layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + id));
    if (layerDiv) {
      locked ? layerDiv.setAttribute("disabled", true) : layerDiv.removeAttribute("disabled");
    }
    this.dispatchEvent({
      type: this.CHANGE_LAYER_LOCKED_EVENT,
      locked,
      layer: this._layers[id]
    });
  }
  /**
   * generic update property
   * @param {Event} e - Event
   * @fires layerswitcher:changeproperty {@link LayerSwitcher#PROPERTY_CHANGE_EVENT}
   * @private
   */
  _updateGenericProperty(e) {
    var id = e.target.gpLayerId;
    var layer = this._layers[id].layer;
    var value2 = layer.get(e.key);
    switch (e.key) {
      case "title":
        this._layers[id].title = value2;
        var nameDiv = document.getElementById(this._addUID("GPname_ID_" + id));
        if (nameDiv) {
          nameDiv.innerHTML = value2;
          nameDiv.title = value2;
        }
        break;
      case "description":
        this._layers[id].description = value2;
        var nameDiv = document.getElementById(this._addUID("GPname_ID_" + id));
        if (nameDiv) {
          nameDiv.title = value2;
        }
        break;
      case "producer":
        this._layers[id].producer = value2;
        var producerDiv = document.getElementById(this._addUID("GPlayerProducer_ID_" + id));
        if (producerDiv) {
          producerDiv.innerHTML = value2;
        }
        break;
      default:
        break;
    }
    this.dispatchEvent({
      type: this.PROPERTY_CHANGE_EVENT,
      key: e.key,
      value: value2,
      layer: this._layers[id]
    });
  }
  /**
   * toggle locked layer
   * @param {Event} e - Event
   * @private
   */
  _onToggleLayerLockedClick(e) {
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var layer = this._layers[layerID].layer;
    var locked = e.target.ariaPressed === "true";
    layer.set("locked", locked);
  }
  /**
   * zoom to extent
   * @fixme dot it for other user data
   * @param {PointerEvent} e - Event
   * @fires layerswitcher:extent
   * @private
   */
  _onZoomToExtentClick(e) {
    logger9.debug(e);
    var domIDShort = e.target.id;
    var domIDLong = SelectorID_default.index(domIDShort);
    var data = this._layers[domIDLong];
    var extent = null;
    var error = null;
    var map = this.getMap();
    if (data.layer.hasOwnProperty("gpResultLayerId") && (data.layer.gpResultLayerId.split(":")[0] === "layerimport" || data.layer.gpResultLayerId.split(":")[0] === "drawing" || data.layer.gpResultLayerId.split(":")[0] === "compute" || data.layer.gpResultLayerId.split(":")[0] === "bookmark")) {
      if (map.getView() && map.getSize()) {
        var sourceExtent = data.layer.getExtent();
        if (!sourceExtent) {
          var source = data.layer.getSource();
          if (source && source.getExtent) {
            sourceExtent = source.getExtent();
          } else {
            sourceExtent = source.getTileGrid().getExtent();
          }
        }
        if (sourceExtent && sourceExtent[0] !== Infinity) {
          map.getView().fit(sourceExtent, map.getSize());
        }
      }
    } else {
      try {
        if (!Config_default2.isConfigLoaded()) {
          throw "ERROR : contract key configuration has to be loaded to load Geoportal layers.";
        }
        var layerName = data.layer.name || data.layer.getSource().name;
        var layerService = data.layer.service || data.layer.getSource().service;
        var layerId = Config_default2.configuration.getLayerId(layerName, layerService);
        if (!layerId) {
          throw "ERROR : Layer ID not found into the catalogue !?";
        }
        var globalConstraints = Config_default2.configuration.getGlobalConstraints(layerId);
        if (globalConstraints) {
          if (!map || !map.getView()) {
            return;
          }
          var view = map.getView();
          var crsTarget = view.getProjection();
          var bbox = [
            globalConstraints.extent.left,
            globalConstraints.extent.bottom,
            globalConstraints.extent.right,
            globalConstraints.extent.top
          ];
          var crsSource = globalConstraints.crs;
          if (!crsSource) {
            crsSource = "EPSG:4326";
          }
          extent = transformExtent(bbox, crsSource, crsTarget);
          if (extent) {
            view.fit(extent);
          }
        }
      } catch (e2) {
        error = e2;
      }
    }
    this.dispatchEvent({
      type: this.EXTENT_LAYER_EVENT,
      extent,
      layer: data,
      error
    });
  }
  /**
   * Action utilisateur pour un outil avancÃ©
   * @param {PointerEvent} e - Event
   * @param {String} action - le nom du bouton (label)
   * @param {Function} cb - callback definie par l'utilisateur
   * @fires layerswitcher:custom
   * @private
   */
  _onClickAdvancedToolsMore(e, action, cb) {
    var divId = e.target.id;
    var layerID = SelectorID_default.index(divId);
    var options = this._layers[layerID];
    var layer = this._layers[layerID].layer;
    if (cb) {
      cb(e, this, layer, options);
      return;
    }
    this.dispatchEvent({
      type: this.CUSTOM_LAYER_EVENT,
      action,
      layer,
      options
    });
  }
  /**
   * Action utilisateur pour un clic sur un bouton du header
   * @param {PointerEvent} e - Event
   * @param {String} action - le nom du bouton (label)
   * @param {Function} cb - callback definie par l'utilisateur
   * @fires layerswitcher:header:button
   * @private
   */
  _onClickHeaderButtons(e, action, cb) {
    if (cb) {
      cb(e, this);
      return;
    }
    this.dispatchEvent({
      type: this.HEADER_BUTTON_EVENT,
      action
    });
  }
  /**
   * SÃ©lectionne une couche et envoie un Ã©vÃ©nement
   * @param {PointerEvent|KeyboardEvent} e - Event
   * @fires layerswitcher:change:selected
   * @private
   */
  _onSelectLayer(e) {
    if (e.type !== "keydown" || ["Enter", "Space"].includes(e.code) && e.target.id.startsWith("GPlayerSwitcher_ID_")) {
      const target2 = e.target;
      const divId = target2.id;
      const layerID = SelectorID_default.index(divId);
      const options = this._layers[layerID];
      if (options) {
        const layer = this._layers[layerID].layer;
        if (layer !== this.getSelectedLayer()) {
          this.setSelectedLayer(layer, true);
        }
      }
    }
  }
  /**
   * SÃ©lectionne une couche et envoie un Ã©vÃ©nement
   * @param {PointerEvent} e - Event
   * @returns {Layer|null} Couche sÃ©lectionnÃ©e.
   * @public
   */
  getSelectedLayer() {
    return this.selectedLayer;
  }
  /**
   * SÃ©lectionne une couche et envoie un Ã©vÃ©nement
   * et dÃ©selectionne la couche dÃ©jÃ  sÃ©lectionnÃ© (si elle existe).
   * @param {Layer} layer - Couche Ã  sÃ©lectionner.
   * @param {Boolean} selected - Vrai si la couche doit Ãªtre sÃ©lectionnÃ©e.
   * @public
   */
  setSelectedLayer(layer, selected) {
    let selectedLayer = this.getSelectedLayer();
    if (layer === selectedLayer && selectedLayer && selectedLayer.get("selected") !== selected) {
      layer.set("selected", selected);
      this.selectedLayer = null;
    } else if (!layer && selectedLayer) {
      selectedLayer.set("selected", false);
      this.selectedLayer = null;
    } else {
      layer.set("selected", !!selected);
      if (selected) {
        this.selectedLayer = layer;
      } else {
        this.selectedLayer = null;
      }
      if (selectedLayer) {
        selectedLayer.set("selected", false);
      }
    }
    if (this.getSelectedLayer()) {
      const div = this._layers[this.getSelectedLayer().gpLayerId].div;
      div.ariaCurrent = true;
    }
    if (selectedLayer) {
      const div = this._layers[selectedLayer.gpLayerId].div;
      div.ariaCurrent = false;
    }
    this.dispatchEvent({
      type: this.CHANGE_LAYER_SELECTED_EVENT,
      layer: this.getSelectedLayer(),
      previous: selectedLayer
    });
  }
  /**
   * check layers range on map movement
   *
   * @param {Map} map - map on which event occured
   * @private
   */
  _onMapMoveEnd(map) {
    map.getLayers().forEach(
      (layer) => {
        var id = layer.gpLayerId;
        if (this._layers[id]) {
          var layerOptions = this._layers[id];
          var layerDiv;
          if (this.isInRange(layer, map) && !layerOptions.inRange) {
            layerOptions.inRange = true;
            layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + id));
            layerDiv.classList.remove("outOfRange");
            var infos = this.getLayerInfo(layer);
            var title3 = infos._title;
            var description = infos._description;
            var label = document.getElementById(this._addUID("GPname_ID_" + id));
            if (label) {
              label.title = description || title3;
            }
          } else if (!this.isInRange(layer, map) && layerOptions.inRange) {
            layerOptions.inRange = false;
            layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + id));
            layerDiv.classList.add("outOfRange");
          }
        }
      }
    );
  }
  // ################################################################### //
  // ############################ Utils ################################ //
  // ################################################################### //
  /**
   * Returns Layer Container Id associated with given olLayer
   *
   * @param {Layer} olLayer - ol layer object
   * @returns {String} - div container Id ; null if layer not found.
   * @private
   */
  getLayerDOMId(olLayer) {
    var foundId = null;
    this.getMap().getLayers().forEach((layer) => {
      if (layer === olLayer) {
        foundId = layer.hasOwnProperty("gpLayerId") ? layer.gpLayerId : null;
      }
    });
    return foundId !== null ? this._addUID("GPlayerSwitcher_ID_" + foundId) : null;
  }
  /**
   * Check if map view is out of layer range (in terms of extent and zoom)
   *
   * @param {Layer} layer - the Layer object
   * @param {Map} map   - the Map object
   * @returns {Boolean} outOfRange - false if map view is out of layer range
   */
  isInRange(layer, map) {
    if (!map) {
      return;
    }
    var id = layer.gpLayerId;
    var label = document.getElementById(this._addUID("GPname_ID_" + id));
    var mapResolution = map.getView().getResolution();
    if (mapResolution > layer.getMaxResolution() || mapResolution < layer.getMinResolution()) {
      var message = "Cette couche n'est pas visible Ã  ce niveau de zoom";
      if (label) {
        label.title = message;
      }
      return false;
    }
    var mapExtent = map.getView().calculateExtent(map.getSize());
    var layerExtent = layer.getExtent();
    if (layerExtent && !intersects(mapExtent, layerExtent)) {
      var message = "Cette couche n'est pas visible Ã  cet endroit";
      if (label) {
        label.title = message;
      }
      return false;
    }
    return true;
  }
  /**
   * Get layer informations : title, description, quicklookurl, legends, metadata
   *
   * @param {Layer} layer - the ol.layer object
   * @returns {Object} layerInfo - layer informations
   */
  getLayerInfo(layer) {
    var layerInfo = {};
    if (layer.getProperties !== void 0 && layer.getSource !== void 0) {
      var layerProperties = layer.getProperties();
      var src = layerProperties.source;
      if (src) {
        layerInfo._title = src._title || layerProperties.title || layerProperties.id || "";
        layerInfo._description = src._description || layerProperties.description || "";
        layerInfo._producer = src._producer || layerProperties.producer || "";
        layerInfo._thumbnail = src._thumbnail || layerProperties.thumbnail || "";
        layerInfo._quicklookUrl = src._quicklookUrl || layerProperties.quicklookUrl || "";
        layerInfo._metadata = src._metadata || layerProperties.metadata || [];
        layerInfo._legends = src._legends || layerProperties.legends || [];
      }
    }
    return layerInfo;
  }
  /**
   * Modifie le nom du producteur de donnÃ©e
   * @param {Layer} layer Couche Ã  modifier
   * @param {String} producer Nom du producteur. Vide si le producteur doit Ãªtre enlevÃ©
   */
  setLayerProducer(layer, producer) {
    let id = layer.gpLayerId;
    let layerDiv = this._layers[id].div;
    if (layerDiv) {
      let layerTitleDiv = layerDiv.querySelector(".GPlayerTitle");
      if (layerTitleDiv.childElementCount === 2) {
        layerTitleDiv.querySelector(".GPlayerProducer").remove();
      }
      if (producer) {
        let div = this._createLayerProducerElement({
          producer
        }, this.options.allowTooltips);
        layerTitleDiv.appendChild(div);
      }
    }
  }
};
__publicField(_LayerSwitcher, "switcherButtons", {
  INFO: "info",
  EDIT: "edition",
  GREYSCALE: "greyscale",
  EXTENT: "extent"
});
var LayerSwitcher = _LayerSwitcher;
Object.assign(LayerSwitcher.prototype, LayerSwitcherDOM_default);
Object.assign(LayerSwitcher.prototype, Widget_default);
var LayerSwitcher_default = LayerSwitcher;
if (window.ol && window.ol.control) {
  window.ol.control.LayerSwitcher = LayerSwitcher;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/GetFeatureInfo/GetFeatureInfo.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/GetFeatureInfo/GPFgetFeatureInfo.css";

// node_modules/geopf-extensions-openlayers/src/packages/Utils/Draggable.js
var logger10 = LoggerByDefault_default2.getLogger("draggable");
var Draggable = {
  /**
  * A draggable HTML element with JavaScript and CSS.
  *
  * @function dragElement
  * @param {HTMLElement} element - element
  * @param {HTMLElement} header - header (optional)
  * @param {HTMLElement} container - container (optional)
  * @see https://gist.github.com/stephanbogner/75de4e84687ae6065fb0a4d81917543e
  * @see https://stackoverflow.com/questions/48097791/how-to-keep-a-draggable-element-from-being-moved-outside-a-boundary
  * @example
  *   // CSS :
  *       // #element { position: absolute; }
  *   // HTML :
  *       // <div id="container">
  *       //   <div id="element">
  *       //     <div id="header"/>
  *       //      <div/> ...
  *       //     </div>
  *       //   </div>
  *       // </div>
  *   // JS :
  *       var element = document.getElementById("element");
  *       Draggable.dragElement(element, header, container);
  */
  dragElement: function(element, header, container) {
    let dragStartMouseX = 0, dragStartMouseY = 0, diffX = 0, diffY = 0, positionX = 0, positionY = 0;
    if (header) {
      header.addEventListener("mousedown", dragMouseDown, true);
    } else {
      element.addEventListener("mousedown", dragMouseDown, true);
    }
    var rect;
    var viewport = {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0
    };
    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      dragStartMouseX = e.clientX;
      dragStartMouseY = e.clientY;
      rect = element.getBoundingClientRect();
      const viewPortRect = container.getBoundingClientRect();
      viewport = {
        bottom: viewPortRect.bottom,
        left: viewPortRect.left,
        right: viewPortRect.right,
        top: viewPortRect.top
      };
      document.addEventListener("mouseup", closeDragElement, true);
      document.addEventListener("mousemove", elementDrag, true);
    }
    function closeDragElement() {
      positionX -= diffX;
      positionY -= diffY;
      document.removeEventListener("mouseup", closeDragElement, true);
      document.removeEventListener("mousemove", elementDrag, true);
    }
    function elementDrag(e) {
      e = e || window.event;
      let currentMouseX = e.clientX;
      let currentMouseY = e.clientY;
      let oldDiffX = diffX;
      let oldDiffY = diffY;
      diffX = dragStartMouseX - currentMouseX;
      diffY = dragStartMouseY - currentMouseY;
      var newLeft = rect.left - diffX;
      var newTop = rect.top - diffY;
      if (newLeft < viewport.left || newTop < viewport.top || newLeft + rect.width > viewport.right || newTop + rect.height > viewport.bottom) {
        diffX = oldDiffX;
        diffY = oldDiffY;
      } else {
        let newX = positionX - diffX;
        let newY = positionY - diffY;
        element.style.transform = "translate(" + newX + "px," + newY + "px)";
      }
    }
  }
};
var Draggable_default = Draggable;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/AsyncData.js
var AsyncData = class {
  constructor(initialData) {
    this.data = initialData;
    this.subscribers = [];
  }
  // Subscribe to changes in the data
  subscribe(callback) {
    if (typeof callback !== "function") {
      throw new Error("Callback must be a function");
    }
    this.subscribers.push(callback);
  }
  // Update the data and wait for all updates to complete
  async set(key, value2) {
    this.data[key] = value2;
    const updates = this.subscribers.map(async (callback) => {
      await callback(key, value2);
    });
    await Promise.allSettled(updates);
  }
  get(key) {
    return this.data[key];
  }
};

// node_modules/geopf-extensions-openlayers/src/packages/Controls/GetFeatureInfo/GetFeatureInfoDOM.js
var GetFeatureInfoDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
  * String to html
  * @param {String} str -string to convert
  * @returns {HTMLElement} return dom element
  */
  stringToHTML: function(str) {
    var support = function() {
      if (!window.DOMParser) {
        return false;
      }
      var parser2 = new DOMParser();
      try {
        parser2.parseFromString("x", "text/html");
      } catch (err) {
        return false;
      }
      return true;
    };
    if (support()) {
      var parser = new DOMParser();
      var doc = parser.parseFromString(str, "text/html");
      return doc.body;
    }
    var dom = document.createElement("div");
    dom.innerHTML = str;
    return dom;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPgetFeatureInfo");
    container.className = "GPgetFeatureInfo gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show GetFeatureInfo
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowGetFeatureInfoPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPgetFeatureInfoPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPgetFeatureInfoPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-getfeatureinfo");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Activer/dÃ©sactiver l'interrogation des couches");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowGetFeatureInfoClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowGetFeatureInfoClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createGetFeatureInfoPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPgetFeatureInfoPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createGetFeatureInfoPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelBody fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createGetFeatureInfoPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header_gfi";
    return container;
  },
  _createGetFeatureInfoPanelIconElement: function() {
    var label = document.createElement("label");
    label.className = "GPpanelIcon gpf-btn-header_gfi gpf-btn-icon-header_gfi";
    label.title = "Get Feature Info";
    return label;
  },
  _createGetFeatureInfoPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title_gfi fr-modal__title";
    div.innerHTML = "Infos sur les couches";
    return div;
  },
  _createGetFeatureInfoPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.className = "GPpanelClose GPcloseGetFeatureInfo gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline";
    btnClose.title = "Fermer le panneau";
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function(e) {
        btnClose.setAttribute("aria-pressed", false);
        self2.onCloseGetFeatureInfoClick();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function(e) {
        btnClose.setAttribute("aria-pressed", false);
        self2.onCloseGetFeatureInfoClick();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    return btnClose;
  },
  /**
   * Create loader
   * @returns {HTMLElement} DOM element
   */
  _createGetFeatureInfoWaitingDiv: function() {
    var waitingDivString = `
        <div class="waiting-div-container"><div class="lds-ring"><div></div><div></div><div></div><div></div></div><div>
        `;
    return waitingDivString;
  },
  /**
   * String to html
   * @param {String} noDataMessage - string Ã  afficher en message de noData du GFI
   * @returns {DOMElement} DOM element
   */
  _createGetFeatureInfoNoData: function(noDataMessage) {
    var div = document.createElement("div");
    div.className = "GPgetFeatureInfoNoData fr-py-2w fr-px-2w";
    console.log(this.stringToHTML(noDataMessage));
    div.insertAdjacentHTML("beforeend", noDataMessage);
    return div;
  },
  // ################################################################### //
  // ####################### Methods for Layer GFI ####################### //
  // ################################################################### //
  /**
   * Create group d'accodeon
   * @returns {HTMLElement} DOM element
   */
  _createGetFeatureInfoAccordionGroup: function() {
    var self2 = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPgetFeatureInfoAccordionGroup");
    div.className = "GPgetFeatureInfoAccordionGroup fr-accordions-group";
    return div;
  },
  /**
   * Create accordeon
   * see evenement !
   * @param { String } layername nom du layer
   * @param { String } content contenu du gfi
   * @returns {HTMLElement} DOM element
   */
  _createGetFeatureInfoLayerAccordion: function(layername) {
    var dsfrTemplate = this.stringToHTML(`
            <section class="fr-accordion">
                <h3 class="fr-accordion__title">
                    <button class="GPgfiLayerButton fr-accordion__btn" aria-expanded="false" aria-controls="accordion-${layername}">
                        <span class="GPshowGfiLayerFeature"></span>
                        <span id="gfiLayerName">${layername}</span>
                    </button>
                </h3>
                <div class="fr-collapse GPgetFeatureInfoAccordionContent GPelementHidden" id="accordion-${layername}" style="margin:unset;">
                    ${this._createGetFeatureInfoWaitingDiv()}
                </div>
            </section>
        `);
    var accordeon = dsfrTemplate.firstChild;
    var button = accordeon.querySelector("button, button.fr-accordion__btn");
    button.addEventListener("click", (e) => {
      e.currentTarget.ariaExpanded = !(e.currentTarget.ariaExpanded === "true");
      var collapse = document.getElementById(e.currentTarget.getAttribute("aria-controls"));
      if (e.currentTarget.ariaExpanded === "true") {
        collapse.classList.add("fr-collapse--expanded");
        collapse.classList.remove("GPelementHidden");
        requestAnimationFrame(() => {
          button.scrollIntoView({
            behavior: "smooth",
            block: "start",
            inline: "nearest"
          });
        });
      } else {
        collapse.classList.remove("fr-collapse--expanded");
        collapse.classList.add("GPelementHidden");
      }
    });
    return accordeon;
  }
};
var GetFeatureInfoDOM_default = GetFeatureInfoDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/GetFeatureInfo/GetFeatureInfo.js
var logger11 = LoggerByDefault_default2.getLogger("getFeatureInfo");
var GetFeatureInfo = class _GetFeatureInfo extends Control_default2 {
  /**
   * @constructor
  * @param {Object} options - options for function call.
  * @example
  * var getFeatureInfo = new ol.control.GetFeatureInfo();
  * map.addControl(getFeatureInfo);
  */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _GetFeatureInfo)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "GetFeatureInfo";
    this.initialize(options);
    this.container = this.initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */
  setMap(map) {
    if (map) {
      if (this.draggable) {
        Draggable_default.dragElement(
          this.panelGetFeatureInfoContainer,
          this.panelGetFeatureInfoHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this.buttonGetFeatureInfoShow.setAttribute("aria-pressed", true);
      }
      if (this.auto) {
        this.addEventsListeners(map);
      }
    } else {
      if (this.auto) {
        this.removeEventsListeners();
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.element.classList.add("gpf-button-no-gutter");
    }
  }
  // ################################################################### //
  // ################### getters / setters ############################# //
  // ################################################################### //
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize GetFeatureInfo control (called by GetFeatureInfo constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this.uid = options.id || SelectorID_default.generate();
    this.options = {
      collapsed: true,
      draggable: false,
      auto: true
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this.noDataMessage = this.options.noDataMessage;
    this.auto = this.options.auto;
    this.buttonGetFeatureInfoShow = null;
    this.panelGetFeatureInfoContainer = null;
    this.getFeatureInfoPanelDiv = null;
    this.panelGetFeatureInfoHeaderContainer = null;
    this.buttonGetFeatureInfoClose = null;
    this.getFeatureInfoAccordionGroup = null;
    this.panelGetFeatureInfoEntriesContainer = null;
    this.noDataMessageDiv = null;
    this.eventsListeners = [];
    this.pixel = [];
    this.coordinates = [];
    this.layers = [];
    this.res = null;
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  initContainer() {
    var container = this._createMainContainerElement();
    var picto = this.buttonGetFeatureInfoShow = this._createShowGetFeatureInfoPictoElement();
    container.appendChild(picto);
    var getFeatureInfoPanel = this.panelGetFeatureInfoContainer = this._createGetFeatureInfoPanelElement();
    var getFeatureInfoPanelDiv = this.getFeatureInfoPanelDiv = this._createGetFeatureInfoPanelDivElement();
    getFeatureInfoPanel.appendChild(getFeatureInfoPanelDiv);
    var getFeatureInfoPanelHeader = this.panelGetFeatureInfoHeaderContainer = this._createGetFeatureInfoPanelHeaderElement();
    var getFeatureInfoPanelIcon = this._createGetFeatureInfoPanelIconElement();
    getFeatureInfoPanelHeader.appendChild(getFeatureInfoPanelIcon);
    var getFeatureInfoPanelTitle = this._createGetFeatureInfoPanelTitleElement();
    getFeatureInfoPanelHeader.appendChild(getFeatureInfoPanelTitle);
    var getFeatureInfoCloseBtn = this.buttonGetFeatureInfoClose = this._createGetFeatureInfoPanelCloseElement();
    getFeatureInfoPanelHeader.appendChild(getFeatureInfoCloseBtn);
    getFeatureInfoPanelDiv.appendChild(getFeatureInfoPanelHeader);
    var accordionGroup = this.getFeatureInfoAccordionGroup = this._createGetFeatureInfoAccordionGroup();
    getFeatureInfoPanelDiv.appendChild(accordionGroup);
    if (this.noDataMessage) {
      this.noDataMessageDiv = this._createGetFeatureInfoNoData(this.noDataMessage);
    }
    container.appendChild(getFeatureInfoPanel);
    logger11.log(container);
    return container;
  }
  /**
   * Add events listeners on map (called by setMap)
   *
   * @param {Map} map - map
   * @private
   */
  addEventsListeners(map) {
    var self2 = this;
    this.eventsListeners["singleclick"] = function(e) {
      logger11.trace(e);
      self2.onMapClick(e);
    };
    map.on("singleclick", this.eventsListeners["singleclick"]);
  }
  /**
   * Remove events listeners on map (called by setMap)
   * @private
   */
  removeEventsListeners() {
    var map = this.getMap();
    map.getLayers().un("singleclick", this.eventsListeners["singleclick"]);
    delete this.eventsListeners["singleclick"];
  }
  /**
   * Tells if control is active or not
   * @private
   * @returns { Boolean } true if active false if not
   */
  getFeatureInfoIsActive() {
    return this.buttonGetFeatureInfoShow.getAttribute("aria-pressed");
  }
  /**
   * event handler
   * @param {Event} e Ã©vÃ¨nement de click
   * @private
   */
  onMapClick(e) {
    if (this.getFeatureInfoIsActive() === "true") {
      this.getFeatureInfoAccordionGroup.remove();
      if (this.noDataMessage) {
        this.noDataMessageDiv.remove();
      }
      this.buttonGetFeatureInfoClose.setAttribute("aria-pressed", true);
      this.layers = e.map.getLayers().getArray().filter((l3) => {
        if (l3.isVisible(e.map.getView()) && l3.getOpacity() > 0) {
          return l3;
        }
      }).sort((a2, b3) => b3.getZIndex() - a2.getZIndex());
      if (this.layers.length > 0) {
        var accordionGroup = this.getFeatureInfoAccordionGroup = this._createGetFeatureInfoAccordionGroup();
        this.getFeatureInfoPanelDiv.appendChild(accordionGroup);
        this.map = e.map;
        this.pixel = e.pixel;
        this.coordinates = e.coordinate;
        this.res = e.map.getView().getResolution();
        this.displayGetFeatureInfo();
      } else {
        if (this.noDataMessage) {
          this.getFeatureInfoPanelDiv.append(this.noDataMessageDiv);
        }
        return;
      }
    }
  }
  /**
   * Main render function
   * @param { Layer } layer layer openlayer
   * @returns { Object } gfiLayer
   * {
   *      format : "wmts",
   *      layer: layer,
   *      url :  url          pour wmts et wms
   * }
   */
  getGetFeatureInfoLayer(layer) {
    var gfiLayer = {};
    let format = this.getLayerFormat(layer);
    gfiLayer = {
      format,
      layer
    };
    if (format === "wmts") {
      let url = layer.getSource().getFeatureInfoUrl(
        this.coordinates,
        this.res,
        this.map.getView().getProjection(),
        {
          INFOFORMAT: "text/html",
          STYLES: ""
        }
      );
      gfiLayer = {
        ...gfiLayer,
        ...{
          url
        }
      };
    }
    if (format === "wms") {
      let url = layer.getSource().getFeatureInfoUrl(
        this.coordinates,
        this.res,
        this.map.getView().getProjection(),
        {
          INFO_FORMAT: "text/html",
          STYLES: ""
        }
      );
      gfiLayer = {
        ...gfiLayer,
        ...{
          url
        }
      };
    }
    return gfiLayer;
  }
  /**
   * Main render function
   * @param { Layer } layer layer openlayer
   * @returns { Array } Array of ol features
   */
  getFeaturesAtClick(layer) {
    var features = [];
    this.getMap().forEachFeatureAtPixel(this.pixel, function(feature, olLayer) {
      if (layer == olLayer) {
        features.push(feature);
      }
    });
    return features;
  }
  /**
   * Main render function
   * @param { Layer } gfiLayer layer openlayer
   * @returns { Object } gfi result
   * {
   *      layername : "layername",
   *      content: "html"
   * }
   */
  async getGetFeatureInfoContent(gfiLayer) {
    var content = null;
    if (gfiLayer.format === "vector") {
      var features = this.getFeaturesAtClick(gfiLayer.layer);
      if (features) {
        content = this.features2html(features);
      }
      return content;
    } else {
      return fetch(gfiLayer.url).then((res) => res.text()).then((text) => {
        var exception = false;
        if (text.trim().length === 0 || text.indexOf("ServiceExceptionReport") !== -1 || text.indexOf("java.lang.NullPointerException") !== -1 || text.indexOf("java.lang.OutOfMemoryError") !== -1 || text.indexOf("not queryable") !== -1 || text.indexOf("No data") !== -1 || text.indexOf("non interrogeable") !== -1) {
          exception = true;
        }
        if (!exception) {
          var dom = this.stringToHTML(text);
          if (dom && dom.innerHTML && dom.innerHTML.trim().length > 0) {
            return text;
          } else {
            return null;
          }
        } else {
          return null;
        }
      }).catch((error) => {
        logger11.log(error);
        return error;
      });
    }
  }
  /**
   * Get layer title
   *
   * @param {Layer} gfiLayer - the layer object used by the gfi widget
   * @returns {String} layerTitle - layer title
   */
  getLayerTitle(gfiLayer) {
    if (gfiLayer.layer.getProperties !== void 0 && gfiLayer.layer.getSource !== void 0) {
      var layerProperties = gfiLayer.layer.getProperties();
      var src = layerProperties.source;
      var layerTitle = "";
      if (src) {
        layerTitle = src._title || src.name || layerProperties.title || layerProperties.name || src.url_ || "Couche de donnÃ©es";
      }
    }
    return layerTitle;
  }
  /**
   * Main render function
   * @private
   */
  displayGetFeatureInfo() {
    var gfiLayers = this.layers.map((l3) => {
      return this.getGetFeatureInfoLayer(l3);
    });
    var gfiContent = gfiLayers.map((gfiLayer) => {
      var layername = this.getLayerTitle(gfiLayer);
      var content = null;
      var accordeon = this._createGetFeatureInfoLayerAccordion(layername);
      accordeon.style.display = "none";
      var pending = true;
      return new AsyncData({
        ...gfiLayer,
        ...{
          layername,
          content,
          contentDiv: accordeon,
          pending
        }
      });
    });
    for (let i = 0; i < gfiContent.length; i++) {
      this.getFeatureInfoAccordionGroup.append(gfiContent[i].data.contentDiv);
    }
    gfiContent.forEach((data) => {
      data.subscribe((key, value2) => {
        if (key == "content") {
          data.set("pending", false);
          if (data.get("content")) {
            data.get("contentDiv").querySelector("div.fr-collapse").innerHTML = data.get("content");
            this.buttonGetFeatureInfoClose.setAttribute("aria-pressed", true);
            data.get("contentDiv").style.display = "block";
          } else {
            data.get("contentDiv").remove();
          }
          if (gfiContent.filter((gfi) => gfi.get("pending") === true).length == 0 && gfiContent.filter((gfi) => gfi.get("content")).length == 0) {
            if (this.noDataMessage) {
              this.getFeatureInfoPanelDiv.append(this.noDataMessageDiv);
            } else {
              this.buttonGetFeatureInfoClose.setAttribute("aria-pressed", false);
            }
          }
        }
      });
    });
    gfiContent.forEach((asyncD) => {
      this.getGetFeatureInfoContent(asyncD.data).then((res) => {
        asyncD.set("content", res);
      });
    });
  }
  /**
   * Return layer format
   *
   * @param {ol.layer.Layer} l - layer openlayers
   * @returns {String} format - layer format can be wms, wmts, vector or unknown
   *
   */
  getLayerFormat(l3) {
    var type = typeof l3.getType === "function" ? l3.getType() : null;
    var source = l3.getSource();
    if (type) {
      if (type === "VECTOR" || type === "VECTOR_TILE") {
        return "vector";
      }
      if (type === "TILE") {
        if (source.tileGrid) {
          return "wmts";
        } else {
          return "wms";
        }
      }
      if (type === "IMAGE") {
        return "wms";
      }
    } else {
      if (source instanceof TileWMS_default || source instanceof ImageWMS_default) {
        return "wms";
      }
      if (source instanceof WMTS_default2) {
        return "wmts";
      }
      if (source instanceof Vector_default || source instanceof VectorTile_default) {
        return "vector";
      }
    }
    return "unknown";
  }
  /**
   * Gets HTML content from features array
   *
   * @param {Features[]} features - openlayers features Array
   * @returns {HTMLElement} HTML content.
   */
  features2html(features) {
    var content = document.createElement("div");
    features.forEach(function(f) {
      var props = f.getProperties();
      if (props.hasOwnProperty("render")) {
        content.insertAdjacentHTML("beforeend", props["render"]);
      } else {
        if (props.hasOwnProperty("name")) {
          var nameDiv = document.createElement("div");
          nameDiv.className = "gp-att-name-div";
          nameDiv.insertAdjacentHTML("afterbegin", props["name"]);
          content.appendChild(nameDiv);
        }
        if (props.hasOwnProperty("description")) {
          var descDiv = document.createElement("div");
          descDiv.className = "gp-att-description-div";
          descDiv.insertAdjacentHTML("afterbegin", props["description"]);
          content.appendChild(descDiv);
        }
        var p2 = null;
        var others = false;
        var oDiv = null;
        var ul = null;
        var li = null;
        var listForbidden = [
          // styles
          "fill",
          "fill-opacity",
          "label-fill",
          "label-fill-opacity",
          "label-stroke",
          "label-stroke-opacity",
          "label-stroke-width",
          "label-font",
          "label-textAlign",
          "stroke",
          "stroke-opacity",
          "stroke-width",
          "marker-symbol",
          "marker-color",
          "marker-size",
          "geometry",
          // geometrie
          "value",
          "name",
          // dÃ©jÃ  traitÃ©
          "description",
          // dÃ©jÃ  traitÃ©
          "styleUrl",
          "extensionsNode_",
          // extensions GPX
          "icon"
          // ajoutÃ© par la 3D en cas de switch
        ];
        for (p2 in props) {
          if (props[p2] === void 0) {
            continue;
          }
          if (listForbidden.indexOf(p2) !== -1) {
            continue;
          }
          if (!others) {
            oDiv = document.createElement("div");
            oDiv.className = "gp-att-others-div";
            ul = document.createElement("ul");
            others = true;
          }
          li = document.createElement("li");
          var span = document.createElement("span");
          span.className = "gp-attname-others-span";
          span.appendChild(document.createTextNode(p2 + " : "));
          li.appendChild(span);
          li.appendChild(document.createTextNode(props[p2]));
          ul.appendChild(li);
        }
        if (ul) {
          oDiv.appendChild(ul);
          content.appendChild(oDiv);
        }
      }
    });
    if (!content.hasChildNodes()) {
      content = "";
    } else {
      content = content.innerHTML;
    }
    return content;
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onShowGetFeatureInfoClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    if (e.target.ariaPressed === "false") {
      this.buttonGetFeatureInfoClose.setAttribute("aria-pressed", false);
    }
    logger11.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onCloseGetFeatureInfoClick(e) {
    logger11.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onGetFeatureInfoComputationSubmit(e) {
    logger11.trace(e);
  }
};
Object.assign(GetFeatureInfo.prototype, GetFeatureInfoDOM_default);
Object.assign(GetFeatureInfo.prototype, Widget_default);
var GetFeatureInfo_default = GetFeatureInfo;
if (window.ol && window.ol.control) {
  window.ol.control.GetFeatureInfo = GetFeatureInfo;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/SearchEngine/SearchEngine.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/SearchEngine/GPFsearchEngine.css";

// node_modules/geopf-extensions-openlayers/src/packages/Utils/MathUtils.js
var MathUtils = {
  /**
   * Reste de la division euclidienne
   * 
   * @function modulo
   * @param {Number} a - divisor
   * @param {Number} b - quotient
   * @returns {Number} Modulo
   */
  modulo: function(a2, b3) {
    var r2 = a2 % b3;
    return r2 * b3 < 0 ? r2 + b3 : r2;
  },
  /**
   * Transform degrees, minutes, seconds form decimal degrees -
   * Largely inspired by the private function degreesToStringHDMS from ol/coordinate.js
   *
   * @function decimalToDMS
   * @param {Number} degrees - decimal degrees
   * @param {Array} hemispheres - "NS" ou "EO"
   * @param {Number} numDigits - number of digits for seconds
   * @returns {Object} DMS coordinate
   */
  decimalToDMS: function(degrees, hemispheres, numDigits) {
    var normalizedDegrees = this.modulo(degrees + 180, 360) - 180;
    var x3 = Math.abs(3600 * normalizedDegrees);
    var dflPrecision = numDigits || 0;
    var precision = Math.pow(10, dflPrecision);
    var deg = Math.floor(x3 / 3600);
    var min = Math.floor((x3 - deg * 3600) / 60);
    var sec = x3 - deg * 3600 - min * 60;
    sec = Math.ceil(sec * precision) / precision;
    if (sec >= 60) {
      sec = 0;
      min += 1;
    }
    if (min >= 60) {
      min = 0;
      deg += 1;
    }
    var direction = hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    return {
      d: deg,
      m: min,
      s: sec,
      direction
    };
  },
  /**
   * Transform decimal degrees form degrees, minutes, seconds
   * 
   * @function dmsToDecimal
   * @param {*} degrees - degrees
   * @param {*} minutes - minutes
   * @param {*} seconds - seconds
   * @param {*} hemispheres - "NS" ou "EO"
   * @returns {Number} decimal coordinate
   */
  dmsToDecimal(degrees, minutes, seconds, hemispheres) {
    var dd = degrees + minutes / 60 + seconds / (60 * 60);
    if (hemispheres == "S" || hemispheres == "O") {
      dd = dd * -1;
    }
    return dd;
  },
  /**
   * ol coordinate to decimal
   * 
   * @function coordinateToDecimal
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {lat, lng, unit:Â°}
   */
  coordinateToDecimal(olCoordinate) {
    var coordinate = {};
    coordinate.lat = olCoordinate[1].toFixed(6);
    coordinate.lng = olCoordinate[0].toFixed(6);
    coordinate.unit = "Â°";
    return coordinate;
  },
  /**
   * ol coordinate to dms
   * 
   * @function coordinateToDMS
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {lat, lng, unit:dms}
   */
  coordinateToDMS(olCoordinate) {
    return {
      lng: MathUtils.decimalToDMS(olCoordinate[0], "EO", 2),
      lat: MathUtils.decimalToDMS(olCoordinate[1], "NS", 2),
      unit: "DMS"
    };
  },
  /**
   * ol coordinate to rad
   * 
   * @function coordinateToRad
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {lat, lng, unit:rad}
   */
  coordinateToRad(olCoordinate) {
    var coordinate = {};
    var d4 = 0.017453292519943295;
    coordinate.lng = olCoordinate[0] * d4;
    coordinate.lng = coordinate.lng.toFixed(8);
    coordinate.lat = olCoordinate[1] * d4;
    coordinate.lat = coordinate.lat.toFixed(8);
    coordinate.unit = "rad";
    return coordinate;
  },
  /**
   * ol coordinate to gon
   * 
   * @function coordinateToGon
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {lat, lng, unit:gon}
   */
  coordinateToGon(olCoordinate) {
    var coordinate = {};
    var d4 = 1.1111111111111112;
    coordinate.lng = olCoordinate[0] * d4;
    coordinate.lng = coordinate.lng.toFixed(8);
    coordinate.lat = olCoordinate[1] * d4;
    coordinate.lat = coordinate.lat.toFixed(8);
    coordinate.unit = "gon";
    return coordinate;
  },
  /**
   * ol coordinate to meter
   * 
   * @function coordinateToMeter
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {x, y, unit:m}
   */
  coordinateToMeter(olCoordinate) {
    var coordinate = {};
    coordinate.x = olCoordinate[0].toFixed(2);
    coordinate.y = olCoordinate[1].toFixed(2);
    coordinate.unit = "m";
    return coordinate;
  },
  /**
   * ol coordinate to kilometer
   * 
   * @function coordinateToKMeter
   * @param {*} olCoordinate - see ol/coordinate.js
   * @returns {Object} - {x, lyng, unit:km}
   */
  coordinateToKMeter(olCoordinate) {
    var coordinate = {};
    coordinate.x = (olCoordinate[0] / 1e3).toFixed(2);
    coordinate.y = (olCoordinate[1] / 1e3).toFixed(2);
    coordinate.unit = "km";
    return coordinate;
  },
  /**
   * Converts string to Integer
   *
   * @function toInteger
   * @param {String} s - string number
   * @param {Numeric} base - between 2 and 36
   * @returns {null|Numeric} result
   */
  toInteger: function(s, base) {
    var _base = base || 10;
    var n = parseInt(s, _base);
    if (!isNaN(n) && isFinite(n)) {
      return n;
    }
    return null;
  },
  /**
   * check if s represents an integer
   *
   * @function isInteger
   * @param {String} s - string number
   * @returns {Boolean} is integer
   */
  isInteger: function(s) {
    if (isNaN(s)) {
      return false;
    }
    var v2 = parseFloat(s);
    return (v2 | 0) === v2;
  },
  /**
   * Converts s to float
   *
   * @function toFloat
   * @param {String} s - string number
   * @returns {null|Numeric} result
   */
  toFloat: function(s) {
    var n = parseFloat(s);
    if (!isNaN(n) && isFinite(n)) {
      return n;
    }
    return null;
  },
  /**
   * convert seconds to time : HH:MM:SS
   *
   * @param {Number} duration - duration in seconds
   *
   * @returns {String} time in hours/minutes/seconds
   */
  convertSecondsToTime: function(duration) {
    var time = "";
    duration = Math.round(duration);
    var hours = Math.floor(duration / (60 * 60));
    var divisor4minutes = duration % (60 * 60);
    var minutes = Math.floor(divisor4minutes / 60);
    if (hours) {
      time = hours + "h ";
    }
    time += minutes + " min";
    return time;
  },
  /**
   * convert distance in meters or kilometers
   *
   * @param {Number} distance - distance in meters
   *
   * @returns {String} distance in km
   */
  convertDistance: function(distance) {
    var d4 = "";
    var distanceKm = parseInt(distance / 1e3, 10);
    if (!distanceKm) {
      d4 = parseInt(distance, 10) + " m";
    } else {
      d4 = distanceKm + " km";
    }
    return d4;
  }
};
var MathUtils_default = MathUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/SearchEngineUtils.js
var SearchEngineUtils = {
  /**
   * Advanced Search Filters by default
   * @function advancedSearchFiltersByDefault
   */
  advancedSearchFiltersByDefault: {
    PositionOfInterest: [
      {
        name: "q",
        title: "Chercher un lieu"
      },
      {
        name: "category",
        title: "Type",
        value: [
          "cimetiÃ¨re",
          "aÃ©rodrome",
          "rÃ©servoir",
          "administratif",
          "construction linÃ©aire",
          "construction ponctuelle",
          "construction surfacique",
          "cours d'eau",
          "dÃ©tail hydrographique",
          "dÃ©tail orographique",
          "Ã©quipement de transport",
          "plan d'eau",
          "poste de transformation",
          "terrain de sport",
          "transport par cÃ¢ble",
          "zone d'activitÃ© ou d'intÃ©rÃªt",
          "zone d'habitation",
          "lieu-dit non habitÃ©"
        ]
      },
      {
        name: "postcode",
        title: "Code postal"
      },
      {
        name: "citycode",
        title: "Code INSEE"
      }
    ],
    StreetAddress: [
      {
        name: "address",
        title: "Adresse"
      },
      {
        name: "city",
        title: "Ville"
      },
      {
        name: "postcode",
        title: "Code postal"
      }
    ],
    CadastralParcel: [
      {
        name: "departmentcode",
        title: "Code dÃ©partement (INSEE)",
        description: "Code INSEE du dÃ©partement (ex: 01, 94)"
      },
      {
        name: "municipalitycode",
        title: "Code commune (INSEE)",
        description: "Code INSEE de la commune : 3 chiffres (ex: 067)"
      },
      {
        name: "oldmunicipalitycode",
        title: "Commune absorbÃ©e",
        description: "Commune absorbÃ©e : 3 chiffres (ex: 000, 001)"
      },
      {
        name: "districtcode",
        title: "Arrondissement",
        description: "Arrondissement : 3 chiffres (ex: 004, 012)"
      },
      {
        name: "section",
        title: "Section",
        description: "Section Cadastrale : 2 caractÃ¨res (chiffre et/ou lettre)"
      },
      {
        name: "number",
        title: "NumÃ©ro",
        description: "NumÃ©ro de la parcelle : 4 chiffres (ex: 0041, 0250)"
      },
      {
        name: "sheet",
        title: "Feuille",
        description: "NumÃ©ro de la feuille cadastrale"
      }
    ]
  },
  /**
   * Provides default zoom based on results.
   *
   * @function zoomToResultsByDefault
   * @param {Object} info - location information
   * @returns {Integer} zoom level
   */
  zoomToResultsByDefault: function(info) {
    var zoom = 15;
    var service = info.service;
    var fields = info.fields;
    var type = info.type;
    var importance = {
      1: 11,
      2: 12,
      3: 13,
      4: 14,
      5: 15,
      6: 16,
      7: 17,
      8: 17
    };
    if (service === "SuggestedLocation") {
      if (type === "PositionOfInterest") {
        zoom = importance[fields.classification];
      }
    }
    if (service === "GeocodedLocation") {
      if (type === "PositionOfInterest") {
        zoom = importance[fields.importance] || 14;
      }
    }
    if (type === "StreetAddress") {
      zoom = 17;
    }
    if (type === "CadastralParcel") {
      zoom = 17;
    }
    return zoom;
  }
};
var SearchEngineUtils_default = SearchEngineUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Utils/GeocodeUtils.js
var GeocodeUtils = {
  /**
   * Return the freeform of a structured geocoded item
   *
   * @param {Object} geocodedLocation - Geocoded location
   * @returns {String} freeform string
   */
  getGeocodedLocationFreeform: function(geocodedLocation) {
    var attributes = geocodedLocation.placeAttributes;
    if (attributes.label) {
      return attributes.label;
    } else if (geocodedLocation.type === "PositionOfInterest") {
      var resultToReturn = attributes.toponym;
      if (attributes.category && Array.isArray(attributes.category) && attributes.category.length >= 2 && attributes.category[0] === "administratif") {
        resultToReturn = resultToReturn + ", " + attributes.category[1];
      } else {
        if (attributes.postcode) {
          resultToReturn = resultToReturn + ", " + attributes.postcode[0];
          if (attributes.city) {
            resultToReturn = resultToReturn + " " + attributes.city[0];
          }
        }
      }
      return resultToReturn;
    } else if (geocodedLocation.type === "StreetAddress") {
      return (attributes.housenumber ? attributes.housenumber + " " : "") + attributes.street + " " + (attributes.postcode ? attributes.postcode + ", " : "") + attributes.city;
    } else if (geocodedLocation.type === "CadastralParcel") {
      return attributes.id;
    } else {
      return "...";
    }
  },
  /**
   * Return the freeform of a structured suggested item
   *
   * @param {Object} suggestedLocation - Suggested location
   * @returns {String} freeform string
   */
  getSuggestedLocationFreeform: function(suggestedLocation) {
    if (suggestedLocation.fullText) {
      return suggestedLocation.fullText;
    } else {
      var values = [];
      values.push(suggestedLocation.street || "");
      values.push(suggestedLocation.postalCode || "");
      values.push(suggestedLocation.commune || "");
      if (suggestedLocation.type === "PositionOfInterest") {
        values.push(suggestedLocation.poi || "");
        values.push(suggestedLocation.kind || "");
      }
      return values.join(" - ");
    }
  }
};
var GeocodeUtils_default = GeocodeUtils;

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i = 1; i <= 60; ++i) {
    defs2("EPSG:" + (32600 + i), "+proj=utm +zone=" + i + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i), "+proj=utm +zone=" + i + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;

// node_modules/proj4/lib/constants/PrimeMeridian.js
var exports2 = {};
exports2.greenwich = 0;
exports2.lisbon = -9.131906111111;
exports2.paris = 2.337229166667;
exports2.bogota = -74.080916666667;
exports2.madrid = -3.687938888889;
exports2.rome = 12.452333333333;
exports2.bern = 7.439583333333;
exports2.jakarta = 106.807719444444;
exports2.ferro = -17.666666666667;
exports2.brussels = 4.367975;
exports2.stockholm = 18.058277777778;
exports2.athens = 23.7163375;
exports2.oslo = 10.722916666667;

// node_modules/proj4/lib/constants/units.js
var units_default = {
  "mm": { to_meter: 1e-3 },
  "cm": { to_meter: 0.01 },
  "ft": { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  "fath": { to_meter: 1.8288 },
  "kmi": { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  "km": { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  "mi": { to_meter: 1609.344 },
  "yd": { to_meter: 0.9144 },
  "ch": { to_meter: 20.1168 },
  "link": { to_meter: 0.201168 },
  "dm": { to_meter: 0.01 },
  "in": { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};

// node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v2) {
    return v2.trim();
  }).filter(function(a2) {
    return a2;
  }).reduce(function(p2, a2) {
    var split = a2.split("=");
    split.push(true);
    p2[split[0].toLowerCase()] = split[1];
    return p2;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v2) {
      self2.rf = parseFloat(v2);
    },
    lat_0: function(v2) {
      self2.lat0 = v2 * D2R;
    },
    lat_1: function(v2) {
      self2.lat1 = v2 * D2R;
    },
    lat_2: function(v2) {
      self2.lat2 = v2 * D2R;
    },
    lat_ts: function(v2) {
      self2.lat_ts = v2 * D2R;
    },
    lon_0: function(v2) {
      self2.long0 = v2 * D2R;
    },
    lon_1: function(v2) {
      self2.long1 = v2 * D2R;
    },
    lon_2: function(v2) {
      self2.long2 = v2 * D2R;
    },
    alpha: function(v2) {
      self2.alpha = parseFloat(v2) * D2R;
    },
    gamma: function(v2) {
      self2.rectified_grid_angle = parseFloat(v2);
    },
    lonc: function(v2) {
      self2.longc = v2 * D2R;
    },
    x_0: function(v2) {
      self2.x0 = parseFloat(v2);
    },
    y_0: function(v2) {
      self2.y0 = parseFloat(v2);
    },
    k_0: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    k: function(v2) {
      self2.k0 = parseFloat(v2);
    },
    a: function(v2) {
      self2.a = parseFloat(v2);
    },
    b: function(v2) {
      self2.b = parseFloat(v2);
    },
    r: function(v2) {
      self2.a = self2.b = parseFloat(v2);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v2) {
      self2.zone = parseInt(v2, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v2) {
      self2.datum_params = v2.split(",").map(function(a2) {
        return parseFloat(a2);
      });
    },
    to_meter: function(v2) {
      self2.to_meter = parseFloat(v2);
    },
    units: function(v2) {
      self2.units = v2;
      var unit = match(units_default, v2);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v2) {
      self2.from_greenwich = v2 * D2R;
    },
    pm: function(v2) {
      var pm = match(exports2, v2);
      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R;
    },
    nadgrids: function(v2) {
      if (v2 === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v2;
      }
    },
    axis: function(v2) {
      var legalAxis = "ewnsud";
      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {
        self2.axis = v2;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}

// node_modules/wkt-parser/PROJJSONBuilderBase.js
var PROJJSONBuilderBase = class {
  static getId(node) {
    const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
    if (idNode && idNode.length >= 3) {
      return {
        authority: idNode[1],
        code: parseInt(idNode[2], 10)
      };
    }
    return null;
  }
  static convertUnit(node, type = "unit") {
    if (!node || node.length < 3) {
      return { type, name: "unknown", conversion_factor: null };
    }
    const name = node[1];
    const conversionFactor = parseFloat(node[2]) || null;
    const idNode = node.find((child) => Array.isArray(child) && child[0] === "ID");
    const id = idNode ? {
      authority: idNode[1],
      code: parseInt(idNode[2], 10)
    } : null;
    return {
      type,
      name,
      conversion_factor: conversionFactor,
      id
    };
  }
  static convertAxis(node) {
    const name = node[1] || "Unknown";
    let direction;
    const abbreviationMatch = name.match(/^\((.)\)$/);
    if (abbreviationMatch) {
      const abbreviation = abbreviationMatch[1].toUpperCase();
      if (abbreviation === "E") direction = "east";
      else if (abbreviation === "N") direction = "north";
      else if (abbreviation === "U") direction = "up";
      else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);
    } else {
      direction = node[2] ? node[2].toLowerCase() : "unknown";
    }
    const orderNode = node.find((child) => Array.isArray(child) && child[0] === "ORDER");
    const order = orderNode ? parseInt(orderNode[1], 10) : null;
    const unitNode = node.find(
      (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
    );
    const unit = this.convertUnit(unitNode);
    return {
      name,
      direction,
      // Use the valid PROJJSON direction value
      unit,
      order
    };
  }
  static extractAxes(node) {
    return node.filter((child) => Array.isArray(child) && child[0] === "AXIS").map((axis) => this.convertAxis(axis)).sort((a2, b3) => (a2.order || 0) - (b3.order || 0));
  }
  static convert(node, result = {}) {
    switch (node[0]) {
      case "PROJCRS":
        result.type = "ProjectedCRS";
        result.name = node[1];
        result.base_crs = node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "BASEGEOGCRS")) : null;
        result.conversion = node.find((child) => Array.isArray(child) && child[0] === "CONVERSION") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "CONVERSION")) : null;
        const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
        if (csNode) {
          result.coordinate_system = {
            type: csNode[1],
            axis: this.extractAxes(node)
          };
        }
        const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT");
        if (lengthUnitNode) {
          const unit2 = this.convertUnit(lengthUnitNode);
          result.coordinate_system.unit = unit2;
        }
        result.id = this.getId(node);
        break;
      case "BASEGEOGCRS":
      case "GEOGCRS":
        result.type = "GeographicCRS";
        result.name = node[1];
        const datumOrEnsembleNode = node.find(
          (child) => Array.isArray(child) && (child[0] === "DATUM" || child[0] === "ENSEMBLE")
        );
        if (datumOrEnsembleNode) {
          const datumOrEnsemble = this.convert(datumOrEnsembleNode);
          if (datumOrEnsembleNode[0] === "ENSEMBLE") {
            result.datum_ensemble = datumOrEnsemble;
          } else {
            result.datum = datumOrEnsemble;
          }
          const primem = node.find((child) => Array.isArray(child) && child[0] === "PRIMEM");
          if (primem && primem[1] !== "Greenwich") {
            datumOrEnsemble.prime_meridian = {
              name: primem[1],
              longitude: parseFloat(primem[2])
            };
          }
        }
        result.coordinate_system = {
          type: "ellipsoidal",
          axis: this.extractAxes(node)
        };
        result.id = this.getId(node);
        break;
      case "DATUM":
        result.type = "GeodeticReferenceFrame";
        result.name = node[1];
        result.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID")) : null;
        break;
      case "ENSEMBLE":
        result.type = "DatumEnsemble";
        result.name = node[1];
        result.members = node.filter((child) => Array.isArray(child) && child[0] === "MEMBER").map((member) => ({
          type: "DatumEnsembleMember",
          name: member[1],
          id: this.getId(member)
          // Extract ID as { authority, code }
        }));
        const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === "ENSEMBLEACCURACY");
        if (accuracyNode) {
          result.accuracy = parseFloat(accuracyNode[1]);
        }
        const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === "ELLIPSOID");
        if (ellipsoidNode) {
          result.ellipsoid = this.convert(ellipsoidNode);
        }
        result.id = this.getId(node);
        break;
      case "ELLIPSOID":
        result.type = "Ellipsoid";
        result.name = node[1];
        result.semi_major_axis = parseFloat(node[2]);
        result.inverse_flattening = parseFloat(node[3]);
        const units = node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "LENGTHUNIT"), result) : null;
        break;
      case "CONVERSION":
        result.type = "Conversion";
        result.name = node[1];
        result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
        result.parameters = node.filter((child) => Array.isArray(child) && child[0] === "PARAMETER").map((param) => this.convert(param));
        break;
      case "METHOD":
        result.type = "Method";
        result.name = node[1];
        result.id = this.getId(node);
        break;
      case "PARAMETER":
        result.type = "Parameter";
        result.name = node[1];
        result.value = parseFloat(node[2]);
        result.unit = this.convertUnit(
          node.find(
            (child) => Array.isArray(child) && (child[0] === "LENGTHUNIT" || child[0] === "ANGLEUNIT" || child[0] === "SCALEUNIT")
          )
        );
        result.id = this.getId(node);
        break;
      case "BOUNDCRS":
        result.type = "BoundCRS";
        const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === "SOURCECRS");
        if (sourceCrsNode) {
          const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));
          result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
        }
        const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === "TARGETCRS");
        if (targetCrsNode) {
          const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));
          result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
        }
        const transformationNode = node.find((child) => Array.isArray(child) && child[0] === "ABRIDGEDTRANSFORMATION");
        if (transformationNode) {
          result.transformation = this.convert(transformationNode);
        } else {
          result.transformation = null;
        }
        break;
      case "ABRIDGEDTRANSFORMATION":
        result.type = "Transformation";
        result.name = node[1];
        result.method = node.find((child) => Array.isArray(child) && child[0] === "METHOD") ? this.convert(node.find((child) => Array.isArray(child) && child[0] === "METHOD")) : null;
        result.parameters = node.filter((child) => Array.isArray(child) && (child[0] === "PARAMETER" || child[0] === "PARAMETERFILE")).map((param) => {
          if (param[0] === "PARAMETER") {
            return this.convert(param);
          } else if (param[0] === "PARAMETERFILE") {
            return {
              name: param[1],
              value: param[2],
              id: {
                "authority": "EPSG",
                "code": 8656
              }
            };
          }
        });
        if (result.parameters.length === 7) {
          const scaleDifference = result.parameters[6];
          if (scaleDifference.name === "Scale difference") {
            scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
          }
        }
        result.id = this.getId(node);
        break;
      case "AXIS":
        if (!result.coordinate_system) {
          result.coordinate_system = { type: "unspecified", axis: [] };
        }
        result.coordinate_system.axis.push(this.convertAxis(node));
        break;
      case "LENGTHUNIT":
        const unit = this.convertUnit(node, "LinearUnit");
        if (result.coordinate_system && result.coordinate_system.axis) {
          result.coordinate_system.axis.forEach((axis) => {
            if (!axis.unit) {
              axis.unit = unit;
            }
          });
        }
        if (unit.conversion_factor && unit.conversion_factor !== 1) {
          if (result.semi_major_axis) {
            result.semi_major_axis = {
              value: result.semi_major_axis,
              unit
            };
          }
        }
        break;
      default:
        result.keyword = node[0];
        break;
    }
    return result;
  }
};
var PROJJSONBuilderBase_default = PROJJSONBuilderBase;

// node_modules/wkt-parser/PROJJSONBuilder2015.js
var PROJJSONBuilder2015 = class extends PROJJSONBuilderBase_default {
  static convert(node, result = {}) {
    super.convert(node, result);
    if (result.coordinate_system && result.coordinate_system.subtype === "Cartesian") {
      delete result.coordinate_system;
    }
    if (result.usage) {
      delete result.usage;
    }
    return result;
  }
};
var PROJJSONBuilder2015_default = PROJJSONBuilder2015;

// node_modules/wkt-parser/PROJJSONBuilder2019.js
var PROJJSONBuilder2019 = class extends PROJJSONBuilderBase_default {
  static convert(node, result = {}) {
    super.convert(node, result);
    const csNode = node.find((child) => Array.isArray(child) && child[0] === "CS");
    if (csNode) {
      result.coordinate_system = {
        subtype: csNode[1],
        axis: this.extractAxes(node)
      };
    }
    const usageNode = node.find((child) => Array.isArray(child) && child[0] === "USAGE");
    if (usageNode) {
      const scope = usageNode.find((child) => Array.isArray(child) && child[0] === "SCOPE");
      const area = usageNode.find((child) => Array.isArray(child) && child[0] === "AREA");
      const bbox = usageNode.find((child) => Array.isArray(child) && child[0] === "BBOX");
      result.usage = {};
      if (scope) {
        result.usage.scope = scope[1];
      }
      if (area) {
        result.usage.area = area[1];
      }
      if (bbox) {
        result.usage.bbox = bbox.slice(1);
      }
    }
    return result;
  }
};
var PROJJSONBuilder2019_default = PROJJSONBuilder2019;

// node_modules/wkt-parser/buildPROJJSON.js
function detectWKT2Version(root) {
  if (root.find((child) => Array.isArray(child) && child[0] === "USAGE")) {
    return "2019";
  }
  if (root.find((child) => Array.isArray(child) && child[0] === "CS")) {
    return "2015";
  }
  if (root[0] === "BOUNDCRS" || root[0] === "PROJCRS" || root[0] === "GEOGCRS") {
    return "2015";
  }
  return "2015";
}
function buildPROJJSON(root) {
  const version3 = detectWKT2Version(root);
  const builder = version3 === "2019" ? PROJJSONBuilder2019_default : PROJJSONBuilder2015_default;
  return builder.convert(root);
}

// node_modules/wkt-parser/detectWKTVersion.js
function detectWKTVersion(wkt) {
  const normalizedWKT = wkt.toUpperCase();
  if (normalizedWKT.includes("PROJCRS") || normalizedWKT.includes("GEOGCRS") || normalizedWKT.includes("BOUNDCRS") || normalizedWKT.includes("VERTCRS") || normalizedWKT.includes("LENGTHUNIT") || normalizedWKT.includes("ANGLEUNIT") || normalizedWKT.includes("SCALEUNIT")) {
    return "WKT2";
  }
  if (normalizedWKT.includes("PROJCS") || normalizedWKT.includes("GEOGCS") || normalizedWKT.includes("LOCAL_CS") || normalizedWKT.includes("VERT_CS") || normalizedWKT.includes("UNIT")) {
    return "WKT1";
  }
  return "WKT1";
}

// node_modules/wkt-parser/parser.js
var parser_default = parseString;
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser2(text) {
  if (typeof text !== "string") {
    throw new Error("not a string");
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser2.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser2.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser2.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser2.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser2.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser2.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser2.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser2.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser2(txt);
  return parser.output();
}

// node_modules/wkt-parser/process.js
function mapit(obj, key, value2) {
  if (Array.isArray(key)) {
    value2.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value2.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v2, obj) {
  if (!Array.isArray(v2)) {
    obj[v2] = true;
    return;
  }
  var key = v2.shift();
  if (key === "PARAMETER") {
    key = v2.shift();
  }
  if (v2.length === 1) {
    if (Array.isArray(v2[0])) {
      obj[key] = {};
      sExpr(v2[0], obj[key]);
      return;
    }
    obj[key] = v2[0];
    return;
  }
  if (!v2.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v2;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v2);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v2[0].toLowerCase(),
        convert: v2[1]
      };
      if (v2.length === 3) {
        sExpr(v2[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v2[0],
        a: v2[1],
        rf: v2[2]
      };
      if (v2.length === 4) {
        sExpr(v2[3], obj[key]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v2[0] = ["name", v2[0]];
      mapit(obj, key, v2);
      obj[key].type = key;
      return;
    default:
      i = -1;
      while (++i < v2.length) {
        if (!Array.isArray(v2[i])) {
          return sExpr(v2, obj[key]);
        }
      }
      return mapit(obj, key, v2);
  }
}

// node_modules/wkt-parser/util.js
var D2R2 = 0.017453292519943295;
function d2r(input) {
  return input * D2R2;
}
function applyProjectionDefaults(wkt) {
  const normalizedProjName = (wkt.projName || "").toLowerCase().replace(/_/g, " ");
  if (!wkt.long0 && wkt.longc && (normalizedProjName === "albers conic equal area" || normalizedProjName === "lambert azimuthal equal area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === "stereographic south pole" || normalizedProjName === "polar stereographic (variant b)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === "polar stereographic" || normalizedProjName === "polar stereographic (variant a)")) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}

// node_modules/wkt-parser/transformPROJJSON.js
function processUnit(unit) {
  let result = { units: null, to_meter: void 0 };
  if (typeof unit === "string") {
    result.units = unit.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    if (result.units === "meter") {
      result.to_meter = 1;
    }
  } else if (unit && unit.name) {
    result.units = unit.name.toLowerCase();
    if (result.units === "metre") {
      result.units = "meter";
    }
    result.to_meter = unit.conversion_factor;
  }
  return result;
}
function toValue(valueOrObject) {
  if (typeof valueOrObject === "object") {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value2, result) {
  if (value2.ellipsoid.radius) {
    result.a = value2.ellipsoid.radius;
    result.rf = 0;
  } else {
    result.a = toValue(value2.ellipsoid.semi_major_axis);
    if (value2.ellipsoid.inverse_flattening !== void 0) {
      result.rf = value2.ellipsoid.inverse_flattening;
    } else if (value2.ellipsoid.semi_major_axis !== void 0 && value2.ellipsoid.semi_minor_axis !== void 0) {
      result.rf = result.a / (result.a - toValue(value2.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson, result = {}) {
  if (!projjson || typeof projjson !== "object") {
    return projjson;
  }
  if (projjson.type === "BoundCRS") {
    transformPROJJSON(projjson.source_crs, result);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === "NTv2") {
        result.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        result.datum_params = projjson.transformation.parameters.map((param) => param.value);
      }
    }
    return result;
  }
  Object.keys(projjson).forEach((key) => {
    const value2 = projjson[key];
    if (value2 === null) {
      return;
    }
    switch (key) {
      case "name":
        if (result.srsCode) {
          break;
        }
        result.name = value2;
        result.srsCode = value2;
        break;
      case "type":
        if (value2 === "GeographicCRS") {
          result.projName = "longlat";
        } else if (value2 === "ProjectedCRS" && projjson.conversion && projjson.conversion.method) {
          result.projName = projjson.conversion.method.name;
        }
        break;
      case "datum":
      case "datum_ensemble":
        if (value2.ellipsoid) {
          result.ellps = value2.ellipsoid.name;
          calculateEllipsoid(value2, result);
        }
        if (value2.prime_meridian) {
          result.from_greenwich = value2.prime_meridian.longitude * Math.PI / 180;
        }
        break;
      case "ellipsoid":
        result.ellps = value2.name;
        calculateEllipsoid(value2, result);
        break;
      case "prime_meridian":
        result.long0 = (value2.longitude || 0) * Math.PI / 180;
        break;
      case "coordinate_system":
        if (value2.axis) {
          result.axis = value2.axis.map((axis) => {
            const direction = axis.direction;
            if (direction === "east") return "e";
            if (direction === "north") return "n";
            if (direction === "west") return "w";
            if (direction === "south") return "s";
            throw new Error(`Unknown axis direction: ${direction}`);
          }).join("") + "u";
          if (value2.unit) {
            const { units, to_meter } = processUnit(value2.unit);
            result.units = units;
            result.to_meter = to_meter;
          } else if (value2.axis[0] && value2.axis[0].unit) {
            const { units, to_meter } = processUnit(value2.axis[0].unit);
            result.units = units;
            result.to_meter = to_meter;
          }
        }
        break;
      case "id":
        if (value2.authority && value2.code) {
          result.title = value2.authority + ":" + value2.code;
        }
        break;
      case "conversion":
        if (value2.method && value2.method.name) {
          result.projName = value2.method.name;
        }
        if (value2.parameters) {
          value2.parameters.forEach((param) => {
            const paramName = param.name.toLowerCase().replace(/\s+/g, "_");
            const paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result[paramName] = paramValue * param.unit.conversion_factor;
            } else if (param.unit === "degree") {
              result[paramName] = paramValue * Math.PI / 180;
            } else {
              result[paramName] = paramValue;
            }
          });
        }
        break;
      case "unit":
        if (value2.name) {
          result.units = value2.name.toLowerCase();
          if (result.units === "metre") {
            result.units = "meter";
          }
        }
        if (value2.conversion_factor) {
          result.to_meter = value2.conversion_factor;
        }
        break;
      case "base_crs":
        transformPROJJSON(value2, result);
        result.datumCode = value2.id ? value2.id.authority + "_" + value2.id.code : value2.name;
        break;
      default:
        break;
    }
  });
  if (result.latitude_of_false_origin !== void 0) {
    result.lat0 = result.latitude_of_false_origin;
  }
  if (result.longitude_of_false_origin !== void 0) {
    result.long0 = result.longitude_of_false_origin;
  }
  if (result.latitude_of_standard_parallel !== void 0) {
    result.lat0 = result.latitude_of_standard_parallel;
    result.lat1 = result.latitude_of_standard_parallel;
  }
  if (result.latitude_of_1st_standard_parallel !== void 0) {
    result.lat1 = result.latitude_of_1st_standard_parallel;
  }
  if (result.latitude_of_2nd_standard_parallel !== void 0) {
    result.lat2 = result.latitude_of_2nd_standard_parallel;
  }
  if (result.latitude_of_projection_centre !== void 0) {
    result.lat0 = result.latitude_of_projection_centre;
  }
  if (result.longitude_of_projection_centre !== void 0) {
    result.longc = result.longitude_of_projection_centre;
  }
  if (result.easting_at_false_origin !== void 0) {
    result.x0 = result.easting_at_false_origin;
  }
  if (result.northing_at_false_origin !== void 0) {
    result.y0 = result.northing_at_false_origin;
  }
  if (result.latitude_of_natural_origin !== void 0) {
    result.lat0 = result.latitude_of_natural_origin;
  }
  if (result.longitude_of_natural_origin !== void 0) {
    result.long0 = result.longitude_of_natural_origin;
  }
  if (result.longitude_of_origin !== void 0) {
    result.long0 = result.longitude_of_origin;
  }
  if (result.false_easting !== void 0) {
    result.x0 = result.false_easting;
  }
  if (result.easting_at_projection_centre) {
    result.x0 = result.easting_at_projection_centre;
  }
  if (result.false_northing !== void 0) {
    result.y0 = result.false_northing;
  }
  if (result.northing_at_projection_centre) {
    result.y0 = result.northing_at_projection_centre;
  }
  if (result.standard_parallel_1 !== void 0) {
    result.lat1 = result.standard_parallel_1;
  }
  if (result.standard_parallel_2 !== void 0) {
    result.lat2 = result.standard_parallel_2;
  }
  if (result.scale_factor_at_natural_origin !== void 0) {
    result.k0 = result.scale_factor_at_natural_origin;
  }
  if (result.scale_factor_at_projection_centre !== void 0) {
    result.k0 = result.scale_factor_at_projection_centre;
  }
  if (result.scale_factor_on_pseudo_standard_parallel !== void 0) {
    result.k0 = result.scale_factor_on_pseudo_standard_parallel;
  }
  if (result.azimuth !== void 0) {
    result.alpha = result.azimuth;
  }
  if (result.azimuth_at_projection_centre !== void 0) {
    result.alpha = result.azimuth_at_projection_centre;
  }
  if (result.angle_from_rectified_to_skew_grid) {
    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
  }
  applyProjectionDefaults(result);
  return result;
}

// node_modules/wkt-parser/index.js
var knownTypes = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys = Object.keys(wkt);
  for (var i = 0, ii = keys.length; i < ii; ++i) {
    var key = keys[i];
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (typeof wkt[key] === "object") {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a2) {
    return rename(wkt, a2);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
function wkt_parser_default(wkt) {
  if (typeof wkt === "object") {
    return transformPROJJSON(wkt);
  }
  const version3 = detectWKTVersion(wkt);
  var lisp = parser_default(wkt);
  if (version3 === "WKT2") {
    const projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projString_default(arguments[1]);
      } else {
        defs[name] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v2) {
        if (Array.isArray(v2)) {
          defs.apply(that, v2);
        } else {
          defs(v2);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
global_default(defs);
var defs_default = defs;

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse2(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else {
    return code;
  }
}
var parseCode_default = parse2;

// node_modules/proj4/lib/extend.js
function extend_default(destination, source) {
  destination = destination || {};
  var value2, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value2 = source[property];
    if (value2 !== void 0) {
      destination[property] = value2;
    }
  }
  return destination;
}

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}

// node_modules/proj4/lib/common/sign.js
function sign_default(x3) {
  return x3 < 0 ? -1 : 1;
}

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x3) {
  return Math.abs(x3) <= SPI ? x3 : x3 - sign_default(x3) * TWO_PI;
}

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}

// node_modules/proj4/lib/projections/merc.js
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p2) {
  var lon = p2.x;
  var lat = p2.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x3, y3;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x3 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y3 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x3 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y3 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p2.x = x3;
    p2.y = y3;
    return p2;
  }
}
function inverse(p2) {
  var x3 = p2.x - this.x0;
  var y3 = p2.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y3 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y3 / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x3 / (this.a * this.k0));
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
var merc_default = {
  init,
  forward,
  inverse,
  names
};

// node_modules/proj4/lib/projections/longlat.js
function init2() {
}
function identity(pt) {
  return pt;
}
var names2 = ["longlat", "identity"];
var longlat_default = {
  init: init2,
  forward: identity,
  inverse: identity,
  names: names2
};

// node_modules/proj4/lib/projections.js
var projs = [merc_default, longlat_default];
var names3 = {};
var projStore = [];
function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names3[n.toLowerCase()] = len;
  });
  return this;
}
function get3(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names3[n] !== "undefined" && projStore[names3[n]]) {
    return projStore[names3[n]];
  }
}
function start() {
  projs.forEach(add);
}
var projections_default = {
  start,
  add,
  get: get3
};

// node_modules/proj4/lib/constants/Ellipsoid.js
var exports3 = {};
exports3.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports3.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports3.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports3.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports3.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports3.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports3.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports3.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports3.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports3.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports3.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports3.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports3.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports3.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports3.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports3.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
exports3.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports3.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports3.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports3.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports3.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports3.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports3.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports3.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports3.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports3.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports3.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports3.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports3.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports3.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports3.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports3.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports3.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports3.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports3.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports3.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports3.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports3.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports3.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports3.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports3.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports3.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports3.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports3.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a2, b3, rf, R_A) {
  var a22 = a2 * a2;
  var b22 = b3 * b3;
  var es = (a22 - b22) / a22;
  var e = 0;
  if (R_A) {
    a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a22 = a2 * a2;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a22 - b22) / b22;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a2, b3, rf, ellps, sphere2) {
  if (!a2) {
    var ellipse = match(exports3, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a2 = ellipse.a;
    b3 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b3) {
    b3 = (1 - 1 / rf) * a2;
  }
  if (rf === 0 || Math.abs(a2 - b3) < EPSLN) {
    sphere2 = true;
    b3 = a2;
  }
  return {
    a: a2,
    b: b3,
    rf,
    sphere: sphere2
  };
}

// node_modules/proj4/lib/constants/Datum.js
var datums = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  }
};
for (key in datums) {
  datum2 = datums[key];
  datums[datum2.datumName] = datum2;
}
var datum2;
var key;
var Datum_default = datums;

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a2, b3, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a2;
  out.b = b3;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default = datum;

// node_modules/proj4/lib/nadgrid.js
var loadedNadgrids = {};
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value2) {
  if (value2.length === 0) {
    return null;
  }
  var optional = value2[0] === "@";
  if (optional) {
    value2 = value2.slice(1);
  }
  if (value2 === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value2,
    mandatory: !optional,
    grid: loadedNadgrids[value2] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    gridOffset += 176 + subHeader.gridNodeCount * 16;
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r2) {
    return [secondsToRadians(r2.longitudeShift), secondsToRadians(r2.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

// node_modules/proj4/lib/Proj.js
function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parseCode_default(srsCode);
  if (typeof json !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(Datum_default, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum_default(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection.projections = projections_default;
Projection.projections.start();
var Proj_default = Projection;

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p2, es, a2) {
  var Longitude = p2.x;
  var Latitude = p2.y;
  var Height = p2.z ? p2.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p2.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p2.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p2, es, a2, b3) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P3;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X2 = p2.x;
  var Y = p2.y;
  var Z2 = p2.z ? p2.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P3 = Math.sqrt(X2 * X2 + Y * Y);
  RR = Math.sqrt(X2 * X2 + Y * Y + Z2 * Z2);
  if (P3 / a2 < genau) {
    Longitude = 0;
    if (RR / a2 < genau) {
      Latitude = HALF_PI;
      Height = -b3;
      return {
        x: p2.x,
        y: p2.y,
        z: p2.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X2);
  }
  CT = Z2 / RR;
  ST = P3 / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P3 * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x + datum_params[0],
      y: p2.y + datum_params[1],
      z: p2.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p2.x - Rz_BF * p2.y + Ry_BF * p2.z) + Dx_BF,
      y: M_BF * (Rz_BF * p2.x + p2.y - Rx_BF * p2.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p2.x + Rx_BF * p2.y + p2.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x - datum_params[0],
      y: p2.y - datum_params[1],
      z: p2.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p2.x - Dx_BF) / M_BF;
    var y_tmp = (p2.y - Dy_BF) / M_BF;
    var z_tmp = (p2.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse33, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  outer:
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      onlyMandatoryGrids = grid.mandatory;
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j2 = 0, jj = subgrids.length; j2 < jj; j2++) {
        var subgrid = subgrids[j2];
        var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon;
        var minY = subgrid.ll[1] - epsilon;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
        if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
          continue;
        }
        output = applySubgridShift(input, inverse33, subgrid);
        if (!isNaN(output.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse33, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse33) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v2, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === void 0) {
      continue;
    }
    if (i === 0) {
      v2 = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i === 1) {
      v2 = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v2 = zin;
      t = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t] = v2;
        break;
      case "w":
        out[t] = -v2;
        break;
      case "n":
        out[t] = v2;
        break;
      case "s":
        out[t] = -v2;
        break;
      case "u":
        if (point[t] !== void 0) {
          out.z = v2;
        }
        break;
      case "d":
        if (point[t] !== void 0) {
          out.z = -v2;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}

// node_modules/proj4/lib/transform.js
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = toPoint_default(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity_default(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Proj_default("WGS84");
    point = transform2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis_default(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform_default(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}

// node_modules/proj4/lib/core.js
var wgs84 = Proj_default("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.slice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform2(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Proj_default(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var core_default = proj4;

// node_modules/mgrs/mgrs.js
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A = 65;
var I = 73;
var O = 79;
var V = 86;
var Z = 90;
var mgrs_default = {
  forward: forward2,
  inverse: inverse2,
  toPoint
};
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse2(mgrs) {
  var bbox = UTMtoLL(decode2(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode2(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N3, T2, C3, A5, M4;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N3 = a2 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T2 = Math.tan(LatRad) * Math.tan(LatRad);
  C3 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A5 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M4 = a2 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N3 * (A5 + (1 - T2 + C3) * A5 * A5 * A5 / 6 + (5 - 18 * T2 + T2 * T2 + 72 * C3 - 58 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 / 120) + 5e5;
  var UTMNorthing = k0 * (M4 + N3 * Math.tan(LatRad) * (A5 * A5 / 2 + (5 - T2 + 9 * C3 + 4 * C3 * C3) * A5 * A5 * A5 * A5 / 24 + (61 - 58 * T2 + T2 * T2 + 600 * C3 - 330 * eccPrimeSquared) * A5 * A5 * A5 * A5 * A5 * A5 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a2 = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D2, M4;
  var LongOrigin;
  var mu, phi1Rad;
  var x3 = UTMEasting - 5e5;
  var y3 = UTMNorthing;
  if (zoneLetter < "N") {
    y3 -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M4 = y3 / k0;
  mu = M4 / (a2 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a2 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a2 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D2 = x3 / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D2 * D2 * D2 * D2 * D2 * D2 / 720);
  lat = radToDeg(lat);
  var lon = (D2 - (1 + 2 * T1 + C12) * D2 * D2 * D2 / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index2 = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index2);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index2);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode2(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e, set) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n, set) {
  if (n > "V") {
    throw "MGRSPoint given invalid Northing " + n;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}

// node_modules/proj4/lib/Point.js
function Point(x3, y3, z3) {
  if (!(this instanceof Point)) {
    return new Point(x3, y3, z3);
  }
  if (Array.isArray(x3)) {
    this.x = x3[0];
    this.y = x3[1];
    this.z = x3[2] || 0;
  } else if (typeof x3 === "object") {
    this.x = x3.x;
    this.y = x3.y;
    this.z = x3.z || 0;
  } else if (typeof x3 === "string" && typeof y3 === "undefined") {
    var coords = x3.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x3;
    this.y = y3;
    this.z = z3 || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point.fromMGRS = function(mgrsStr) {
  return new Point(toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return forward2([this.x, this.y], accuracy);
};
var Point_default2 = Point;

// node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn_default(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}

// node_modules/proj4/lib/common/pj_inv_mlfn.js
var MAX_ITER = 20;
function pj_inv_mlfn_default(arg, es, en) {
  var k3 = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) {
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    t = (pj_mlfn_default(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k3;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  return phi;
}

// node_modules/proj4/lib/projections/tmerc.js
function init3() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x3, y3;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b3 = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b3) - 1) < EPSLN) {
      return 93;
    } else {
      x3 = 0.5 * this.a * this.k0 * Math.log((1 + b3) / (1 - b3)) + this.x0;
      y3 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b3, 2));
      b3 = Math.abs(y3);
      if (b3 >= 1) {
        if (b3 - 1 > EPSLN) {
          return 93;
        } else {
          y3 = 0;
        }
      } else {
        y3 = Math.acos(y3);
      }
      if (lat < 0) {
        y3 = -y3;
      }
      y3 = this.a * this.k0 * (y3 - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x3 = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y3 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse3(p2) {
  var con, phi;
  var lat, lon;
  var x3 = (p2.x - this.x0) * (1 / this.a);
  var y3 = (p2.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x3 / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y3 / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y3 < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g, h) + this.long0);
    }
  } else {
    con = this.ml0 + y3 / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d4 = x3 * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d4, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon_default(this.long0 + d4 * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y3);
      lon = 0;
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
var tmerc_default = {
  init: init3,
  forward: forward3,
  inverse: inverse3,
  names: names4
};

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x3) {
  var r2 = Math.exp(x3);
  r2 = (r2 - 1 / r2) / 2;
  return r2;
}

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x3, y3) {
  x3 = Math.abs(x3);
  y3 = Math.abs(y3);
  var a2 = Math.max(x3, y3);
  var b3 = Math.min(x3, y3) / (a2 ? a2 : 1);
  return a2 * Math.sqrt(1 + Math.pow(b3, 2));
}

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x3) {
  var y3 = 1 + x3;
  var z3 = y3 - 1;
  return z3 === 0 ? x3 : x3 * Math.log(y3) / z3;
}

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x3) {
  var y3 = Math.abs(x3);
  y3 = log1py_default(y3 * (1 + y3 / (hypot_default(1, y3) + 1)));
  return x3 < 0 ? -y3 : y3;
}

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B2) {
  var cos_2B = 2 * Math.cos(2 * B2);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B2 + h * Math.sin(2 * B2);
}

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r2 = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r2 * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x3) {
  var r2 = Math.exp(x3);
  r2 = (r2 + 1 / r2) / 2;
  return r2;
}

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r2 = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j2 = pp.length - 1;
  var hr = pp[j2];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j2 >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r2 * hr1 - i * hi1 + pp[j2];
    hi = -hi2 + i * hr1 + r2 * hi1;
  }
  r2 = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r2 * hr - i * hi, r2 * hi + i * hr];
}

// node_modules/proj4/lib/projections/etmerc.js
function init4() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens_default(this.gtu, 2 * Z2));
}
function forward4(p2) {
  var Ce2 = adjust_lon_default(p2.x - this.long0);
  var Cn = p2.y;
  Cn = gatg_default(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce2);
  var cos_Ce = Math.cos(Ce2);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce2 = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce2 = asinhy_default(Math.tan(Ce2));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn, 2 * Ce2);
  Cn = Cn + tmp[0];
  Ce2 = Ce2 + tmp[1];
  var x3;
  var y3;
  if (Math.abs(Ce2) <= 2.623395162778) {
    x3 = this.a * (this.Qn * Ce2) + this.x0;
    y3 = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x3 = Infinity;
    y3 = Infinity;
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse4(p2) {
  var Ce2 = (p2.x - this.x0) * (1 / this.a);
  var Cn = (p2.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce2 = Ce2 / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce2) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn, 2 * Ce2);
    Cn = Cn + tmp[0];
    Ce2 = Ce2 + tmp[1];
    Ce2 = Math.atan(sinh_default(Ce2));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce2);
    var cos_Ce = Math.cos(Ce2);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce2 = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce2 + this.long0);
    lat = gatg_default(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
var etmerc_default = {
  init: init4,
  forward: forward4,
  inverse: inverse4,
  names: names5
};

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}

// node_modules/proj4/lib/projections/utm.js
var dependsOn = "etmerc";
function init5() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var names6 = ["Universal Transverse Mercator System", "utm"];
var utm_default = {
  init: init5,
  names: names6,
  dependsOn
};

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}

// node_modules/proj4/lib/projections/gauss.js
var MAX_ITER2 = 20;
function init6() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p2) {
  var lon = p2.x;
  var lat = p2.y;
  p2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p2.x = this.C * lon;
  return p2;
}
function inverse5(p2) {
  var DEL_TOL = 1e-14;
  var lon = p2.x / this.C;
  var lat = p2.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p2.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p2.y) < DEL_TOL) {
      break;
    }
    p2.y = lat;
  }
  if (!i) {
    return null;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names7 = ["gauss"];
var gauss_default = {
  init: init6,
  forward: forward5,
  inverse: inverse5,
  names: names7
};

// node_modules/proj4/lib/projections/sterea.js
function init7() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p2) {
  var sinc, cosc, cosl, k3;
  p2.x = adjust_lon_default(p2.x - this.long0);
  gauss_default.forward.apply(this, [p2]);
  sinc = Math.sin(p2.y);
  cosc = Math.cos(p2.y);
  cosl = Math.cos(p2.x);
  k3 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p2.x = k3 * cosc * Math.sin(p2.x);
  p2.y = k3 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p2.x = this.a * p2.x + this.x0;
  p2.y = this.a * p2.y + this.y0;
  return p2;
}
function inverse6(p2) {
  var sinc, cosc, lon, lat, rho;
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  p2.x /= this.k0;
  p2.y /= this.k0;
  if (rho = hypot_default(p2.x, p2.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p2.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p2.x * sinc, rho * this.cosc0 * cosc - p2.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p2.x = lon;
  p2.y = lat;
  gauss_default.inverse.apply(this, [p2]);
  p2.x = adjust_lon_default(p2.x + this.long0);
  return p2;
}
var names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
var sterea_default = {
  init: init7,
  forward: forward6,
  inverse: inverse6,
  names: names8
};

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init8() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A5, X2, sinX, cosX, ts, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p2.x = NaN;
    p2.y = NaN;
    return p2;
  }
  if (this.sphere) {
    A5 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p2.x = this.a * A5 * coslat * Math.sin(dlon) + this.x0;
    p2.y = this.a * A5 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p2;
  } else {
    X2 = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X2);
    sinX = Math.sin(X2);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p2.x = this.x0 + rh * Math.sin(lon - this.long0);
      p2.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p2;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A5 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p2.y = A5 * sinX;
    } else {
      A5 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p2.y = A5 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p2.x = A5 * cosX * Math.sin(dlon) + this.x0;
  }
  return p2;
}
function inverse7(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon, lat, ts, ce2, Chi;
  var rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p2.x = lon;
      p2.y = lat;
      return p2;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p2.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, -1 * p2.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, p2.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p2.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p2.y * this.sinlat0 * Math.sin(c)));
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p2.x = lon;
        p2.y = lat;
        return p2;
      }
      p2.x *= this.con;
      p2.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p2.x, -1 * p2.y));
    } else {
      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p2.y * Math.sin(ce2) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p2.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p2.y * this.sinX0 * Math.sin(ce2)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names9 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
var stere_default = {
  init: init8,
  forward: forward7,
  inverse: inverse7,
  names: names9,
  ssfn_
};

// node_modules/proj4/lib/projections/somerc.js
function init9() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k22 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k22 + this.alpha * e / 2 * k3;
}
function forward8(p2) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p2.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p2.y)) / (1 - this.e * Math.sin(p2.y)));
  var S3 = -this.alpha * (Sa1 + Sa2) + this.K;
  var b3 = 2 * (Math.atan(Math.exp(S3)) - Math.PI / 4);
  var I4 = this.alpha * (p2.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I4) / (Math.sin(this.b0) * Math.tan(b3) + Math.cos(this.b0) * Math.cos(I4)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b3) - Math.sin(this.b0) * Math.cos(b3) * Math.cos(I4));
  p2.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p2.x = this.R * rotI + this.x0;
  return p2;
}
function inverse8(p2) {
  var Y = p2.x - this.x0;
  var X2 = p2.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X2 / this.R)) - Math.PI / 4);
  var b3 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I4 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I4 / this.alpha;
  var S3 = 0;
  var phy = b3;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S3 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b3 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S3)) - Math.PI / 2;
  }
  p2.x = lambda;
  p2.y = phy;
  return p2;
}
var names10 = ["somerc"];
var somerc_default = {
  init: init9,
  forward: forward8,
  inverse: inverse8,
  names: names10
};

// node_modules/proj4/lib/projections/omerc.js
var TOL = 1e-7;
function isTypeA(P3) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P3.PROJECTION === "object" ? Object.keys(P3.PROJECTION)[0] : P3.PROJECTION;
  return "no_uoff" in P3 || "no_off" in P3 || typeAProjections.indexOf(projectionName) !== -1;
}
function init10() {
  var con, com, cosph0, D2, F2, H, L3, sinph0, p2, J2, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D2 = this.B * com / (cosph0 * Math.sqrt(con));
    F2 = D2 * D2 - 1;
    if (F2 <= 0) {
      F2 = 0;
    } else {
      F2 = Math.sqrt(F2);
      if (this.lat0 < 0) {
        F2 = -F2;
      }
    }
    this.E = F2 += D2;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D2 = F2 = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D2);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D2 * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F2 - 1 / F2) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L3 = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F2 = this.E / H;
    p2 = (L3 - H) / (L3 + H);
    J2 = this.E * this.E;
    J2 = (J2 - L3 * H) / (J2 + L3 * H);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J2 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p2) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F2 - 1 / F2));
    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F2 = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F2));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F2));
}
function forward9(p2) {
  var coords = {};
  var S3, T2, U2, V3, W2, temp, u, v2;
  p2.x = p2.x - this.lam0;
  if (Math.abs(Math.abs(p2.y) - HALF_PI) > EPSLN) {
    W2 = this.E / Math.pow(tsfnz_default(this.e, p2.y, Math.sin(p2.y)), this.B);
    temp = 1 / W2;
    S3 = 0.5 * (W2 - temp);
    T2 = 0.5 * (W2 + temp);
    V3 = Math.sin(this.B * p2.x);
    U2 = (S3 * this.singam - V3 * this.cosgam) / T2;
    if (Math.abs(Math.abs(U2) - 1) < EPSLN) {
      throw new Error();
    }
    v2 = 0.5 * this.ArB * Math.log((1 - U2) / (1 + U2));
    temp = Math.cos(this.B * p2.x);
    if (Math.abs(temp) < TOL) {
      u = this.A * p2.x;
    } else {
      u = this.ArB * Math.atan2(S3 * this.cosgam + V3 * this.singam, temp);
    }
  } else {
    v2 = p2.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p2.y;
  }
  if (this.no_rot) {
    coords.x = u;
    coords.y = v2;
  } else {
    u -= this.u_0;
    coords.x = v2 * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v2 * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse9(p2) {
  var u, v2, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p2.x = (p2.x - this.x0) * (1 / this.a);
  p2.y = (p2.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v2 = p2.y;
    u = p2.x;
  } else {
    v2 = p2.x * this.cosrot - p2.y * this.sinrot;
    u = p2.y * this.cosrot + p2.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v2);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }
  coords.x += this.lam0;
  return coords;
}
var names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
var omerc_default = {
  init: init10,
  forward: forward9,
  inverse: inverse9,
  names: names11
};

// node_modules/proj4/lib/projections/lcc.js
function init11() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p2) {
  var lon = p2.x;
  var lat = p2.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p2.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p2.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p2;
}
function inverse10(p2) {
  var rh1, con, ts;
  var lat, lon;
  var x3 = (p2.x - this.x0) / this.k0;
  var y3 = this.rh - (p2.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x3 * x3 + y3 * y3);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x3 * x3 + y3 * y3);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x3, con * y3);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names12 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
var lcc_default = {
  init: init11,
  forward: forward10,
  inverse: inverse10,
  names: names12
};

// node_modules/proj4/lib/projections/krovak.js
function init12() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p2) {
  var gfi, u, deltav, s, d4, eps, ro;
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d4 = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d4;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p2.y = ro * Math.cos(eps) / 1;
  p2.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p2.y *= -1;
    p2.x *= -1;
  }
  return p2;
}
function inverse11(p2) {
  var u, deltav, s, d4, eps, ro, fi1;
  var ok;
  var tmp = p2.x;
  p2.x = p2.y;
  p2.y = tmp;
  if (!this.czech) {
    p2.y *= -1;
    p2.x *= -1;
  }
  ro = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  eps = Math.atan2(p2.y, p2.x);
  d4 = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d4));
  deltav = Math.asin(Math.cos(s) * Math.sin(d4) / Math.cos(u));
  p2.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p2.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p2.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p2;
}
var names13 = ["Krovak", "krovak"];
var krovak_default = {
  init: init12,
  forward: forward11,
  inverse: inverse11,
  names: names13
};

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x3) {
  return 1 - 0.25 * x3 * (1 + x3 / 16 * (3 + 1.25 * x3));
}

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x3) {
  return 0.375 * x3 * (1 + 0.25 * x3 * (1 + 0.46875 * x3));
}

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x3) {
  return 0.05859375 * x3 * x3 * (1 + 0.75 * x3);
}

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x3) {
  return x3 * x3 * x3 * (35 / 3072);
}

// node_modules/proj4/lib/common/gN.js
function gN_default(a2, e, sinphi) {
  var temp = e * sinphi;
  return a2 / Math.sqrt(1 - temp * temp);
}

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x3) {
  return Math.abs(x3) < HALF_PI ? x3 : x3 - sign_default(x3) * Math.PI;
}

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}

// node_modules/proj4/lib/projections/cass.js
function init13() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p2) {
  var x3, y3;
  var lam = p2.x;
  var phi = p2.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x3 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y3 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x3 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y3 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p2.x = x3 + this.x0;
  p2.y = y3 + this.y0;
  return p2;
}
function inverse12(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var x3 = p2.x / this.a;
  var y3 = p2.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y3 + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x3));
    lam = Math.atan2(Math.tan(x3), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y3;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p2.x = this.long0;
      p2.y = HALF_PI;
      if (y3 < 0) {
        p2.y *= -1;
      }
      return p2;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x3 * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p2.x = adjust_lon_default(lam + this.long0);
  p2.y = adjust_lat_default(phi);
  return p2;
}
var names14 = ["Cassini", "Cassini_Soldner", "cass"];
var cass_default = {
  init: init13,
  forward: forward12,
  inverse: inverse12,
  names: names14
};

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}

// node_modules/proj4/lib/projections/laea.js
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init14() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p2) {
  var x3, y3, coslam, sinlam, sinphi, q2, sinb, cosb, b3, cosphi;
  var lam = p2.x;
  var phi = p2.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y3 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y3 <= EPSLN) {
        return null;
      }
      y3 = Math.sqrt(2 / y3);
      x3 = y3 * cosphi * Math.sin(lam);
      y3 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y3 = FORTPI - phi * 0.5;
      y3 = 2 * (this.mode === this.S_POLE ? Math.cos(y3) : Math.sin(y3));
      x3 = y3 * Math.sin(lam);
      y3 *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b3 = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q2 = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q2 / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b3 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b3 = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b3 = HALF_PI + phi;
        q2 = this.qp - q2;
        break;
      case this.S_POLE:
        b3 = phi - HALF_PI;
        q2 = this.qp + q2;
        break;
    }
    if (Math.abs(b3) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b3 = Math.sqrt(2 / b3);
        if (this.mode === this.OBLIQ) {
          y3 = this.ymf * b3 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y3 = (b3 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x3 = this.xmf * b3 * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q2 >= 0) {
          x3 = (b3 = Math.sqrt(q2)) * sinlam;
          y3 = coslam * (this.mode === this.S_POLE ? b3 : -b3);
        } else {
          x3 = y3 = 0;
        }
        break;
    }
  }
  p2.x = this.a * x3 + this.x0;
  p2.y = this.a * y3 + this.y0;
  return p2;
}
function inverse13(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var x3 = p2.x / this.a;
  var y3 = p2.y / this.a;
  var lam, phi, cCe, sCe, q2, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x3 * x3 + y3 * y3);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y3 * sinz / rh);
        x3 *= sinz;
        y3 = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y3 * sinz * this.cosph0 / rh);
        x3 *= sinz * this.cosph0;
        y3 = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y3 = -y3;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y3 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x3, y3);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x3 /= this.dd;
      y3 *= this.dd;
      rho = Math.sqrt(x3 * x3 + y3 * y3);
      if (rho < EPSLN) {
        p2.x = this.long0;
        p2.y = this.lat0;
        return p2;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x3 *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y3 * sCe * this.cosb1 / rho;
        q2 = this.qp * ab;
        y3 = rho * this.cosb1 * cCe - y3 * this.sinb1 * sCe;
      } else {
        ab = y3 * sCe / rho;
        q2 = this.qp * ab;
        y3 = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y3 = -y3;
      }
      q2 = x3 * x3 + y3 * y3;
      if (!q2) {
        p2.x = this.long0;
        p2.y = this.lat0;
        return p2;
      }
      ab = 1 - q2 / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x3, y3);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p2.x = adjust_lon_default(this.long0 + lam);
  p2.y = phi;
  return p2;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
var laea_default = {
  init: init14,
  forward: forward13,
  inverse: inverse13,
  names: names15,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x3) {
  if (Math.abs(x3) > 1) {
    x3 = x3 > 1 ? 1 : -1;
  }
  return Math.asin(x3);
}

// node_modules/proj4/lib/projections/aea.js
function init15() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p2) {
  var lon = p2.x;
  var lat = p2.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x3 = rh1 * Math.sin(theta) + this.x0;
  var y3 = this.rh - rh1 * Math.cos(theta) + this.y0;
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse14(p2) {
  var rh1, qs, con, theta, lon, lat;
  p2.x -= this.x0;
  p2.y = this.rh - p2.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p2.x, con * p2.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
var aea_default = {
  init: init15,
  forward: forward14,
  inverse: inverse14,
  names: names16,
  phi1z
};

// node_modules/proj4/lib/projections/gnom.js
function init16() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p2) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x3, y3;
  var lon = p2.x;
  var lat = p2.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x3 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y3 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x3 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y3 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse15(p2) {
  var rh;
  var sinc, cosc;
  var c;
  var lon, lat;
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  p2.x /= this.k0;
  p2.y /= this.k0;
  if (rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz_default(cosc * this.sin_p14 + p2.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p2.x * sinc, rh * this.cos_p14 * cosc - p2.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names17 = ["gnom"];
var gnom_default = {
  init: init16,
  forward: forward15,
  inverse: inverse15,
  names: names17
};

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q2) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q2) - temp) < 1e-6) {
    if (q2 < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q2);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q2 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}

// node_modules/proj4/lib/projections/cea.js
function init17() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var x3, y3;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x3 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y3 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x3 = this.x0 + this.a * this.k0 * dlon;
    y3 = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse16(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p2.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p2.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p2.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p2.x / (this.a * this.k0));
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names18 = ["cea"];
var cea_default = {
  init: init17,
  forward: forward16,
  inverse: inverse16,
  names: names18
};

// node_modules/proj4/lib/projections/eqc.js
function init18() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p2.x = this.x0 + this.a * dlon * this.rc;
  p2.y = this.y0 + this.a * dlat;
  return p2;
}
function inverse17(p2) {
  var x3 = p2.x;
  var y3 = p2.y;
  p2.x = adjust_lon_default(this.long0 + (x3 - this.x0) / (this.a * this.rc));
  p2.y = adjust_lat_default(this.lat0 + (y3 - this.y0) / this.a);
  return p2;
}
var names19 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
var eqc_default = {
  init: init18,
  forward: forward17,
  inverse: inverse17,
  names: names19
};

// node_modules/proj4/lib/projections/poly.js
var MAX_ITER3 = 20;
function init19() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var x3, y3, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x3 = this.a * dlon;
      y3 = -1 * this.a * this.lat0;
    } else {
      x3 = this.a * Math.sin(el) / Math.tan(lat);
      y3 = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x3 = this.a * dlon;
      y3 = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x3 = nl * Math.sin(el);
      y3 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p2.x = x3 + this.x0;
  p2.y = y3 + this.y0;
  return p2;
}
function inverse18(p2) {
  var lon, lat, x3, y3, i;
  var al, bl;
  var phi, dphi;
  x3 = p2.x - this.x0;
  y3 = p2.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y3 + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x3 / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y3 / this.a;
      bl = x3 * x3 / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER3; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x3 * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y3 + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x3 / this.a);
    } else {
      al = (this.ml0 + y3) / this.a;
      bl = x3 * x3 / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER3; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x3 * cl / this.a) / Math.sin(lat));
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names20 = ["Polyconic", "poly"];
var poly_default = {
  init: init19,
  forward: forward18,
  inverse: inverse18,
  names: names20
};

// node_modules/proj4/lib/projections/nzmg.js
function init20() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p2) {
  var n;
  var lon = p2.x;
  var lat = p2.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }
  p2.x = z_im * this.a + this.x0;
  p2.y = z_re * this.a + this.y0;
  return p2;
}
function inverse19(p2) {
  var n;
  var x3 = p2.x;
  var y3 = p2.y;
  var delta_x = x3 - this.x0;
  var delta_y = y3 - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names21 = ["New_Zealand_Map_Grid", "nzmg"];
var nzmg_default = {
  init: init20,
  forward: forward19,
  inverse: inverse19,
  names: names21
};

// node_modules/proj4/lib/projections/mill.js
function init21() {
}
function forward20(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x3 = this.x0 + this.a * dlon;
  var y3 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse20(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p2.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p2.y / this.a)) - Math.PI / 4);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names22 = ["Miller_Cylindrical", "mill"];
var mill_default = {
  init: init21,
  forward: forward20,
  inverse: inverse20,
  names: names22
};

// node_modules/proj4/lib/projections/sinu.js
var MAX_ITER4 = 20;
function init22() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p2) {
  var x3, y3;
  var lon = p2.x;
  var lat = p2.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k3 = this.n * Math.sin(lat);
      for (var i = MAX_ITER4; i; --i) {
        var V3 = (this.m * lat + Math.sin(lat) - k3) / (this.m + Math.cos(lat));
        lat -= V3;
        if (Math.abs(V3) < EPSLN) {
          break;
        }
      }
    }
    x3 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y3 = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y3 = this.a * pj_mlfn_default(lat, s, c, this.en);
    x3 = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse21(p2) {
  var lat, temp, lon, s;
  p2.x -= this.x0;
  lon = p2.x / this.a;
  p2.y -= this.y0;
  lat = p2.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p2.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p2.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names23 = ["Sinusoidal", "sinu"];
var sinu_default = {
  init: init22,
  forward: forward21,
  inverse: inverse21,
  names: names23
};

// node_modules/proj4/lib/projections/moll.js
function init23() {
}
function forward22(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x3 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y3 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse22(p2) {
  var theta;
  var arg;
  p2.x -= this.x0;
  p2.y -= this.y0;
  arg = p2.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p2.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names24 = ["Mollweide", "moll"];
var moll_default = {
  init: init23,
  forward: forward22,
  inverse: inverse22,
  names: names24
};

// node_modules/proj4/lib/projections/eqdc.js
function init24() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x3 = this.x0 + rh1 * Math.sin(theta);
  var y3 = this.y0 + this.rh - rh1 * Math.cos(theta);
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse23(p2) {
  p2.x -= this.x0;
  p2.y = this.rh - p2.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p2.x, con * p2.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
}
var names25 = ["Equidistant_Conic", "eqdc"];
var eqdc_default = {
  init: init24,
  forward: forward23,
  inverse: inverse23,
  names: names25
};

// node_modules/proj4/lib/projections/vandg.js
function init25() {
  this.R = this.a;
}
function forward24(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x3, y3;
  if (Math.abs(lat) <= EPSLN) {
    x3 = this.x0 + this.R * dlon;
    y3 = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x3 = this.x0;
    if (lat >= 0) {
      y3 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y3 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m2 = g * (2 / sinth - 1);
  var msq = m2 * m2;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x3 = this.x0 + con;
  var q2 = asq + g;
  con = Math.PI * this.R * (m2 * q2 - al * Math.sqrt((msq + asq) * (asq + 1) - q2 * q2)) / (msq + asq);
  if (lat >= 0) {
    y3 = this.y0 + con;
  } else {
    y3 = this.y0 - con;
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse24(p2) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d4;
  p2.x -= this.x0;
  p2.y -= this.y0;
  con = Math.PI * this.R;
  xx = p2.x / con;
  yy = p2.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d4 = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d4 / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p2.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names26 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
var vandg_default = {
  init: init25,
  forward: forward24,
  inverse: inverse24,
  names: names26
};

// node_modules/proj4/lib/projections/aeqd.js
function init26() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward25(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var sinphi = Math.sin(p2.y);
  var cosphi = Math.cos(p2.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G2, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p2.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p2.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p2.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p2.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p2;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p2.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p2.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p2;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p2.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p2.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p2.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p2.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p2;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN_default(this.a, this.e, this.sin_p12);
      Nl = gN_default(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G2 * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G2 * G2 * (1 - 7 * Hs)) - s5 / 48 * GH);
      p2.x = this.x0 + c * Math.sin(Az);
      p2.y = this.y0 + c * Math.cos(Az);
      return p2;
    }
  }
}
function inverse25(p2) {
  p2.x -= this.x0;
  p2.y -= this.y0;
  var rh, z3, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M4, N1, psi, Az, cosAz, tmp, A5, B2, D2, Ee2, F2, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z3 = rh / this.a;
    sinz = Math.sin(z3);
    cosz = Math.cos(z3);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p2.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, -p2.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p2.x, p2.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p2.x * sinz, rh * this.cos_p12 * cosz - p2.y * this.sin_p12 * sinz));
      }
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      M4 = Mlp - rh;
      lat = imlfn_default(M4 / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, -1 * p2.y));
      p2.x = lon;
      p2.y = lat;
      return p2;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      M4 = rh - Mlp;
      lat = imlfn_default(M4 / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, p2.y));
      p2.x = lon;
      p2.y = lat;
      return p2;
    } else {
      rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
      Az = Math.atan2(p2.x, p2.y);
      N1 = gN_default(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A5 = -tmp * tmp / (1 - this.es);
      B2 = 3 * this.es * (1 - A5) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D2 = rh / N1;
      Ee2 = D2 - A5 * (1 + A5) * Math.pow(D2, 3) / 6 - B2 * (1 + 3 * A5) * Math.pow(D2, 4) / 24;
      F2 = 1 - A5 * Ee2 * Ee2 / 2 - D2 * Ee2 * Ee2 * Ee2 / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee2) + this.cos_p12 * Math.sin(Ee2) * cosAz);
      lon = adjust_lon_default(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee2) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F2 * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p2.x = lon;
      p2.y = lat;
      return p2;
    }
  }
}
var names27 = ["Azimuthal_Equidistant", "aeqd"];
var aeqd_default = {
  init: init26,
  forward: forward25,
  inverse: inverse25,
  names: names27
};

// node_modules/proj4/lib/projections/ortho.js
function init27() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p2) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x3, y3;
  var lon = p2.x;
  var lat = p2.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x3 = this.a * ksp * cosphi * Math.sin(dlon);
    y3 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p2.x = x3;
  p2.y = y3;
  return p2;
}
function inverse26(p2) {
  var rh;
  var z3;
  var sinz, cosz;
  var con;
  var lon, lat;
  p2.x -= this.x0;
  p2.y -= this.y0;
  rh = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  z3 = asinz_default(rh / this.a);
  sinz = Math.sin(z3);
  cosz = Math.cos(z3);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
  lat = asinz_default(cosz * this.sin_p14 + p2.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p2.x, -p2.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p2.x, p2.y));
    }
    p2.x = lon;
    p2.y = lat;
    return p2;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p2.x * sinz, rh * this.cos_p14 * cosz - p2.y * this.sin_p14 * sinz));
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names28 = ["ortho"];
var ortho_default = {
  init: init27,
  forward: forward26,
  inverse: inverse26,
  names: names28
};

// node_modules/proj4/lib/projections/qsc.js
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init28() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p2) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t, mu;
  var area = { value: 0 };
  p2.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p2.y));
  } else {
    lat = p2.y;
  }
  lon = p2.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q2, r2, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q2 = coslat * coslon;
    r2 = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q2);
      theta = qsc_fwd_equat_face_theta(phi, s, r2, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r2);
      theta = qsc_fwd_equat_face_theta(phi, s, -q2, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q2);
      theta = qsc_fwd_equat_face_theta(phi, s, -r2, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r2);
      theta = qsc_fwd_equat_face_theta(phi, s, q2, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p2.x = xy.x;
  p2.y = xy.y;
  return p2;
}
function inverse27(p2) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = { value: 0 };
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p2.x * p2.x + p2.y * p2.y));
  mu = Math.atan2(p2.y, p2.x);
  if (p2.x >= 0 && p2.x >= Math.abs(p2.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p2.y >= 0 && p2.y >= Math.abs(p2.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p2.x < 0 && -p2.x >= Math.abs(p2.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q2, r2, s;
    q2 = cosphi;
    t = q2 * q2;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r2 = 0;
    } else {
      r2 = Math.sqrt(1 - t);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t = r2;
      r2 = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r2 = -r2;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r2;
      r2 = s;
      s = -t;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t = q2;
      q2 = -r2;
      r2 = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q2 = -q2;
      r2 = -r2;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q2;
      q2 = r2;
      r2 = -t;
    }
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r2, q2);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p2.x = lp.lam;
  p2.y = lp.phi;
  return p2;
}
function qsc_fwd_equat_face_theta(phi, y3, x3, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y3, x3);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
var qsc_default = {
  init: init28,
  forward: forward27,
  inverse: inverse27,
  names: names29
};

// node_modules/proj4/lib/projections/robin.js
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x3) {
  return coefs[0] + x3 * (coefs[1] + x3 * (coefs[2] + x3 * coefs[3]));
};
var poly3_der = function(coefs, x3) {
  return coefs[1] + x3 * (2 * coefs[2] + x3 * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x3 = start2;
  for (; iters; --iters) {
    var upd = f_df(x3);
    x3 -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x3;
}
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse28(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t = newton_rapshon(function(x3) {
      return (poly3_val(coefs, x3) - ll.y) / poly3_der(coefs, x3);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var names30 = ["Robinson", "robin"];
var robin_default = {
  init: init29,
  forward: forward28,
  inverse: inverse28,
  names: names30
};

// node_modules/proj4/lib/projections/geocent.js
function init30() {
  this.name = "geocent";
}
function forward29(p2) {
  var point = geodeticToGeocentric(p2, this.es, this.a);
  return point;
}
function inverse29(p2) {
  var point = geocentricToGeodetic(p2, this.es, this.a, this.b);
  return point;
}
var names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
var geocent_default = {
  init: init30,
  forward: forward29,
  inverse: inverse29,
  names: names31
};

// node_modules/proj4/lib/projections/tpers.js
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: true, degrees: true },
  // default is North
  tilt: { def: 0, num: true, degrees: true },
  // default is Nadir
  long0: { def: 0, num: true },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: true }
  // default is Equator, conversion to rad is automatic
};
function init31() {
  Object.keys(params).forEach((function(p2) {
    if (typeof this[p2] === "undefined") {
      this[p2] = params[p2].def;
    } else if (params[p2].num && isNaN(this[p2])) {
      throw new Error("Invalid parameter value, must be numeric " + p2 + " = " + this[p2]);
    } else if (params[p2].num) {
      this[p2] = parseFloat(this[p2]);
    }
    if (params[p2].degrees) {
      this[p2] = this[p2] * D2R;
    }
  }).bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p2) {
  p2.x -= this.long0;
  var sinphi = Math.sin(p2.y);
  var cosphi = Math.cos(p2.y);
  var coslam = Math.cos(p2.x);
  var x3, y3;
  switch (this.mode) {
    case mode.OBLIQ:
      y3 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y3 = cosphi * coslam;
      break;
    case mode.S_POLE:
      y3 = -sinphi;
      break;
    case mode.N_POLE:
      y3 = sinphi;
      break;
  }
  y3 = this.pn1 / (this.p - y3);
  x3 = y3 * cosphi * Math.sin(p2.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y3 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y3 *= sinphi;
      break;
    case mode.N_POLE:
      y3 *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y3 *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y3 * this.cg + x3 * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x3 = (x3 * this.cg - y3 * this.sg) * this.cw * ba;
  y3 = yt * ba;
  p2.x = x3 * this.a;
  p2.y = y3 * this.a;
  return p2;
}
function inverse30(p2) {
  p2.x /= this.a;
  p2.y /= this.a;
  var r2 = { x: p2.x, y: p2.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p2.y * this.sw);
  bm = this.pn1 * p2.x * yt;
  bq = this.pn1 * p2.y * this.cw * yt;
  p2.x = bm * this.cg + bq * this.sg;
  p2.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p2.x, p2.y);
  if (Math.abs(rh) < EPSLN) {
    r2.x = 0;
    r2.y = p2.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r2.y = Math.asin(cosz * this.sinph0 + p2.y * sinz * this.cosph0 / rh);
        p2.y = (cosz - this.sinph0 * Math.sin(r2.y)) * rh;
        p2.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r2.y = Math.asin(p2.y * sinz / rh);
        p2.y = cosz * rh;
        p2.x *= sinz;
        break;
      case mode.N_POLE:
        r2.y = Math.asin(cosz);
        p2.y = -p2.y;
        break;
      case mode.S_POLE:
        r2.y = -Math.asin(cosz);
        break;
    }
    r2.x = Math.atan2(p2.x, p2.y);
  }
  p2.x = r2.x + this.long0;
  p2.y = r2.y;
  return p2;
}
var names32 = ["Tilted_Perspective", "tpers"];
var tpers_default = {
  init: init31,
  forward: forward30,
  inverse: inverse30,
  names: names32
};

// node_modules/proj4/lib/projections/geos.js
function init32() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p2) {
  var lon = p2.x;
  var lat = p2.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r2 = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r2 * Math.cos(lon) * Math.cos(lat);
    v_y = r2 * Math.sin(lon) * Math.cos(lat);
    v_z = r2 * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p2.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p2.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p2.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p2.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p2.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p2.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p2.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p2.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p2.x = p2.x * this.a;
  p2.y = p2.y * this.a;
  return p2;
}
function inverse31(p2) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a2, b3, det, k3;
  p2.x = p2.x / this.a;
  p2.y = p2.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p2.y / this.radius_g_1);
      v_y = Math.tan(p2.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p2.x / this.radius_g_1);
      v_z = Math.tan(p2.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a2 = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b3 = 2 * this.radius_g * v_x;
    det = b3 * b3 - 4 * a2 * this.C;
    if (det < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    k3 = (-b3 - Math.sqrt(det)) / (2 * a2);
    v_x = this.radius_g + k3 * v_x;
    v_y *= k3;
    v_z *= k3;
    p2.x = Math.atan2(v_y, v_x);
    p2.y = Math.atan(v_z * Math.cos(p2.x) / v_x);
    p2.y = Math.atan(this.radius_p_inv2 * Math.tan(p2.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p2.y / this.radius_g_1);
      v_y = Math.tan(p2.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p2.x / this.radius_g_1);
      v_z = Math.tan(p2.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a2 = v_y * v_y + v_z * v_z + v_x * v_x;
    b3 = 2 * this.radius_g * v_x;
    det = b3 * b3 - 4 * a2 * this.C;
    if (det < 0) {
      p2.x = Number.NaN;
      p2.y = Number.NaN;
      return p2;
    }
    k3 = (-b3 - Math.sqrt(det)) / (2 * a2);
    v_x = this.radius_g + k3 * v_x;
    v_y *= k3;
    v_z *= k3;
    p2.x = Math.atan2(v_y, v_x);
    p2.y = Math.atan(v_z * Math.cos(p2.x) / v_x);
  }
  p2.x = p2.x + this.long0;
  return p2;
}
var names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
var geos_default = {
  init: init32,
  forward: forward31,
  inverse: inverse31,
  names: names33
};

// node_modules/proj4/lib/projections/eqearth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = Math.sqrt(3) / 2;
function init33() {
  this.es = 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function forward32(p2) {
  var lam = adjust_lon_default(p2.x - this.long0);
  var phi = p2.y;
  var paramLat = Math.asin(M * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p2.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
  p2.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
  p2.x = this.a * p2.x + this.x0;
  p2.y = this.a * p2.y + this.y0;
  return p2;
}
function inverse32(p2) {
  p2.x = (p2.x - this.x0) / this.a;
  p2.y = (p2.y - this.y0) / this.a;
  var EPS = 1e-9, NITER = 12, paramLat = p2.y, paramLatSq, paramLatPow6, fy, fpy, dlat, i;
  for (i = 0; i < NITER; ++i) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p2.y;
    fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p2.x = M * p2.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
  p2.y = Math.asin(Math.sin(paramLat) / M);
  p2.x = adjust_lon_default(p2.x + this.long0);
  return p2;
}
var names34 = ["eqearth", "Equal Earth", "Equal_Earth"];
var eqearth_default = {
  init: init33,
  forward: forward32,
  inverse: inverse32,
  names: names34
};

// node_modules/proj4/lib/projections/bonne.js
var EPS10 = 1e-10;
function init34() {
  var c;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.m1 = pj_mlfn_default(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      c = Math.cos(this.phi1),
      this.en
    );
    this.am1 = c / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= HALF_PI) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p2) {
  var lam = adjust_lon_default(p2.x - (this.long0 || 0));
  var phi = p2.y;
  var rh, E2, c;
  rh = this.am1 + this.m1 - pj_mlfn_default(phi, E2 = Math.sin(phi), c = Math.cos(phi), this.en);
  E2 = c * lam / (rh * Math.sqrt(1 - this.es * E2 * E2));
  p2.x = rh * Math.sin(E2);
  p2.y = this.am1 - rh * Math.cos(E2);
  p2.x = this.a * p2.x + (this.x0 || 0);
  p2.y = this.a * p2.y + (this.y0 || 0);
  return p2;
}
function e_inv(p2) {
  p2.x = (p2.x - (this.x0 || 0)) / this.a;
  p2.y = (p2.y - (this.y0 || 0)) / this.a;
  var s, rh, lam, phi;
  rh = hypot_default(p2.x, p2.y = this.am1 - p2.y);
  phi = pj_inv_mlfn_default(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s = Math.abs(phi)) < HALF_PI) {
    s = Math.sin(phi);
    lam = rh * Math.atan2(p2.x, p2.y) * Math.sqrt(1 - this.es * s * s) / Math.cos(phi);
  } else if (Math.abs(s - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p2.x = adjust_lon_default(lam + (this.long0 || 0));
  p2.y = adjust_lat_default(phi);
  return p2;
}
function s_fwd(p2) {
  var lam = adjust_lon_default(p2.x - (this.long0 || 0));
  var phi = p2.y;
  var E2, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p2.x = rh * Math.sin(E2 = lam * Math.cos(phi) / rh);
    p2.y = this.cphi1 - rh * Math.cos(E2);
  } else {
    p2.x = p2.y = 0;
  }
  p2.x = this.a * p2.x + (this.x0 || 0);
  p2.y = this.a * p2.y + (this.y0 || 0);
  return p2;
}
function s_inv(p2) {
  p2.x = (p2.x - (this.x0 || 0)) / this.a;
  p2.y = (p2.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = hypot_default(p2.x, p2.y = this.cphi1 - p2.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > HALF_PI) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - HALF_PI) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p2.x, p2.y) / Math.cos(phi);
  }
  p2.x = adjust_lon_default(lam + (this.long0 || 0));
  p2.y = adjust_lat_default(phi);
  return p2;
}
var names35 = ["bonne", "Bonne (Werner lat_1=90)"];
var bonne_default = {
  init: init34,
  names: names35
};

// node_modules/proj4/projs.js
function projs_default(proj42) {
  proj42.Proj.projections.add(tmerc_default);
  proj42.Proj.projections.add(etmerc_default);
  proj42.Proj.projections.add(utm_default);
  proj42.Proj.projections.add(sterea_default);
  proj42.Proj.projections.add(stere_default);
  proj42.Proj.projections.add(somerc_default);
  proj42.Proj.projections.add(omerc_default);
  proj42.Proj.projections.add(lcc_default);
  proj42.Proj.projections.add(krovak_default);
  proj42.Proj.projections.add(cass_default);
  proj42.Proj.projections.add(laea_default);
  proj42.Proj.projections.add(aea_default);
  proj42.Proj.projections.add(gnom_default);
  proj42.Proj.projections.add(cea_default);
  proj42.Proj.projections.add(eqc_default);
  proj42.Proj.projections.add(poly_default);
  proj42.Proj.projections.add(nzmg_default);
  proj42.Proj.projections.add(mill_default);
  proj42.Proj.projections.add(sinu_default);
  proj42.Proj.projections.add(moll_default);
  proj42.Proj.projections.add(eqdc_default);
  proj42.Proj.projections.add(vandg_default);
  proj42.Proj.projections.add(aeqd_default);
  proj42.Proj.projections.add(ortho_default);
  proj42.Proj.projections.add(qsc_default);
  proj42.Proj.projections.add(robin_default);
  proj42.Proj.projections.add(geocent_default);
  proj42.Proj.projections.add(tpers_default);
  proj42.Proj.projections.add(geos_default);
  proj42.Proj.projections.add(eqearth_default);
  proj42.Proj.projections.add(bonne_default);
}

// node_modules/proj4/lib/index.js
core_default.defaultDatum = "WGS84";
core_default.Proj = Proj_default;
core_default.WGS84 = new core_default.Proj("WGS84");
core_default.Point = Point_default2;
core_default.toPoint = toPoint_default;
core_default.defs = defs_default;
core_default.nadgrid = nadgrid;
core_default.transform = transform2;
core_default.mgrs = mgrs_default;
core_default.version = "__VERSION__";
projs_default(core_default);
var lib_default = core_default;

// node_modules/geopf-extensions-openlayers/src/packages/CRS/Proj4.js
var logger12 = LoggerByDefault_default2.getLogger("CRS");
function register(proj42) {
  const projCodes = Object.keys(proj42.defs);
  logger12.trace("proj. codes :", projCodes);
  const len = projCodes.length;
  let i, j2;
  for (i = 0; i < len; ++i) {
    const code = projCodes[i];
    if (!get2(code)) {
      const def = proj42.defs(code);
      addProjection(new Projection_default({
        code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: def.units
      }));
    }
  }
  for (i = 0; i < len; ++i) {
    const code1 = projCodes[i];
    const proj1 = get2(code1);
    for (j2 = 0; j2 < len; ++j2) {
      const code2 = projCodes[j2];
      const proj2 = get2(code2);
      if (!get(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          const transform3 = proj42(code1, code2);
          addCoordinateTransforms(proj1, proj2, transform3.forward, transform3.inverse);
        }
      }
    }
  }
}

// node_modules/geopf-extensions-openlayers/src/packages/Utils/Register.js
var Register = {
  /**
   * instance already loaded into proj4
   */
  isLoaded: false,
  /**
   * get the definition for a code
   *
   * @function get
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Object} definition
   * @example
   * Register.get("EPSG:2154");
   * // "+title=RGF93 / Lambert-93 +proj=lcc +lat_1=49 ..."
   */
  get: function(name) {
    if (name === "" || name === null || typeof name === "undefined") {
      return;
    }
    var s = name.split(":");
    if (s.length !== 2) {
      return;
    }
    var _register = s[0];
    var _code = s[1];
    if (!this.hasOwnProperty(_register)) {
      return;
    }
    if (!this[_register].hasOwnProperty(_code)) {
      return;
    }
    return this[_register][_code];
  },
  /**
   * does projection code exist ?
   *
   * @function exist
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Boolean} true/false
   * @example
   * Register.exist("EPSG:2154"); // true
   */
  exist: function(name) {
    if (name === "" || name === null || typeof name === "undefined") {
      return false;
    }
    var s = name.split(":");
    if (s.length !== 2) {
      return false;
    }
    var _register = s[0];
    var _code = s[1];
    if (!this.hasOwnProperty(_register)) {
      return false;
    }
    if (!this[_register].hasOwnProperty(_code)) {
      return false;
    }
    return true;
  },
  /**
   * load all defs to proj4
   * @function load
   * @param {Object} Proj4 - proj4 instance
   */
  load: function(Proj4) {
    if (!this.isLoaded) {
      var registers = [
        "IGNF",
        // exception lors du register IGNF ?
        "EPSG",
        "CRS"
      ];
      for (var i = 0; i < registers.length; i++) {
        var _register = registers[i];
        var codes2 = this[_register];
        for (var _code in codes2) {
          if (codes2.hasOwnProperty(_code)) {
            var name = _register + ":" + _code;
            Proj4.defs(name, this.get(name));
          }
        }
      }
      this.isLoaded = true;
    }
  },
  /**
   * load defs by default to proj4
   *
   * include into proj4 :
   * - WGS84
   * - ['EPSG:4326']
   * - ['EPSG:3785'], ['EPSG:3857'], GOOGLE, ['EPSG:900913'], ['EPSG:102113']
   * +
   * - ["EPSG:2154"], ["EPSG:27571"],  ["EPSG:27572"],  ["EPSG:27573"],  ["EPSG:2757"],
   * - ["CRS:84"],
   * - ["IGNF:LAMB93"],
   * - ["IGNF:LAMBE"], ["IGNF:LAMB1"],  ["IGNF:LAMB2"],  ["IGNF:LAMB3"],  ["IGNF:LAMB4"],
   * - ["IGNF:RGF93G"],
   * - ["IGNF:WGS84G"]
   *
   * @function loadByDefault
   * @param {Object} Proj4 - proj4 instance
   */
  loadByDefault: function(Proj4) {
    var registers = {
      EPSG: {
        2154: Register["EPSG"]["2154"],
        27571: Register["EPSG"]["27571"],
        27572: Register["EPSG"]["27572"],
        27573: Register["EPSG"]["27573"],
        27574: Register["EPSG"]["27574"]
      },
      CRS: {
        84: Register["CRS"]["84"]
      },
      IGNF: {
        LAMB93: Register["IGNF"]["LAMB93"],
        LAMBE: Register["IGNF"]["LAMBE"],
        LAMB1: Register["IGNF"]["LAMB1"],
        LAMB2: Register["IGNF"]["LAMB2"],
        LAMB3: Register["IGNF"]["LAMB3"],
        LAMB4: Register["IGNF"]["LAMB4"],
        RGF93G: Register["IGNF"]["RGF93G"],
        WGS84G: Register["IGNF"]["WGS84G"]
      }
    };
    for (var register2 in registers) {
      if (registers.hasOwnProperty(register2)) {
        var codes2 = registers[register2];
        for (var code in codes2) {
          if (codes2.hasOwnProperty(code)) {
            var name = register2 + ":" + code;
            Proj4.defs(name, codes2[code]);
          }
        }
      }
    }
  },
  /**
   * load only a def to proj4
   *
   * @function loadByName
   * @param {Object} Proj4 - proj4 instance
   * @param {String} name - ie. EPSG:2154 (Lambert)
   * @returns {Boolean} true/false
   */
  loadByName: function(Proj4, name) {
    if (!this.exist(name)) {
      return false;
    }
    try {
      Proj4.defs(name, this.get(name));
    } catch (e) {
      return false;
    }
    return true;
  },
  /**
   * definitions EPSG
   * @enum
   */
  EPSG: {
    4978: "+proj=geocent +datum=WGS84 +units=m +no_defs ",
    3857: "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs",
    3785: "+title=WGS 84 / Pseudo-Mercator (deprecated) +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs",
    4149: "+title=CH1903 +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ",
    4150: "+title=CH1903plus +proj=longlat +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +no_defs ",
    4151: "+title=CHTRF95 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4171: "+title=RGF93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4230: "+title=ED50 +proj=longlat +ellps=intl +no_defs ",
    4235: "+title=Guyane Francaise +proj=longlat +ellps=intl +no_defs ",
    4258: "+title=ETRS89 +proj=longlat +ellps=GRS80 +no_defs ",
    4275: "+title=NTF +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +no_defs ",
    4322: "+title=WGS 72 +proj=longlat +ellps=WGS72 +no_defs ",
    4326: "+title=WGS 84 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ",
    4467: "+proj=utm +zone=21 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4470: "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4471: "+proj=utm +zone=38 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4474: "+proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ",
    4558: "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4559: "+proj=utm +zone=20 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    4621: "+title=Fort Marigot +proj=longlat +ellps=intl +towgs84=137,248,-430,0,0,0,0 +no_defs ",
    4622: "+title=Guadeloupe 1948 +proj=longlat +ellps=intl +no_defs ",
    4623: "+title=CSG67 +proj=longlat +ellps=intl +towgs84=-186,230,110,0,0,0,0 +no_defs ",
    4624: "+title=RGFG95 +proj=longlat +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +no_defs ",
    4625: "+title=Martinique 1938 +proj=longlat +ellps=intl +no_defs ",
    4626: "+title=Reunion 1947 +proj=longlat +ellps=intl +no_defs ",
    4627: "+title=RGR92 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4628: "+title=Tahiti 52 +proj=longlat +ellps=intl +towgs84=162,117,154,0,0,0,0 +no_defs ",
    4629: "+title=Tahaa 54 +proj=longlat +ellps=intl +no_defs ",
    4630: "+title=IGN72 Nuku Hiva +proj=longlat +ellps=intl +no_defs ",
    4632: "+title=Combani 1950 +proj=longlat +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +no_defs ",
    4633: "+title=IGN56 Lifou +proj=longlat +ellps=intl +no_defs ",
    4634: "+title=IGN72 Grand Terre +proj=longlat +ellps=intl +no_defs ",
    4637: "+title=Perroud 1950 +proj=longlat +ellps=intl +towgs84=325,154,172,0,0,0,0 +no_defs ",
    4638: "+title=Saint Pierre et Miquelon 1950 +proj=longlat +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +no_defs ",
    4640: "+title=RRAF 1991 +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4641: "+title=IGN53 Mare +proj=longlat +ellps=intl +no_defs ",
    4645: "+title=RGNC 1991 +proj=longlat +ellps=intl +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4687: "+proj=longlat +ellps=GRS80 +no_defs ",
    4662: "+title=IGN72 Grande Terre +proj=longlat +ellps=intl +no_defs ",
    4689: "+title=IGN63 Hiva Oa +proj=longlat +ellps=intl +no_defs ",
    4690: "+title=Tahiti 79 +proj=longlat +ellps=intl +no_defs ",
    4691: "+title=Moorea 87 +proj=longlat +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +no_defs ",
    4692: "+title=Maupiti 83 +proj=longlat +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +no_defs ",
    4698: "+title=IGN 1962 Kerguelen +proj=longlat +ellps=intl +towgs84=145,-187,103,0,0,0,0 +no_defs ",
    4749: "+title=RGNC91-93 +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ",
    4750: "+title=ST87 Ouvea +proj=longlat +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +no_defs ",
    4807: "+title=NTF (Paris) +proj=longlat +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +no_defs ",
    2056: "+title=CH1903+ / LV95 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ",
    2154: "+title=RGF93 / Lambert-93 +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2213: "+title=ETRS89 / TM 30 NE +proj=tmerc +lat_0=0 +lon_0=30 +k=0.9996 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs ",
    2969: "+title=Fort Marigot / UTM zone 20N +proj=utm +zone=20 +ellps=intl +towgs84=137,248,-430,0,0,0,0 +units=m +no_defs ",
    2970: "+title=Guadeloupe 1948 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ",
    2971: "+title=CSG67 / UTM zone 22N +proj=utm +zone=22 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ",
    2972: "+title=RGFG95 / UTM zone 22N +proj=utm +zone=22 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ",
    2973: "+title=Martinique 1938 / UTM zone 20N +proj=utm +zone=20 +ellps=intl +units=m +no_defs ",
    2975: "+title=RGR92 / UTM zone 40S +proj=utm +zone=40 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2976: "+title=Tahiti 52 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=162,117,154,0,0,0,0 +units=m +no_defs ",
    2977: "+title=Tahaa 54 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +units=m +no_defs ",
    2978: "+title=IGN72 Nuku Hiva / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ",
    2980: "+title=Combani 1950 / UTM zone 38S +proj=utm +zone=38 +south +ellps=intl +towgs84=-382,-59,-262,0,0,0,0 +units=m +no_defs ",
    2981: "+title=IGN56 Lifou / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    2982: "+title=IGN72 Grand Terre / UTM zone 58S (deprecated) +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    2984: "+title=RGNC 1991 / Lambert New Caledonia (deprecated) +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=intl +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2986: "+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67.000000000 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs",
    2987: "+title=Saint Pierre et Miquelon 1950 / UTM zone 21N +proj=utm +zone=21 +ellps=clrk66 +towgs84=30,430,368,0,0,0,0 +units=m +no_defs ",
    2989: "+title=RRAF 1991 / UTM zone 20N +proj=utm +zone=20 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    2990: "+title=Reunion 1947 / TM Reunion (deprecated) +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=50000 +y_0=160000 +ellps=intl +units=m +no_defs ",
    2995: "+title=IGN53 Mare / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    3038: "+proj=utm +zone=26 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3039: "+proj=utm +zone=27 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3040: "+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3041: "+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3042 : "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3043 : "+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 3044 : "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3045: "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3046: "+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3047: "+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3048: "+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3049: "+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3050: "+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3051: "+proj=utm +zone=39 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3034: "+title=ETRS89 / ETRS-LCC +proj=lcc +lat_1=35 +lat_2=65 +lat_0=52 +lon_0=10 +x_0=4000000 +y_0=2800000 +ellps=GRS80 +units=m +no_defs ",
    3035: "+title=ETRS89 / ETRS-LAEA +proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ",
    3042: "+title=ETRS89 / ETRS-TM30 +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ",
    3043: "+title=ETRS89 / ETRS-TM31 +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ",
    3044: "+title=ETRS89 / ETRS-TM32 +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ",
    25828: "+proj=utm +zone=28 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25829: "+proj=utm +zone=29 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25830 : "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25831 : "+proj=utm +zone=31 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    // 25832 : "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25833: "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25834: "+proj=utm +zone=34 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25835: "+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25836: "+proj=utm +zone=36 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25837: "+proj=utm +zone=37 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    25838: "+proj=utm +zone=38 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3060: "+title=IGN72 Grande Terre / UTM zone 58S +proj=utm +zone=58 +south +ellps=intl +units=m +no_defs ",
    3163: "+title=RGNC91-93 / Lambert New Caledonia +proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3164: "+title=ST87 Ouvea / UTM zone 58S +proj=utm +zone=58 +south +ellps=WGS84 +towgs84=-56.263,16.136,-22.856,0,0,0,0 +units=m +no_defs ",
    3165: "+title=NEA74 Noumea / Noumea Lambert +proj=lcc +lat_1=-22.24469175 +lat_2=-22.29469175 +lat_0=-22.26969175 +lon_0=166.44242575 +x_0=0.66 +y_0=1.02 +ellps=intl +units=m +no_defs ",
    3166: "+title=NEA74 Noumea / Noumea Lambert 2 +proj=lcc +lat_1=-22.24472222222222 +lat_2=-22.29472222222222 +lat_0=-22.26972222222222 +lon_0=166.4425 +x_0=8.313000000000001 +y_0=-2.354 +ellps=intl +units=m +no_defs ",
    3169: "+title=RGNC91-93 / UTM zone 57S +proj=utm +zone=57 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3170: "+title=RGNC91-93 / UTM zone 58S +proj=utm +zone=58 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3171: "+title=RGNC91-93 / UTM zone 59S +proj=utm +zone=59 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ",
    3172: "+title=IGN53 Mare / UTM zone 59S +proj=utm +zone=59 +south +ellps=intl +units=m +no_defs ",
    3296: "+title=RGPF / UTM zone 5S +proj=utm +zone=5 +south +ellps=GRS80 +units=m +no_defs ",
    3297: "+title=RGPF / UTM zone 6S +proj=utm +zone=6 +south +ellps=GRS80 +units=m +no_defs ",
    3298: "+title=RGPF / UTM zone 7S +proj=utm +zone=7 +south +ellps=GRS80 +units=m +no_defs ",
    3299: "+title=RGPF / UTM zone 8S +proj=utm +zone=8 +south +ellps=GRS80 +units=m +no_defs ",
    3302: "+title=IGN63 Hiva Oa / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +units=m +no_defs ",
    3303: "+title=Fatu Iva 72 / UTM zone 7S +proj=utm +zone=7 +south +ellps=intl +towgs84=347.103,1078.12,2623.92,-33.8875,70.6773,-9.3943,186.074 +units=m +no_defs ",
    3304: "+title=Tahiti 79 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +units=m +no_defs ",
    3305: "+title=Moorea 87 / UTM zone 6S +proj=utm +zone=6 +south +ellps=intl +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773 +units=m +no_defs ",
    3306: "+title=Maupiti 83 / UTM zone 5S +proj=utm +zone=5 +south +ellps=intl +towgs84=217.037,86.959,23.956,0,0,0,0 +units=m +no_defs ",
    3312: "+title=CSG67 / UTM zone 21N +proj=utm +zone=21 +ellps=intl +towgs84=-186,230,110,0,0,0,0 +units=m +no_defs ",
    3313: "+title=RGFG95 / UTM zone 21N +proj=utm +zone=21 +ellps=GRS80 +towgs84=2,2,-2,0,0,0,0 +units=m +no_defs ",
    3336: "+title=IGN 1962 Kerguelen / UTM zone 42S +proj=utm +zone=42 +south +ellps=intl +towgs84=145,-187,103,0,0,0,0 +units=m +no_defs ",
    3395: "+title=WGS 84 / World Mercator +proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    3727: "+title=Reunion 1947 / TM Reunion +proj=tmerc +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=160000 +y_0=50000 +ellps=intl +units=m +no_defs ",
    21781: "+title=CH1903 / LV03 +proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ",
    25830: "+title=ETRS89 / UTM zone 30N +proj=utm +zone=30 +ellps=GRS80 +units=m +no_defs ",
    25831: "+title=ETRS89 / UTM zone 31N +proj=utm +zone=31 +ellps=GRS80 +units=m +no_defs ",
    25832: "+title=ETRS89 / UTM zone 32N +proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs ",
    27561: "+title=NTF (Paris) / Lambert Nord France +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27562: "+title=NTF (Paris) / Lambert Centre France +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27563: "+title=NTF (Paris) / Lambert Sud France +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27564: "+title=NTF (Paris) / Lambert Corse +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27571: "+title=NTF (Paris) / Lambert zone I +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27572: "+title=NTF (Paris) / Lambert zone II +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27573: "+title=NTF (Paris) / Lambert zone III +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27574: "+title=NTF (Paris) / Lambert zone IV +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27581: "+title=NTF (Paris) / France I (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=1200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27582: "+title=NTF (Paris) / France II (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27583: "+title=NTF (Paris) / France III (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=3200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27584: "+title=NTF (Paris) / France IV (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=4185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27591: "+title=NTF (Paris) / Nord France (deprecated) +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27592: "+title=NTF (Paris) / Centre France (deprecated) +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27593: "+title=NTF (Paris) / Sud France (deprecated) +proj=lcc +lat_1=44.10000000000001 +lat_0=44.10000000000001 +lon_0=0 +k_0=0.9998774990000001 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    27594: "+title=NTF (Paris) / Corse (deprecated) +proj=lcc +lat_1=42.16500000000001 +lat_0=42.16500000000001 +lon_0=0 +k_0=0.9999447100000001 +x_0=234.358 +y_0=185861.369 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs ",
    32601: "+proj=utm +zone=1 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32602: "+proj=utm +zone=2 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32603: "+proj=utm +zone=3 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32604: "+proj=utm +zone=4 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32605: "+proj=utm +zone=5 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32606: "+proj=utm +zone=6 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32607: "+proj=utm +zone=7 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32608: "+proj=utm +zone=8 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32609: "+proj=utm +zone=9 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32610: "+proj=utm +zone=10 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32611: "+proj=utm +zone=11 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32612: "+proj=utm +zone=12 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32613: "+proj=utm +zone=13 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32614: "+proj=utm +zone=14 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32615: "+proj=utm +zone=15 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32616: "+proj=utm +zone=16 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32617: "+proj=utm +zone=17 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32618: "+proj=utm +zone=18 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32619: "+proj=utm +zone=19 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32620: "+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32621: "+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32622: "+proj=utm +zone=22 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32623: "+proj=utm +zone=23 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32624: "+proj=utm +zone=24 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32625: "+proj=utm +zone=25 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32626: "+proj=utm +zone=26 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32627: "+proj=utm +zone=27 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32628: "+proj=utm +zone=28 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32629: "+proj=utm +zone=29 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32630: "+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32631: "+proj=utm +zone=31 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32632: "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32633: "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32634: "+proj=utm +zone=34 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32635: "+proj=utm +zone=35 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32636: "+proj=utm +zone=36 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32637: "+proj=utm +zone=37 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32638: "+proj=utm +zone=38 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32639: "+proj=utm +zone=39 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32640: "+proj=utm +zone=40 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32641: "+proj=utm +zone=41 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32642: "+proj=utm +zone=42 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32643: "+proj=utm +zone=43 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32644: "+proj=utm +zone=44 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32645: "+proj=utm +zone=45 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32646: "+proj=utm +zone=46 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32647: "+proj=utm +zone=47 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32648: "+proj=utm +zone=48 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32649: "+proj=utm +zone=49 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32650: "+proj=utm +zone=50 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32651: "+proj=utm +zone=51 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32652: "+proj=utm +zone=52 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32653: "+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32654: "+proj=utm +zone=54 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32655: "+proj=utm +zone=55 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32656: "+proj=utm +zone=56 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32657: "+proj=utm +zone=57 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32658: "+proj=utm +zone=58 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32659: "+proj=utm +zone=59 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32660: "+proj=utm +zone=60 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32661: "+proj=stere +lat_0=90 +lat_ts=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32662: "+title=WGS 84 / Plate Carree +proj=eqc +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32701: "+proj=utm +zone=1 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32702: "+proj=utm +zone=2 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32703: "+proj=utm +zone=3 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32704: "+proj=utm +zone=4 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32705: "+proj=utm +zone=5 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32706: "+proj=utm +zone=6 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32707: "+proj=utm +zone=7 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32708: "+proj=utm +zone=8 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32709: "+proj=utm +zone=9 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32710: "+proj=utm +zone=10 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32711: "+proj=utm +zone=11 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32712: "+proj=utm +zone=12 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32713: "+proj=utm +zone=13 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32714: "+proj=utm +zone=14 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32715: "+proj=utm +zone=15 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32716: "+proj=utm +zone=16 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32717: "+proj=utm +zone=17 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32718: "+proj=utm +zone=18 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32719: "+proj=utm +zone=19 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32720: "+proj=utm +zone=20 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32721: "+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32722: "+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32723: "+proj=utm +zone=23 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32724: "+proj=utm +zone=24 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32725: "+proj=utm +zone=25 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32726: "+proj=utm +zone=26 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32727: "+proj=utm +zone=27 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32728: "+proj=utm +zone=28 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32729: "+proj=utm +zone=29 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32730: "+proj=utm +zone=30 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32731: "+proj=utm +zone=31 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32732: "+proj=utm +zone=32 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32733: "+proj=utm +zone=33 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32734: "+proj=utm +zone=34 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32735: "+proj=utm +zone=35 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32736: "+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32737: "+proj=utm +zone=37 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32738: "+proj=utm +zone=38 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32739: "+proj=utm +zone=39 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32740: "+proj=utm +zone=40 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32741: "+proj=utm +zone=41 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32742: "+proj=utm +zone=42 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32743: "+proj=utm +zone=43 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32744: "+proj=utm +zone=44 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32745: "+proj=utm +zone=45 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32746: "+proj=utm +zone=46 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32747: "+proj=utm +zone=47 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32748: "+proj=utm +zone=48 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32749: "+proj=utm +zone=49 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32750: "+proj=utm +zone=50 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32751: "+proj=utm +zone=51 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32752: "+proj=utm +zone=52 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32753: "+proj=utm +zone=53 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32754: "+proj=utm +zone=54 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32755: "+proj=utm +zone=55 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32756: "+proj=utm +zone=56 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32757: "+proj=utm +zone=57 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32758: "+proj=utm +zone=58 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32759: "+proj=utm +zone=59 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32760: "+proj=utm +zone=60 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    32761: "+proj=stere +lat_0=-90 +lat_ts=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",
    310024802: "+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310915814: "+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310486805: "+title=Geoportail - Guyane +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310700806: "+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310702807: "+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310706808: "+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310547809: "+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642810: "+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310032811: "+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642812: "+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642801: "+title=Geoportail - Crozet +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642813: "+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    310642901: "+title=Geoportail - Monde +proj=mill +towgs84=0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.000000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    5489: "+title=RGAF09 geographiques (dms) +proj=longlat +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +units=m +no_defs",
    5490: "+title=RGAF09 UTM Nord Fuseau 20 +proj=tmerc +nadgrids=@null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137 +rf=298.257222101 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs"
  },
  /**
   * definitions CRS
   * @enum
   */
  CRS: {
    84: "+title=WGS 84 longitude-latitude +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "
  },
  /**
   * definitions IGNF
   * @enum
   */
  IGNF: {
    AMST63: "+title=Amsterdam 1963 +proj=geocent +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CROZ63: "+title=Crozet 1963 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CSG67: "+title=Guyane CSG67 +proj=geocent +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ED50: "+title=ED50 +proj=geocent +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ETRS89: "+title=Systeme de reference terrestre Europeen (1989) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    GUAD48: "+title=Guadeloupe Ste Anne +proj=geocent +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUADFM49: "+title=Guadeloupe Fort Marigot +proj=geocent +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN63: "+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=geocent +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN72: "+title=IGN 1972 Grande-Terre / Ile des Pins +proj=geocent +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    KERG62CAR: "+title=Kerguelen - K0 +proj=geocent +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MART38: "+title=Martinique Fort-Desaix +proj=geocent +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MAYO50: "+title=Mayotte Combani +proj=geocent +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MOOREA87: "+title=Moorea 1987 +proj=geocent +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    NTF: "+title=Nouvelle Triangulation Francaise +proj=geocent +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs",
    NUKU72: "+title=IGN 1972 Nuku Hiva +proj=geocent +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    REUN47: "+title=Reunion 1947 +proj=geocent +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    RGF93: "+title=Reseau geodesique francais 1993 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGFG95: "+title=Reseau geodesique francais de Guyane 1995 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGM04: "+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGNC: "+title=Reseau Geodesique de Nouvelle-Caledonie +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGPF: "+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGR92: "+title=Reseau geodesique Reunion 1992 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGSPM06: "+title=Reseau Geodesique Saint-Pierre-et-Miquelon (2006) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGTAAF07: "+title=Reseau Geodesique des TAAF (2007) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RRAF91: "+title=RRAF 1991 (Reseau de Reference des Antilles Francaises) +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    STPL69: "+title=Saint-Paul 1969 +proj=geocent +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    STPM50: "+title=St Pierre et Miquelon 1950 +proj=geocent +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs",
    TAHAA: "+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=geocent +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TAHI79: "+title=IGN79 (Tahiti) Iles de la Societe +proj=geocent +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TERA50: "+title=Pointe Geologie - Perroud 1950 +proj=geocent +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WALL78: "+title=Wallis-Uvea 1978 (MOP78) +proj=geocent +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WGS72: "+title=World Geodetic System 1972 +proj=geocent +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs",
    WGS84: "+title=World Geodetic System 1984 +proj=geocent +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    AMST63GEO: "+title=Amsterdam 1963 +proj=longlat +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CROZ63GEO: "+title=Crozet 1963 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    CSG67GEO: "+title=Guyane CSG67 +proj=longlat +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    ED50G: "+title=ED50 +proj=longlat +towgs84=-84.0000,-97.0000,-117.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUAD48GEO: "+title=Guadeloupe Ste Anne +proj=longlat +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    GUADFM49GEO: "+title=Guadeloupe Fort Marigot +proj=longlat +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN63GEO: "+title=IGN 1963 (Hiva Oa, Tahuata, Mohotani) +proj=longlat +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    IGN72GEO: "+title=IGN 1972 Grande-Terre / Ile des Pins +proj=longlat +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    KERG62GEO: "+title=Kerguelen - K0 +proj=longlat +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MART38GEO: "+title=Martinique Fort-Desaix +proj=longlat +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MAYO50GEO: "+title=Mayotte Combani +proj=longlat +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    MOOREA87GEO: "+title=Moorea 1987 +proj=longlat +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    NTFG: "+title=Nouvelle Triangulation Francaise Greenwich degres sexagesimaux +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +units=m +no_defs",
    NTFP: "+title=Nouvelle Triangulation Francaise Paris grades +proj=longlat +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +units=m +no_defs",
    NUKU72GEO: "+title=IGN 1972 Nuku Hiva +proj=longlat +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    REUN47GEO: "+title=Reunion 1947 +proj=longlat +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    RGF93G: "+title=Reseau geodesique francais 1993 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGFG95GEO: "+title=Reseau geodesique francais de Guyane 1995 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGM04GEO: "+title=RGM04 (Reseau Geodesique de Mayotte 2004) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGNCGEO: "+title=Reseau Geodesique de Nouvelle-Caledonie +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGPFGEO: "+title=RGPF (Reseau Geodesique de Polynesie Francaise) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGR92GEO: "+title=Reseau geodesique de la Reunion 1992 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGSPM06GEO: "+title=Saint-Pierre-et-Miquelon (2006) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    RGTAAF07G: "+title=Reseau Geodesique des TAAF (2007) (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    STPL69GEO: "+title=Saint-Paul 1969 +proj=longlat +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    STPM50GEO: "+title=St Pierre et Miquelon 1950  +proj=longlat +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +units=m +no_defs",
    TAHAAGEO: "+title=Raiatea - Tahaa 51-54 (Tahaa, Base Terme Est) +proj=longlat +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TAHI79GEO: "+title=IGN79 (Tahiti) Iles de la Societe +proj=longlat +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    TERA50G: "+title=Pointe Geologie - Perroud 1950 +proj=longlat +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WALL78GEO: "+title=Wallis - Uvea 1978 (MOP78) +proj=longlat +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +units=m +no_defs",
    WGS72G: "+title=WGS72 +proj=longlat +towgs84=0.0000,12.0000,6.0000 +a=6378135.0000 +rf=298.2600000000000 +units=m +no_defs",
    WGS84G: "+title=World Geodetic System 1984 +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    WGS84RRAFGEO: "+title=Reseau de reference des Antilles francaises (1988-1991) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    XGEO: "+title=Systeme CIO-BIH +proj=longlat +towgs84=0.0000,0.0000,0.5000,0.0000,0.0000,0.0140,-0.100000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    AMST63UTM43S: "+title=Amsterdam 1963 UTM fuseau 43 Sud +proj=tmerc +towgs84=109.753,-528.133,-362.244,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    CROZ63UTM39S: "+title=Crozet 1963 +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    CSG67UTM21: "+title=Guyane CSG67 UTM fuseau 21 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    CSG67UTM22: "+title=Guyane CSG67 UTM fuseau 22 +proj=tmerc +towgs84=-193.0660,236.9930,105.4470,0.4814,-0.8074,0.1276,1.564900 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALANF: "+title=Geoportail - Antilles francaises +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALASP: "+title=Geoportail - Amsterdam et Saint-Paul +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-38.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALCRZ: "+title=Geoportail - Crozet +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-46.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALFXX: "+title=Geoportail - France metropolitaine +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=46.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALGUF: "+title=Geoportail - Guyane +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=4.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALKER: "+title=Geoportail - Kerguelen +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-49.500000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALMYT: "+title=Geoportail - Mayotte +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-12.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALNCL: "+title=Geoportail - Nouvelle-Caledonie +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-22.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALPYF: "+title=Geoportail - Polynesie francaise +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-15.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALREU: "+title=Geoportail - Reunion et dependances +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-21.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALSPM: "+title=Geoportail - Saint-Pierre et Miquelon +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=47.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GEOPORTALWLF: "+title=Geoportail - Wallis et Futuna +proj=eqc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=0.000000000 +lat_ts=-14.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    GUAD48UTM20: "+title=Guadeloupe Ste Anne +proj=tmerc +towgs84=-472.2900,-5.6300,-304.1200,0.4362,-0.8374,0.2563,1.898400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    GUADFM49U20: "+title=Guadeloupe Fort Marigot  +proj=tmerc +towgs84=136.5960,248.1480,-429.7890 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    IGN63UTM7S: "+title=IGN 1963 - Hiva Oa, Tahuata, Mohotani - UTM fuseau 7 Sud +proj=tmerc +towgs84=410.7210,55.0490,80.7460,-2.5779,-2.3514,-0.6664,17.331100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    IGN72UTM58S: "+title=IGN 1972 - UTM fuseau 58 Sud +proj=tmerc +towgs84=-11.6400,-348.6000,291.6800 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    KERG62UTM42S: "+title=Kerguelen 1962 +proj=tmerc +towgs84=144.8990,-186.7700,100.9230 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    LAMB1: "+title=Lambert I +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB1C: "+title=Lambert I Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=49.500000000 +lon_0=0.000000000 +k_0=0.99987734 +lat_1=49.500000000 +x_0=600000.000 +y_0=1200000.000 +units=m +no_defs",
    LAMB2: "+title=Lambert II +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB2C: "+title=Lambert II Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs",
    LAMB3: "+title=Lambert III +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=200000.000 +units=m +no_defs",
    LAMB3C: "+title=Lambert III Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=44.100000000 +lon_0=0.000000000 +k_0=0.99987750 +lat_1=44.100000000 +x_0=600000.000 +y_0=3200000.000 +units=m +no_defs",
    LAMB4: "+title=Lambert IV +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=185861.369 +units=m +no_defs",
    LAMB4C: "+title=Lambert IV Carto +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=42.165000000 +lon_0=0.000000000 +k_0=0.99994471 +lat_1=42.165000000 +x_0=234.358 +y_0=4185861.369 +units=m +no_defs",
    LAMB93: "+title=Lambert 93 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.500000000 +lon_0=3.000000000 +lat_1=44.000000000 +lat_2=49.000000000 +x_0=700000.000 +y_0=6600000.000 +units=m +no_defs",
    RGF93CC42: "+title=Lambert conique conforme Zone 1 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=42.000000000 +lon_0=3.000000000 +lat_1=41.200000000 +lat_2=42.800000000 +x_0=1700000.000 +y_0=1200000.000 +units=m +no_defs",
    RGF93CC43: "+title=Lambert conique conforme Zone 2 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=43.000000000 +lon_0=3.000000000 +lat_1=42.200000000 +lat_2=43.800000000 +x_0=1700000.000 +y_0=2200000.000 +units=m +no_defs",
    RGF93CC44: "+title=Lambert conique conforme Zone 3 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=44.000000000 +lon_0=3.000000000 +lat_1=43.200000000 +lat_2=44.800000000 +x_0=1700000.000 +y_0=3200000.000 +units=m +no_defs",
    RGF93CC45: "+title=Lambert conique conforme Zone 4 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=45.000000000 +lon_0=3.000000000 +lat_1=44.200000000 +lat_2=45.800000000 +x_0=1700000.000 +y_0=4200000.000 +units=m +no_defs",
    RGF93CC46: "+title=Lambert conique conforme Zone 5 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=46.000000000 +lon_0=3.000000000 +lat_1=45.200000000 +lat_2=46.800000000 +x_0=1700000.000 +y_0=5200000.000 +units=m +no_defs",
    RGF93CC47: "+title=Lambert conique conforme Zone 6 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=47.000000000 +lon_0=3.000000000 +lat_1=46.200000000 +lat_2=47.800000000 +x_0=1700000.000 +y_0=6200000.000 +units=m +no_defs",
    RGF93CC48: "+title=Lambert conique conforme Zone 7 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=48.000000000 +lon_0=3.000000000 +lat_1=47.200000000 +lat_2=48.800000000 +x_0=1700000.000 +y_0=7200000.000 +units=m +no_defs",
    RGF93CC49: "+title=Lambert conique conforme Zone 8 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=49.000000000 +lon_0=3.000000000 +lat_1=48.200000000 +lat_2=49.800000000 +x_0=1700000.000 +y_0=8200000.000 +units=m +no_defs",
    RGF93CC50: "+title=Lambert conique conforme Zone 9 +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=50.000000000 +lon_0=3.000000000 +lat_1=49.200000000 +lat_2=50.800000000 +x_0=1700000.000 +y_0=9200000.000 +units=m +no_defs",
    LAMBE: "+title=Lambert II etendu +proj=lcc +nadgrids=ntf_r93.gsb,null +wktext +towgs84=-168.0000,-60.0000,320.0000 +a=6378249.2000 +rf=293.4660210000000 +pm=2.337229167 +lat_0=46.800000000 +lon_0=0.000000000 +k_0=0.99987742 +lat_1=46.800000000 +x_0=600000.000 +y_0=2200000.000 +units=m +no_defs",
    MART38UTM20: "+title=Martinique Fort-Desaix +proj=tmerc +towgs84=126.9260,547.9390,130.4090,-2.7867,5.1612,-0.8584,13.822650 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    MAYO50UTM38S: "+title=Mayotte Combani +proj=tmerc +towgs84=-599.9280,-275.5520,-195.6650,-0.0835,-0.4715,0.0602,49.281400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    MILLER: "+title=Geoportail - Monde +proj=mill +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lon_0=0.000000000 +x_0=0.000 +y_0=0.000 +units=m +no_defs",
    MOOREA87U6S: "+title=Moorea 1987 - UTM fuseau 6 Sud +proj=tmerc +towgs84=215.9820,149.5930,176.2290,3.2624,1.6920,1.1571,10.477300 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    NUKU72U7S: "+title=IGN 1972 Nuku Hiva - UTM fuseau 7 Sud +proj=tmerc +towgs84=165.7320,216.7200,180.5050,-0.6434,-0.4512,-0.0791,7.420400 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    // REUN47GAUSSL : "+title=Reunion Gauss Laborde +proj=gstmerc +towgs84=789.5240,-626.4860,-89.9040,0.6006,76.7946,-10.5788,-32.324100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-21.116666667 +lon_0=55.533333333 +k_0=1.00000000 +x_0=160000.000 +y_0=50000.000 +units=m +no_defs",
    RGM04UTM38S: "+title=UTM fuseau 38 Sud (Reseau Geodesique de Mayotte 2004) +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM57S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 57 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=159.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM58S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 58 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=165.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGNCUTM59S: "+title=Reseau Geodesique de Nouvelle-Caledonie - UTM fuseau 59 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=171.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM5S: "+title=RGPF - UTM fuseau 5 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM6S: "+title=RGPF - UTM fuseau 6 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGPFUTM7S: "+title=RGPF - UTM fuseau 7 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-141.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGR92UTM40S: "+title=RGR92 UTM fuseau 40 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    RGSPM06U21: "+title=Saint-Pierre-et-Miquelon (2006) UTM Fuseau 21 Nord +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    STPL69UTM43S: "+title=Saint-Paul 1969 UTM fuseau 43 Sud +proj=tmerc +towgs84=225.571,-346.608,-46.567,0,0,0,0 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    STPM50UTM21: "+title=St Pierre et Miquelon 1950 +proj=tmerc +towgs84=-95.5930,573.7630,173.4420,-0.9602,1.2510,-1.3918,42.626500 +a=6378206.4000 +rf=294.9786982000000 +lat_0=0.000000000 +lon_0=-57.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    TAHAAUTM05S: "+title=Tahaa 1951 +proj=tmerc +towgs84=72.4380,345.9180,79.4860,-1.6045,-0.8823,-0.5565,1.374600 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-153.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TAHI51UTM06S: "+title=Tahiti-Terme Nord UTM fuseau 6 Sud +proj=tmerc +towgs84=162.0000,117.0000,154.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TAHI79UTM6S: "+title=Tahiti 1979 +proj=tmerc +towgs84=221.5250,152.9480,176.7680,2.3847,1.3896,0.8770,11.474100 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-147.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    TERA50STEREO: "+title=Terre Adelie 1950 +proj=stere +towgs84=324.9120,153.2820,172.0260 +a=6378388.0000 +rf=297.0000000000000 +lat_0=-90.000000000 +lon_0=140.000000000 +lat_ts=-67 +k=0.96027295 +x_0=300000.000 +y_0=-2299363.482 +units=m +no_defs",
    UTM01SW84: "+title=World Geodetic System 1984 UTM fuseau 01 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM20W84GUAD: "+title=World Geodetic System 1984 UTM fuseau 20 Nord-Guadeloupe +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM20W84MART: "+title=World Geodetic System 1984 UTM fuseau 20 Nord-Martinique +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-63.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM22RGFG95: "+title=RGFG95 UTM fuseau 22 Nord-Guyane +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM39SW84: "+title=World Geodetic System 1984 UTM fuseau 39 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=51.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM42SW84: "+title=World Geodetic System 1984 UTM fuseau 42 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=69.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    UTM43SW84: "+title=World Geodetic System 1984 UTM fuseau 43 Sud +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=75.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    WALL78UTM1S: "+title=Wallis-Uvea 1978 (MOP78) UTM 1 SUD +proj=tmerc +towgs84=253.0000,-133.0000,-127.0000 +a=6378388.0000 +rf=297.0000000000000 +lat_0=0.000000000 +lon_0=-177.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=10000000.000 +units=m +no_defs",
    ETRS89GEO: "+title=ETRS89 geographiques (dms) +proj=longlat +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +units=m +no_defs",
    ETRS89LAEA: "+title=ETRS89 Lambert Azimutal Equal Area +proj=laea +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=10.000000000 +x_0=4321000.000 +y_0=3210000.000 +units=m +no_defs",
    ETRS89LCC: "+title=ETRS89 Lambert Conformal Conic +proj=lcc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=52.000000000 +lon_0=9.999999995 +lat_1=35.000000000 +lat_2=65.000000000 +x_0=4000000.000 +y_0=2800000.000 +units=m +no_defs",
    UTM26ETRS89: "+title=Europe - de 30d a 24d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM27ETRS89: "+title=Europe - de 24d a 18d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM28ETRS89: "+title=Europe - de 18d a 12d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM29ETRS89: "+title=Europe - de 12d a 6d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM30ETRS89: "+title=Europe - de -6d a 0d Ouest +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=-3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM31ETRS89: "+title=Europe - de 0d a 6d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=3.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM32ETRS89: "+title=Europe - de 6d a 12d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=9.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM33ETRS89: "+title=Europe - de 12d a 18d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=15.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM34ETRS89: "+title=Europe - de 18d a 24d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=21.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM35ETRS89: "+title=Europe - de 24d a 30d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=27.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM36ETRS89: "+title=Europe - de 30d a 36d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=33.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM37ETRS89: "+title=Europe - de 36d a 42d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=39.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs",
    UTM38ETRS89: "+title=Europe - de 42d a 48d Est +proj=tmerc +nadgrids=null +wktext +towgs84=0.0000,0.0000,0.0000 +a=6378137.0000 +rf=298.2572221010000 +lat_0=0.000000000 +lon_0=45.000000000 +k_0=0.99960000 +x_0=500000.000 +y_0=0.000 +units=m +no_defs"
  }
};
var Register_default = Register;

// node_modules/geopf-extensions-openlayers/src/packages/CRS/CRS.js
var logger13 = LoggerByDefault_default2.getLogger("CRS");
var CRS = {
  /**
  * List of extent projections
  */
  projectionsExtent: {
    "EPSG:2154": {
      left: -9.62,
      bottom: 41.18,
      right: 10.3,
      top: 51.54
    },
    "EPSG:27572": {
      left: -4.87,
      bottom: 42.33,
      right: 8.23,
      top: 51.14
    }
  },
  /**
  * Load all custom definition projection
  */
  load: function() {
    logger13.trace("Loading custom definitions projections");
    if (!Register_default.isLoaded) {
      Register_default.load(lib_default);
      try {
        register(lib_default);
        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = register;
          window.ol.proj.proj4.register(lib_default);
        }
      } catch (e) {
        logger13.error(e);
      }
    }
  },
  /**
  * Load definition projection by default
  *
  * include into proj4 :
  * - WGS84
  * - ['EPSG:4326']
  * - ['EPSG:3785'], ['EPSG:3857'], GOOGLE, ['EPSG:900913'], ['EPSG:102113']
  * +
  * - ["EPSG:2154"], ["EPSG:27571"],  ["EPSG:27572"],  ["EPSG:27573"],  ["EPSG:2757"],
  * - ["CRS:84"],
  * - ["IGNF:LAMB93"],
  * - ["IGNF:LAMBE"], ["IGNF:LAMB1"],  ["IGNF:LAMB2"],  ["IGNF:LAMB3"],  ["IGNF:LAMB4"],
  * - ["IGNF:RGF93G"],
  * - ["IGNF:WGS84G"]
  */
  loadByDefault: function() {
    logger13.trace("Loading custom definitions projections by default");
    if (!Register_default.isLoaded) {
      Register_default.loadByDefault(lib_default);
      try {
        register(lib_default);
        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = register;
          window.ol.proj.proj4.register(lib_default);
        }
      } catch (e) {
        logger13.error(e);
      }
    }
  },
  /**
  * Load a custom definition projection
  * @param {String} name - ie. EPSG:2154 (Lambert)
  */
  loadByName: function(name) {
    logger13.trace("Loading a custom definition projection : ", name);
    if (!Register_default.isLoaded) {
      Register_default.loadByName(lib_default, name);
      try {
        register(lib_default);
        if (window.ol && window.ol.proj && window.ol.proj.proj4) {
          window.ol.proj.proj4.register = register;
          window.ol.proj.proj4.register(lib_default);
        }
      } catch (e) {
        logger13.error(e);
      }
    }
  },
  /**
   * Overload OpenLayers ol.proj parameters,
   * to manage EPSG:2154 extent restriction
   */
  overload: function() {
    logger13.trace("Loading projections aera (extent)");
    for (var code in this.projectionsExtent) {
      if (this.projectionsExtent.hasOwnProperty(code)) {
        var extent = this.projectionsExtent[code];
        var proj = get2(code);
        var fromLonLat2 = getTransform("EPSG:4326", proj);
        var _extent = applyTransform([extent.bottom, extent.right, extent.top, extent.left], fromLonLat2);
        proj.setExtent(_extent);
        addProjection(proj);
        if (window.ol && window.ol.proj && window.ol.proj.addProjection) {
          window.ol.proj.addProjection(proj);
        }
      }
    }
  }
};
var CRS_default = CRS;
if (window.ol && window.ol.proj && window.ol.proj.proj4) {
  window.ol.proj.proj4.register = register;
}

// node_modules/geopf-extensions-openlayers/src/packages/Services/Search.js
var m_suggestions = [];
var controller = new AbortController();
var m_index = "geoplateforme";
var m_fields = "title,layer_name";
var m_size = "1000";
var m_maximumResponses = 10;
var m_filterByService = ["WMTS", "TMS"];
var m_filterByProjection = [];
var m_filterByLayerPriority = [];
var m_filterWMTSPriority = false;
var m_filterTMS = true;
var m_url = `https://data.geopf.fr/recherche/api/indexes/${m_index}/suggest`;
var target = new EventTarget();
var suggest = async (text) => {
  clear();
  controller = new AbortController();
  let url = new URL(m_url);
  let params2 = {
    text,
    fields: m_fields,
    size: m_size
  };
  Object.keys(params2).forEach((key) => url.searchParams.append(key, params2[key]));
  var response = await fetch(url, {
    // FIXME
    // signal : controller.signal
  });
  var results = await response.json();
  if (response.status !== 200) {
    throw new Error(response.message);
  }
  if (!results || results.length === 0) {
    return;
  }
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    const found = m_filterByLayerPriority.findIndex((element) => {
      return element.includes(result.source.layer_name);
    });
    if (found >= 0) {
      results[i].score += 100;
    }
  }
  results.sort((a2, b3) => b3.score - a2.score);
  var filter = null;
  if (m_filterWMTSPriority) {
    filter = inventory(results);
  }
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    var services = m_filterByService.length === 0 || m_filterByService.includes(result.source.type);
    if (services) {
      if (unique().length >= m_maximumResponses) {
        break;
      }
      var o = {
        attribution: result.source.attribution || {},
        srs: result.source.srs || [],
        keywords: result.source.keywords || [],
        extent: result.source.extent || {},
        metadata: result.source.metadata_urls || [],
        // mapping
        name: result.source.layer_name || "",
        title: result.source.title || "",
        description: result.source.description,
        service: result.source.type || "",
        // mapping
        url: result.source.url || "",
        tech: result.source.tech || {},
        // FIXME extra ?
        tags: result.source.tags || {},
        theme: result.source.theme || "",
        producer: result.source.producer || ""
      };
      if (m_filterByProjection.length) {
        if (m_filterByProjection.includes(o.srs[0])) {
          continue;
        }
      }
      if (filter && filter[o.name] && o.service === "WMS") {
        continue;
      }
      if (o.service === "TMS") {
        o.styles = false;
        if (o.metadata.length !== 0 && /(\.json)$/i.test(o.metadata[0])) {
          o.styles = true;
        }
        if (!o.styles && m_filterTMS) {
          continue;
        }
      }
      if (o.service === "WMTS") {
        if (o.metadata.length !== 0 && /(.json)$/i.test(o.metadata[0]) && m_filterTMS === true) {
          continue;
        }
      }
      m_suggestions.push(o);
    }
  }
  target.dispatchEvent(
    new CustomEvent("suggest", {
      bubbles: true,
      detail: getSuggestions()
    })
  );
  return getSuggestions();
};
var unique = () => {
  return m_suggestions.filter(
    (value2, index2, self2) => index2 === self2.findIndex((t) => t.service === value2.service && t.name === value2.name && t.title === value2.title && t.description === value2.description)
  );
};
var clear = () => {
  controller.abort();
  m_suggestions = [];
};
var inventory = (results) => {
  var inventory2 = {};
  for (let i = 0; i < results.length; i++) {
    const type = results[i].source.type;
    const name = results[i].source.layer_name;
    if (type === "WMTS" || type === "WMS") {
      if (inventory2[name] === void 0) {
        inventory2[name] = type === "WMTS";
      }
      inventory2[name] || (inventory2[name] = type === "WMTS");
    }
  }
  return inventory2;
};
var getSuggestions = () => {
  return unique();
};
var getNames = () => {
  return unique().map((o) => {
    return o.name;
  });
};
var getTitles = () => {
  return unique().map((o) => {
    return o.title;
  });
};
var setIndex = (value2) => {
  m_index = value2;
};
var setFields = (value2) => {
  m_fields = value2;
};
var setSuggestions = (value2) => {
  m_suggestions = value2;
};
var setSize = (value2) => {
  m_size = parseInt(value2);
};
var setUrl = (value) => {
  m_url = eval("`" + value + "`");
};
var setMaximumResponses = (value2) => {
  m_maximumResponses = parseInt(value2);
};
var setFiltersByService = (value2) => {
  m_filterByService = value2 === "" ? [] : value2.split(",");
};
var setFiltersByProjection = (value2) => {
  m_filterByProjection = value2 === "" ? [] : value2.split(",");
};
var setFiltersByLayerPriority = (value2) => {
  m_filterByLayerPriority = value2 === "" ? [] : value2.split(",");
};
var setFilterWMTSPriority = (value2) => {
  m_filterWMTSPriority = value2;
};
var setFilterTMS = (value2) => {
  m_filterTMS = value2;
};
var Search_default = {
  target,
  suggest,
  clear,
  getSuggestions,
  getNames,
  getTitles,
  setIndex,
  setFields,
  setSuggestions,
  setSize,
  setUrl,
  setMaximumResponses,
  setFiltersByService,
  setFiltersByProjection,
  setFiltersByLayerPriority,
  setFilterWMTSPriority,
  setFilterTMS
};

// node_modules/geopf-extensions-openlayers/src/packages/Controls/SearchEngine/SearchEngineDOM.js
var SearchEngineDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPsearchEngine");
    container.className = "GPwidget gpf-widget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * SElement with picto and search input
   * @returns {HTMLElement} DOM element
   */
  _createSearchDivElement: function() {
    var searchDiv = document.createElement("div");
    searchDiv.id = this._addUID("GPshowSearchDiv");
    return searchDiv;
  },
  /**
   * Show search engine
   * @param {Boolean} collapsible - ...
   * @returns {HTMLElement} DOM element
   */
  _createShowSearchEnginePictoElement: function(collapsible) {
    var self2 = this;
    if (CheckDsfr_default()) {
      collapsible = true;
    }
    var button = document.createElement("button");
    button.id = this._addUID("GPshowSearchEnginePicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowSearchEnginePicto gpf-btn gpf-btn-icon-search fr-btn";
    button.title = "Afficher/masquer la recherche par lieux";
    if (CheckDsfr_default()) {
      button.title = "Rechercher";
    }
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", !collapsible);
    button.disabled = !collapsible;
    button.setAttribute("type", "button");
    button.addEventListener("click", function(e) {
      if (CheckDsfr_default()) {
        var container = document.getElementById(self2._addUID("GPautocompleteResults"));
        var curr = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current");
        var list = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine");
        var length = list.length;
        if (!length) {
          return;
        }
        var current = null;
        if (!curr.length) {
          current = list[0];
          current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
          current.style.color = "#000000";
          current.style["background-color"] = "#CEDBEF";
        } else {
          current = curr[0];
        }
        current.click();
        return;
      }
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      if (status) {
      }
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      var showAdvancedSearch = document.getElementById(self2._addUID("GPshowAdvancedSearch"));
      if (showAdvancedSearch) {
        showAdvancedSearch.style.display = null;
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
      }
      var showGeolocate = document.getElementById(self2._addUID("GPshowGeolocate"));
      if (showGeolocate) {
        showGeolocate.style.display = null;
      }
      var showCoordinate = document.getElementById(self2._addUID("GPshowSearchByCoordinate"));
      if (showCoordinate) {
        showCoordinate.style.display = null;
      }
      var id = "#GPsearchInput-" + self2._uid;
      document.querySelector(id + " input").disabled = false;
      if (CheckDsfr_default()) {
        document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
      }
      self2.onShowSearchEngineClick(e);
    });
    return button;
  },
  /**
   * Simple search input
   * @param {String} placeholder - placeholder
   *
   * @returns {HTMLElement} DOM element
   */
  _createSearchInputElement: function(placeholder) {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPsearchInput");
    form.className = "gpf-panel__content fr-modal__content";
    form.addEventListener("submit", function(e) {
      e.preventDefault();
      if (document.getElementById(self2._addUID("GPsearchInputText")).value === "") {
        return false;
      }
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementHidden", "GPelementVisible");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-hidden", "gpf-visible");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      self2.onGeocodingSearchSubmit(e);
      return false;
    });
    var input = document.createElement("input");
    input.id = this._addUID("GPsearchInputText");
    input.className = "GPsearchInputText gpf-input fr-input";
    input.type = "text";
    input.placeholder = placeholder;
    input.autocomplete = "off";
    input.addEventListener("keyup", function(e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
        return;
      }
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      if (input.value.length > 2) {
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-hidden", "gpf-visible");
      } else {
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      }
      self2.onAutoCompleteSearchText(e);
    });
    var lastFocusedElement = null;
    document.addEventListener("pointerdown", function(e) {
      lastFocusedElement = e.target;
    });
    input.addEventListener("blur", function(e) {
      if (!lastFocusedElement.classList.contains("GPautoCompleteProposal")) {
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      }
    });
    input.addEventListener("keydown", function(e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13) {
        e.preventDefault();
      }
      var container = document.getElementById(self2._addUID("GPautocompleteResults"));
      if (!container) {
        return;
      }
      var curr = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current");
      var list = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine");
      var length = list.length;
      if (!length) {
        return;
      }
      var current = null;
      if (!curr.length) {
        current = list[0];
        current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
        current.style.color = "#000000";
        current.style["background-color"] = "#CEDBEF";
        if (charCode !== 13) {
          return;
        }
      } else {
        current = curr[0];
      }
      var index2 = parseInt(SelectorID_default.index(current.id), 10);
      var next = index2 === length - 1 ? list[0] : list[index2 + 1];
      var prev = index2 === 0 ? list[length - 1] : list[index2 - 1];
      current.style["background-color"] = "";
      current.style.color = "";
      prev.style["background-color"] = "";
      prev.style.color = "";
      next.style["background-color"] = "";
      next.style.color = "";
      switch (charCode) {
        case 38:
          current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
          prev.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
          prev.style.color = "#000000";
          prev.style["background-color"] = "#CEDBEF";
          current.scrollIntoView();
          break;
        case 40:
          current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
          next.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
          next.style.color = "#000000";
          next.style["background-color"] = "#CEDBEF";
          current.scrollIntoView();
          break;
        case 13:
          e.preventDefault();
          current.click(e);
          break;
      }
      current.focus();
    });
    form.appendChild(input);
    return form;
  },
  _createSearchResetElement: function() {
    var self2 = this;
    var buttonReset = document.createElement("button");
    buttonReset.id = this._addUID("GPsearchInputReset");
    buttonReset.className = "GPshowOpen GPsearchInputReset gpf-btn gpf-btn-icon-reset gpf-btn-icon-search-reset fr-btn fr-btn--secondary gpf-btn--secondary";
    buttonReset.setAttribute("aria-label", "Supprimer la recherche");
    buttonReset.addEventListener("click", function(e) {
      document.getElementById(self2._addUID("GPsearchInputText")).value = "";
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      self2.onSearchResetClick();
    });
    return buttonReset;
  },
  _createButtonsElement: function() {
    var div = document.createElement("div");
    div.className = "GPbuttonsContainer";
    return div;
  },
  _createFirstLineWrapper: function() {
    var div = document.createElement("div");
    div.className = "GPsearchFirstLineWrapper";
    return div;
  },
  _createRadioContainer: function() {
    var div = document.createElement("div");
    div.className = "GPsearchRadioContainer";
    return div;
  },
  _createRadioElements: function() {
    var div = document.createElement("div");
    div.className = "GPsearchRadioElements";
    var choiceLocations = document.createElement("div");
    choiceLocations.className = "GPsearchSplitChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
    var inputLocations = document.createElement("input");
    inputLocations.id = this._addUID("GPsearchSplitLocations");
    inputLocations.type = "radio";
    inputLocations.name = "GPsearchSplit";
    inputLocations.value = "address";
    inputLocations.checked = true;
    choiceLocations.appendChild(inputLocations);
    var labelLocations = document.createElement("label");
    labelLocations.className = "gpf-label fr-label";
    labelLocations.htmlFor = this._addUID("GPsearchSplitLocations");
    labelLocations.title = "Adresses";
    labelLocations.innerHTML = "Adresses";
    choiceLocations.appendChild(labelLocations);
    if (inputLocations.addEventListener) {
      inputLocations.addEventListener("change", function() {
        if (inputLocations.checked) {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.add("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.remove("gpf-hidden", "GPelementHidden");
        } else {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.remove("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.add("gpf-hidden", "GPelementHidden");
        }
      });
    } else if (inputLocations.attachEvent) {
      inputLocations.attachEvent("onchange", function() {
        if (inputLocations.checked) {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.add("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.remove("gpf-hidden", "GPelementHidden");
        } else {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.remove("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.add("gpf-hidden", "GPelementHidden");
        }
      });
    }
    var choiceData = document.createElement("div");
    choiceData.className = "GPsearchSplitChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
    var inputData = document.createElement("input");
    inputData.id = this._addUID("GPsearchSplitData");
    inputData.type = "radio";
    inputData.name = "GPsearchSplit";
    inputData.value = "data";
    choiceData.appendChild(inputData);
    var labelData = document.createElement("label");
    labelData.className = "gpf-label fr-label";
    labelData.htmlFor = this._addUID("GPsearchSplitData");
    labelData.title = "Cartes et donnÃ©es";
    labelData.innerHTML = "Cartes et donnÃ©es";
    choiceData.appendChild(labelData);
    if (inputData.addEventListener) {
      inputData.addEventListener("change", function() {
        if (inputData.checked) {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.remove("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.add("gpf-hidden", "GPelementHidden");
        } else {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.add("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.remove("gpf-hidden", "GPelementHidden");
        }
      });
    } else if (inputData.attachEvent) {
      inputData.attachEvent("onchange", function() {
        if (inputData.checked) {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.remove("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.remove("gpf-hidden", "GPelementHidden");
        } else {
          document.querySelector("[id^='GPautocompleteResultsSuggest']").classList.remove("gpf-hidden", "GPelementHidden");
          document.querySelector("[id^='GPautocompleteResultsLocation']").classList.add("gpf-hidden", "GPelementHidden");
        }
      });
    }
    div.appendChild(choiceLocations);
    div.appendChild(choiceData);
    return [div, inputLocations, inputData];
  },
  /**
   * Show advanced search panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowAdvancedSearchElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowAdvancedSearch");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowAdvancedSearch GPshowOpen gpf-btn gpf-btn-icon-search-advanced fr-btn fr-btn--secondary gpf-btn--secondary fr-m-1w";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      var id = "#GPsearchInput-" + self2._uid;
      if (status) {
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
        document.querySelector(id + " input").disabled = false;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = false;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
      } else {
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-hidden", "gpf-visible");
        document.querySelector(id + " input").disabled = true;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = true;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = true;
        }
      }
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      var panelCoordinate = document.getElementById(self2._addUID("GPcoordinateSearchPanel"));
      if (panelCoordinate) {
        panelCoordinate.classList.replace("GPelementVisible", "GPelementHidden");
        panelCoordinate.classList.replace("gpf-visible", "gpf-hidden");
      }
      var btnCoordinate = document.getElementById(self2._addUID("GPshowSearchByCoordinate"));
      if (btnCoordinate) {
        btnCoordinate.setAttribute("aria-pressed", false);
      }
    });
    return button;
  },
  /**
   * Show geolocate button
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowGeolocateElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowGeolocate");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowGeolocate gpf-btn gpf-btn-icon-search-geolocate fr-btn fr-btn--secondary gpf-btn--secondary fr-m-1w";
    button.title = "Activer la gÃ©olocalisation";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      if (status) {
      }
      self2.onShowSearchGeolocateClick(e);
    });
    return button;
  },
  /**
   * Show search by coordinate button
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowSearchByCoordinateElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowSearchByCoordinate");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowSearchByCoordinate gpf-btn gpf-btn-icon-search-coordinate fr-btn fr-btn--secondary gpf-btn--secondary fr-m-1w";
    button.title = "Ouvrir la recherche par coordonnÃ©es";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      var id = "#GPsearchInput-" + self2._uid;
      if (status) {
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
        document.querySelector(id + " input").disabled = false;
        document.querySelector(id + " .GPsearchInputReset").disabled = false;
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
      } else {
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("gpf-hidden", "gpf-visible");
        document.querySelector(id + " input").disabled = true;
        document.querySelector(id + " .GPsearchInputReset").disabled = true;
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = true;
        }
      }
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
      document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
      document.getElementById(self2._addUID("GPshowAdvancedSearch")).setAttribute("aria-pressed", false);
    });
    return button;
  },
  // ################################################################### //
  // ################### Methods of advanced search #################### //
  // ################################################################### //
  /**
   * Advanced search panel
   *
   * FIXME
   * don't call this._createAdvancedSearchPanelHeaderElement
   * don't call this._createAdvancedSearchPanelFormElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchPanelElement: function() {
    var div = document.createElement("dialog");
    div.id = this._addUID("GPadvancedSearchPanel");
    div.className = "GPpanel GPelementHidden gpf-panel gpf-hidden fr-modal";
    return div;
  },
  _createAdvancedSearchPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Geocoding results
   *
   * FIXME
   * don't call this._createGeocodeResultsListElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createGeocodeResultsElement: function() {
    var div = document.createElement("dialog");
    div.id = this._addUID("GPgeocodeResultsList");
    div.className = "GPpanel GPelementHidden gpf-panel gpf-hidden fr-modal";
    return div;
  },
  _createGeocodeResultsDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    div.appendChild(this._createGeocodeResultsHeaderElement());
    return div;
  },
  /**
   * Autocompletion results
   *
   * FIXME
   * don't call this._createAutoCompleteListElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createAutoCompleteElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPautoCompleteList");
    div.className = "GPautoCompleteList GPelementHidden gpf-panel fr-modal gpf-hidden ";
    return div;
  },
  /**
   * Coordinate search panel
   *
   * FIXME
   * don't call this._createCoordinateSearchPanelHeaderElement
   * don't call this._createCoordinateSearchPanelFormElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createCoordinateSearchPanelElement: function() {
    var div = document.createElement("dialog");
    div.id = this._addUID("GPcoordinateSearchPanel");
    div.className = "GPpanel GPelementHidden gpf-panel gpf-hidden fr-modal";
    return div;
  },
  _createCoordinateSearchPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  // ################################################################### //
  // ################### Autocompletion container ###################### //
  // ################################################################### //
  /**
   * Autocompletion results list.
   *
   * @returns {HTMLElement} DOM element
   */
  _createAutoCompleteListElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.id = this._addUID("GPautocompleteResults");
    container.className = "";
    if (container.addEventListener) {
      container.addEventListener("click", function(e) {
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      }, false);
    } else if (container.attachEvent) {
      container.attachEvent("onclick", function(e) {
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPautoCompleteList")).classList.replace("gpf-visible", "gpf-hidden");
      });
    }
    return container;
  },
  _createAutoCompletedLocationContainer() {
    var container = document.createElement("div");
    container.id = this._addUID("GPautocompleteResultsLocation");
    container.className = "GPelementHidden gpf-hidden gpf-select";
    container.size = 20;
    container.autofocus = true;
    return container;
  },
  _createAutoCompletedLocationTitleElement() {
    var container = document.getElementById(this._addUID("GPautocompleteResultsLocation"));
    var label = document.createElement("p");
    label.className = "GPlabel GPlabelTitle gpf-label fr-label search-results-loc";
    label.innerHTML = "Lieux et adresses";
    container.appendChild(label);
  },
  /**
   * Autocompletion result.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   * TODO formaliser le contenu des reponse
   *
   * @param {Object} location - suggested or geocoded location results
   * @param {Number} id - ID
   */
  _createAutoCompletedLocationElement: function(location, id) {
    var self2 = this;
    var container = document.getElementById(this._addUID("GPautocompleteResultsLocation"));
    var div = document.createElement("p");
    div.id = this._addUID("AutoCompletedLocation_" + id);
    div.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
    var value2 = GeocodeUtils_default.getSuggestedLocationFreeform(location);
    div.innerHTML = value2;
    div.title = value2;
    if (div.addEventListener) {
      div.addEventListener("click", function(e) {
        self2.onAutoCompletedResultsItemClick(e);
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function(e) {
        self2.onAutoCompletedResultsItemClick(e);
      });
    }
    container.appendChild(div);
  },
  _createSearchedSuggestContainer() {
    var container = document.createElement("div");
    container.id = this._addUID("GPautocompleteResultsSuggest");
    container.className = "GPelementHidden gpf-hidden gpf-select";
    container.size = 6;
    container.autofocus = true;
    return container;
  },
  _createSearchedSuggestTitleElement() {
    var container = document.getElementById(this._addUID("GPautocompleteResultsSuggest"));
    var label = document.createElement("p");
    label.className = "GPlabel GPlabelTitle gpf-label fr-label search-results-data";
    label.innerHTML = "Cartes et donnÃ©es";
    container.appendChild(label);
  },
  /**
   * Autocompletion result of search service.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   *
   * @param {Object} suggest - suggested results
   * @param {Number} id - ID
   */
  _createSearchedSuggestElement: function(suggest2, id) {
    var self2 = this;
    var container = document.getElementById(this._addUID("GPautocompleteResultsSuggest"));
    var div = document.createElement("p");
    div.id = this._addUID("AutoCompletedSuggest_" + id);
    div.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
    div.innerHTML = suggest2.title + " (" + suggest2.service + ")";
    div.dataset.layer = suggest2.name;
    div.title = `${suggest2.description} (nom technique : ${suggest2.name})`;
    if (div.addEventListener) {
      div.addEventListener("click", function(e) {
        self2.onSearchedResultsItemClick(e);
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function(e) {
        self2.onSearchedResultsItemClick(e);
      });
    }
    container.appendChild(div);
  },
  // ################################################################### //
  // ############### Geocoding with advanced container ################# //
  // ################################################################### //
  /**
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchPanelHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    divTitle.innerHTML = "Recherche avancÃ©e";
    container.appendChild(divTitle);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPadvancedSearchClose");
    divClose.className = "GPpanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer la recherche avancÃ©e";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        var id = "#GPsearchInput-" + self2._uid;
        document.querySelector(id + " input").disabled = false;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = false;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
        document.getElementById(self2._addUID("GPshowAdvancedSearch")).setAttribute("aria-pressed", false);
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        var id = "#GPsearchInput-" + self2._uid;
        document.querySelector(id + " input").disabled = false;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = false;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
        document.getElementById(self2._addUID("GPshowAdvancedSearch")).setAttribute("aria-pressed", false);
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPadvancedSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * @param {Object[]} advancedSearchCodes - codes
   * @param {Boolean} coordinateSearchInAdvancedSearch - coords in advanced search?
   *
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchPanelFormElement: function(advancedSearchCodes, coordinateSearchInAdvancedSearch) {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPadvancedSearchForm");
    form.className = "gpf-panel__content fr-modal__content";
    form.addEventListener("submit", function(e) {
      e.preventDefault();
      var data = [];
      var id = "#GPadvancedSearchFilters-" + self2._uid;
      var matchesFilters = document.querySelectorAll(id + " > div > div > input,select#category");
      for (var i = 0; i < matchesFilters.length; i++) {
        var element = matchesFilters[i];
        data.push({
          key: element.name,
          value: element.value
        });
      }
      self2.onGeocodingAdvancedSearchSubmit(e, data);
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementHidden", "GPelementVisible");
      document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-hidden", "gpf-visible");
      return false;
    });
    var div = document.createElement("div");
    div.className = "GPflexInput gpf-flex-column ";
    var label = document.createElement("label");
    label.className = "GPadvancedSearchCodeLabel gpf-label fr-label";
    label.innerHTML = "Recherche par";
    div.appendChild(label);
    var select = this._createAdvancedSearchFormCodeElement(advancedSearchCodes, coordinateSearchInAdvancedSearch);
    div.appendChild(select);
    form.appendChild(div);
    return form;
  },
  /**
   * @param {Object[]} codes - codes
   * @param {Boolean} coordinateSearchInAdvancedSearch - coords in advanced search?
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchFormCodeElement: function(codes2, coordinateSearchInAdvancedSearch) {
    var self2 = this;
    var select = document.createElement("select");
    select.id = this._addUID("GPadvancedSearchCode");
    select.title = "Choisir un type de recherche";
    select.className = "GPadvancedSearchCode gpf-select fr-select";
    select.addEventListener("change", function(e) {
      self2.onGeocodingAdvancedSearchCodeChange(e);
    }, false);
    if (!codes2) {
      codes2 = [{
        id: "PositionOfInterest",
        title: "Lieux/toponymes"
      }, {
        id: "StreetAddress",
        title: "Adresses"
      }, {
        id: "CadastralParcel",
        title: "Parcelles cadastrales"
      }];
    }
    for (var i = 0; i < codes2.length; i++) {
      var option2 = document.createElement("option");
      option2.value = codes2[i].id;
      option2.text = codes2[i].title;
      select.appendChild(option2);
    }
    if (coordinateSearchInAdvancedSearch) {
      var option2 = document.createElement("option");
      option2.value = "Coordinates";
      option2.text = "CoordonnÃ©es";
      select.appendChild(option2);
    }
    return select;
  },
  /**
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchFormInputElement: function() {
    var input = document.createElement("input");
    input.type = "submit";
    input.id = this._addUID("GPadvancedSearchSubmit");
    input.className = "GPsubmit gpf-btn gpf-btn-icon-submit  fr-btn fr-btn--secondary gpf-btn--secondary";
    input.value = "Chercher";
    return input;
  },
  /**
   * Filters geocoding.
   *
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchFormFiltersElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPadvancedSearchFilters");
    return container;
  },
  /**
   * Create filter container for resources :
   * "PositionOfInterest", "StreetAddress", ...
   *
   * @param {String} code - code of geocoding resource
   * @param {Boolean} display - display
   *
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchFiltersTableElement: function(code, display) {
    var container = document.createElement("div");
    container.id = this._addUID(code);
    if (!display) {
      container.style.display = "none";
    }
    return container;
  },
  /**
   * Create filter attribut for a resource :
   * "PositionOfInterest", "StreetAddress", ...
   * Research filters are filled in Javascript depending on developer choice
   *
   * @param {Object} filterAttributes - filter attributes :
   * @param {String} filterAttributes.code - code of geocoding resource
   * @param {String} filterAttributes.name - ID
   * @param {String} filterAttributes.title - label
   * @param {String} filterAttributes.description - description
   * @param {String} filterAttributes.value - value
   *
   * @returns {HTMLElement} DOM element
   */
  _createAdvancedSearchFiltersAttributElement: function(filterAttributes) {
    var container = null;
    var name = filterAttributes.name;
    var title3 = filterAttributes.title;
    var description = filterAttributes.description;
    var code = filterAttributes.code;
    var value2 = filterAttributes.value;
    var div = document.createElement("div");
    div.className = "GPflexInput gpf-flex-column ";
    var label = document.createElement("label");
    label.className = "GPadvancedSearchFilterLabel gpf-label fr-label";
    label.htmlFor = name;
    label.title = description || title3;
    label.innerHTML = title3;
    div.appendChild(label);
    if (name === "category") {
      var select = document.createElement("select");
      select.id = name;
      select.name = name;
      select.title = title3;
      select.className = "GPadvancedSearchFilterInput gpf-select fr-select";
      if (value2) {
        if (Array.isArray(value2)) {
          for (var i = 0; i < value2.length; i++) {
            var option2 = document.createElement("option");
            option2.value = value2[i];
            option2.text = value2[i];
            select.appendChild(option2);
          }
        }
      }
      div.appendChild(select);
    } else {
      var input = document.createElement("input");
      input.id = name;
      input.className = "GPadvancedSearchFilterInput gpf-input fr-input";
      input.type = "text";
      input.name = name;
      if (value2) {
        if (Array.isArray(value2)) {
          var listId = name + "_list";
          input.setAttribute("list", listId);
          var dl = document.createElement("datalist");
          dl.id = listId;
          for (var i = 0; i < value2.length; ++i) {
            var option2 = document.createElement("option");
            option2.value = value2[i];
            dl.appendChild(option2);
          }
          div.appendChild(dl);
        } else {
          input.value = value2;
        }
      }
      div.appendChild(input);
    }
    container = document.getElementById(this._addUID(code));
    if (container) {
      container.appendChild(div);
    } else {
      container = div;
    }
    return container;
  },
  // ################################################################### //
  // ################## Geocoding results container #################### //
  // ################################################################### //
  /**
   * @returns {HTMLElement} DOM element
   */
  _createGeocodeResultsHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    divTitle.innerHTML = "RÃ©sultats de la recherche";
    container.appendChild(divTitle);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPgeocodeResultsClose");
    divClose.className = "GPpanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer la fenÃªtre de rÃ©sultats";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Geocoding results list.
   *
   * @returns {HTMLElement} DOM element
   */
  _createGeocodeResultsListElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.id = this._addUID("GPgeocodeResults");
    container.className = "gpf-panel__list";
    container.setAttribute("tabindex", "0");
    if (container.addEventListener) {
      container.addEventListener("click", function(e) {
        if (!e.ctrlKey) {
          document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
          document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
        }
        self2.onGeocodedResultsItemClick(e);
      }, false);
    } else if (container.attachEvent) {
      container.attachEvent("onclick", function(e) {
        if (!e.ctrlKey) {
          document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("GPelementVisible", "GPelementHidden");
          document.getElementById(self2._addUID("GPgeocodeResultsList")).classList.replace("gpf-visible", "gpf-hidden");
        }
        self2.onGeocodedResultsItemClick(e);
      });
    }
    return container;
  },
  /**
   * Geocoding result.
   * Results are dynamically filled in Javascript by geocoding service
   *
   * TODO formaliser le contenu des reponses
   * FIXME formater la reponse en amont !
   *
   * @param {Object} location - suggested or geocoded location results
   * @param {Number} id - ID
   */
  _createGeocodedLocationElement: function(location, id) {
    var container = document.getElementById(this._addUID("GPgeocodeResults"));
    var div = document.createElement("div");
    div.id = this._addUID("GeocodedLocation_" + id);
    div.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
    if (typeof location === "string") {
      div.innerHTML = location;
    } else {
      div.innerHTML = GeocodeUtils_default.getGeocodedLocationFreeform(location);
    }
    container.appendChild(div);
  },
  // ################################################################### //
  // ################## Coordinate search container #################### //
  // ################################################################### //
  _createCoordinateSearchPanelHeaderElement() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    divTitle.innerHTML = "Recherche par coordonnÃ©es";
    container.appendChild(divTitle);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPcoordinateSearchClose");
    divClose.className = "GPpanelClose GPcoordinateSearchClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer la recherche par coordonnÃ©es";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        var id = "#GPsearchInput-" + self2._uid;
        document.querySelector(id + " input").disabled = false;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = false;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
        document.getElementById(self2._addUID("GPshowSearchByCoordinate")).setAttribute("aria-pressed", false);
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
        self2.onCoordinateSearchClose();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        var id = "#GPsearchInput-" + self2._uid;
        document.querySelector(id + " input").disabled = false;
        if (document.querySelector(id + " .GPsearchInputReset")) {
          document.querySelector(id + " .GPsearchInputReset").disabled = false;
        }
        if (CheckDsfr_default()) {
          document.querySelector("#GPshowSearchEnginePicto-" + self2._uid).disabled = false;
        }
        document.getElementById(self2._addUID("GPshowSearchByCoordinate")).setAttribute("aria-pressed", false);
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPcoordinateSearchPanel")).classList.replace("gpf-visible", "gpf-hidden");
        self2.onCoordinateSearchClose();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  _createCoordinateSearchPanelFormElement() {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPcoordinateSearchForm");
    form.className = "gpf-panel__content fr-modal__content";
    form.addEventListener("submit", function(e) {
      e.preventDefault();
      self2.onShowSearchByCoordinateClick();
      return false;
    });
    return form;
  },
  __createCoordinateSearchDivElement() {
    var div = document.createElement("div");
    div.className = "GPflexInput gpf-flex-column ";
    return div;
  },
  _createCoordinateSearchSystemsLabelElement() {
    var label = document.createElement("label");
    label.className = "GPcoordinateSearchSystemsLabel gpf-label fr-label";
    label.innerHTML = "SystÃ¨me de rÃ©fÃ©rence";
    return label;
  },
  _setCoordinateSearchSystemsSelectElement(systems) {
    if (document.getElementById(this._addUID("GPcoordinateSearchSystem"))) {
      document.getElementById(this._addUID("GPcoordinateSearchSystem")).remove();
    }
    var context = this;
    var selectSystem = document.createElement("select");
    selectSystem.id = this._addUID("GPcoordinateSearchSystem");
    selectSystem.title = "Choisir un systÃ¨me de rÃ©ference";
    selectSystem.className = "GPselect GPcoordinateSearchSystemsSelect gpf-select fr-select";
    selectSystem.addEventListener("change", function(e) {
      context.onCoordinateSearchSystemChange(e);
    });
    for (var i = 0; i < systems.length; i++) {
      var obj = systems[i];
      var option2 = document.createElement("option");
      option2.value = obj.code;
      option2.text = obj.label || i;
      selectSystem.appendChild(option2);
    }
    return selectSystem;
  },
  _createCoordinateSearchUnitsLabelElement() {
    var label = document.createElement("label");
    label.className = "GPcoordinateSearchUnitsLabel gpf-label fr-label";
    label.innerHTML = "UnitÃ©s";
    return label;
  },
  _setCoordinateSearchUnitsSelectElement(units) {
    if (document.getElementById(this._addUID("GPcoordinateSearchUnits"))) {
      document.getElementById(this._addUID("GPcoordinateSearchUnits")).remove();
    }
    var context = this;
    var selectUnits = document.createElement("select");
    selectUnits.id = this._addUID("GPcoordinateSearchUnits");
    selectUnits.title = "Choisir un type d'unitÃ©";
    selectUnits.className = "GPselect GPcoordinateSearchUnitsSelect gpf-select fr-select";
    selectUnits.addEventListener("change", function(e) {
      context.onCoordinateSearchUnitsChange(e);
    });
    for (var j2 = 0; j2 < units.length; j2++) {
      var obj = units[j2];
      var option2 = document.createElement("option");
      option2.value = obj.code ? obj.code : j2;
      option2.text = obj.label || j2;
      selectUnits.appendChild(option2);
    }
    return selectUnits;
  },
  /**
   * update Label
   * @param {String} type - Geographical or Metric
   * @returns {HTMLElement} label
   */
  _setCoordinateSearchLngLabelElement(type) {
    if (document.getElementById(this._addUID("GPcoordinateSearchLngLabel"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLngLabel")).remove();
    }
    var labelLng = document.createElement("label");
    labelLng.className = "GPcoordinateSearchLabel gpf-label fr-label";
    labelLng.id = this._addUID("GPcoordinateSearchLngLabel");
    labelLng.htmlFor = "coordinate-lng";
    labelLng.innerHTML = type === "Geographical" ? "Longitude :" : "Y :";
    return labelLng;
  },
  /**
   * update Input coordinate
   * @param {String} code - ex. DMS : degrÃ©s sexadecimaux
   * @returns {HTMLElement} input
   */
  _setCoordinateSearchLngInputElement(code) {
    if (document.getElementById(this._addUID("GPcoordinateSearchLngInput"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLngInput")).remove();
    }
    if (document.getElementById(this._addUID("GPcoordinateSearchLngDMS"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLngDMS")).remove();
    }
    var input = document.createElement("input");
    input.id = this._addUID("GPcoordinateSearchLngInput");
    input.className = "GPcoordinateSearchInput gpf-input fr-input";
    input.title = "Saisir des coordonnÃ©es";
    input.name = "coordinate-lng";
    input.type = "number";
    input.step = "any";
    input.required = "";
    switch (code) {
      case "DMS":
        input.title += " gÃ©ographiques (en sexa)";
        input.className = "GPelementHidden gpf-hidden";
        return this._setCoordinateSearchLngDMSElement();
      case "DEC":
        input.title += " gÃ©ographiques (en decimal)";
        input.min = "-180";
        input.max = "180";
        break;
      case "M":
        input.title += " cartÃ©siennes (en mÃ¨tre)";
        break;
      case "KM":
        input.title += " cartÃ©siennes (en kilomÃ¨tre)";
        break;
      default:
        break;
    }
    return input;
  },
  _setCoordinateSearchLngDMSElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPcoordinateSearchLngDMS");
    div.innerHTML = `
        <div class="GPflexInput gpf-flex">
            <input step="1"
                id="GPcoordinatSearchInputSexLonDeg"
                class="gpf-input fr-input"
                name="inputSexLonDeg"
                title="Saisir une valeur de degrÃ© entre 0Â° et 180Â°"
                type="number"
                required=""
                min="0"
                max="180">
            <label>Â°</label>
            <input step="1"
                id="GPcoordinatSearchInputSexLonMin"
                class="gpf-input fr-input"
                name="inputSexLonMin"
                title="Saisir une valeur de minute entre 0' et 59'"
                type="number"
                required=""
                min="0"
                max="59">
            <label>'</label>
            <input step="any"
                id="GPcoordinatSearchInputSexLonSec"
                class="gpf-input fr-input"
                name="inputSexLonSec"
                title="Saisir une valeur de seconde entre 0'' et 59''"
                type="number"
                required=""
                min="0"
                max="59.9999">
            <label>"</label>
            <select
                id="GPcoordinatSearchInputSexLonToward"
                class="GPselect gpf-select fr-select"
                title="Saisir une direction pour Est et 0uest"
                name="inputSexLonToward">
                <option value="O">O</option>
                <option value="E" selected="">E</option>
            </select>
        </div>
        `;
    return div;
  },
  /**
   * update Label
   * @param {String} type - Geographical or Metric
   * @returns {HTMLElement} label
   */
  _setCoordinateSearchLatLabelElement(type) {
    if (document.getElementById(this._addUID("GPcoordinateSearchLatLabel"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLatLabel")).remove();
    }
    var labelLat = document.createElement("label");
    labelLat.className = "GPcoordinateSearchLabel gpf-label fr-label";
    labelLat.id = this._addUID("GPcoordinateSearchLatLabel");
    labelLat.htmlFor = "coordinate-lat";
    labelLat.innerHTML = type === "Geographical" ? "Latitude :" : "X :";
    return labelLat;
  },
  /**
   * update Input coordinate
   * @param {String} code - ex. DMS : degrÃ©s sexadecimaux
   * @returns {HTMLElement} input
   */
  _setCoordinateSearchLatInputElement(code) {
    if (document.getElementById(this._addUID("GPcoordinateSearchLatInput"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLatInput")).remove();
    }
    if (document.getElementById(this._addUID("GPcoordinateSearchLatDMS"))) {
      document.getElementById(this._addUID("GPcoordinateSearchLatDMS")).remove();
    }
    var input = document.createElement("input");
    input.id = this._addUID("GPcoordinateSearchLatInput");
    input.className = "GPcoordinateSearchInput gpf-input fr-input";
    input.title = "Saisir des coordonnÃ©es";
    input.name = "coordinate-lat";
    input.type = "number";
    input.step = "any";
    input.required = "";
    switch (code) {
      case "DMS":
        input.title += " gÃ©ographiques (en sexa)";
        input.className = "GPelementHidden gpf-hidden";
        return this._setCoordinateSearchLatDMSElement();
      case "DEC":
        input.title += " gÃ©ographiques (en decimal)";
        input.min = "-180";
        input.max = "180";
        break;
      case "M":
        input.title += " cartÃ©siennes (en mÃ¨tre)";
        break;
      case "KM":
        input.title += " cartÃ©siennes (en kilomÃ¨tre)";
        break;
      default:
        break;
    }
    return input;
  },
  _setCoordinateSearchLatDMSElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPcoordinateSearchLatDMS");
    div.innerHTML = `
        <div class="GPflexInput gpf-flex">
            <input step="1"
                id="GPcoordinatSearchInputSexLatDeg"
                class="gpf-input fr-input"
                name="inputSexLatDeg"
                title="Saisir une valeur de degrÃ© entre 0Â° et 85Â°"
                type="number"
                required=""
                min="0"
                max="85">
            <label>Â°</label>
            <input step="1"
                id="GPcoordinatSearchInputSexLatMin"
                class="gpf-input fr-input"
                name="inputSexLatMin"
                title="Saisir une valeur de minute entre 0' et 59'"
                type="number"
                required=""
                min="0"
                max="59">
            <label>'</label>
            <input step="any"
                id="GPcoordinatSearchInputSexLatSec"
                class="gpf-input fr-input"
                name="inputSexLatSec"
                title="Saisir une valeur de seconde entre 0' et 59'"
                type="number"
                required=""
                min="0"
                max="59.9999">
            <label>"</label>
            <select
                id="GPcoordinatSearchInputSexLatToward"
                class="GPselect gpf-select fr-select"
                title="Saisir une direction pour Nord et Sud"
                name="inputSexLatToward">
                <option value="N">N</option>
                <option value="S">S</option>
            </select>
        </div>
        `;
    return div;
  },
  /**
   * submit
   * @returns {HTMLElement} input
   */
  _createCoordinateSearchSubmitElement() {
    var input = document.createElement("input");
    input.type = "submit";
    input.id = this._addUID("GPcoordinateSearchSubmit");
    input.className = "GPsubmit gpf-btn gpf-btn-icon-submit  fr-btn fr-btn--secondary gpf-btn--secondary";
    input.value = "Chercher";
    return input;
  }
};
var SearchEngineDOM_default = SearchEngineDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/SearchEngine/SearchEngine.js
var logger14 = LoggerByDefault_default2.getLogger("searchengine");
var SearchEngine = class _SearchEngine extends Control_default2 {
  /**
   * @constructor
   * @param {SearchEngineOptions}  options - control options
   * @fires searchengine:autocomplete:click
   * @fires searchengine:geocode:click
   * @fires searchengine:search:click
   * @fires searchengine:geolocation:click
   * @fires searchengine:geolocation:remove
   * @fires searchengine:coordinates:click
   * @todo option : direction (start|end) de la position du picto (loupe)
   * @todo option : choix du target pour les fenetres geocodage ou recherche par coordonnÃ©es
   * @example
   *  var SearchEngine = ol.control.SearchEngine({
   *      apiKey : "CLEAPI",
   *      collapsed : true,
   *      collapsible : true,
   *      displayButtonAdvancedSearch : true,
   *      displayButtonGeolocate : true,
   *      displayButtonCoordinateSearch : true,
   *      markerStyle : "lightOrange" // "http://..." or "data/base64..."
   *      resources : {
   *          geocode : ["StreetAddress", "PositionOfInterest"],
   *          autocomplete : ["StreetAddress"],
   *          search : false
   *      },
   *      advancedSearch : {
   *          target : document.getElementById("dialog"),
   *          PositionOfInterest : [{name : "municipality", title : "Ville"}],
   *          StreetAddress : [{...}]
   *      },
   *      coordinateSearch : {
   *          target : null
   *          systems : [
   *            {
   *              "crs" : "EPSG:3857",
   *              "label" : "Web Mercator",
   *              "type" : "Metric"
   *            },
   *            {
   *              "crs" : "EPSG:4326",
   *              "label" : "GÃ©ographiques",
   *              "type" : "Geographical"
   *            }
   *          ],
   *          units : ["DEC", "DMS"]
   *      },
   *      geocodeOptions : {},
   *      autocompleteOptions : {},
   *      searchOptions : {}
   *  });
   *
   *  SearchEngine.on("searchengine:autocomplete:click", function (e) {
   *    console.warn("autocomplete", e.location);
   *  });
   *  SearchEngine.on("searchengine:search:click", function (e) {
   *    console.warn("search", e.suggest);
   *  });
   *  SearchEngine.on("searchengine:geocode:click", function (e) {
   *    console.warn("geocode", e.location);
   *  });
   *  SearchEngine.on("searchengine:geolocation:click", function (e) {
   *    console.warn("geolocation", e.);
   *  });
   *  SearchEngine.on("searchengine:coordinate:click", function (e) {
   *    console.warn("coordinate", e.);
   *  });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _SearchEngine)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "SearchEngine";
    this.initialize(options);
    this.container = this._initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (!map) {
      this._clearResults();
    }
    if (!this.collapsed) {
      this._showSearchEngineButton.setAttribute("aria-pressed", true);
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger14.log("[ERROR] SearchEngine:setCollapsed - missing collapsed parameter");
      return;
    }
    if (!this.options.collapsible) {
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    this._showSearchEngineButton.click();
    this.collapsed = collapsed;
  }
  /**
   * Get locations data from geocode service
   *
   * @returns {Object} data - locations
   */
  getData() {
    return this._geocodedLocations;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize SearchEngine control (called by SearchEngine constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this._checkInputOptions(options);
    this.options = {
      collapsed: true,
      collapsible: true,
      zoomTo: "",
      resources: {
        geocode: [],
        autocomplete: [],
        search: false
      },
      displayButtonClose: true,
      displayButtonAdvancedSearch: false,
      displayButtonGeolocate: false,
      displayButtonCoordinateSearch: false,
      coordinateSearchInAdvancedSearch: false,
      advancedSearch: {},
      coordinateSearch: {},
      searchOptions: {
        addToMap: true,
        maximumEntries: 5,
        serviceOptions: {
          maximumResponses: 10
        },
        filterLayers: true
      },
      geocodeOptions: {
        serviceOptions: {}
      },
      autocompleteOptions: {
        serviceOptions: {
          maximumResponses: 5
        },
        triggerGeocode: false,
        triggerDelay: 1e3,
        prettifyResults: false
      },
      displayMarker: true,
      markerStyle: "lightOrange",
      markerUrl: "",
      placeholder: "Rechercher un lieu, une adresse",
      splitResults: false
    };
    Helper_default2.mergeParams(this.options, options);
    if (this.options.resources.geocode === "") {
      this.options.resources.geocode = ["PositionOfInterest", "StreetAddress"];
    }
    if (this.options.resources.autocomplete.length === 0) {
      this.options.resources.autocomplete = ["PositionOfInterest", "StreetAddress"];
    }
    if (this.options.resources.search) {
      if (this.options.searchOptions) {
        if (this.options.searchOptions.serviceOptions) {
          if (this.options.searchOptions.serviceOptions.url) {
            Search_default.setUrl(this.options.searchOptions.serviceOptions.url);
          }
          if (this.options.searchOptions.serviceOptions.fields) {
            Search_default.setFields(this.options.searchOptions.serviceOptions.fields);
          }
          if (this.options.searchOptions.serviceOptions.index) {
            Search_default.setIndex(this.options.searchOptions.serviceOptions.index);
          }
          if (this.options.searchOptions.serviceOptions.size) {
            Search_default.setSize(this.options.searchOptions.serviceOptions.size);
          }
          if (this.options.searchOptions.serviceOptions.maximumResponses) {
            Search_default.setMaximumResponses(this.options.searchOptions.serviceOptions.maximumResponses);
          }
        }
        if (this.options.searchOptions.filterServices) {
          Search_default.setFiltersByService(this.options.searchOptions.filterServices);
        }
        if (this.options.searchOptions.filterLayersPriority) {
          Search_default.setFiltersByLayerPriority(this.options.searchOptions.filterLayersPriority);
        }
        if (this.options.searchOptions.filterWMTSPriority) {
          Search_default.setFilterWMTSPriority(this.options.searchOptions.filterWMTSPriority);
        }
        if (this.options.searchOptions.filterTMS === false) {
          Search_default.setFilterTMS(this.options.searchOptions.filterTMS);
        }
        if (this.options.searchOptions.filterProjections) {
          Search_default.setFiltersByProjection(this.options.searchOptions.filterProjections);
        }
      }
      Search_default.target.addEventListener("suggest", (e) => {
        logger14.debug(e);
        let suggestResults = e.detail;
        suggestResults = this._filterResultsFromConfigLayers(suggestResults);
        this._fillSearchedSuggestListContainer(suggestResults);
      });
    }
    if (!this.options.collapsible) {
      this.options.collapsed = false;
    }
    this.collapsed = this.options.collapsed;
    this._uid = this.options.id || SelectorID_default.generate();
    this._showSearchEngineButton = null;
    this._showSearchEngineAdvancedButton = null;
    this._inputSearchContainer = null;
    this._autocompleteContainer = null;
    this._containerResultsLocation = null;
    this._containerResultsSuggest = null;
    this._radioButtonLocation = null;
    this._radioButtonSuggest = null;
    this._suggestedLocations = [];
    this._geocodedContainer = null;
    this._geocodedLocations = [];
    this._filterContainer = null;
    this._currentGeocodingCode = null;
    this._currentGeocodingLocation = null;
    this._advancedSearchFilters = {};
    this._initAdvancedSearchFilters();
    this._advancedSearchCodes = [];
    this._initAdvancedSearchCodes();
    this._coordinateSearchSystems = [];
    if (this.options.displayButtonCoordinateSearch) {
      this._initCoordinateSearchSystems();
      this._currentCoordinateSearchSystems = this._coordinateSearchSystems[0];
      this._currentCoordinateSearchType = this._coordinateSearchSystems[0].type;
    }
    this._coordinateSearchUnits = [];
    if (this.options.displayButtonCoordinateSearch) {
      this._initCoordinateSearchUnits();
      this._currentCoordinateSearchUnits = this._coordinateSearchUnits[this._currentCoordinateSearchType][0].code;
    }
    this._coordinateSearchLngInput = null;
    this._coordinateSearchLatInput = null;
    this._marker = null;
    var _markerStyle = this.options.markerStyle;
    var _markerUrl = this.options.markerUrl;
    if (_markerUrl) {
      this._markerUrl = _markerUrl;
    } else {
      this._markerUrl = Object.keys(Markers_default).indexOf(_markerStyle) === -1 ? Markers_default["lightOrange"] : Markers_default[_markerStyle];
    }
    this._displayMarker = this.options.displayMarker;
    this._popupContent = null;
    this._popupDiv = this._initPopupDiv();
    this._popupOverlay = null;
    this._triggerHandler = null;
  }
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - options
   *
   * @private
   */
  _checkInputOptions(options) {
    var i;
    if (options.resources) {
      if (typeof options.resources === "object") {
        var geocodeResources = options.resources.geocode;
        if (geocodeResources) {
          if (Array.isArray(geocodeResources)) {
            var geocodeResourcesList = ["StreetAddress", "PositionOfInterest", "CadastralParcel", "Administratif"];
            for (i = 0; i < geocodeResources.length; i++) {
              if (geocodeResourcesList.indexOf(geocodeResources[i]) === -1) {
                logger14.log("[SearchEngine] options.resources.geocode : " + geocodeResources[i] + " is not a resource for geocode");
              }
            }
          } else {
            logger14.log("[SearchEngine] 'options.resources.geocode' parameter should be an array");
            geocodeResources = null;
          }
        }
        var autocompleteResources = options.resources.autocomplete;
        if (autocompleteResources) {
          if (Array.isArray(autocompleteResources)) {
            var autocompleteResourcesList = ["StreetAddress", "PositionOfInterest"];
            for (i = 0; i < autocompleteResources.length; i++) {
              if (autocompleteResourcesList.indexOf(autocompleteResources[i]) === -1) {
                logger14.log("[SearchEngine] options.resources.autocomplete : " + autocompleteResources[i] + " is not a resource for autocomplete");
              }
            }
          } else {
            logger14.log("[SearchEngine] 'options.resources.autocomplete' parameter should be an array");
            autocompleteResources = null;
          }
        }
      } else {
        logger14.log("[SearchEngine] 'resources' parameter should be an object");
        options.resources = null;
      }
    }
  }
  /**
   * this method is called by this.initialize()
   * and initialize the geocoding resources titles.
   *
   * @private
   */
  _initAdvancedSearchCodes() {
    var geocodeResources = this.options.resources.geocode;
    if (geocodeResources === "location") {
      geocodeResources = ["PositionOfInterest", "StreetAddress", "CadastralParcel"];
    }
    if (!Array.isArray(geocodeResources)) {
      geocodeResources = [geocodeResources];
    }
    for (var i = 0; i < geocodeResources.length; i++) {
      switch (geocodeResources[i]) {
        case "PositionOfInterest":
          this._advancedSearchCodes.push({
            id: "PositionOfInterest",
            title: "Lieux/toponymes"
          });
          break;
        case "StreetAddress":
          this._advancedSearchCodes.push({
            id: "StreetAddress",
            title: "Adresses"
          });
          break;
        case "CadastralParcel":
          this._advancedSearchCodes.push({
            id: "CadastralParcel",
            title: "Parcelles cadastrales"
          });
          break;
        default:
          break;
      }
    }
    if (this._advancedSearchCodes.length === 0) {
      this._advancedSearchCodes = [{
        id: "StreetAddress",
        title: "Adresses"
      }, {
        id: "PositionOfInterest",
        title: "Lieux/toponymes"
      }, {
        id: "CadastralParcel",
        title: "Cadastre"
      }];
    }
    logger14.log("advancedSearchCodes", this._advancedSearchCodes);
  }
  /**
   * this method is called by this.onAdd()
   * and initialize the advanced geocoding filters.
   *
   * @private
   */
  _initAdvancedSearchFilters() {
    this._advancedSearchFilters = SearchEngineUtils_default.advancedSearchFiltersByDefault;
    var advancedSearchFiltersCustom = this.options.advancedSearch;
    Helper_default2.assign(this._advancedSearchFilters, advancedSearchFiltersCustom);
    logger14.log("advancedSearchFilters", this._advancedSearchFilters);
  }
  /**
   * this method is called by the constructor and initialize the projection
   * systems.
   * getting coordinates in the requested projection :
   * see this.onCoordinateSearchSystemChange()
   *
   * @private
   */
  _initCoordinateSearchSystems() {
    var projectionSystemsByDefault = [{
      label: "GÃ©ographique",
      crs: "EPSG:4326",
      type: "Geographical"
    }, {
      label: "Web Mercator",
      crs: "EPSG:3857",
      type: "Metric"
    }, {
      label: "Lambert 93",
      crs: "EPSG:2154",
      type: "Metric"
    }];
    var systems = this.options.coordinateSearch.systems;
    if (systems) {
      for (var i = 0; i < systems.length; i++) {
        var sys = systems[i];
        this._setSystem(sys);
      }
    }
    if (this._coordinateSearchSystems.length === 0) {
      for (var j2 = 0; j2 < projectionSystemsByDefault.length; j2++) {
        this._setSystem(projectionSystemsByDefault[j2]);
      }
    }
  }
  /**
   * this method is called by the constructor and initialize the units.
   * getting coordinates in the requested units :
   * see this.onCoordinateSearchUnitsChange()
   *
   * @private
   */
  _initCoordinateSearchUnits() {
    var projectionUnitsByDefault = {
      Geographical: [{
        code: "DEC",
        label: "degrÃ©s dÃ©cimaux",
        format: MathUtils_default.coordinateToDecimal
      }, {
        code: "DMS",
        label: "degrÃ©s sexagÃ©simaux",
        format: MathUtils_default.coordinateToDMS
      }],
      Metric: [{
        code: "M",
        label: "mÃ¨tres",
        format: MathUtils_default.coordinateToMeter
      }, {
        code: "KM",
        label: "kilomÃ¨tres",
        format: MathUtils_default.coordinateToKMeter
      }]
    };
    var units = this.options.coordinateSearch.units;
    if (units) {
      for (var type in projectionUnitsByDefault) {
        if (projectionUnitsByDefault.hasOwnProperty(type)) {
          var found = false;
          for (var j2 = 0; j2 < projectionUnitsByDefault[type].length; j2++) {
            var obj = projectionUnitsByDefault[type][j2];
            for (var i = 0; i < units.length; i++) {
              var unit = units[i];
              if (obj.code === unit) {
                found = true;
                if (!this._coordinateSearchUnits[type]) {
                  this._coordinateSearchUnits[type] = [];
                }
                this._coordinateSearchUnits[type].push(obj);
              }
            }
          }
          if (!found) {
            this._coordinateSearchUnits[type] = projectionUnitsByDefault[type];
          }
        }
      }
    }
    if (typeof this._coordinateSearchUnits === "object" && Object.keys(this._coordinateSearchUnits).length === 0) {
      this._coordinateSearchUnits = projectionUnitsByDefault;
    }
  }
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on marker click)
   *
   * @returns {Object} element - DOM element for popup
   * @private
   */
  _initPopupDiv() {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div gpf-widget-color";
    var remove = document.createElement("button");
    remove.title = "Supprimer le marqueur";
    remove.className = "gp-styling-button remove gpf-btn gpf-btn-icon-remove fr-btn--remove fr-btn fr-btn--tertiary-no-outline fr-mt-1v fr-mr-2v";
    remove.onclick = function() {
      var map = context.getMap();
      if (context._marker) {
        map.removeOverlay(context._marker);
        context._marker = null;
      }
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(void 0);
      }
      context.dispatchEvent({
        type: "searchengine:geolocation:remove"
      });
    };
    var closer = document.createElement("button");
    closer.title = "Fermer la pop-up";
    closer.className = "gp-styling-button closer gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-mt-1v fr-mr-2v";
    closer.onclick = function() {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(void 0);
      }
      return false;
    };
    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    this._popupContent.style["min-width"] = "200px";
    element.appendChild(closer);
    element.appendChild(this._popupContent);
    element.appendChild(remove);
    return element;
  }
  // ################################################################### //
  // ######################## DOM initialize ########################### //
  // ################################################################### //
  /**
   * Create control main container
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var searchDiv = this._createSearchDivElement();
    var picto = this._showSearchEngineButton = this._createShowSearchEnginePictoElement(this.options.collapsible);
    searchDiv.appendChild(picto);
    if (!this.options.collapsible) {
      container.classList.add("gpf-widget-color", "gpf-widget-padding");
    }
    var search = this._inputSearchContainer = this._createSearchInputElement(this.options.placeholder);
    if (this.options.displayButtonClose) {
      search.appendChild(this._createSearchResetElement());
    }
    var context = this;
    if (search.addEventListener) {
      search.addEventListener("click", function() {
        context.onAutoCompleteInputClick();
      });
    } else if (search.attachEvent) {
      search.attachEvent("onclick", function() {
        context.onAutoCompleteInputClick();
      });
    }
    searchDiv.appendChild(search);
    var buttonsContainer = this._createButtonsElement();
    var firstLineWrapper = this._createFirstLineWrapper();
    firstLineWrapper.appendChild(searchDiv);
    firstLineWrapper.appendChild(buttonsContainer);
    container.appendChild(firstLineWrapper);
    if (CheckDsfr_default() && this.options.splitResults) {
      var radioContainer = this._createRadioContainer();
      container.appendChild(radioContainer);
    }
    if (CheckDsfr_default() && this.options.splitResults) {
      var radioElements;
      [radioElements, this._radioButtonLocation, this._radioButtonSuggest] = this._createRadioElements();
      radioContainer.appendChild(radioElements);
    }
    if (this.options.displayButtonGeolocate) {
      var geolocateShow = this._createShowGeolocateElement();
      buttonsContainer.appendChild(geolocateShow);
    }
    if (this.options.displayButtonCoordinateSearch || this.options.coordinateSearchInAdvancedSearch) {
      var searchByCoordinateShow = this._createShowSearchByCoordinateElement();
      if (!this.options.coordinateSearchInAdvancedSearch) {
        buttonsContainer.appendChild(searchByCoordinateShow);
      }
      var coordinatePanel = this._createCoordinateSearchPanelElement();
      var coordinatePanelDiv = this._createCoordinateSearchPanelDivElement();
      var coordinateHeader = this._createCoordinateSearchPanelHeaderElement();
      var coordinateForm = this._createCoordinateSearchPanelFormElement();
      var div = null;
      div = this._containerSystems = this.__createCoordinateSearchDivElement();
      coordinateForm.appendChild(div);
      var labelSystems = this._createCoordinateSearchSystemsLabelElement();
      var systems = this._setCoordinateSearchSystemsSelectElement(this._coordinateSearchSystems);
      div.appendChild(labelSystems);
      div.appendChild(systems);
      div = this._containerUnits = this.__createCoordinateSearchDivElement();
      coordinateForm.appendChild(div);
      var labelUnits = this._createCoordinateSearchUnitsLabelElement();
      var units = this._setCoordinateSearchUnitsSelectElement(this._coordinateSearchUnits[this._currentCoordinateSearchType]);
      div.appendChild(labelUnits);
      div.appendChild(units);
      div = this._containerCoordinateLat = this.__createCoordinateSearchDivElement();
      coordinateForm.appendChild(div);
      var coordinateLat = this._setCoordinateSearchLatLabelElement(this._currentCoordinateSearchType);
      var coordinateInputLat = this._coordinateSearchLatInput = this._setCoordinateSearchLatInputElement(this._currentCoordinateSearchUnits);
      div.appendChild(coordinateLat);
      div.appendChild(coordinateInputLat);
      div = this._containerCoordinateLng = this.__createCoordinateSearchDivElement();
      coordinateForm.appendChild(div);
      var coordinateLng = this._setCoordinateSearchLngLabelElement(this._currentCoordinateSearchType);
      var coordinateInputLng = this._coordinateSearchLngInput = this._setCoordinateSearchLngInputElement(this._currentCoordinateSearchUnits);
      div.appendChild(coordinateLng);
      div.appendChild(coordinateInputLng);
      var submit = this._createCoordinateSearchSubmitElement();
      coordinateForm.appendChild(submit);
      coordinatePanelDiv.appendChild(coordinateHeader);
      coordinatePanelDiv.appendChild(coordinateForm);
      coordinatePanel.appendChild(coordinatePanelDiv);
      if (!this.options.coordinateSearchInAdvancedSearch) {
        container.appendChild(coordinatePanel);
      }
    }
    if (this.options.displayButtonAdvancedSearch) {
      var advancedShow = this._showSearchEngineAdvancedButton = this._createShowAdvancedSearchElement();
      buttonsContainer.appendChild(advancedShow);
      var advancedPanel = this._createAdvancedSearchPanelElement();
      var advancedPanelDiv = this._createAdvancedSearchPanelDivElement();
      var advancedHeader = this._createAdvancedSearchPanelHeaderElement();
      var advancedForm = this._createAdvancedSearchPanelFormElement(this._advancedSearchCodes, this.options.coordinateSearchInAdvancedSearch);
      var advancedFormFilters = this._filterContainer = this._createAdvancedSearchFormFiltersElement();
      this._setFilter(this._advancedSearchCodes[0].id);
      var advancedFormInput = this._createAdvancedSearchFormInputElement();
      advancedForm.appendChild(advancedFormFilters);
      if (this.options.coordinateSearchInAdvancedSearch) {
        advancedForm.appendChild(coordinateForm);
      }
      advancedForm.appendChild(advancedFormInput);
      advancedPanelDiv.appendChild(advancedHeader);
      advancedPanelDiv.appendChild(advancedForm);
      advancedPanel.appendChild(advancedPanelDiv);
      container.appendChild(advancedPanel);
    }
    var autocomplete = this._autocompleteContainer = this._createAutoCompleteElement();
    var autocompleteList = this._createAutoCompleteListElement();
    var containerResultsLocation = this._containerResultsLocation = this._createAutoCompletedLocationContainer();
    var containerResultsSuggest = this._containerResultsSuggest = this._createSearchedSuggestContainer();
    autocompleteList.appendChild(containerResultsLocation);
    autocompleteList.appendChild(containerResultsSuggest);
    autocomplete.appendChild(autocompleteList);
    container.appendChild(autocomplete);
    var geocode = this._createGeocodeResultsElement();
    var geocodeDiv = this._createGeocodeResultsDivElement();
    geocode.appendChild(geocodeDiv);
    var geocodeList = this._geocodedContainer = this._createGeocodeResultsListElement();
    geocodeDiv.appendChild(geocodeList);
    container.appendChild(geocode);
    return container;
  }
  /**
   * this method is called by :
   * - this._initContainer() : ...
   * - this.onGeocodingAdvancedSearchCodeChoice() : ...
   * and initialize or create the filters container HTMLElement
   * to the geocoding advanced menu.
   *
   * @param {String} code - resource geocoding name
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  _setFilter(code) {
    var container = this._filterContainer;
    var codeFound = false;
    for (var i = 0; i < this._advancedSearchCodes.length; i++) {
      if (this._advancedSearchCodes[i].id === code) {
        codeFound = true;
        break;
      }
    }
    if (!codeFound) {
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      return;
    }
    this._currentGeocodingCode = code;
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var lstAttributs = this._advancedSearchFilters[code];
    if (!lstAttributs || lstAttributs.length === 0) {
      return;
    }
    var divTable = this._createAdvancedSearchFiltersTableElement(code, true);
    for (var j2 = 0; j2 < lstAttributs.length; j2++) {
      var divFilter = this._createAdvancedSearchFiltersAttributElement(lstAttributs[j2]);
      divTable.appendChild(divFilter);
    }
    container.appendChild(divTable);
    return container;
  }
  // ################################################################### //
  // ################ methods to request and results ################### //
  // ################################################################### //
  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.text - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */
  _requestAutoComplete(settings) {
    if (!settings || typeof settings === "object" && Object.keys(settings).length === 0) {
      return;
    }
    if (!settings.text) {
      return;
    }
    logger14.log(settings);
    var options = {};
    Helper_default2.assign(options, this.options.autocompleteOptions.serviceOptions);
    Helper_default2.assign(options, settings);
    var resources = this.options.resources.autocomplete;
    if (resources && Array.isArray(resources)) {
      if (!options.type) {
        options.type = resources;
      }
    }
    options.apiKey = options.apiKey || this.options.apiKey;
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    logger14.log(options);
    Gp_default.Services.autoComplete(options);
  }
  /**
   * this method is called by this.onAutoCompleteSearchText() (case of success)
   * and fills the container of the location list.
   * it creates a HTML Element per location
   *
   * @param {Array} locations - Array of Gp.Services.AutoComplete.SuggestedLocation corresponding to autocomplete results list
   * @private
   */
  _fillAutoCompletedLocationListContainer(locations) {
    if (!locations || locations.length === 0) {
      return;
    }
    var element = this._containerResultsLocation;
    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    element.classList.add("GPelementHidden", "gpf-hidden");
    if (locations.length) {
      if (!this._radioButtonLocation || this._radioButtonLocation && this._radioButtonLocation.checked) {
        element.classList.remove("GPelementHidden", "gpf-hidden");
      }
      this._displaySuggestedLocation();
      if (!CheckDsfr_default() || !this.options.splitResults) {
        this._createAutoCompletedLocationTitleElement();
      }
      for (var i = 0; i < locations.length; i++) {
        this._createAutoCompletedLocationElement(locations[i], i);
      }
    }
  }
  /**
   * this method is called by this.() (case of success)
   * and fills the container of the suggest list.
   * it creates a HTML Element per suggest
   *
   * @param {Array} suggests - Array of suggested corresponding to search results list
   * @private
   */
  _fillSearchedSuggestListContainer(suggests) {
    if (this.options.searchOptions.maximumEntries) {
      suggests = suggests.slice(0, this.options.searchOptions.maximumEntries);
    }
    var element = this._containerResultsSuggest;
    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    element.classList.add("GPelementHidden", "gpf-hidden");
    if (suggests.length) {
      if (!this._radioButtonSuggest || this._radioButtonSuggest && this._radioButtonSuggest.checked) {
        element.classList.remove("GPelementHidden", "gpf-hidden");
      }
      if (!CheckDsfr_default() || !this.options.splitResults) {
        this._createSearchedSuggestTitleElement();
      }
      for (let i = 0; i < suggests.length; i++) {
        const suggest2 = suggests[i];
        this._createSearchedSuggestElement(suggest2, i);
      }
    }
  }
  /**
   * this method is called by this.() (case of success)
   * and clean the results of the suggest list from a list of layers
   * by default, the Config.layers list.
   *
   * @param {Array} suggests - Array of suggested corresponding to search results list
   * @returns {Array} suggests - Array of suggested corresponding to search results list filtered by Config
   * @private
   */
  _filterResultsFromConfigLayers(suggests) {
    if (this.options.searchOptions.filterLayers) {
      var layerList = {};
      if (this.options.searchOptions.filterLayersList) {
        layerList = this.options.searchOptions.filterLayersList;
      } else {
        var layersObject = window.Gp.Config.layers;
        for (let layer in layersObject) {
          if (layersObject.hasOwnProperty(layer)) {
            layerList[layersObject[layer].name] = layersObject[layer].serviceParams.id.split(":")[1];
          }
        }
      }
      let i = suggests.length;
      while (i--) {
        if (!layerList[suggests[i].name] || suggests[i].service.toUpperCase() !== layerList[suggests[i].name].toUpperCase()) {
          suggests.splice(i, 1);
        }
      }
    }
    Search_default.setSuggestions(suggests);
    return suggests;
  }
  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.location - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */
  _requestGeocoding(settings) {
    if (!settings || typeof settings === "object" && Object.keys(settings).length === 0) {
      return;
    }
    if (settings.query === null) {
      return;
    }
    logger14.log(settings);
    var options = {};
    Helper_default2.assign(options, this.options.geocodeOptions.serviceOptions);
    Helper_default2.assign(options, settings);
    var self2 = this;
    var bOnFailure = !!(this.options.geocodeOptions.serviceOptions.onFailure !== null && typeof this.options.geocodeOptions.serviceOptions.onFailure === "function");
    var bOnSuccess = !!(this.options.geocodeOptions.serviceOptions.onSuccess !== null && typeof this.options.geocodeOptions.serviceOptions.onSuccess === "function");
    if (bOnSuccess) {
      var cbOnSuccess = function(e) {
        settings.onSuccess.call(self2, e);
        self2.options.geocodeOptions.serviceOptions.onSuccess.call(self2, e);
      };
      options.onSuccess = cbOnSuccess;
    }
    if (bOnFailure) {
      var cbOnFailure = function(e) {
        settings.onFailure.call(self2, e);
        self2.options.geocodeOptions.serviceOptions.onFailure.call(self2, e);
      };
      options.onFailure = cbOnFailure;
    }
    var resources = this.options.resources.geocode;
    if (resources) {
      if (!options.index) {
        options.index = resources;
      }
    }
    options.apiKey = options.apiKey || this.options.apiKey;
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    logger14.log(options);
    Gp_default.Services.geocode(options);
  }
  /**
   * this method is called by this.onGeocodingSearch()
   * and fills the container of the location results.
   * it creates a HTML Element per location
   * (cf. this. ...)
   *
   * @param {Object[]} locations - locations
   *
   * @private
   */
  _fillGeocodedLocationListContainer(locations) {
    if (!locations || locations.length === 0) {
      this._clearGeocodedLocation();
      return;
    }
    var element = this._geocodedContainer;
    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    for (var i = 0; i < locations.length; i++) {
      logger14.log(locations[i]);
      this._createGeocodedLocationElement(locations[i], i);
    }
    this._geocodedLocations = locations;
  }
  // ################################################################### //
  // ######################### other methods ########################### //
  // ################################################################### //
  /**
   * this sends the label to the panel.
   *
   * @param {String} label - label suggested location
   * @private
   */
  _setLabel(label) {
    document.getElementById("GPsearchInputText-" + this._uid).value = label;
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   * and move/zoom on a position.
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] (en lat/lon : "EPSG:4326")
   * @param {Number} zoom - zoom level
   * @private
   */
  _setPosition(position, zoom) {
    var view = this.getMap().getView();
    view.setCenter(position);
    view.setZoom(zoom);
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   *
   * @param {*} extent - ol.Extent
   * @private
   */
  _setPositionFromExtent(extent) {
    var view = this.getMap().getView();
    view.fit(extent);
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   * and displays a marker.
   * FIXME
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] ou [x, y]
   * @param {Object} info - location information
   * @private
   */
  _setMarker(position, info) {
    var map = this.getMap();
    var context = this;
    if (this._marker != null) {
      map.removeOverlay(this._marker);
      this._marker = null;
    }
    if (position) {
      var markerDiv = document.createElement("img");
      markerDiv.src = this._markerUrl;
      if (markerDiv.addEventListener) {
        markerDiv.addEventListener(
          "click",
          function() {
            context._onResultMarkerSelect(info, position);
          }
        );
      } else if (markerDiv.attachEvent) {
        markerDiv.attachEvent(
          "onclick",
          function() {
            context._onResultMarkerSelect(info, position);
          }
        );
      }
      this._marker = new Overlay_default({
        position,
        // offset : [-25.5, -38], // FIXME mauvais rendu !?
        positioning: "center-center",
        element: markerDiv,
        stopEvent: false
      });
      map.addOverlay(this._marker);
    }
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   * and get zoom to results.
   *
   * @param {Object} info - info
   *
   * @returns {Integer} zoom
   * @private
   */
  _getZoom(info) {
    var map = this.getMap();
    var key = this.options.zoomTo;
    var zoom = null;
    if (typeof key === "function") {
      logger14.trace("zoom function");
      zoom = key.call(this, info);
    }
    if (typeof key === "number") {
      logger14.trace("zoom level");
      zoom = key;
    }
    if (typeof key === "string") {
      if (key === "auto") {
        logger14.trace("zoom auto");
        zoom = SearchEngineUtils_default.zoomToResultsByDefault(info);
      } else {
        logger14.trace("zoom level parsing");
        var value2 = parseInt(key, 10);
        if (!isNaN(value2)) {
          logger14.trace("zoom parsing");
          zoom = value2;
        }
      }
    }
    Number.isInteger = Number.isInteger || function(value3) {
      return typeof value3 === "number" && isFinite(value3) && Math.floor(value3) === value3;
    };
    if (!zoom || zoom === "" || !Number.isInteger(zoom)) {
      logger14.trace("zoom not found, current zoom...");
      zoom = map.getView().getZoom();
    }
    var min = map.minZoom;
    var max = map.maxZoom;
    if (zoom < min) {
      logger14.trace("zoom level min...");
      zoom = min;
    }
    if (zoom > max) {
      logger14.trace("zoom level max...");
      zoom = max;
    }
    logger14.trace("zoom", zoom);
    return zoom;
  }
  /**
   * this method is called on 'click' on this._marker
   * (cf. this._setMarker() )
   * and sets a popup with marker information
   *
   * @param {Object} information - location information
   * @param {Array} position - [lon, lat] of marker
   * @private
   */
  _onResultMarkerSelect(information, position = null) {
    var map = this.getMap();
    if (position) {
      map.getView().animate({
        center: position,
        duration: 250
      });
    }
    var popupContent = "";
    if (typeof information !== "string") {
      if (information.service === "GeocodedLocation") {
        popupContent = "<ul>";
        var attributes = information.location.placeAttributes;
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr)) {
            if (attr !== "trueGeometry" && attr !== "extraFields" && attr !== "houseNumberInfos" && attr !== "_count") {
              popupContent += "<li>";
              popupContent += '<span class="gp-attname-others-span">' + attr.toUpperCase() + " : </span>";
              popupContent += attributes[attr];
              popupContent += " </li>";
            }
          }
        }
        popupContent += " </ul>";
      } else if (information.service === "SuggestedLocation") {
        popupContent = GeocodeUtils_default.getSuggestedLocationFreeform(information.location);
      } else {
        popupContent = "sans informations.";
      }
    } else {
      popupContent = information;
    }
    this._popupContent.innerHTML = popupContent;
    if (!this._popupOverlay) {
      this._popupOverlay = new Overlay_default({
        element: this._popupDiv,
        positioning: "bottom-center",
        position: this._marker.getPosition(),
        offset: [0, -42]
      });
      map.addOverlay(this._popupOverlay);
    } else {
      this._popupOverlay.setPosition(this._marker.getPosition());
    }
  }
  /**
   * Set additional projection system
   *
   * @param {Object} system - projection system
   * @param {String} system.crs - Proj4 crs alias (from proj4 defs) e.g. "EPSG:4326"
   * @param {String} [system.label] - CRS label to be displayed in control. Default is system.crs alias
   * @param {String} [system.type] - CRS units type for coordinates conversion (one of control options.units). Default is "Metric"
   * @private
   */
  _setSystem(system) {
    if (typeof system !== "object") {
      logger14.log("[ERROR] MousePosition:addSystem - system parameter should be an object");
      return;
    }
    if (!system.crs) {
      logger14.error("crs not defined !");
      return;
    }
    if (!system.label) {
      logger14.warn("crs label not defined, use crs code by default.");
      system.label = system.crs;
    }
    if (!system.type) {
      logger14.warn("type srs not defined, use 'Metric' by default.");
      system.type = "Metric";
    }
    CRS_default.loadByName(system.crs);
    if (!get2(system.crs)) {
      logger14.error("crs '{}' not available into proj4 definitions !", system.crs);
      return;
    }
    for (var j2 = 0; j2 < this._coordinateSearchSystems.length; j2++) {
      var obj = this._coordinateSearchSystems[j2];
      if (system.crs === obj.crs) {
        logger14.info("crs '{}' already configured", obj.crs);
      }
    }
    system.code = this._coordinateSearchSystems.length;
    this._coordinateSearchSystems.push(system);
  }
  // ################################################################### //
  // ###################### other handlers events ###################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPshowSearchEnginePicto' tag label
   * (cf. this._createShowSearchEnginePictoElement), and it cleans the component
   * when it's closed.
   *
   * @param { Event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowSearchEngineClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    var opened = this._showSearchEngineButton.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
    if (this.collapsed) {
      this._clearResults();
    }
  }
  /**
   * this method is called by event 'click' on 'GPsearchInputReset' tag div
   * (cf. this._createSearchInputElement), and it cleans the value of input.
   *
   * @private
   */
  onSearchResetClick() {
    this._clearResults();
  }
  /**
   * this method is called by event 'click' on 'GPshowGeolocate' tag div
   * (cf. this._createShowGeolocateElement)
   *
   * @private
   */
  onShowSearchGeolocateClick() {
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition((position) => {
        var view = this.getMap().getView();
        var viewProj = view.getProjection().getCode();
        var coordinates_4326 = [position.coords.longitude, position.coords.latitude];
        var coordinates;
        if (viewProj !== "EPSG:4326") {
          coordinates = transform(coordinates_4326, "EPSG:4326", viewProj);
        } else {
          coordinates = coordinates_4326;
        }
        if (isNaN(coordinates[0]) || isNaN(coordinates[1])) {
          this._setMarker();
          return;
        }
        this._setPosition(coordinates, 15);
        if (this._displayMarker) {
          var markerInfo = "<h6> Ma position </h6> latitude : " + coordinates_4326[1] + "<br/> longitude : " + coordinates_4326[0];
          this._setMarker(coordinates, markerInfo);
        }
        this.dispatchEvent({
          type: "searchengine:geolocation:click",
          coordinates
        });
      });
    } else {
    }
  }
  /**
   * this method is called by event 'click' on 'GPshowSearchByCoordinate' tag div
   * (cf. this._createShowSearchByCoordinateElement)
   *
   * @private
   */
  onShowSearchByCoordinateClick() {
    var lng = null;
    var lat = null;
    if (this._coordinateSearchLngInput && this._coordinateSearchLngInput.nodeName === "DIV" && this._coordinateSearchLatInput && this._coordinateSearchLatInput.nodeName === "DIV") {
      lng = this._getCoordinateSearchDMS(this._coordinateSearchLngInput);
      lat = this._getCoordinateSearchDMS(this._coordinateSearchLatInput);
    } else {
      lng = this._coordinateSearchLngInput.value;
      lat = this._coordinateSearchLatInput.value;
    }
    if (!lng || !lat) {
      return;
    }
    var coordinates = [lng, lat];
    var view = this.getMap().getView();
    var viewProj = view.getProjection().getCode();
    if (viewProj !== "EPSG:4326") {
      coordinates = transform(coordinates, "EPSG:4326", viewProj);
    }
    if (isNaN(coordinates[0]) || isNaN(coordinates[1])) {
      this._setMarker();
      return;
    }
    this._setPosition(coordinates, 10);
    if (this._displayMarker) {
      this._setMarker(coordinates, lat + ", " + lng);
    }
    this.dispatchEvent({
      type: "searchengine:coordinates:click",
      coordinates
    });
  }
  /**
   * ...
   * @param {*} dom - ...
   * @private
   * @returns {Object} ...
   */
  _getCoordinateSearchDMS(dom) {
    if (dom && dom.nodeName === "DIV") {
      var nodes = dom.querySelectorAll("[name]");
      if (nodes) {
        var degrees = MathUtils_default.toInteger(nodes[0].value);
        var minutes = MathUtils_default.toInteger(nodes[1].value);
        var seconds = MathUtils_default.toInteger(nodes[2].value);
        var hemispheres = nodes[3].options[nodes[3].selectedIndex].text;
        if (!degrees || !minutes || !seconds || !hemispheres) {
          return;
        }
        return MathUtils_default.dmsToDecimal(degrees, minutes, seconds, hemispheres);
      }
    }
  }
  // ################################################################### //
  // ################## handlers events AutoComplete ################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPlocationOrigin' input
   *
   * @private
   */
  onAutoCompleteInputClick() {
    var inputSearchTextContainer = document.getElementById("GPsearchInputText-" + this._uid);
    if (inputSearchTextContainer && !inputSearchTextContainer.disabled && inputSearchTextContainer.value.length > 2) {
      this._displaySuggestedLocation();
    }
  }
  /**
   * this method is called by event 'keyup' on 'GPsearchInputText' tag input
   * (cf. this._createSearchInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service autocomplete (text).
   * the results of the request are displayed into a drop down menu.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onAutoCompleteSearchText(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    this._currentGeocodingLocation = value2;
    if (value2.length < 3) {
      this._clearSuggestedLocation();
      return;
    }
    var _triggerGeocode = this.options.autocompleteOptions.triggerGeocode;
    var _triggerDelay = this.options.autocompleteOptions.triggerDelay;
    var _maximumEntries = this.options.autocompleteOptions.maximumEntries;
    var _prettifyResults = this.options.autocompleteOptions.prettifyResults;
    var context = this;
    this._requestAutoComplete({
      text: value2,
      // callback onSuccess
      onSuccess: function(results) {
        logger14.log("request from AutoComplete", results);
        if (results) {
          context._suggestedLocations = results.suggestedLocations;
          context._locationsToBeDisplayed = [];
          for (var i = 0; i < context._suggestedLocations.length; i++) {
            var ilocation = context._suggestedLocations[i];
            if (ilocation.position && ilocation.position.x === 0 && ilocation.position.y === 0 && ilocation.fullText) {
              context._getGeocodeCoordinatesFromFullText(ilocation, i);
            } else {
              context._locationsToBeDisplayed.push(ilocation);
            }
          }
          ;
          if (_prettifyResults === true) {
            context._prettifyAutocompleteResults(context._locationsToBeDisplayed);
          }
          if (_maximumEntries) {
            context._locationsToBeDisplayed = context._locationsToBeDisplayed.slice(0, _maximumEntries);
          }
          context._fillAutoCompletedLocationListContainer(context._locationsToBeDisplayed);
          if (context._triggerHandler) {
            clearTimeout(context._triggerHandler);
            context._triggerHandler = null;
            logger14.warn("Cancel a geocode request !");
          }
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._clearSuggestedLocation();
        logger14.log(error.message);
        if (error.message === "No suggestion matching the search" && _triggerGeocode) {
          if (context._triggerHandler) {
            clearTimeout(context._triggerHandler);
            logger14.warn("Cancel the last geocode request !");
          }
          context._triggerHandler = setTimeout(
            function() {
              logger14.warn("Launch a geocode request !");
              context._requestGeocoding({
                location: value2,
                // callback onSuccess
                onSuccess: function(results) {
                  logger14.log("request from Geocoding", results);
                  if (results) {
                    context._locationsToBeDisplayed = [];
                    var locations = results.locations;
                    for (var i = 0; i < locations.length; i++) {
                      var location = locations[i];
                      location.fullText = GeocodeUtils_default.getGeocodedLocationFreeform(location);
                      location.position = {
                        x: location.position.lon,
                        y: location.position.lat
                      };
                      context._locationsToBeDisplayed.push(location);
                    }
                    context._fillAutoCompletedLocationListContainer(locations);
                  }
                },
                // callback onFailure
                onFailure: function(error2) {
                  logger14.log(error2.message);
                }
              });
            },
            _triggerDelay
          );
        }
      }
    });
    if (this.options.resources.search) {
      Search_default.suggest(value2);
    }
    var context = this;
    var map = this.getMap();
    map.once(
      "click",
      function() {
        context._hideSuggestedLocation();
      }
    );
    map.once(
      "pointerdrag",
      function() {
        context._hideSuggestedLocation();
      }
    );
  }
  /**
   * this method is called by Gp.Services.autoComplete callback in case of success
   * (cf. this.onAutoCompleteSearchText), for suggested locations with null coordinates
   * (case of postalCode research for instance).
   * Send a geocode request with suggested location 'fullText' attribute, to get its coordinates and display it in autocomplete results list container.
   *
   * @param {Gp.Services.AutoCompleteResponse.SuggestedLocation} suggestedLocation - autocompletion result (with null coordinates) to be geocoded
   * @param {Number} i - suggestedLocation position in Gp.Services.AutoCompleteResponse.suggestedLocations autocomplete results list
   * @private
   */
  _getGeocodeCoordinatesFromFullText(suggestedLocation, i) {
    var context = this;
    Gp_default.Services.geocode({
      apiKey: this.options.apiKey,
      ssl: this.options.ssl,
      q: GeocodeUtils_default.getSuggestedLocationFreeform(suggestedLocation),
      index: suggestedLocation.type,
      // callback onSuccess
      onSuccess: function(response) {
        logger14.log("request from Geocoding (coordinates null)", response);
        if (response.locations && response.locations.length !== 0 && response.locations[0].position) {
          if (context._suggestedLocations && context._suggestedLocations[i]) {
            context._suggestedLocations[i].position = {
              lon: response.locations[0].position.y,
              lat: response.locations[0].position.x
            };
            context._locationsToBeDisplayed.unshift(context._suggestedLocations[i]);
            context._fillAutoCompletedLocationListContainer(context._locationsToBeDisplayed);
          }
        }
      },
      // callback onFailure
      onFailure: function() {
        if (context._suggestedLocations && context._suggestedLocations[i]) {
          context._createAutoCompletedLocationElement(context._suggestedLocations[i], i);
        }
      }
    });
  }
  /**
   * this method is called by event 'click' on 'GPautoCompleteResultsList' tag div
   * (cf. this._createAutoCompleteListElement), and it selects the location.
   * this location displays a marker on the map.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onAutoCompletedResultsItemClick(e) {
    var idx = SelectorID_default.index(e.target.id);
    logger14.log(idx);
    logger14.log(this._locationsToBeDisplayed[idx]);
    if (!idx) {
      return;
    }
    var position = [
      this._locationsToBeDisplayed[idx].position.x,
      this._locationsToBeDisplayed[idx].position.y
    ];
    var info = {
      service: "SuggestedLocation",
      location: this._locationsToBeDisplayed[idx]
    };
    var label = GeocodeUtils_default.getSuggestedLocationFreeform(this._locationsToBeDisplayed[idx]);
    this._setLabel(label);
    this._currentGeocodingLocation = label;
    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();
    if (mapProj !== "EPSG:4326") {
      position = transform(position, "EPSG:4326", mapProj);
    }
    this._requestGeocoding({
      index: "address,poi",
      limit: 1,
      returnTrueGeometry: true,
      location: label,
      onSuccess: (results) => {
        if (results.locations[0].placeAttributes.truegeometry) {
          var geom = JSON.parse(results.locations[0].placeAttributes.truegeometry);
          if (geom.type === "Point") {
            this._setPosition(position, 15);
          } else {
            var format = new GeoJSON_default();
            var geometry = format.readGeometry(geom, {
              dataProjection: "EPSG:4326",
              // incoming data
              featureProjection: "EPSG:3857"
              // map projection
            });
            var extent = geometry.getExtent();
            this._setPositionFromExtent(extent);
          }
        } else {
          this._setPosition(position, 15);
        }
        if (this._displayMarker) {
          this._setMarker(position, info);
        }
        var container = document.getElementById(this._addUID("GPautocompleteResults"));
        if (!container) {
          return;
        }
        var list = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine");
        for (let index2 = 0; index2 < list.length; index2++) {
          const element = list[index2];
          element.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
        }
        var current = list[idx];
        current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
        this.dispatchEvent({
          type: "searchengine:autocomplete:click",
          location: this._locationsToBeDisplayed[idx]
        });
      },
      onFailure: (error) => {
        logger14.warn(error);
        var zoom = this._getZoom(info);
        this._setPosition(position, zoom);
        if (this._displayMarker) {
          this._setMarker(position, info);
        }
        var container = document.getElementById(this._addUID("GPautocompleteResults"));
        if (!container) {
          return;
        }
        var list = container.getElementsByClassName("GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine");
        for (let index2 = 0; index2 < list.length; index2++) {
          const element = list[index2];
          element.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine";
        }
        var current = list[idx];
        current.className = "GPautoCompleteProposal gpf-panel__items gpf-panel__items_searchengine current";
        this.dispatchEvent({
          type: "searchengine:autocomplete:click",
          location: this._locationsToBeDisplayed[idx]
        });
      }
    });
  }
  /**
   * this method is called by event 'click' on '' tag div
   * (cf. this.), and it selects the suggest.
   * this suggest call an event to added layer on the map.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onSearchedResultsItemClick(e) {
    var idx = SelectorID_default.index(e.target.id);
    var error = null;
    try {
      var suggest2 = Search_default.getSuggestions()[idx];
      if (!suggest2) {
        throw "No suggestions found !";
      }
      if (this.options.searchOptions.addToMap) {
        if (!Config_default2.isConfigLoaded()) {
          throw "ERROR : contract key configuration has to be loaded to load Geoportal layers.";
        }
        var service = suggest2.service;
        var name = suggest2.name;
        var layer = null;
        switch (service) {
          case "WMS":
            layer = new LayerWMS_default({
              layer: name
            });
            break;
          case "WMTS":
            layer = new LayerWMTS_default({
              layer: name
            });
            break;
          case "WFS":
            layer = new LayerWFS_default({
              layer: name
            });
            break;
          case "TMS":
            layer = new LayerMapBox_default({
              layer: name
            }, {
              declutter: true
            });
          default:
            break;
        }
        if (layer) {
          var map = this.getMap();
          map.addLayer(layer);
        }
      }
    } catch (e2) {
      error = e2;
    }
    this.dispatchEvent({
      type: "searchengine:search:click",
      suggest: suggest2,
      error
    });
  }
  // ################################################################### //
  // ################### handlers events Geocode ####################### //
  // ################################################################### //
  /**
   * this method is called by event 'submit' on 'GPsearchInput' tag form
   * (cf. this._createSearchInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service geocoding.
   * the results of the request are displayed into a window.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onGeocodingSearchSubmit(e) {
    var value2 = e.target[0].value;
    if (!value2) {
      return;
    }
    this._currentGeocodingLocation = value2;
    var context = this;
    this._requestGeocoding({
      query: value2,
      // callback onSuccess
      onSuccess: function(results) {
        logger14.log("request from Geocoding", results);
        if (results) {
          var locations = results.locations;
          context._fillGeocodedLocationListContainer(locations);
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._clearGeocodedLocation();
        logger14.log(error.message);
      }
    });
  }
  /**
   * this method is called by event 'submit' on 'GPgeocodeResultsList' tag div
   * (cf. this._createGeocodeResultsListElement), and it selects the location.
   * this location displays a marker on the map.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onGeocodedResultsItemClick(e) {
    var idx = SelectorID_default.index(e.target.id);
    if (!idx) {
      return;
    }
    var position = [
      this._geocodedLocations[idx].position.lon,
      this._geocodedLocations[idx].position.lat
    ];
    var info = {
      service: "GeocodedLocation",
      location: this._geocodedLocations[idx]
    };
    var label = GeocodeUtils_default.getGeocodedLocationFreeform(this._geocodedLocations[idx]);
    this._setLabel(label);
    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();
    if (mapProj !== "EPSG:4326") {
      position = transform(position, "EPSG:4326", mapProj);
    }
    var zoom = this._getZoom(this.options.zoomTo);
    this._setPosition(position, zoom);
    if (this._displayMarker) {
      this._setMarker(position, info);
    }
    this.dispatchEvent({
      type: "searchengine:geocode:click",
      location: this._geocodedLocations[idx]
    });
    this._clearSuggestedLocation();
    this._showSearchEngineAdvancedButton.click();
  }
  // ################################################################### //
  // ############## handlers events Geocode Advanced ################### //
  // ################################################################### //
  /**
   * this method is called by event 'change' on 'GPadvancedSearchCode' tag select
   * (cf. this._createAdvancedSearchFormCodeElement), and it gets the value of
   * option selected.
   * this value is passed as a parameter to create the attributs container.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onGeocodingAdvancedSearchCodeChange(e) {
    logger14.log(e);
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    if (!value2) {
      return;
    }
    this._setFilter(value2);
  }
  /**
   * this method is called by event 'submit' on 'GPadvancedSearchForm' tag form
   * (cf. this._createAdvancedSearchPanelFormElement), and it gets the value of all input.
   * this value is passed as a parameter for the service geocoding.
   * the results of the request are displayed into a window.
   *
   * @param {Event} e - HTMLElement
   * @param {Array} data - [{key: ..., value: ...}]
   * @private
   */
  onGeocodingAdvancedSearchSubmit(e, data) {
    logger14.log(data);
    if (!data || data.length === 0) {
      return;
    }
    var _location;
    var _filterOptions = {};
    for (var i = 0; i < data.length; i++) {
      var filter = data[i];
      if (filter.value) {
        if (filter.key === "section") {
          filter.value = filter.value.toUpperCase();
        }
        _filterOptions[filter.key] = filter.value;
      }
    }
    var inputSearchTextContainer = document.getElementById("GPsearchInputText-" + this._uid);
    _location = inputSearchTextContainer.value;
    if (this._currentGeocodingCode === "CadastralParcel") {
      _location = "";
    }
    if (this._currentGeocodingCode === "StreetAddress") {
      _location = `${_filterOptions.address} ${_filterOptions.postcode} ${_filterOptions.city}`;
      _filterOptions = {};
    }
    if (this._currentGeocodingCode === "PositionOfInterest") {
      _location = _filterOptions.q;
      delete _filterOptions.q;
    }
    var context = this;
    this._requestGeocoding({
      query: _location,
      index: this._currentGeocodingCode,
      filters: _filterOptions,
      // callback onSuccess
      onSuccess: function(results) {
        logger14.log(results);
        if (results) {
          var locations = results.locations;
          context._fillGeocodedLocationListContainer(locations);
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._clearGeocodedLocation();
        logger14.log(error.message);
      }
    });
  }
  /**
   * this method is called by 'onGeocodingAdvancedSearchSubmit' method,
   * in case geocoding type is 'CadastralParcel',
   * and gets request parameters from inputs
   *
   * @param {Object} filterOptions - object with inputs value (department, insee, ...)
   * @returns {String} location - cadastral parcel number : concatenation of inputs values (e.g. : 940670000D0041 or 94067_____0041)
   * @private
   */
  _getCadastralParcelRequestParams(filterOptions) {
    var _location = "";
    var l3;
    var dep = filterOptions.department;
    if (dep) {
      l3 = dep.length;
      if (l3 === 2) {
        _location = dep;
      } else if (l3 === 1) {
        _location = "0" + dep;
      } else {
        _location = dep.substring(0, 2);
      }
    } else {
      _location = "__";
    }
    var commune = filterOptions.commune;
    if (commune) {
      l3 = commune.length;
      if (l3 === 3) {
        _location += commune;
      } else if (l3 === 2) {
        _location += "_" + commune;
      } else if (l3 === 1) {
        _location += "__" + commune;
      } else {
        _location += commune.substring(0, 3);
      }
    } else {
      _location += "___";
    }
    var insee = filterOptions.insee;
    if (insee) {
      if (insee.length === 5) {
        _location = insee;
      }
    }
    var absorbedCity = filterOptions.absorbedCity;
    if (absorbedCity) {
      l3 = absorbedCity.length;
      if (l3 === 3) {
        _location += absorbedCity;
      } else if (l3 < 3) {
        if (l3 === 2) {
          _location += "_" + absorbedCity;
        } else if (l3 === 1) {
          _location += "__" + absorbedCity;
        }
      } else {
        _location += absorbedCity.substring(0, 3);
      }
    } else {
      _location += "___";
    }
    var section = filterOptions.section;
    if (section) {
      l3 = section.length;
      if (l3 === 2) {
        _location += section;
      } else if (l3 === 1) {
        _location += "_" + section;
      } else {
        _location += section.substring(0, 2);
      }
    } else {
      _location += "__";
    }
    var number = filterOptions.number;
    if (number) {
      l3 = number.length;
      if (l3 === 4) {
        _location += number;
      } else if (l3 === 3) {
        _location += "_" + number;
      } else if (l3 === 2) {
        _location += "__" + number;
      } else if (l3 === 1) {
        _location += "___" + number;
      } else {
        _location += number.substring(0, 4);
      }
    } else {
      _location += "___";
    }
    logger14.log("location : " + _location);
    return _location;
  }
  // ################################################################### //
  // ############### handlers events Coordinate Search ################# //
  // ################################################################### //
  /**
   * this method is called by event 'change' on ''
   * tag select (cf. this.),
   * and selects the system projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onCoordinateSearchSystemChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    this._coordinateSearchLngInput.value = "";
    this._coordinateSearchLatInput.value = "";
    var type = null;
    for (var i = 0; i < this._coordinateSearchSystems.length; ++i) {
      if (this._coordinateSearchSystems[i].code === Number(value2)) {
        type = this._coordinateSearchSystems[i].type;
        break;
      }
    }
    if (!type) {
      logger14.log("system not found in projection systems container");
      return;
    }
    this._currentCoordinateSearchSystems = this._coordinateSearchSystems[Number(value2)];
    if (type !== this._currentCoordinateSearchType) {
      this._currentCoordinateSearchType = type;
      this._currentCoordinateSearchUnits = this._coordinateSearchUnits[type][0].code;
      this._containerUnits.appendChild(this._setCoordinateSearchUnitsSelectElement(this._coordinateSearchUnits[type]));
      this._updateCoordinateSearchElements();
    }
  }
  /**
   * this method is called by event 'change' on ''
   * tag select (cf. this.),
   * and selects the units projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onCoordinateSearchUnitsChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    this._coordinateSearchLngInput.value = "";
    this._coordinateSearchLatInput.value = "";
    this._currentCoordinateSearchUnits = value2;
    this._updateCoordinateSearchElements();
  }
  /**
   * this method is called by event 'click' on ''
   * tag select (cf. this.),
   * and clear app.
   *
   * @private
   */
  onCoordinateSearchClose() {
    this._setMarker();
    this._coordinateSearchLngInput.value = "";
    this._coordinateSearchLatInput.value = "";
  }
  /**
   * @private
   */
  _updateCoordinateSearchElements() {
    var lbl = this._setCoordinateSearchLngLabelElement(this._currentCoordinateSearchType);
    var input = this._coordinateSearchLngInput = this._setCoordinateSearchLngInputElement(this._currentCoordinateSearchUnits);
    this._containerCoordinateLng.appendChild(lbl);
    this._containerCoordinateLng.appendChild(input);
    lbl = this._setCoordinateSearchLatLabelElement(this._currentCoordinateSearchType);
    input = this._coordinateSearchLatInput = this._setCoordinateSearchLatInputElement(this._currentCoordinateSearchUnits);
    this._containerCoordinateLat.appendChild(lbl);
    this._containerCoordinateLat.appendChild(input);
  }
  // ################################################################### //
  // ############################## clean ############################## //
  // ################################################################### //
  /**
   * this method is called by this.onSearchReset()
   * and it clears all results and the marker.
   *
   * @private
   */
  _clearResults() {
    var map = this.getMap();
    this._currentGeocodingLocation = null;
    this._clearSuggestedLocation();
    this._clearGeocodedLocation();
    this._setMarker();
    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    }
  }
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */
  _clearSuggestedLocation() {
    this._suggestedLocations = [];
    if (this._containerResultsLocation) {
      while (this._containerResultsLocation.firstChild) {
        this._containerResultsLocation.removeChild(this._containerResultsLocation.firstChild);
      }
    }
    if (this.options.resources.search) {
      Search_default.clear();
      if (this._containerResultsSuggest) {
        while (this._containerResultsSuggest.firstChild) {
          this._containerResultsSuggest.removeChild(this._containerResultsSuggest.firstChild);
        }
      }
    }
  }
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears suggested location from duplicate entries and improve unprecise fulltext entries.
   *
   * @param {Array} autocompleteResults - Array of autocompleteResults to display
   * @private
   */
  _prettifyAutocompleteResults(autocompleteResults) {
    for (var i = autocompleteResults.length - 1; i >= 0; i--) {
      var autocompleteResult = autocompleteResults[i];
      if (autocompleteResult.type === "StreetAddress" && autocompleteResult.kind === "municipality" || autocompleteResult.type === "PositionOfInterest" && autocompleteResult.poiType[0] === "lieu-dit habitÃ©" && autocompleteResult.poiType[1] === "zone d'habitation") {
        autocompleteResults.splice(i, 1);
      }
      if (autocompleteResult.type === "PositionOfInterest" && autocompleteResult.poiType[0] === "administratif" && (autocompleteResult.poiType[1] === "dÃ©partement" || autocompleteResult.poiType[1] === "rÃ©gion")) {
        autocompleteResult.fullText = autocompleteResult.fullText + ", " + autocompleteResult.poiType[1];
      }
    }
    ;
  }
  /**
   * this method is called to hide suggested locations
   *
   * @private
   */
  _hideSuggestedLocation() {
    if (this._autocompleteContainer) {
      this._autocompleteContainer.classList.replace("GPelementVisible", "GPelementHidden");
      this._autocompleteContainer.classList.replace("gpf-visible", "gpf-hidden");
    }
  }
  /**
   * this method is called to display suggested location.
   *
   * @private
   */
  _displaySuggestedLocation() {
    if (this._autocompleteContainer) {
      this._autocompleteContainer.classList.replace("GPelementHidden", "GPelementVisible");
      this._autocompleteContainer.classList.replace("gpf-hidden", "gpf-visible");
    }
  }
  /**
   * this method is called by this.onGeocodingAdvancedSearchSubmit()
   * and it clears all geocoded location.
   *
   * @private
   */
  _clearGeocodedLocation() {
    this._geocodedLocations = [];
    if (this._geocodedContainer) {
      while (this._geocodedContainer.firstChild) {
        this._geocodedContainer.removeChild(this._geocodedContainer.firstChild);
      }
    }
  }
};
Object.assign(SearchEngine.prototype, SearchEngineDOM_default);
Object.assign(SearchEngine.prototype, Widget_default);
var SearchEngine_default = SearchEngine;
if (window.ol && window.ol.control) {
  window.ol.control.SearchEngine = SearchEngine;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/MousePosition/MousePosition.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/MousePosition/GPFmousePosition.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/MousePosition/MousePositionDOM.js
var stringToHTML = (str) => {
  var support = function() {
    if (!window.DOMParser) {
      return false;
    }
    var parser2 = new DOMParser();
    try {
      parser2.parseFromString("x", "text/html");
    } catch (err) {
      return false;
    }
    return true;
  };
  if (support()) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(str, "text/html");
    return doc.body;
  }
  var dom = document.createElement("div");
  dom.innerHTML = str;
  return dom;
};
var MousePositionDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePosition");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show mouse position control
   * @param {Boolean} isDesktop - specifies if the support is desktop or tactile
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowMousePositionPictoElement: function(isDesktop) {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowMousePositionPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-position");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Afficher les coordonnÃ©es du curseur");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowMousePositionClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowMousePositionClick(e);
      });
    }
    return button;
  },
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPmousePositionPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createMousePositionPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Map center localisation (tactile use)
   *
   * @returns {HTMLElement} container
   */
  _createMapCenter: function() {
    var div = document.createElement("div");
    div.id = "GPmapCenter";
    div.className = "";
    return div;
  },
  // ################################################################### //
  // ####################### Panel container ########################### //
  // ################################################################### //
  /**
   * @returns {HTMLElement} container
   */
  /**
   * Create Header Title Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.id = this._addUID("GPmousePositionHeaderTitle");
    div.innerHTML = "CoordonnÃ©es";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    return container;
  },
  /**
   * Create Header close div
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionPanelCloseElement: function() {
    var self2 = this;
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPmousePositionPanelClose");
    divClose.className = "GPpanelClose gpf-btn gpf-btn-icon-close  fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowMousePositionPicto")).click();
      }, false);
      divClose.addEventListener("keydown", function(event) {
        if (event.keyCode === 13) {
          document.getElementById(self2._addUID("GPshowMousePositionPicto")).click();
        }
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowMousePositionPicto")).click();
      });
      divClose.attachEvent("onkeydown", function(event) {
        if (event.keyCode === 13) {
          document.getElementById(self2._addUID("GPshowMousePositionPicto")).click();
        }
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    return divClose;
  },
  /**
   * coordinate panel
   * @param {Boolean} [displayAltitude] - specifies if the altitude panel must be displayed
   * @param {Boolean} [displayCoordinates] - specifies if the coordinates panel must be displayed
   * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed
   * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units
   *
   * FIXME
   * call this._createMousePositionPanelBasicCoordinateElement
   * call this._createMousePositionPanelBasicAltitudeElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionPanelBasicElement: function(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {
    displayAltitude = typeof displayAltitude === "undefined" ? true : displayAltitude;
    displayCoordinates = typeof displayCoordinates === "undefined" ? true : displayCoordinates;
    editCoordinates = typeof editCoordinates === "undefined" ? false : editCoordinates;
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePositionBasicPanel");
    container.classList.add("fr-mx-1w");
    container.appendChild(this._createMousePositionPanelBasicCoordinateElement(displayCoordinates, editCoordinates, currentProjectionUnits));
    container.appendChild(this._createMousePositionPanelEditToolsElement(editCoordinates));
    container.appendChild(this._createMousePositionPanelBasicAltitudeElement(displayAltitude));
    return container;
  },
  /**
   * create coordinate elements
   *
   * @param {String} coordType - ("Lon" ou "Lat")
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {Array} list of DOM elements
   */
  _createCoordinateElement: function(coordType, editCoordinates) {
    var context = this;
    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return [];
    }
    var list = [];
    var input = document.createElement("input");
    input.id = this._addUID("GPmousePosition" + coordType);
    input.title = editCoordinates === true ? "Cliquer pour saisir des coordonnÃ©es" : "";
    input.readOnly = true;
    if (editCoordinates) {
      input.addEventListener("click", function() {
        context.onMousePositionEditModeClick(true);
      });
      input.addEventListener("change", function(e) {
        this.classList.remove("error");
        var valid = context.validateExtentCoordinate(coordType, this.value, e);
        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }
    list.push(input);
    var span = document.createElement("span");
    span.className = "GPmousePositionUnits";
    list.push(span);
    return list;
  },
  /**
   *
   * @param {String} coordType - ("Lon" ou "Lat")
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {Array} list of DOM elements
   */
  _createDMSCoordinateElement: function(coordType, editCoordinates) {
    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return [];
    }
    var context = this;
    var list = [];
    var input = document.createElement("input");
    input.id = this._addUID("GPmousePosition" + coordType + "Degrees");
    input.className = "GPSexagesimal";
    input.setAttribute("name", "degrees");
    input.title = editCoordinates === true ? "Cliquer pour saisir des coordonnÃ©es" : "";
    input.readOnly = true;
    input.dataset.min = 0;
    input.dataset.max = coordType === "Lon" ? 180 : 90;
    if (editCoordinates) {
      input.addEventListener("click", function() {
        context.onMousePositionEditModeClick(true);
      });
      input.addEventListener("change", function() {
        this.classList.remove("error");
        var valid = context._checkDMSDegrees(coordType, this);
        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }
    list.push(input);
    var span = document.createElement("span");
    span.className = "GPmousePositionSexagesimalLabel";
    span.innerHTML = "Â°";
    list.push(span);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPmousePosition" + coordType + "Minutes");
    input1.className = "GPSexagesimal";
    input1.setAttribute("name", "minutes");
    input1.title = editCoordinates === true ? "Cliquer pour saisir des coordonnÃ©es" : "";
    input1.readOnly = true;
    input1.dataset.min = 0;
    input1.dataset.max = 59;
    if (editCoordinates) {
      input1.addEventListener("click", function() {
        context.onMousePositionEditModeClick(true);
      });
      input1.addEventListener("change", function() {
        this.classList.remove("error");
        var valid = context._checkDMSElement(this);
        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }
    list.push(input1);
    var span1 = document.createElement("span");
    span1.className = "GPmousePositionSexagesimalLabel";
    span1.innerHTML = "'";
    list.push(span1);
    var input2 = document.createElement("input");
    input2.id = this._addUID("GPmousePosition" + coordType + "Seconds");
    input2.className = "GPSexagesimalsec";
    input2.setAttribute("name", "seconds");
    input2.title = editCoordinates === true ? "Cliquer pour saisir des coordonnÃ©es" : "";
    input2.readOnly = true;
    input2.dataset.min = 0;
    input2.dataset.max = 59;
    if (editCoordinates) {
      input2.addEventListener("click", function() {
        context.onMousePositionEditModeClick(true);
      });
      input2.addEventListener("change", function() {
        this.classList.remove("error");
        var valid = context._checkDMSElement(this, true);
        valid ? this.classList.remove("error") : this.classList.add("error");
      });
    }
    list.push(input2);
    var span2 = document.createElement("span");
    span2.className = "GPmousePositionSexagesimalLabel";
    span2.innerHTML = "''";
    list.push(span2);
    var select = document.createElement("select");
    select.id = this._addUID("GPmousePosition" + coordType + "Direction");
    select.className = "GPmousePositionDirection";
    select.setAttribute("name", "direction");
    select.disabled = true;
    var option2 = document.createElement("option");
    option2.value = coordType === "Lon" ? "E" : "N";
    option2.innerHTML = coordType === "Lon" ? "E" : "N";
    select.appendChild(option2);
    var option1 = document.createElement("option");
    option1.value = coordType === "Lon" ? "O" : "S";
    option1.innerHTML = coordType === "Lon" ? "O" : "S";
    select.appendChild(option1);
    list.push(select);
    return list;
  },
  /**
   * @param {Boolean} [display=false] - specifies if the coordinates panel must be displayed
   * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed
   * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units
   *
   * @returns {HTMLElement} container
   */
  _createMousePositionPanelBasicCoordinateElement: function(display, editCoordinates, currentProjectionUnits) {
    var div = document.createElement("div");
    div.id = this._addUID("GPmousePositionCoordinate");
    div.style.display = display ? "block" : "none";
    var divLat = document.createElement("div");
    var spanLat = document.createElement("span");
    spanLat.className = "GPmousePositionLabel";
    spanLat.id = this._addUID("GPmousePositionLatLabel");
    spanLat.innerHTML = "Latitude : ";
    divLat.appendChild(spanLat);
    var span = document.createElement("span");
    span.id = this._addUID("GPmousePositionLatCoordinate");
    var arrayCoords;
    if (currentProjectionUnits === "DMS") {
      arrayCoords = this._createDMSCoordinateElement("Lat", editCoordinates);
    } else {
      arrayCoords = this._createCoordinateElement("Lat", editCoordinates);
    }
    for (var i = 0; i < arrayCoords.length; i++) {
      span.appendChild(arrayCoords[i]);
    }
    divLat.appendChild(span);
    div.appendChild(divLat);
    var divLon = document.createElement("div");
    var spanLon = document.createElement("span");
    spanLon.className = "GPmousePositionLabel";
    spanLon.id = this._addUID("GPmousePositionLonLabel");
    spanLon.innerHTML = "Longitude : ";
    divLon.appendChild(spanLon);
    var span1 = document.createElement("span");
    span1.id = this._addUID("GPmousePositionLonCoordinate");
    var arrayCoords1;
    if (currentProjectionUnits === "DMS") {
      arrayCoords1 = this._createDMSCoordinateElement("Lon", editCoordinates);
    } else {
      arrayCoords1 = this._createCoordinateElement("Lon", editCoordinates);
    }
    for (var j2 = 0; j2 < arrayCoords1.length; j2++) {
      span1.appendChild(arrayCoords1[j2]);
    }
    divLon.appendChild(span1);
    div.appendChild(divLon);
    return div;
  },
  /**
   * @param {Boolean} [display=false] - specifies if the altitude panel must be displayed
   *
   * @returns {HTMLElement} container
   */
  _createMousePositionPanelBasicAltitudeElement: function(display) {
    var div = document.createElement("div");
    div.id = this._addUID("GPmousePositionAltitude");
    div.style.display = display ? "block" : "none";
    var spanLabel = document.createElement("span");
    spanLabel.className = "GPmousePositionLabel";
    spanLabel.innerHTML = "Altitude : ";
    div.appendChild(spanLabel);
    var spanAlt = document.createElement("span");
    spanAlt.className = "GPmousePositionCoords";
    spanAlt.id = this._addUID("GPmousePositionAlt");
    spanAlt.innerHTML = "...";
    div.appendChild(spanAlt);
    var spanUnits = document.createElement("span");
    spanUnits.className = "GPmousePositionAltitudeUnits";
    spanUnits.innerHTML = "m";
    div.appendChild(spanUnits);
    return div;
  },
  /**
   * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed
   *
   * @returns {HTMLElement} container
   */
  _createMousePositionPanelEditToolsElement: function(editCoordinates) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPmousePositionPanelEditTools";
    div.id = this._addUID("GPmousePositionPanelEditTools");
    if (!editCoordinates) {
      div.style.display = "none";
    }
    var span1 = document.createElement("span");
    span1.className = "GPmousePositionEditTool gpf-btn gpf-btn-icon gpf-btn-icon-mp-edit fr-btn fr-btn--tertiary gpf-btn--tertiary";
    span1.id = this._addUID("GPmousePositionLocate");
    span1.title = editCoordinates === true ? "Cliquer pour saisir des coordonnÃ©es" : "";
    if (editCoordinates) {
      span1.addEventListener("click", function() {
        context.onMousePositionEditModeLocateClick();
      });
    }
    div.appendChild(span1);
    var span2 = document.createElement("span");
    span2.className = "GPmousePositionEditTool gpf-btn gpf-btn-icon gpf-btn-icon-mp-edit-close fr-btn fr-btn--tertiary gpf-btn--tertiary";
    span2.id = this._addUID("GPmousePositionCloseEdit");
    span2.title = "Quitter la saisie des coordonnÃ©es";
    span2.style.display = "none";
    if (editCoordinates) {
      span2.addEventListener("click", function() {
        context.onMousePositionEditModeClick(false);
      });
    }
    div.appendChild(span2);
    return div;
  },
  // ################################################################### //
  // #################### Settings container ########################### //
  // ################################################################### //
  /**
   * @param {Boolean} [display=false] - specifies if the settings panel must be displayed
   *
   * @returns {HTMLElement[]} array containing input and label elements
   */
  _createShowMousePositionSettingsElement: function(display) {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowMousePositionSettings");
    button.className = "GPelementHidden GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowMousePositionSettingsPicto gpf-hidden gpf-btn fr-btn--sm fr-btn--tertiary gpf-btn--tertiary fr-icon-arrow-down-fill";
    button.title = "RÃ©glages";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", true);
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowMousePositionSettingsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowMousePositionSettingsClick(e);
      });
    }
    return button;
  },
  /**
   * settings panel
   * @param {Boolean} [display=true] - specifies if the settings panel must be displayed
   *
   * FIXME
   * don't call this._createMousePositionSettingsSystemsElement
   * don't call this._createMousePositionSettingsUnitsElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionSettingsElement: function(display) {
    var container = document.createElement("div");
    container.id = this._addUID("GPmousePositionSettings");
    container.style.display = display === void 0 || display ? "block" : "none";
    container.classList.add("fr-m-1w");
    var span = document.createElement("span");
    span.className = "GPmousePositionSettingsLabel";
    container.appendChild(span);
    return container;
  },
  /**
   * settings accordion
   * @param { [HTMLElement] } htmlContent - array of DOM elements to append
   *
   * @returns {HTMLElement} DOM element
   */
  _createMousePositionSettingsAccordion: function(htmlContent) {
    var div = stringToHTML(
      `
                <section class="fr-accordion">
                               <div class="fr-accordion__title GPmousePositionSettingsLabel">
                                   <button type="button" class="fr-accordion__btn" aria-expanded="false" aria-controls="accordion-more-settings-1">
                                       <span class="GPshowMousePositionAdvancedTools gpf-hidden"></span>SystÃ¨me de rÃ©fÃ©rence
                                   </button>
                               </div>
                               <div class="fr-collapse GPelementHidden" id="accordion-more-settings-1">
                               </div>
                    </section>
           `
    );
    htmlContent.map((content) => div.getElementsByClassName("fr-collapse")[0].append(content));
    div.getElementsByTagName("button")[0].addEventListener("click", function(e) {
      var status = e.target.ariaExpanded === "true";
      e.target.setAttribute("aria-expanded", !status);
      if (!status) {
        div.getElementsByClassName("fr-collapse")[0].classList.add("fr-collapse--expanded");
        div.getElementsByClassName("fr-collapse")[0].classList.remove("GPelementHidden");
      } else {
        div.getElementsByClassName("fr-collapse")[0].classList.remove("fr-collapse--expanded");
        div.getElementsByClassName("fr-collapse")[0].classList.add("GPelementHidden");
      }
    });
    return div;
  },
  /**
   * @param {Object[]} systems - list of systems
   *
   * @returns {HTMLElement} DOM element select
   */
  _createMousePositionSettingsSystemsElement: function(systems) {
    var context = this;
    var selectSystem = document.createElement("select");
    selectSystem.id = this._addUID("GPmousePositionProjectionSystem");
    selectSystem.className = "GPselect GPmousePositionSettingsSelect gpf-select fr-select fr-my-1w";
    selectSystem.addEventListener("change", function(e) {
      context.onMousePositionProjectionSystemChange(e);
    });
    selectSystem.addEventListener("mouseover", function(e) {
      if (e.target.nodeName !== "OPTION") {
        context.onMousePositionProjectionSystemMouseOver(e);
      }
    });
    selectSystem.title = "Type de systÃ¨me";
    for (var i = 0; i < systems.length; i++) {
      var obj = systems[i];
      var option2 = document.createElement("option");
      option2.value = obj.code;
      option2.text = obj.label || i;
      selectSystem.appendChild(option2);
    }
    return selectSystem;
  },
  /**
   * @param {Object[]} units - list of units
   *
   * @returns {HTMLElement} DOM element select
   */
  _createMousePositionSettingsUnitsElement: function(units) {
    var context = this;
    var selectUnits = document.createElement("select");
    selectUnits.id = this._addUID("GPmousePositionProjectionUnits");
    selectUnits.className = "GPselect GPmousePositionSettingsSelect gpf-select fr-select";
    selectUnits.addEventListener("change", function(e) {
      context.onMousePositionProjectionUnitsChange(e);
    });
    selectUnits.title = "UnitÃ©s du systÃ¨me";
    for (var j2 = 0; j2 < units.length; j2++) {
      var obj = units[j2];
      var option2 = document.createElement("option");
      option2.value = obj.code ? obj.code : j2;
      option2.text = obj.label || j2;
      selectUnits.appendChild(option2);
    }
    return selectUnits;
  },
  /**
   * @param {String} [currentProjectionType="Metric"] - "Geographical" or "Metric"
   */
  _resetLabelElements: function(currentProjectionType) {
    var spanLat = document.getElementById(this._addUID("GPmousePositionLatLabel"));
    spanLat.innerHTML = currentProjectionType === "Geographical" ? "Latitude :" : "X :";
    var spanLon = document.getElementById(this._addUID("GPmousePositionLonLabel"));
    spanLon.innerHTML = currentProjectionType === "Geographical" ? "Longitude :" : "Y :";
  },
  /**
   * @param {String} currentProjectionUnits - projection units
   */
  _resetUnitElements: function(currentProjectionUnits) {
    var value2 = "";
    if (currentProjectionUnits === "M" || currentProjectionUnits === "KM") {
      value2 = currentProjectionUnits.toLowerCase();
    }
    var elts = document.getElementsByClassName("GPmousePositionUnits");
    for (var e = 0; e < elts.length; e++) {
      elts[e].innerHTML = value2;
    }
  },
  /**
   * @param {Boolean} editCoordinates - edit coordinates option
   * @param {String} currentProjectionType - current projection type
   * @param {String} currentProjectionUnits - current projection unit
   */
  _resetCoordinateElements: function(editCoordinates, currentProjectionType, currentProjectionUnits) {
    var latElt = document.getElementById(this._addUID("GPmousePositionLatCoordinate"));
    while (latElt.firstChild) {
      latElt.removeChild(latElt.firstChild);
    }
    var arrayCoords;
    if (currentProjectionUnits === "DMS") {
      arrayCoords = this._createDMSCoordinateElement("Lat", editCoordinates);
    } else {
      arrayCoords = this._createCoordinateElement("Lat", editCoordinates);
    }
    for (var i = 0; i < arrayCoords.length; i++) {
      latElt.appendChild(arrayCoords[i]);
    }
    var lonElt = document.getElementById(this._addUID("GPmousePositionLonCoordinate"));
    while (lonElt.firstChild) {
      lonElt.removeChild(lonElt.firstChild);
    }
    var arrayCoords1;
    if (currentProjectionUnits === "DMS") {
      arrayCoords1 = this._createDMSCoordinateElement("Lon", editCoordinates);
    } else {
      arrayCoords1 = this._createCoordinateElement("Lon", editCoordinates);
    }
    for (var j2 = 0; j2 < arrayCoords1.length; j2++) {
      lonElt.appendChild(arrayCoords1[j2]);
    }
  },
  /**
   * Set/unset editing mode
   *
   * @param {Boolean} editing - active edit coordinates mode
   */
  _setEditMode: function(editing) {
    var locateElt = document.getElementById(this._addUID("GPmousePositionLocate"));
    locateElt.title = editing ? "Aller Ã  la position ..." : "Cliquer pour saisir des coordonnÃ©es";
    var closeEditElt = document.getElementById(this._addUID("GPmousePositionCloseEdit"));
    closeEditElt.style.display = editing ? "inline-block" : "none";
    if (editing === true) {
      locateElt.classList.remove("gpf-btn-icon-mp-edit");
      locateElt.classList.add("gpf-btn-icon-mp-edit-center");
      document.getElementById(this._addUID("GPmousePositionLat")).focus();
    } else {
      locateElt.classList.remove("gpf-btn-icon-mp-edit-center");
      locateElt.classList.add("gpf-btn-icon-mp-edit");
    }
    var selector = "div[id^=" + this._addUID("GPmousePositionCoordinate") + "]";
    var inputs = document.querySelectorAll(selector + " input");
    for (var i = 0; i < inputs.length; i++) {
      inputs[i].readOnly = !editing;
      if (editing) {
        inputs[i].classList.remove("error");
      }
    }
    var selects = document.querySelectorAll(selector + " select");
    for (var j2 = 0; j2 < selects.length; j2++) {
      selects[j2].disabled = !editing;
    }
  },
  /**
   *
   * @param {HTMLElement} input - input element
   * @param {Boolean} isFloat - check for float value
   *
   * @returns {Boolean} true if input value is within bounds
   */
  _checkDMSElement: function(input, isFloat) {
    var b3 = isFloat !== void 0;
    var value2 = input.value;
    if (b3) {
      value2 = value2.replace(",", ".");
    }
    if (isNaN(value2)) {
      return false;
    }
    var v2 = parseFloat(value2);
    if (!b3 && (v2 | 0) !== v2) {
      return false;
    }
    var min = Number(input.dataset.min);
    var max = Number(input.dataset.max);
    return v2 >= min && v2 <= max;
  },
  /**
   * @param {String} coordType - "Lon" or "Lat"
   * @param {HTMLElement} input - input element
   *
   * @returns {Boolean} true if input value is within bounds
   */
  _checkDMSDegrees: function(coordType, input) {
    if (isNaN(input.value)) {
      return false;
    }
    var v2 = parseFloat(input.value);
    if ((v2 | 0) !== v2) {
      return false;
    }
    var min = Number(input.dataset.min);
    var max = Number(input.dataset.max);
    if (v2 < min || v2 > max) {
      return false;
    }
    var inputMinutes = document.getElementById(this._addUID("GPmousePosition" + coordType + "Minutes"));
    var inputSeconds = document.getElementById(this._addUID("GPmousePosition" + coordType + "Seconds"));
    if (v2 >= max) {
      inputMinutes.dataset.max = 0;
      inputSeconds.dataset.max = 0;
    } else {
      inputMinutes.dataset.max = 59;
      inputSeconds.dataset.max = 59.9999;
    }
    return true;
  },
  // ################################################################### //
  // ####################### handlers Event ############################ //
  // ################################################################### //
  /**
   * Function displaying coordinates from cursor position (desktop)
   * or map center (tactile)
   * @param {Object} coordinate - coordinates
   */
  GPdisplayCoords: function(coordinate) {
    if (coordinate) {
      var labelLon = document.getElementById(this._addUID("GPmousePositionLonLabel"));
      var labelLat = document.getElementById(this._addUID("GPmousePositionLatLabel"));
      if (coordinate.x || coordinate.y) {
        labelLat.innerHTML = "X : ";
        labelLon.innerHTML = "Y : ";
      } else if (coordinate.e || coordinate.n) {
        labelLat.innerHTML = "E : ";
        labelLon.innerHTML = "N : ";
      } else {
        labelLat.innerHTML = "Latitude : ";
        labelLon.innerHTML = "Longitude : ";
      }
      if (typeof coordinate.lat === "object" && typeof coordinate.lng === "object") {
        var parts = {
          lng: "Lon",
          lat: "Lat"
        };
        var units = ["Degrees", "Minutes", "Seconds"];
        for (var p2 in parts) {
          for (var u = 0; u < units.length; ++u) {
            var selector = "GPmousePosition" + parts[p2] + units[u];
            var elt = document.getElementById(this._addUID(selector));
            var key = units[u].charAt(0).toLowerCase();
            elt.value = coordinate[p2][key];
          }
        }
        document.getElementById(this._addUID("GPmousePositionLonDirection")).value = coordinate.lng.direction;
        document.getElementById(this._addUID("GPmousePositionLatDirection")).value = coordinate.lat.direction;
      } else {
        var elLat = document.getElementById(this._addUID("GPmousePositionLat"));
        var elLon = document.getElementById(this._addUID("GPmousePositionLon"));
        elLat.value = coordinate.x || coordinate.lat || coordinate.e || "0";
        elLon.value = coordinate.y || coordinate.lng || coordinate.lon || coordinate.n || "0";
        elLat.title = "Latitude";
        elLon.title = "Longitude";
        elLat.type = "text";
        elLon.type = "text";
        var unit = coordinate.unit === void 0 ? "" : coordinate.unit;
        var elements = document.getElementsByClassName("GPmousePositionUnits");
        for (var n = 0; n < elements.length; ++n) {
          elements[n].innerHTML = unit;
        }
      }
    }
  },
  /**
   * Function displaying altitude from cursor position (desktop)
   * or map center (tactile)
   * @param {Object} coordinate - coordinates
   * @param {Number} altitudeTimeoutDelay - when the mouse stop moving, delay before the altitude request is launched
   * @param {Number} noDataValue - the no data value
   * @param {Number} noDataValueTolerance - the no data value tolerance
   */
  GPdisplayElevation: function(coordinate, altitudeTimeoutDelay, noDataValue, noDataValueTolerance) {
    var self2 = this;
    var altitudeTimeout;
    if (!altitudeTimeoutDelay) {
      altitudeTimeoutDelay = 500;
    }
    clearTimeout(altitudeTimeout);
    document.getElementById(this._addUID("GPmousePositionAlt")).innerHTML = "...";
    if (noDataValue == null) {
      noDataValue = -99999;
    }
    if (noDataValueTolerance == null) {
      noDataValueTolerance = 99980;
    }
    var maxThreshold = noDataValue + noDataValueTolerance;
    var minThreshold = noDataValue - noDataValueTolerance;
    if (coordinate) {
      if (document.getElementById(this._addUID("GPmousePositionAltitude"))) {
        altitudeTimeout = setTimeout(function() {
          self2.onRequestAltitude(coordinate, function(z3) {
            if (minThreshold < z3 && z3 < maxThreshold) {
              self2.GPresetElevation();
            } else {
              document.getElementById(self2._addUID("GPmousePositionAlt")).innerHTML = z3;
            }
          });
        }, altitudeTimeoutDelay);
      }
    }
  },
  /**
   * Function reseting altitude value
   */
  GPresetElevation: function() {
    if (document.getElementById(this._addUID("GPmousePositionAltitude"))) {
      document.getElementById(this._addUID("GPmousePositionAlt")).innerHTML = "---";
    }
  }
};
var MousePositionDOM_default = MousePositionDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/MousePosition/MousePosition.js
var logger15 = LoggerByDefault_default2.getLogger("GeoportalMousePosition");
var MousePosition = class _MousePosition extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - options for function call.
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {String}  [options.apiKey] - API key. The key "calcul" is used by default.
   * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
   * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
   * @param {Boolean} [options.collapsed = true] - Specify if MousePosition control should be collapsed at startup. Default is true.
   * @param {Array}   [options.units] - list of coordinates units, to be displayed in control units list.
   *      Values may be "DEC" (decimal degrees), "DMS" (sexagecimal), "RAD" (radians) and "GON" (grades) for geographical coordinates,
   *      and "M" or "KM" for metric coordinates
   * @param {Boolean}   [options.displayAltitude = true] - activate (true) or deactivate (false) the altitude panel. True by default
   * @param {Boolean}   [options.displayCoordinates = true] - activate (true) or deactivate (false) the coordinates panel. True by default
   * @param {Boolean} [options.editCoordinates = false] - If true, coordinates from the MousePosition control can be edited by users to re-center the view. False by default.
   * @param {Function} [options.mapCenterCallback] - callback...
   * @param {Array}   [options.systems] - list of projection systems, default are Geographical ("EPSG:4326"), Web Mercator ("EPSG:3857"), Lambert 93 ("EPSG:2154") and extended Lambert 2 ("EPSG:27572").
   *      Each array element (=system) is an object with following properties :
   * @param {String}  options.systems.crs - Proj4 crs alias (from proj4 defs). e.g. : "EPSG:4326". Required
   * @param {String}  [options.systems.label] - CRS label to be displayed in control. Default is crs code (e.g. "EPSG:4326")
   * @param {String}  options.systems.type - CRS units type for coordinates conversion : "Geographical" or "Metric". Default: "Metric"
   * @param {Object}  [options.systems.geoBBox] - Aera covered by the system (WGS84 coordinates).
   * @param {Number}  options.systems.geoBBox.right - Right bound.
   * @param {Number}  options.systems.geoBBox.left - Left bound.
   * @param {Number}  options.systems.geoBBox.top - Top bound.
   * @param {Number}  options.systems.geoBBox.bottom - Bottom bound.
   * @param {Object} [options.positionMarker] - options for position marker
   * @param {String} options.positionMarker.url - Marker url (define in src/Openlayers/Controls/Utils/Markers.js)
   * @param {Array} options.positionMarker.offset - Offsets in pixels used when positioning the marker towards targeted point.
   *      The first element in the array is the horizontal offset. A positive value shifts the marker right.
   *      The second element in the array is the vertical offset. A positive value shifts the marker down. [0,0] value positions the top-left corner of the marker image to the targeted point.
   *      Default is offset associated to default marker image.
   * @param {Boolean} options.positionMarker.hide - if true, marker is not displayed, otherwise displayed (False by default.)
   * @param {Object}  [options.altitude] - elevation configuration
   * @param {Object}  [options.altitude.serviceOptions] - options of elevation service
   * @param {Number}  [options.altitude.responseDelay] - latency for altitude request, 500 ms by default
   * @param {Number}  [options.altitude.triggerDelay] - immobilisation time of movement on the map to trigger the elevation calculation, 200 ms by default
   * @param {Number}  [options.altitude.noDataValue] - value used for altitude service no data (default is -99999). In this case, "---m" will be displayed instead of "-99999m"
   * @param {Number}  [options.altitude.noDataValueTolerance] - tolerance for no data value :
   *                  values in [noDataValue + noDataValueTolerance ; noDataValue - noDataValueTolerance] interval will not be displayed, but "---m" will be displayed instead.
   *                  Default is 90000 (no data values = [-9999 ; -189999])
   *  @example
   *  var MousePosition = new ol.control.GeoportalMousePosition({
   *      "collapsed" : false,
   *      "graggable" : true,
   *      "displayCoordinates" : true,
   *      "displayAltitude" : true,
   *      "altitude" : {
   *           "triggerDelay" : 100,
   *           "responseDelay" : 500,
   *           "noDataValue" : -99999,
   *           "noDataValueTolerance" : 99000,
   *           "serviceOptions" : {}
   *      },
   *      "systems" : [
   *       {
   *          "crs" : "EPSG:3857",
   *          "label" : "Web Mercator",
   *          "type" : "Metric"
   *       },
   *       {
   *          "crs" : "EPSG:4326",
   *          "label" : "GÃ©ographiques",
   *          "type" : "Geographical"
   *       },
   *       {
   *           "label" : "Lambert 93",
   *           "crs" : "EPSG:2154",
   *           "type" : "Metric",
   *           "geoBBox" : {
   *               "left" : -9.86,
   *               "bottom" : 41.15,
   *               "right" : 10.38,
   *               "top" : 51.56
   *           }
   *        }
   *      ],
   *      "units" : ["DEC", "DMS"]
   * });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _MousePosition)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "MousePosition";
    this._initialize(options);
    this.container = this._initContainer(this.options);
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  /**
   * Overload ol.control.Control setMap method, called when
   *
   * @param {Map} map - the map
   *
   */
  setMap(map) {
    var context = this;
    if (map) {
      var center = this._createMapCenter();
      map.getViewport().appendChild(center);
      if (!this.collapsed && !this._isDesktop) {
        center.className = "GPmapCenterVisible";
      }
      if (this.draggable) {
        Draggable_default.dragElement(
          this._panelMousePositionContainer,
          this._panelHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        if (this._isDesktop) {
          this.listenerKey = map.on(
            "pointermove",
            (e) => {
              this.onMouseMove(e);
            }
          );
        } else {
          this.listenerKey = map.on(
            "moveend",
            (e) => this.onMapMove(e)
          );
        }
        this._showMousePositionButton.setAttribute("aria-pressed", true);
      }
      if (this.options.editCoordinates) {
        var markerDiv = document.createElement("img");
        markerDiv.id = this._addUID("GPmousePositionMarker");
        markerDiv.src = this._markerUrl;
        markerDiv.title = "Cliquer pour supprimer";
        markerDiv.addEventListener("click", function() {
          context._markerOverlay.setPosition(void 0);
        });
        this._markerOverlay = new Overlay_default({
          offset: this._markerOffset,
          element: markerDiv,
          stopEvent: false
        });
        map.addOverlay(this._markerOverlay);
      }
    } else {
      unByKey(this.listenerKey);
    }
    super.setMap(map);
    if (map === null) {
      return;
    }
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
    if (!this.collapsed) {
      var inputShow = document.getElementById("GPshowMousePosition-" + this._uid);
      inputShow.checked = "checked";
      this._setElevationPanel(this.options.displayAltitude);
      this._setCoordinatesPanel(this.options.displayCoordinates);
      if (!this.options.displayCoordinates) {
        this._setSettingsPanel(false);
      }
    }
  }
  // ################################################################### //
  // #################### user interface methods ####################### //
  // ################################################################### //
  /**
   * Set additional projection system
   *
   * @param {Object} system - projection system
   * @param {String} system.crs - Proj4 crs alias (from proj4 defs) e.g. "EPSG:4326"
   * @param {String} [system.label] - CRS label to be displayed in control. Default is system.crs alias
   * @param {String} [system.type] - CRS units type for coordinates conversion (one of control options.units). Default is "Metric"
   */
  addSystem(system) {
    if (typeof system !== "object") {
      logger15.log("[ERROR] MousePosition:addSystem - system parameter should be an object");
      return;
    }
    if (!system.crs) {
      logger15.error("crs not defined !");
      return;
    }
    if (!system.label) {
      logger15.warn("crs label not defined, use crs code by default.");
      system.label = system.crs;
    }
    if (!system.type) {
      logger15.warn("type srs not defined, use 'Metric' by default.");
      system.type = "Metric";
    }
    CRS_default.loadByName(system.crs);
    if (!get2(system.crs)) {
      logger15.error("crs '{}' not available into proj4 definitions !", system.crs);
      return;
    }
    for (var j2 = 0; j2 < this._projectionSystems.length; j2++) {
      var obj = this._projectionSystems[j2];
      if (system.crs === obj.crs) {
        logger15.info("crs '{}' already configured", obj.crs);
      }
    }
    system.code = this._projectionSystems.length;
    this._projectionSystems.push(system);
    var selectSystem = document.getElementById("GPmousePositionProjectionSystem-" + this._uid);
    if (selectSystem) {
      var option2 = document.createElement("option");
      option2.value = system.code;
      option2.text = system.label;
      selectSystem.appendChild(option2);
    }
  }
  /**
   * Set additional projection systems
   *
   * @param {Array} systems - Array of system object, with following properties :
   * @param {String} systems.crs - Proj4 CRS alias (from proj4 defs) e.g. "EPSG:4326"
   * @param {String} systems.label - CRS label (for coordinates conversion)
   * @param {String} systems.type - CRS units type to be displayed in control (one of control options.units). Default is "Metric"
   */
  addSystems(systems) {
    if (!systems) {
      return;
    }
    if (!Array.isArray(systems)) {
      logger15.log("[ERROR] MousePosition:addSystems - systems parameter should be an array");
      return;
    }
    for (var i = 0; i < systems.length; i++) {
      this.addSystem(systems[i]);
    }
  }
  /**
   * Remove projection system (in case there are several system with same code, only the first one will be removed)
   *
   * @param {String} systemCrs - CRS alias (from proj4 defs)
   */
  removeSystem(systemCrs) {
    if (!systemCrs || typeof systemCrs !== "string") {
      logger15.log("[ERROR] MousePosition:removeSystem - systemCode parameter should be a string");
      return;
    }
    var systemList = document.getElementById("GPmousePositionProjectionSystem-" + this._uid);
    var systemCode = null;
    for (var i = 0; i < this._projectionSystems.length; i++) {
      var proj = this._projectionSystems[i];
      if (systemCrs === proj.crs) {
        systemCode = proj.code;
        this._projectionSystems.splice(i, 1);
        break;
      }
    }
    if (systemCode == null) {
      logger15.log("[WARN] MousePosition:removeSystem - system not found");
      return;
    }
    var oldNewCodeMap = [];
    for (var j2 = 0; j2 < this._projectionSystems.length; j2++) {
      oldNewCodeMap[Number(this._projectionSystems[j2].code)] = j2;
      this._projectionSystems[j2].code = j2;
    }
    var indexChildToRemove = null;
    for (var k3 = 0; k3 < systemList.childNodes.length; k3++) {
      if (systemCode === systemList.childNodes[j2].value) {
        indexChildToRemove = k3;
        continue;
      }
      systemList.childNodes[j2].value = oldNewCodeMap[Number(systemList.childNodes[j2].value)];
    }
    if (indexChildToRemove != null) {
      systemList.removeChild(systemList.childNodes[indexChildToRemove]);
    }
    if (this._currentProjectionSystems.code === Number(systemCode)) {
      systemList.childNodes[0].setAttribute("selected", "selected");
      this._setCurrentSystem(systemList.childNodes[0].value);
    }
  }
  /**
   * Set control units (to be displayed)
   *
   * @param {Array} units - list of all coordinates units, to be displayed in control units list.
   *      Values may be "DEC" (decimal degrees), "DMS" (sexagecimal), "RAD" (radians) and "GON" (grades) for geographical coordinates,
   *      and "M" or "KM" for metric coordinates
   */
  setUnits(units) {
    if (!units || !Array.isArray(units)) {
      return;
    }
    this.options.units = units;
    this._projectionUnits = [];
    this._initProjectionUnits();
    if (this._currentProjectionType) {
      this._setTypeUnitsPanel(this._currentProjectionType);
    }
  }
  /**
   * Set control altitude options (useless if displayAltitude == false)
   *
   * @param {Object} options - altitude options
   * @param {Object}  [options.serviceOptions] - options of elevation service
   * @param {Number}  [options.responseDelay] - latency for elevation request, 500 ms by default
   * @param {Number}  [options.triggerDelay] - immobilisation time of movement on the map to trigger the elevation calculation, 200 ms by default
   */
  setAltitudeOptions(options) {
    if (!options || typeof options !== "object") {
      return;
    }
    this.options.altitude.triggerDelay = options.triggerDelay;
    this.options.altitude.responseDelay = options.responseDelay;
    if (options.serviceOptions) {
      for (var opt in options.serviceOptions) {
        if (options.serviceOptions.hasOwnProperty(opt)) {
          this.options.altitude.serviceOptions[opt] = options.serviceOptions[opt];
        }
      }
    }
  }
  /**
   * Display or hide elevation panel
   *
   * @param {Boolean} displayAltitude - true to display elevation panel, false to hide it
   */
  displayAltitude(displayAltitude) {
    if (displayAltitude === void 0) {
      return;
    }
    this.options.displayAltitude = displayAltitude;
    this._setElevationPanel(displayAltitude);
  }
  /**
   * Display or hide coordinates panel
   *
   * @param {Boolean} displayCoordinates - true to display coordinates panel, false to hide it
   */
  displayCoordinates(displayCoordinates) {
    if (displayCoordinates === void 0) {
      return;
    }
    this.options.displayCoordinates = displayCoordinates;
    this._setCoordinatesPanel(displayCoordinates);
    this._setSettingsPanel(displayCoordinates);
  }
  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger15.log("[ERROR] MousePosition:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (!this._isDesktop) {
      document.getElementById("GPmapCenter").className = collapsed ? "" : "GPmapCenterVisible";
    }
    this.onShowMousePositionClick();
    this._showMousePositionContainer.checked = !collapsed;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ######################## initialize control ####################### //
  // ################################################################### //
  /**
   * Initialize control (called by MousePosition constructor)
   *
   * @param {Object} options - control options (set by user)
   * @private
   */
  _initialize(options) {
    options = options || {};
    this.options = options;
    this.options.collapsed = options.collapsed !== void 0 ? options.collapsed : true;
    this.collapsed = this.options.collapsed;
    this.options.draggable = options.draggable !== void 0 ? options.draggable : false;
    this.draggable = this.options.draggable;
    this._markerOverlay = null;
    this._markerUrl = null;
    this._markerOffset = [0, 0];
    this._hideMarker = false;
    this._initMarker(options.positionMarker);
    this.options.units = options.units || [];
    this.options.displayAltitude = options.displayAltitude !== void 0 ? options.displayAltitude : true;
    this.options.displayCoordinates = options.displayCoordinates !== void 0 ? options.displayCoordinates : true;
    if (this.options.displayCoordinates) {
      this.options.editCoordinates = options.editCoordinates !== void 0 ? options.editCoordinates : false;
    } else {
      this.options.editCoordinates = false;
    }
    this.editing = false;
    this.options.systems = options.systems || [];
    if (options.altitude) {
      var altitude = options.altitude;
      this.options.altitude = {
        triggerDelay: altitude.triggerDelay !== void 0 ? altitude.triggerDelay : 200,
        responseDelay: altitude.responseDelay !== void 0 ? altitude.responseDelay : 500,
        serviceOptions: altitude.serviceOptions || {},
        noDataValue: altitude.noDataValue !== void 0 ? altitude.noDataValue : -99999,
        noDataValueTolerance: altitude.noDataValueTolerance !== void 0 ? altitude.noDataValueTolerance : 9e4
      };
    } else {
      this.options.altitude = {
        triggerDelay: 200,
        responseDelay: 500,
        serviceOptions: {}
      };
    }
    this._uid = this.options.id || SelectorID_default.generate();
    this._projectionSystems = [];
    this._initProjectionSystems();
    this._projectionUnits = {};
    this._initProjectionUnits();
    this._isDesktop = Helper_default2.detectSupport();
    if (this.options.altitude.triggerDelay < 100) {
      this.options.altitude.triggerDelay = 100;
    }
    this._timer = this.options.altitude.triggerDelay;
    this._currentProjectionSystems = this._projectionSystems[0];
    this._currentProjectionType = this._projectionSystems[0].type;
    this._currentProjectionUnits = this._projectionUnits[this._currentProjectionType][0].code;
    this._projectionUnitsContainer = null;
    this._showMousePositionContainer = null;
    this._panelMousePositionContainer = null;
    this._panelHeaderMousePositionContainer = null;
    if (!this.options.displayAltitude && !this.options.displayCoordinates) {
      this.options.displayCoordinates = true;
    }
    this.listenerKey = null;
  }
  /**
   *
   * @param {Object} option - positionMarker option
   * @private
   */
  _initMarker(option2) {
    if (!this.options.editCoordinates) {
      return;
    }
    if (!option2) {
      this._markerUrl = Markers_default["lightOrange"];
      this._markerOffset = Markers_default.defaultOffset;
      return;
    }
    this._hideMarker = option2.hide !== void 0 ? option2.hide : false;
    if (option2.offset) {
      if (Array.isArray(option2.offset) && option2.offset.length === 2) {
        this._markerOffset = option2.offset;
      } else {
        logger15.log("positionMarker.offset should be an array. e.g. : [0,0]");
        this._markerOffset = Markers_default.defaultOffset;
      }
    } else {
      this._markerOffset = Markers_default.defaultOffset;
    }
    var url = option2.url;
    if (!url) {
      this._markerUrl = Markers_default["lightOrange"];
    } else if (url.match(/^[a-zA-Z]+$/)) {
      this._markerUrl = Markers_default[url] !== void 0 ? Markers_default[url] : Markers_default["lightOrange"];
    } else {
      this._markerUrl = url;
    }
  }
  /**
   * this method is called by the constructor and initialize the projection
   * systems.
   * getting coordinates in the requested projection :
   * see this.onMousePositionProjectionSystemChange()
   *
   * @private
   */
  _initProjectionSystems() {
    var projectionSystemsByDefault = [{
      label: "GÃ©ographique",
      crs: get2("EPSG:4326").getCode(),
      type: "Geographical"
    }, {
      label: "Web Mercator",
      crs: get2("EPSG:3857").getCode(),
      type: "Metric"
    }, {
      label: "Lambert 93",
      crs: get2("EPSG:2154").getCode(),
      type: "Metric",
      geoBBox: {
        left: -9.86,
        bottom: 41.15,
        right: 10.38,
        top: 51.56
      }
    }, {
      label: "Lambert II Ã©tendu",
      crs: get2("EPSG:27572").getCode(),
      type: "Metric",
      geoBBox: {
        left: -4.87,
        bottom: 42.33,
        right: 8.23,
        top: 51.14
      }
    }];
    var systems = this.options.systems;
    for (var i = 0; i < systems.length; i++) {
      var sys = systems[i];
      this.addSystem(sys);
    }
    if (this._projectionSystems.length === 0) {
      for (var j2 = 0; j2 < projectionSystemsByDefault.length; j2++) {
        this.addSystem(projectionSystemsByDefault[j2]);
      }
    }
  }
  /**
   * this method is called by the constructor and initialize the units.
   * getting coordinates in the requested units :
   * see this.onMousePositionProjectionUnitsChange()
   *
   * @private
   */
  _initProjectionUnits() {
    var projectionUnitsByDefault = {
      Geographical: [{
        code: "DEC",
        label: "DegrÃ©s dÃ©cimaux",
        format: MathUtils_default.coordinateToDecimal
      }, {
        code: "DMS",
        label: "DegrÃ©s sexagÃ©simaux",
        format: MathUtils_default.coordinateToDMS
      }, {
        code: "RAD",
        label: "Radians",
        format: MathUtils_default.coordinateToRad
      }, {
        code: "GON",
        label: "Grades",
        format: MathUtils_default.coordinateToGon
      }],
      Metric: [{
        code: "M",
        label: "MÃ¨tres",
        format: MathUtils_default.coordinateToMeter
      }, {
        code: "KM",
        label: "KilomÃ¨tres",
        format: MathUtils_default.coordinateToKMeter
      }]
    };
    var units = this.options.units;
    for (var type in projectionUnitsByDefault) {
      if (projectionUnitsByDefault.hasOwnProperty(type)) {
        var found = false;
        for (var j2 = 0; j2 < projectionUnitsByDefault[type].length; j2++) {
          var obj = projectionUnitsByDefault[type][j2];
          for (var i = 0; i < units.length; i++) {
            var unit = units[i];
            if (obj.code === unit) {
              found = true;
              if (!this._projectionUnits[type]) {
                this._projectionUnits[type] = [];
              }
              this._projectionUnits[type].push(obj);
            }
          }
        }
        if (!found) {
          this._projectionUnits[type] = projectionUnitsByDefault[type];
        }
      }
    }
    if (typeof this._projectionUnits === "object" && Object.keys(this._projectionUnits).length === 0) {
      this._projectionUnits = projectionUnitsByDefault;
    }
  }
  /**
   * this method get label from the current projection units
   *
   * @returns {String} projection information
   *
   * @private
   */
  _getCurrentProjectionInformation() {
    var systemInfo = [
      this._currentProjectionSystems.label,
      "en"
    ];
    var units = this._projectionUnits[this._currentProjectionType];
    for (var u = 0; u < units.length; ++u) {
      if (units[u].code === this._currentProjectionUnits) {
        systemInfo.push(units[u].label);
        break;
      }
    }
    return systemInfo.join(" ");
  }
  // ################################################################### //
  // ######################## methods handle dom ####################### //
  // ################################################################### //
  /**
   * Create control main container (called by MousePosition constructor)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var picto = this._showMousePositionButton = this._createShowMousePositionPictoElement();
    container.appendChild(picto);
    var mousePositionPanel = this._panelMousePositionContainer = this._createMousePositionPanelElement();
    var mousePositionPanelDiv = this._createMousePositionPanelDivElement();
    mousePositionPanel.appendChild(mousePositionPanelDiv);
    var panelHeader = this._panelHeaderContainer = this._createMousePositionPanelHeaderElement();
    var panelTitle = this._panelTitleContainer = this._createMousePositionPanelTitleElement();
    panelHeader.appendChild(panelTitle);
    var closeDiv = this._panelCloseButton = this._createMousePositionPanelCloseElement();
    panelHeader.appendChild(closeDiv);
    mousePositionPanelDiv.appendChild(panelHeader);
    var basic = this._createMousePositionPanelBasicElement(
      this.options.displayAltitude,
      this.options.displayCoordinates,
      this.options.editCoordinates,
      this._currentProjectionUnits
    );
    mousePositionPanelDiv.appendChild(basic);
    var buttonSettings = this._createShowMousePositionSettingsElement(this.options.displayCoordinates);
    mousePositionPanelDiv.appendChild(buttonSettings);
    var settings = this._createMousePositionSettingsElement();
    var systems = this._projectionSystemsContainer = this._createMousePositionSettingsSystemsElement(this._projectionSystems);
    var units = this._projectionUnitsContainer = this._createMousePositionSettingsUnitsElement(this._projectionUnits[this._currentProjectionType]);
    var settingsAccordion = this._createMousePositionSettingsAccordion([systems, units]);
    settings.appendChild(settingsAccordion);
    mousePositionPanelDiv.appendChild(settings);
    container.appendChild(mousePositionPanel);
    return container;
  }
  /**
   * this method is called by this.()
   * and it changes the elevation view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */
  _setElevationPanel(active) {
    var div = null;
    if (!active) {
      div = document.getElementById("GPmousePositionAltitude-" + this._uid);
      div.style.display = "none";
    } else {
      div = document.getElementById("GPmousePositionAltitude-" + this._uid);
      div.style.display = "";
    }
  }
  /**
   * this method is called by this.()
   * and it changes the coordinate view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */
  _setCoordinatesPanel(active) {
    var div = document.getElementById("GPmousePositionCoordinate-" + this._uid);
    if (!active) {
      div.style.display = "none";
    } else {
      div.style.display = "";
    }
  }
  /**
   * this method is called by this.()
   * and it changes the settings view panel into the dom.
   *
   * @param {Boolean} active - true:active, false:disable
   * @private
   */
  _setSettingsPanel(active) {
    var divPicto = document.getElementById("GPshowMousePositionSettingsPicto-" + this._uid);
    var divPanel = document.getElementById("GPmousePositionSettings-" + this._uid);
    if (!active) {
      divPicto.style.display = "none";
      divPanel.style.display = "none";
    } else {
      divPicto.style.display = "";
      divPanel.style.display = "";
    }
  }
  /**
   * this method is called by this.onMousePositionProjectionSystemChange()
   * when changes to a metric or a geographical units.
   *
   * @param {String} type - Geographical or Metric
   * @private
   */
  _setTypeUnitsPanel(type) {
    var container = this._projectionUnitsContainer;
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var units = this._projectionUnits[type];
    for (var j2 = 0; j2 < units.length; j2++) {
      var obj = units[j2];
      var option2 = document.createElement("option");
      option2.value = obj.code ? obj.code : j2;
      option2.text = obj.label || j2;
      container.appendChild(option2);
    }
    var projectionUnits = this._projectionUnits[type][0].code;
    if (this._currentProjectionUnits === "DMS" || projectionUnits === "DMS") {
      this._resetCoordinateElements(this.options.editCoordinates, type, projectionUnits);
      this._setEditMode(this.editing);
    }
    this._currentProjectionType = type;
    this._resetLabelElements(type);
    this._resetUnitElements(projectionUnits);
    this._currentProjectionUnits = projectionUnits;
  }
  // ################################################################### //
  // ##################### handlers events to control ################## //
  // ################################################################### //
  /**
   * this sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */
  _setCoordinate(olCoordinate, crs) {
    var coordinate = {};
    var oSrs = this._currentProjectionSystems.crs;
    if (!oSrs) {
      logger15.log("ERROR : system crs not found");
      return;
    }
    olCoordinate = transform(olCoordinate, crs, oSrs);
    var type = this._currentProjectionSystems.type;
    var format = null;
    var units = this._projectionUnits[type];
    for (var i = 0; i < units.length; i++) {
      if (units[i].code === this._currentProjectionUnits) {
        format = units[i].format;
        break;
      }
    }
    if (!format || typeof format !== "function") {
      logger15.log("WARNING : coordinates format function not found");
      return;
    } else {
      coordinate = format(olCoordinate);
    }
    if (!coordinate || Object.keys(coordinate).length === 0) {
      return;
    }
    this.GPdisplayCoords(coordinate);
  }
  /**
   * this sends the coordinates to the panel.
   * (cf. this.GPdisplayElevation() into the DOM functions)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @private
   */
  _setElevation(olCoordinate) {
    var delay = this.options.altitude.responseDelay;
    var noDataValue = this.options.altitude.noDataValue;
    var noDataValueTolerance = this.options.altitude.noDataValueTolerance;
    this.GPdisplayElevation(olCoordinate, delay, noDataValue, noDataValueTolerance);
  }
  /**
   * this method is triggered when the mouse or the map is stopped.
   * (cf. onMouseMove and onMapMove)
   *
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat]
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */
  onMoveStopped(olCoordinate, crs) {
    var oLatLng = transform(olCoordinate, crs, "EPSG:4326");
    this._setElevation(oLatLng);
  }
  /**
   * this method is an handler event to control. The event is 'mousemove' on
   * the map. The handler sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onMouseMove(e) {
    var self2 = this;
    const event = e.originalEvent || e;
    if (this._panelMousePositionContainer.contains(event.target)) {
      return;
    }
    var coordinate = e.coordinate;
    if (!e.map || !e.map.getView()) {
      return;
    }
    var crs = e.map.getView().getProjection();
    this._setCoordinate(coordinate, crs);
    clearTimeout(this._timer);
    this._timer = setTimeout(function() {
      self2.onMoveStopped(coordinate, crs);
    }, this.options.altitude.triggerDelay);
  }
  /**
   * this method is an handler event to control. The event is 'moveend' on
   * the map. The handler sends the coordinates to the panel.
   * (cf. this.GPdisplayCoords() into the DOM functions)
   *
   * @private
   */
  onMapMove() {
    var self2 = this;
    var map = this.getMap();
    if (!map || !map.getView()) {
      return;
    }
    var view = map.getView();
    var coordinate = view.getCenter();
    var crs = view.getProjection();
    this._setCoordinate(coordinate, crs);
    clearTimeout(this._timer);
    this._timer = setTimeout(function() {
      self2.onMoveStopped(coordinate, crs);
    }, this.options.altitude.triggerDelay);
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by this.GPdisplayElevation() in the dom, and
   * it executes a request to the elevation service.
   *
   * @param {Object} coordinate - {lat:..., lng:...}
   * @param {Function} callback - callback
   * @private
   */
  onRequestAltitude(coordinate, callback) {
    if (!coordinate || Object.keys(coordinate).length === 0) {
      return;
    }
    if (!this.options.displayAltitude) {
      return;
    }
    var options = this.options.altitude.serviceOptions || {};
    var _protocol = options.protocol || "XHR";
    var _timeout = options.timeOut || 0;
    if (_protocol === "JSONP" && _timeout === 0) {
      _timeout = 15e3;
    }
    var _outputFormat = options.outputFormat || "json";
    var _zonly = true;
    var _zonly;
    if (options.zonly === false) {
      _zonly = options.zonly;
    } else {
      _zonly = true;
    }
    var _measures = options.measures || false;
    var _positions = [{
      lon: coordinate[0],
      lat: coordinate[1]
    }];
    var _resource = options.resource;
    var _scope = this;
    var _rawResponse = options.rawResponse || false;
    var _customOnSuccess = options.onSuccess || null;
    var _onSuccess = null;
    var _onFailure = null;
    if (!_rawResponse) {
      _onSuccess = function(results) {
        if (results && Object.keys(results).length) {
          if (_customOnSuccess) {
            _customOnSuccess.call(this, results);
          }
          callback.call(this, results.elevations[0].z);
        }
      };
    } else {
      _onSuccess = function(results) {
        if (_customOnSuccess) {
          _customOnSuccess.call(this, results);
        }
        logger15.log("alti service raw response : ", results);
      };
    }
    _onFailure = function(error) {
      logger15.log("[getAltitude] ERROR : " + error.message);
    };
    var _apiKey = options.apiKey || this.options.apiKey;
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    var _ssl = options.ssl;
    Gp_default.Services.getAltitude({
      apiKey: _apiKey,
      protocol: _protocol,
      ssl: _ssl,
      timeOut: _timeout,
      scope: _scope,
      outputFormat: _outputFormat,
      rawResponse: _rawResponse,
      onSuccess: _onSuccess,
      onFailure: _onFailure,
      zonly: _zonly,
      measures: _measures,
      resource: _resource,
      positions: _positions
    });
  }
  /**
   * this method is called by event 'click' on 'GPshowMousePositionPicto' tag label
   * (cf. this._createShowMousePositionPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @param { event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowMousePositionClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    var opened = this._showMousePositionButton.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
    if (opened === "false") {
      unByKey(this.listenerKey);
    } else if (!this.editing) {
      if (this._isDesktop) {
        this.listenerKey = map.on("pointermove", (e2) => {
          this.onMouseMove(e2);
        });
      } else {
        this.listenerKey = map.on("moveend", (e2) => this.onMapMove(e2));
        this.onMapMove();
      }
    }
    this._setElevationPanel(this.options.displayAltitude);
    this._setCoordinatesPanel(this.options.displayCoordinates);
    if (!this.options.displayCoordinates) {
      this._setSettingsPanel(false);
    }
  }
  /**
   * this method is called by event 'click' on 'GPshowMousePositionPicto' tag label
   * (cf. this._createShowMousePositionPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onShowMousePositionSettingsClick(e) {
    if (!this.draggable) {
      var opened = e.target.ariaPressed;
      if (opened === "true") {
      }
    }
  }
  /**
   * this method is called by event 'click' on input coordinate
   *
   * @param {Boolean} editing - editing mode
   * @private
   */
  onMousePositionEditModeClick(editing) {
    if (!this.options.editCoordinates) {
      return;
    }
    if (this.editing === editing) {
      return;
    }
    this.editing = editing;
    this._setEditMode(this.editing);
    var map = this.getMap();
    if (this._isDesktop) {
      if (this.editing) {
        unByKey(this.listenerKey);
      } else {
        this.listenerKey = map.on("pointermove", (e) => {
          this.onMouseMove(e);
        });
        this.onMapMove();
      }
    } else {
      if (this.editing) {
        unByKey(this.listenerKey);
      } else {
        this.listenerKey = map.on("moveend", (e) => this.onMapMove(e));
        this.onMapMove();
      }
    }
    if (!this.editing && this._markerOverlay) {
      this._markerOverlay.setPosition(void 0);
    }
  }
  /**
   * Get coordinate from inputs and select in decimal degrees
   *
   * @param {String} coordType - "Lon" or "Lat"
   * @returns {undefined}
   * @private
   */
  getCoordinate(coordType) {
    var inputDegrees = document.getElementById(this._addUID("GPmousePosition" + coordType + "Degrees"));
    var degrees = inputDegrees.value;
    if (!degrees) {
      return null;
    }
    degrees = degrees.replace(",", ".");
    if (!MathUtils_default.isInteger(degrees)) {
      return null;
    }
    var result = MathUtils_default.toInteger(degrees);
    if (result < Number(inputDegrees.dataset.min) || result > Number(inputDegrees.dataset.max)) {
      return null;
    }
    var direction = document.getElementById(this._addUID("GPmousePosition" + coordType + "Direction")).value;
    var inputMinutes = document.getElementById(this._addUID("GPmousePosition" + coordType + "Minutes"));
    var minutes = inputMinutes.value;
    if (minutes) {
      minutes = minutes.replace(",", ".");
      if (MathUtils_default.isInteger(minutes)) {
        var mins = MathUtils_default.toInteger(minutes);
        if (mins >= Number(inputMinutes.dataset.min) && mins <= Number(inputMinutes.dataset.max)) {
          result += mins / 60;
        }
      }
    }
    var inputSeconds = document.getElementById(this._addUID("GPmousePosition" + coordType + "Seconds"));
    var seconds = inputSeconds.value;
    if (seconds) {
      seconds = seconds.replace(",", ".");
      var secs = MathUtils_default.toFloat(seconds);
      if (secs && secs >= Number(inputSeconds.dataset.min) && secs <= Number(inputSeconds.dataset.max)) {
        result += secs / 3600;
      }
    }
    if (direction === "O" || direction === "S") {
      result = -result;
    }
    return result;
  }
  /**
   * locate DMS coordinates on map
   *
   * @private
   */
  locateDMSCoordinates() {
    var lonlat = [
      this.getCoordinate("Lon"),
      this.getCoordinate("Lat")
    ];
    if (lonlat[0] === null || lonlat[1] === null) {
      return;
    }
    var oSrs = this._currentProjectionSystems.crs;
    if (!oSrs) {
      logger15.log("ERROR : system crs not found");
      return;
    }
    var view = this.getMap().getView();
    var coordinate = transform(lonlat, oSrs, view.getProjection());
    view.setCenter(coordinate);
    if (this._markerOverlay && !this._hideMarker) {
      this._markerOverlay.setPosition(coordinate);
    }
  }
  /**
   * locate coordinates on map (not DMS)
   *
   * @private
   */
  locateCoordinates() {
    var lon = document.getElementById(this._addUID("GPmousePositionLon")).value;
    lon = lon.replace(",", ".");
    lon = MathUtils_default.toFloat(lon);
    if (lon === null) {
      return;
    }
    var lat = document.getElementById(this._addUID("GPmousePositionLat")).value;
    lat = lat.replace(",", ".");
    lat = MathUtils_default.toFloat(lat);
    if (lat === null) {
      return;
    }
    var oSrs = this._currentProjectionSystems.crs;
    if (!oSrs) {
      logger15.log("ERROR : system crs not found");
      return;
    }
    var xy;
    if (this._currentProjectionSystems.type === "Geographical") {
      xy = [this.convert(lon), this.convert(lat)];
    } else {
      xy = [this.convert(lat), this.convert(lon)];
    }
    var xyWGS84 = transform(xy, this._currentProjectionSystems.crs, "EPSG:4326");
    var geoBBox = this._currentProjectionSystems.geoBBox;
    if (geoBBox) {
      var extent = [geoBBox.left, geoBBox.bottom, geoBBox.right, geoBBox.top];
      if (xyWGS84[0] < extent[0] || xyWGS84[0] > extent[2]) {
        return;
      }
      if (xyWGS84[1] < extent[1] || xyWGS84[1] > extent[3]) {
        return;
      }
    }
    var view = this.getMap().getView();
    var coordinate = transform(xy, oSrs, view.getProjection());
    view.setCenter(coordinate);
    if (this._markerOverlay && !this._hideMarker) {
      this._markerOverlay.setPosition(coordinate);
    }
  }
  /**
   * locate coordinates on map
   *
   * @private
   */
  onMousePositionEditModeLocateClick() {
    if (!this.options.editCoordinates) {
      return;
    }
    if (!this.editing) {
      this.onMousePositionEditModeClick(true);
      return;
    }
    if (this._currentProjectionUnits === "DMS") {
      this.locateDMSCoordinates();
    } else {
      this.locateCoordinates();
    }
    var mapCenterFunction = this.options.mapCenterCallback;
    if (typeof mapCenterFunction === "function") {
      var view = this.getMap().getView();
      var center = view.getCenter();
      mapCenterFunction.call(this, center);
    }
  }
  /**
   * this method is called by event 'change' on 'GPmousePositionProjectionSystem'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the system projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onMousePositionProjectionSystemChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    this._setCurrentSystem(value2);
  }
  /**
   * this method selects the current system projection.
   *
   * @param {String} systemCode - inner code (rank in array _projectionSystems)
   * @private
   */
  _setCurrentSystem(systemCode) {
    var type = null;
    for (var i = 0; i < this._projectionSystems.length; ++i) {
      if (this._projectionSystems[i].code === Number(systemCode)) {
        type = this._projectionSystems[i].type;
        break;
      }
    }
    if (!type) {
      logger15.log("system not found in projection systems container");
      return;
    }
    this._currentProjectionSystems = this._projectionSystems[Number(systemCode)];
    if (type !== this._currentProjectionType) {
      this._setTypeUnitsPanel(type);
    }
    if (!this._isDesktop) {
      this.onMapMove();
    }
  }
  /**
   * this method is called by event 'mouseover' on 'GPmousePositionProjectionSystem'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the system projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onMousePositionProjectionSystemMouseOver(e) {
    logger15.trace(e);
    var map = this.getMap();
    if (!map || !map.getView()) {
      return;
    }
    var view = map.getView();
    var crs = view.getProjection();
    var mapExtent = view.calculateExtent(map.getSize());
    mapExtent = transformExtent(mapExtent, crs, "EPSG:4326");
    var systemList = document.getElementById(this._addUID("GPmousePositionProjectionSystem"));
    systemList.innerHTML = "";
    for (var j2 = 0; j2 < this._projectionSystems.length; j2++) {
      var proj = this._projectionSystems[j2];
      var option2 = null;
      if (proj.geoBBox) {
        if (mapExtent[0] > proj.geoBBox.right || mapExtent[1] > proj.geoBBox.top || mapExtent[2] < proj.geoBBox.left || mapExtent[3] < proj.geoBBox.bottom) {
          if (proj === this._currentProjectionSystems) {
            option2 = document.createElement("option");
            option2.value = proj.code;
            option2.text = proj.label || j2;
            option2.setAttribute("selected", "selected");
            option2.setAttribute("disabled", "disabled");
            systemList.appendChild(option2);
          }
          continue;
        }
      }
      var optionElement = document.createElement("option");
      optionElement.value = proj.code;
      optionElement.text = proj.label || j2;
      if (proj === this._currentProjectionSystems) {
        optionElement.setAttribute("selected", "selected");
      }
      systemList.appendChild(optionElement);
    }
  }
  /**
   * this method is called by event 'change' on 'GPmousePositionProjectionUnits'
   * tag select (cf. this._createMousePositionSettingsElement),
   * and selects the units projection.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onMousePositionProjectionUnitsChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    var oldProjectionUnits = this._currentProjectionUnits;
    this._currentProjectionUnits = value2;
    this._resetLabelElements(this._currentProjectionType);
    this._resetUnitElements(this._currentProjectionUnits);
    if (oldProjectionUnits === "DMS" || this._currentProjectionUnits === "DMS") {
      this._resetCoordinateElements(this.options.editCoordinates, this._currentProjectionType, this._currentProjectionUnits);
      this._setEditMode(this.editing);
    }
    if (!this._isDesktop) {
      this.onMapMove();
    }
  }
  /**
   *
   * @param {Number} value - value to convert (km to meters, radians, grades to decimal degrees)
   * @returns {undefined}
   * @private
   */
  convert(value2) {
    var result;
    if (this._currentProjectionUnits === "M" || this._currentProjectionUnits === "DEC") {
      result = value2;
    } else if (this._currentProjectionUnits === "KM") {
      result = value2 * 1e3;
    } else if (this._currentProjectionUnits === "RAD") {
      var rd = (180 / Math.PI).toFixed(20);
      result = (value2 * rd).toFixed(20);
    } else if (this._currentProjectionUnits === "GON") {
      var d4 = (9 / 10).toFixed(20);
      result = (value2 * d4).toFixed(20);
    }
    return result;
  }
  /**
   * @param {String} coordType - "Lon" or "Lat"
   * @param {String} value - input value
   *
   * @returns {Boolean} value is within extent
   *
   * @private
   */
  validateExtentCoordinate(coordType, value2) {
    if (["Lon", "Lat"].indexOf(coordType) === -1) {
      return false;
    }
    var coord = value2.replace(",", ".");
    coord = MathUtils_default.toFloat(coord);
    if (coord === null) {
      return false;
    }
    coord = this.convert(coord);
    var geoBBox = this._currentProjectionSystems.geoBBox;
    if (geoBBox === void 0) {
      return true;
    }
    var extent = [geoBBox.left, geoBBox.bottom, geoBBox.right, geoBBox.top];
    extent = transformExtent(extent, "EPSG:4326", this._currentProjectionSystems.crs);
    if (coordType === "Lat" && (coord < extent[0] || coord > extent[2])) {
      return false;
    }
    if (coordType === "Lon" && (coord < extent[1] || coord > extent[3])) {
      return false;
    }
    return true;
  }
};
Object.assign(MousePosition.prototype, MousePositionDOM_default);
Object.assign(MousePosition.prototype, Widget_default);
var MousePosition_default = MousePosition;
if (window.ol && window.ol.control) {
  window.ol.control.GeoportalMousePosition = MousePosition;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Drawing/Drawing.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Drawing/GPFdrawing.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/MarkersOther.js
var MarkersOther = {
  /**
   * portail icons used by drawing control with a good ratio !
   *
   * @example
   * image size : [32, 41]
   * scale : 32 / Math.min(size[0], size[1]) = 1
   */
  drawing_portail: [
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAClFBMVEUAAAD//////////////////////////////////////////////////////////fv/+fL//////////////////////////////////////////////////////////////////////////////////////v7//////fr/////+vL//////////////////Pj//////////////////////////////////////////////////////////////////////////v7//////////////////////////////////////v7//////////////////////////////////////////////////////////////////////////////v7/////////////9+v/9ej/9+z/7tT/3q3/y3//v2D/uU//+O7/5L3/xW//piH/mQH/mAD//v7/79f/yXj/oxr/lwD/mQD//fv/58T/tkr/mQL//v3/58P/sTz/79b/tUf/x3X/mQP/5Lv/oRX/ng3/s0H/w2n/u1b/4rf/8Nr/9eb/7tX/pBv/x3P/8d7/3av/79j///7/zH//mgX/2qP//vz/9+3/wGH/qyz/6Mb/vFj/sj//7NH/wGL/rTP/6sr/+fH/yXf/oBP/37H/2aH/6sz/nw//oBT/0pD/+vT/9OX/uE7/pB3/y33/7ND//Pj/26b/mwj/nAn/sT7/w2r/zYL/8+P/ulT/mwb/5Lz/qCj/+/b/1JT/nQz/nQ3/9uj/w2j/mAH/9un/6sv/skH/lwH/3Kf/pB7/pR7/3Kj/nAj/y37/+/f/8t//mQT/rDD/rDH/1JX/7tb/4LT/pR//z4j/z4n/vFn/7dP/4rn//fq31ydlAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKnVAysoAAAMmSURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oBAMCvLzcnOSJcTFGGHyklJFxSWlZYWF5WBQWFhWWlJcJCUJUcEoLSNbUVlVDZWFqqmuqqyQlZEGqZCTV6iprStDkQeqKKurrVGQlwMawMWTXN+ALg9S0VCfzMPFyCAorpjW2ASzvQwIYOymxjRFcUEGLqWa5pZCqONa27Ky2lqhji1saa5R4mJQVklpL4M6rKOzq7u7q7MD6uCy9hQVZQZVtZ5eML+woK+/KBkIivr7CiAivT1qqgzqGhPA3MKy7ImTksFg0sRssEMKCyZoqDNoak2GKJ8ydVoyFEybOgUiNllLk0F7+gwwp2zmrGQ4mDUT7KzCGdO1GZJTZkMUzJmLUDB3DkTB7JRkBp3p8yAK5i9AKFgwH6Jg3nQdBt2FiyD2LV5SBJMvWrIYIrZooS6Dnv5SCKesPQ2mIK0dEpyFS/X1GAwMly2H8FasXAWRX7VyBURk+TJDAwYj49VroAG3dt16oC1F69ethQbtmtXGRgwmphs2boKq2Lxl67ZtW7dshspv2rjB1ITBzFxn+44yeGTu3AmPzrId23XMzRg4LSwrdu2GJQdQkoQxd++qsLTgZGC0MrLes3cfZoLZv3ePtZEVMM0x2tjqHDh4CD3JHdp62M7eBpxqOR0cnY4cPYaaaI8dPeLk7MAJSfZyLq4Vx08UIqkoLDx5qsLNRQ6WMQTdPfasO42sYPOZsx6eiKzF6eXtc27HebiKwvM7zvl4e3EiZU5fv+TcC4icdTFX1M8XNXv7yyZfaoEpaLmULBuAIs/AEGivsrAd4ozCze0LVYICUeUZGIND+C63gTJQYVNbMV9oMJoBQBVh4clXroKC+uqV5PAIDHmgCsnIimv7Cgv3Xa+IlMQiDwzyqOiUG1Om3EiJjrLBpgDojBi7mxcu3LSLCcYqD1QRGzft1q1pcbE45IExH59w+3ZCvBUuBUBnJCYlJaI6AABB269xUXFElwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NDM6MjIrMDA6MDB1WI3HAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACplBMVEUAAAD//////////////////////////////////////////////////////////fz/9/P//////////////////////////////////////////////////////////////////////////////////////v7//////Pr/////////////////////+/n//////////////////////////////////////////////////////////////////////////v7//////////////////////////////////////v7//////////////////////////////////////////////////////////////////////////////v7/////////////8+3/8er/9O7/5dj/zrX/s4z/oHH/lmL/9fD/2MT/qX7/ejj/Zxz/Zhn/Zhr//v7/59z/rof/djL/ZBf/Zxv//fz/3Mr/k13/aBz/ZRn//f3/i1D/5tr/kVr/ZRj/rIP//v3/1sL/cy3/byf/jVX/pnn/aB3/mmf/077/6d7/8On/5tn/dzT/q4H/6+H/zbP/lmH/s43/ah//yK3/9O//oXL/gUP/3cz/m2n/jVT/5Nb/onP/hkn/4ND/9vL/rob/cSv/0Ln/x6r/Zxr/Yxb/pXn/8+7/4NH/cCj/ciz/vZz/+PX/7+f/lWH/eDT/sov/49X/+/n/ya//ayH/bCP/jFL/pnr/tJD/7ub/mWb/ZBb/aiD/18P/fj3/+vf/vp//bSX/bib/v5//pXj/8uv/yrD/eDX/eTb/y7H/bCL/soz/7OL/18T/g0b/hEb/v6D/cy7/wKH/9vP/5tv/jlX/59v/0rz/ejf/uJX/nGr/aR//nGv/g0X/1cD//PvyoJNrAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAA0JJREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/oBAICvLzcnOykyTExRhh8pJSRcUlpWWFheVgUFhYVlpSXCQlCVHBKC0jW1FZVV1TjgRqqqsqK2RlpEEq5OQVaivrygrLUUBhWV1lrYK8HNAALp6k+oZGNHmgisaG+iQeLkYGQXHF1KZ8mO2NZWUwtYX5TamK4oIMXErNLa0FEKGatvbMzPa2GoiSgtaWZiUuBmWV5I5GiHxnV3dPb29Pd1cnREVjR7KKMoOqWl9/IcTICROLkoCgaOIEiJWF/X1qqgzqGpPA3MKyycVgeaCK4slgTxXmT9JQZ9AUmAJRPnVaRRIUVEybChGbIqDJoDV9BpjTOHNWEhzMmgl2VuGM6VoMScmzwQrK5sxFKJg7pwysYHZyEoP29HkQE+YvQChYMB9iwrzp2gw6CxeBFRQsXlIEky9ashgcMoWLFuow6OotBXOWLV+xEqZg5Yrly8CalurpMugbrFoNMWLN2nUQ+XVr10AMWL3KQJ/B0Gj9BkhINm7ctBkkv3nTRqjAhvVGhgzGJlu2boMG7fYdO3ft2rljOzTot23dYmLMYGqmvXvPXmgE7i3bt69sLzQ69+7ZrW1mysBpblGx/0AjLLGBAITdeGB/hYU5JwOjpaHVwUOHMRPMkaMHrQwtgWmO0dpGO+VYAXqSK+g4bmtnDU61nPYOjgvaURNdYWP7Kkcne05Ispdzdqk4cbIGSUVhzanTFa7OcrCMIejmfnDTmQKEgoIzZw+6eyCyFqenl/e5PeVwIwrL95zz9vLkRMqcPr5J5y/AHFpYcPG8qK8Pavb2k026dBkaGo2XryTJ+qPIMzAE2KlcXbEN7IyCbR1XVQIDUOUZGIOC+a61VwMtKay+foMvJAjNAKCK0LCkm7dAIX3rZlJYOIY8UIVkRMXtI4WFR25XREhikQcGeWRU8p27d+8lR0VaY1MAdEa0bdr9+2m20UFY5YEqYmJrHzyojY3BIQ+M+bj4hw/j4yxxKQA6IyExMQHVAQBpWLIaKI0lIgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NDQ6MDYrMDA6MDAh7rXQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACbVBMVEUAAAD/////////////////////////////////////////////////////////+/v/8vL//////////////////////////////////////////////////////////////////////////////////////v7/////+vr/////////////////////+Pj//////////////////////////////////////////////////////////////////////////v7//////////////////////////////////////v7//////////////////////////////////////////////////////////////////////////////v7/////////////6+v/6Oj/7Oz/1NT/ra3/f3//YGD/T0//7u7/vb3/b2//ISH/AQH/AAD//v7/19f/eHj/Ghr/+/v/xMT/Skr/AgL//f3/w8P/PDz/1tb/R0f/dXX/AwP/u7v/FRX/DQ3/QUH/aWn/Vlb/t7f/2tr/5ub/1dX/Gxv/c3P/3t7/q6v/2Nj/BQX/o6P//Pz/7e3/YWH/LCz/xsb/WFj/Pz//0dH/YmL/MzP/ysr/8fH/d3f/ExP/sbH/oaH/zMz/Dw//FBT/kJD/9PT/5eX/Tk7/HR3/fX3/0ND/+Pj/pqb/CAj/CQn/Pj7/amr/goL/4+P/VFT/Bgb/vLz/KCj/9vb/lJT/DAz/aGj/6en/y8v/p6f/Hh7/qKj/fn7/9/f/39//BAT/MDD/MTH/lZX/tLT/Hx//iIj/iYn/WVn/09P/ubn/+vpgzcAPAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAu1JREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/AAzy83JzspMkxMUYYfKSUoVFxSUFSKCkuKhQShKiglFaRra0rLyiAAVUlJeVyspIg1TIyStUVlUXYIDqqkoFeTmgAVw8STW1BVhAbU0SDxcjg6C4YmpdPTYF9XWpiuKCDFxKlQ2NMLGm5szM5iYYr7GhUomLQVkluQXmsNa29o6O9rZWmINbklWUGVTVOrug3u/uKUwCgsKebmiAdHWqqTKoa/RCuVl9YHmgir4sqJZeDXUGTYEMCK9/wsQkKJg4oR8iliGgyaA1aTKEM2VqEhxMnQIRmzxJiyEpeRqEM30GQsGM6RCxaclJDNqTZkI4s2YjFMyeBRGbOUmbQWfOXAhn3vxCmHzh/HkQsblzdBh09RbAfJ0KU5AKC5kFeroM+gYLF0F4i5cshcgvXbIYIrJooYE+g6HRsuVQ9StWrgLaUrhq5QqowPJlRoYMxiar16yFCqxbv2Hjxg3r10G5a9esNjFmMDXT3rQZEYVbtiDYmzdpm5kycJpblG7dhi26t20ttTDnZGC0NLTavmMnpnzTju1WhpbANMdobaOdsisfXT5/w25bO2twquW0d3Dc04ymIr95j6OTPSck2cs5u5Tu3YeqYN/+UldnOVjGEHRz375yLbL8ugMH3T0QWYvT08v70ObDCPnDmw95e3lyImVOH9+knCMIBUdzRH19ULO3n2zSMXjibjyWJOuPIs/AEGCnMqcF6ox1LXNUAgNQ5RkYg4L5aprBGai+uYgvJAjNAKCK0LCk4ydACk4cTwoLx5AHqpCMKD0JDPKdp0ojJLHIA4M8Mir5dH//6eSoSGtsCoDOiLY9c+TIGdvoIKzyQBUxsRPPnp0YG4NDHhjzcfHnzsXHWeJSAHRGQmJiAqoDAOgCnVLAYqeOAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo0NDoxOSswMDowMBsMxacAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACf1BMVEUAAAD//////////////////////////////////////////////////////////P3/9Pn//////////////////////////////////////////////////////////////////////////////////////v7/////+/3/////9fr/////////////////+vz//////////////////////////////////////////////////////////////////////////v7//////////////////////////////////////v7//////////////////////////////////////////////////////////////////////////////v7/////////////7/f/7PX/8Pf/3O7/vd7/mcv/gL//c7n/8fj/yuT/jMX/Tab/NJn/MZj/Mpj//v7/3+//k8n/R6P/L5f/M5n//P3/0Of/brb//f7/z+f/Y7H/MJf/bLX/kcf/yeT/Q6H/PZ7/ZrP/h8P/d7v/xeL/4fD/6/X/3e7/SaT/j8f/5PH/u93/crn//v//mMz/N5r/tdr/gcD/Vqv/0ej/ebz/ZrL/2uz/gsD/XK3/1er/8/n/ksn/QaD/wN//tNn/1ur/P5//QqD/ptL/9vr/6vT/cbj/l8v/+vz/t9v/OJv/Opz/ZLH/iMP/m83/6fP/d7r/N5v/Uqj/Mpn/+Pv/qdT/PJ3/7fb/Z7L/uNz/SqT/S6X/udz/OZz/mMv/5fL/drr/Waz/Wqz/qtT/RKH/q9T/9Pn/3u7/Z7P/w+D/TKX/oM//PZ3/erz/Npr/3O3/x+L/+/0F2pMDAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAM4SURBVDjLdZNnWxNBFIVnEZGEGpBeROkSuoIUwS4KFkTFQp+wFEWzk+AmEFhEDBZQlA5ioxcRsCDYELADSvlBbnY2kACeTztz3r1znztnAOBEEAYbDDcabTKG0HiT0UbDDQYEAXRECIQmpmbmFpaS7GyJpYW5mamJUKBDECIr6802ZE5uXv6lS/l5uTmkzWZrK9EyQdja2cPLBVeuSinEipJevVJwGdrb2RJa38FRJi+8RiOk4IQQfa1QLnN0wATh5OyiLCqWUgodUdLiIqWLs5OGcN3ipiopZZBCT4gpLVG5bXFlCwhNobxsta8hyuTQVEgAkd1W8rpUezrDSvstvU5utRMB4TZV+Q18PqIqbubn36ygMELdKFdtEwJ3D4ma4X+pvHX7zp3btyr5goxa4uEOPL3uViHsV9+TQVaye9WYQFV3vTyBt899bomYGvkDyOmBvIZrBEnv+3gD3+0PMV5bp4K8VHW1eO/hdl/gR9ZzC6ahES6rsYFrC9WTfgBKmjiAbm5ZAVqaaQ5okkAgJltxhUdtK0DbI1yhlRQD/8dPOIB6+kym9WXPnnKTQU8e+4OAwOe4IVpNagFSTeO954EBICi4vQOvOru6sd/d1Yl3OtqDg0BIaE8vnjRT1dfCniJr6avCo6V6e0JDwI6d/QMv+NEOvhwaHh56OciP/sVA/84dICxcPPKK5i+Qpl+/pmn+OulXI+LwMCDYFaEsf8PH6a0mk2/5UL0pV0bsEgAiMiRq9N3Y2sCMvRuNColkM0dE7xaPq6nVkaPU4zGx0VxqBXv27mtr1g8dYt637du/R4Bj73rgoPLDR90aiPr0WXnogKv2YYgOx432Tejknhr8Mhp3ZOVpCY7GJ0xOKZZLIMXUZEL8UYHO4zx2HBZMaw9B1NcCm+PH9J/3CRf47Tt/CPX9B3Q5qecDkBjr8VON26Amhn56nErU9wGRdNr8129NfJH0t9z8TNKqAixxNhnOzGpGPTsDk8+t8VnC4bxybgyhP3PK8w7r+OzIL1yU/J2f/yu5eCF6PYBtIyVmYXp6ISYlaV2fJVLTVIuLqrTU//jszadnLC1lpEf+D2DbyMzKytRv4B+n7ayGbXJj1gAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NDQ6MjkrMDA6MDCVg8JEAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACslBMVEUAAAD////////////////////////////////////////////////////////+/fz79/T////////////////////////////////////////////////////////////////////////////////////+/v7////9/Pv////79/X////////////////9+/r////////////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////58+/48ez69PDz5dzpzr3cspnUoIDQlXP69PHt18rYqIzDeU27ZjS6ZTG6ZTL+/v7059/brpPCdUe6Yy+7ZjP+/fzv29DOkm67ZzS6ZDH+/f3v28/LiWO6YzD05t/OkGy6ZDDarJH+/v3t1snAckO+bj3MjWbUn4DXpYfRmXfr08X16eH48Ovz5t3CdknZqo/26+TozLvQlXL//v7dspi8aTfmyLXUoIHGgFbv3NHSm3m5Yy/LjGby49rVoYLIhVzx39X79vPbrZK/cEHq0MDmxrS6ZjK5Yi/58/Dx4Na+bz/AcULhvab8+Pb47+rPlHHCd0ncsZf9+/rnybe9aji9azrLi2TXpojdtJv37unt18nFfVK7ZTL8+vjivqm+bTziv6n58e3WpIfWpYfx4NXMjWfnyrjCd0rDeEvoyrm9azncsZj27OXRmHbHg1nIg1rt2Mriv6rAckTjwKv79vS8ajm9ajnXpYj05t7r0sPDeUzfuKC+bT3Sm3q8aTbIglns1cf9/Pua7OXrAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAANISURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oLAICAoL8vNyc5IlxMUYYfKSUsUlpWXlRUUVYFBUVF5WWlIsJQlRwSgtI1tZVV1TW4EEamuqqyplZaRBKuTkFerqGxqLKlBAUWNDfZ2CvBzQAC6e5KbmFjR5oIqW5qZkHi5GBkFxxbTWApjtLY2NMLVFBa1piuKCDFxKbe0dhRCh2s6u7u6uzlqIksKO9jYlLgZllZSeFoh8TW9f/4QJ/X29NRAVLT0pKsoMqmoTJxVBjJw8pTgZCIqnTIZYWTRpopoqg7rGVDC3qHFayfRkMJheMg3sqaKCqRrqDJpaMyDKZ86qS4aCulkzIWIztDQZtNNmgzktc+Ymw8HcOWBnFc1O02ZITpkHVjB/wUKEgoUL5oMVzEtJZtBJWwQxYfEShIIliyEmLErTYdBdugysoHD5imKYfPGK5eCQKVq2VJdBT38lWMGq1T1rYArW9KxeBVawUl+PwcBw7TqIk9dv2AiR37hhPURk3VpDAwYj402bITHdsmXrQqAtxQu3boEEbe3mTcZGDCam27bvgAbtzl279+zZvWsnNOh3bN9masJgZq6zt3c+NALnz585c/58aHTO792rY27GwGlhWblvPzQ5HQClyQPQRLV/X6WlBScDo5WR9cFDhzETzOEjB62NrIBpjtHGVufosUL0JFd4/KidvQ041XI6ODqd6EJNdEUtJ084OTtwQpK9nItr5anTtUgqimrPnK10c5GDZQxBd4+DW88VIhQU7jx/0MMTkbU4vbx9LlysgBtRVHHxgo+3FydS5vT1S869BHNoUeHlK6J+vqjZ2182+eo1aGjUXrueLBuAIs/AEGivcqPnJtgZhbdu31AJCkSVZ2AMDuG7cxKU3otqTpbwhQajGQBUERaefPceKKjv3U0Oj8CQB6qQjKy8f7io6MH9ykhJLPLAII+KTnn46NHDlOgoG2wKgM6IsUt//DjdLiYYqzxQRWxc3ZMndXGxOOSBMR+f8PRpQrwVLgVAZyQmJSWiOgAArqa4BP2YBKMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjQ0OjQ2KzAwOjAwpaS7KgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAChVBMVEUAAAD//////////////////////////////////////////////////////////vv//fL//////////////////////////////////////////////////////////////////////////////////////v7//////vr//////////////////////vj//////v///////////////////////////////////////////////////////////////////v7//////////////////////////////////////v7//////////////////////////////////////////////////////////////////////////////v7//////////////Ov/++j//Oz/+dT/863/7X//6mD/50///O7/9r3/62//4SH/3QH/3AD//v7/+df/7Xj/4Br/3QD//vv/98T/5kr/3QL//v3/98P/5Tz/+db/5kf/7HX/3QP/9rv/4BX/3g3/5UH/6WD/62n/6Fb/9bf/+tr/++b/+dX/4Bv/7HP/+t7///7/86v/+dj/3QX/8qP//vz//O3/6mH/4iz/98b/6Fj/5T//+dH/6mL/4zP/+Mr//fH/7Hf/3xP/9LH/8qH/6mn/+Mz/3g//3xT/8JD//fT/++X/507/4B3/7X3/+ND//vj/86b/3Qj/3gn/5T7/62r/7oL/++P/6FT/3Qb/9rz/4ij//fb/8ZT/3gz//Oj/62j/3AH//On/+Mv/86f/4R7/86j/7n7//vf/+t//3QT/4zD/4zH/8JX/3xX/3gj/9bT/4R//74j/74n/6Fn/+dP/9bn//vrsMn7uAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAxZJREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/AAzy83JzspMkxMUYYfKSUoVFxSVAqVIwADJKiosKpSQhKhilZWTLyisqobJQNZUV5WWyMtIgFXLyClXVNQUo8iBTaqqrFOTlgAZw8STV1qHLg1TU1SbxcDEyCIorptY3IGxHuKShPlVRXJCBS6mqsakAKt3c0tra0gxVUtDUWKXExaCsktwGFahs7+js6ursaIc6uKAtWUWZQVWtuwfML8jv7etPAoL+vt58iEhPt5oqg7rGBDC3oCBrYmESGBROzALbUpA/QUOdQVMgA6J80uQpSVAwZfIkiFiGgCaD1tRpEM70GUlwMGM6RGzaVC2GpOSZEM6s2QgFs2dBxGYmJzFoT50D4cydh1Awby5EbM5UbQad+QsgnIWLCmHyhYsWQsQWzNdh0NVbDPX1klSYgtQlUKHFeroM+gZLl0GUL1+xEiK/csVyiMiypQb6DIZGq1ZD1a9Zuw5oS+G6tWugAqtXGRkyGJus37ARKrBp85atW7ds3gTlbtyw3sSYwdRMe9t2RGTu2IGIzu3btM1MGTjNLcp27oIlB0Rslxbs2llmYc7JwGhpaLV7z17MBNO8Z7eVoSUwzTFa22jv238APckd2HLQ1s4anGo57R0cD7Wgqig40HLI0cmeE5Ls5Zxdyg4fQVZQUHDkaJmrsxwsYwi6ue9euxFJRcGmY8fdPRBZi9PTy/vE9pNwFQUnt5/w9vLkRMqcPr5JOacQOet0jqivD2r29pNNOnMWpuDsmSRZfxR5BoYAO5X5becgcbSpbb5KYACqPANjUDBfbQsoAxU0tBTxhQShGQBUERqWdP4CKKgvnE8KC8eQB6qQjCi7uLegYO+lsghJLPLAII+MSr48adLl5KhIa2wKgM6Itr1y6tQV2+ggrPJAFTGxU65enRIbg0MeGPNx8deuxcdZ4lIAdEZCYmICqgMA6f6os3UKuXAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjQ0OjU4KzAwOjAwOTHA6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACr1BMVEUAAAD////////////////////////////////////////////////////////7/v3y+/n////////////////////////////////////////////////////////////////////////////////////+/v7////6/f3////y+/r////////////////4/fz//////v/////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////r+ffo+PXs+ffU8+2t591/28tg0r5Pzbju+vi97ORv1sQhwKUBt5gAtpf+/v7X9O942ckavqIAtZYAt5j7/v3E7udKy7UCt5j9/v7D7uY8x7DW8+5Hy7QAtpZ118cDt5i77OQVvKANup1BybJg0b5p1cJWz7q36uLa9PDm9/XV8u4bvqNz18be9fGr59zY8+9/2ssFuJmj5dr8/v7t+fdh0r8sw6rG7+hYz7s/ybHR8uxi0r8zxazK8Onx+/l32MgTvJ+x6N+h5Nlp1MLM8OoPu54UvJ+Q39L0/Prl9/ROzbcdv6N92srQ8ez4/fym5tsIuJoJuZs+yLBq1cOC28zj9/NUz7oGuJq87OMowaf2/PuU4NQMupwNupyU4dTo+PZo1MIBtpdq1cLp+fbL8OoBtpan5tsev6Mev6So5twIuZt+2sv3/Pvf9fJUzroEt5gwxKsxxKuV4NQVvaCV4dTW8+/X8++06eEfv6T7/f2I3c6J3c9Zz7wFuJrT8u256+L6/f3ow7cxAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAMvSURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oBAMCvLzcnOSJcTFGGHyklJFxSWlZYWF5WBQWFhWWlJcJCUJUcEoLSNbUVlVDZWFqqmuqqyQlZEGqZCTV6iprStDkQeqKKurrVGQlwMawMWTXN/QiCYPVNHYUJ/Mw8XIICiumNbUDLO9sawMprawuSlNUVyQgUuppqW1EOq4tvaOjvY2qGMLW1tqlLgYlFVSOhuhDuvq7unt7enugjq4sTNFRZlBVa2vH8wvLJgwsSgZCIomTiiAiPT3qakyqGtMAnMLG7Mng+WBKiZngx1SWDBJQ51BU2sKRPnUadOToWD6tKkQsSlamgzaM2aCOY2zZifDwexZYGcVzpyhzZCcMgesoGzuPISCeXPLwArmpCQz6MyYDzFhwUKEgoULICbMn6HDoLtoMcS+JUuLYPJFS5dAxBYv0mXQ018G4ZQtT4MpSFsOiZrCZfp6DAaGK1ZCeKtWr4HIr1m9CiKycoWhAYOR8dp10IBbv2Ej0JaijRvWQ4N23VpjIwYT002bt0BVbN22fceO7du2QuW3bN5kasJgZq6zc1cZLBGU7d5dBksaZbt26pibMXBaWFbs2QtLDqAkCWPu3VNhacHJwGhlZL1v/wHMBHPw0D5rIytgmmO0sdU5fOQoepI7euy4nb0NONVyOjg6nWg/iZpoT7afcHJ24IQkezkX14pTpwuRVBQWnjlb4eYiB8sYgu4e+zacQ1aw9fwFD09E1uL08va5eOkyXEXh5UsXfby9OJEyp69fcu4VRM66mivq54uavf1lk6+1whRcv5EsG4Aiz8AQaK+yaDnEGYVbly9SCQpElWdgDA7hu9kOykCFze23+EKD0QwAqggLT759BxTUd24nh0dgyANVSEbevXegsPDA/buRkljkgUEeFZ3y4OHDBynRUTbYFACdEWP36MqVR3YxwVjlgSpi46Y/fjw9LhaHPDDm4xOePEmIt8KlAOiMxKSkRFQHAAAsgrQ2sknLAAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NDU6MTIrMDA6MDD2yfpjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACfFBMVEUAAAD////////////////////////////////////////////////////////8/vz0/fT////////////////////////////////////////////////////////////////////////////////////+/v7////7/vv////1/fX////////////////6/vr//////v/////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////v/O/s++zw/PDc+dy9872Z7ZmA6oBz53Px/PHK9sqM64xN4U003TQx3DEy3DL+/v7f+d+T7ZNH4Ecv3C8z3TP8/vzQ99Bu5m79/v3P989j5WMw3DBs5myR7JHJ9slD4EM93j1m5WaA6YCH64d36HfF9cXh+uHr++vd+d1J4EmP7I/k+uT+//6787ty53KY7Zg33Te18rWB6oFW4lbR99F56Hna+dqC6oJc41zV+NXz/fOS7JJB30HA9MC08rQy3TKH6ofW+NY/3j9C30Km8Kb2/fbq++px53GX7Zfa+Nr6/vq387c43Tg63jpk5WSI64ib7pvp++lS4lL4/fip8ak83jzt/O1n5We487hK4UpL4Uu587k53TmY7pj4/vjl+uV26HZZ41la41qq8KpE30Sr8Kv0/fQ53jne+d7D9cNM4Uyg76B66Ho23TbH9cf7/vts+qXUAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAM8SURBVDjLdZP3X9NQFMVfFIUWLJRpVcoeYlVEQEUExIUyFFFRcfJqqiyb12paDQQKpQXZorJXARcbFRC3oohb/yHTJIUW8fyU5Hxz7/3cdx4ArDBs2XK7FSvtHSB0sF+5wm75MgwDVsIEQkenVSJnF/mlS3IXZ9EqJ0ehwIrAxK5u7h644vKVnNzcnCuXFbiHu5ureJ7APL1Ww7z8gqtKAjEilFcL8vPgai9PzOJL1qjU166TCGlYIURev6ZWrZFwBLZ2nbf2xk0lobESobx5Q+u9bq2ZkPr4UoVFNNLYCNFFhZSvj5QpIHSC6uLFvpkoVkMnIQbEXn54idLSnWZkeVaW4H5eYiD0p3SlXH9ElOnLy/VlBIcQpTrKXwgCAuUGmv/FWFF561ZlhZEvSBvkgQEgKLiqGnF+TW0dZFRXW8MRqLoqOAiEhNazr4huUKsgK5W6gR0EKetDQ8D6sNsc3niHgryoO43ct9th68EG/C77Qt9rgvNquseOhe7iGwCUN7MAqW9ZAFr0JAs0yyGQ4a1chbb2BaC9javQisvAxo5OFiC6ulUWX9XdxW4GdXZsBJs297CAiezFLQDeS5pYoGfzJhC+pa+fG/n+g4ec//DBfe5Lf9+WcBCx9dFjbtN09cAg00U1OFDNrZZ4/GhrBIiMGhoe4Vc7Ojb+5Mn42Ci/+pHhoahIEL1N9tRI8gdIko2NJMkfJ2l8KtsWDQTbd2h1z/g4mcyZNPGheqbT7tguAFhMxM6Jyal/AzM1ObEzIobJHBa7S/bcQCyOHGF4Hhcfy6ZWkLA7sV1vGzpET7cn7kkQcLGX7t2nffGSMFn//+q1dv9eqeViiA8kTQy8sco9Mfr2XdLBhaslOJSc8v6DZr4J0nx4n5J8SGB1OVPTYP6MZVBEfMz3SEu1vd6HveGnWb4JMfsZeh+x8QFIjw+cM3xhCeLL+Fzg0XRbH2AZx0Rfp83xRcppteh4xqICDHEiE377bl71928w8+Q/PkNITml/TCFU9kN7SrKEz6z8dJb8569fP+VZp2OXApgxzsQpZmYUcWcylvQZ4uw56vdv6tzZ//jMyZ+/8OfPhfMx/wOYMS5mZ1+0HeAvs9msMpv5tz0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjQ1OjQxKzAwOjAwj8HumgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACr1BMVEUAAAD////////////////////////////////////////////////////////9/vv5+/L////////////////////////////////////////////////////////////////////////////////////+/v7////9/fr////5+/P////////////////8/fn////////////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////3+uz1+en3+u3t9Nbd6rHK34W912i20lj4+u/j7sDD23ajxyyWvw6VvguVvgz+/v7u9drH3X+gxSWUvgmWvw39/vvm8Me00VP+/v3m8MauzkXu9Nmz0FDG3HyUvgrj7r+exCCbwhqwz0rB2XGWvw+51F7h7Lrv9dz0+Oft9NehxifF3Hrx9t/c6a+201j+//7K3oaYwBHZ56j+/vy+12moyjfn8Mn2+uy61WCwzkns89P3+u6+12qryz7p8c35+/HH3X6dwx7e67XY56aVvg2UvQjq8s6cwhuexB/R45b6/PT0+Oa20leVvgqhxijJ3oT8/fna6KqYwBOZwRavzkfB2XLL34nz+OS41F2UvQmYwBKmyDGWvwz7/PfS5JmawRebwhjT5JrB2XD1+erp8s79/vzb6ayiximixir7/PbJ3oOZwRXK3oTx9+Cpyzuqyzvj7sGexCH5+/KZwBSwz0vu9dng7LijxivO4Y6awRjO4Y+61WGXwBHt89Wpyzri7bz9/frM0I39AAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAANESURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oLAICAoL8vNyc5IlxMUYYfKSUsUlpWXlhUUVYFBUWF5WWlIsJQlRwSgtI1tZVV1QWIEECguqqyplZaRBKuTkFWpq68qLKlBAUXldbY2CvBzQAC6e5PoGdHmQiob6ZB4uRgZBccW0xgKY7U3l5U0wdkFjmqK4IAOXUk1zSyHUca1tWVltrVDHFrY01yhxMSirpLQ3QeQ7Oru6e3q6uzo7ICqa2lNUlBlU1Xr7iiBG9k8oTgaC4gn9ECuL+nrVVBnUNSaCuUXlk0omJ4PB5JJJYEcXFUzUUGfQ1JoCUT512vRkKJg+bSpEbIqWJoN22gwwp2nmrGQ4mDUT7KyiGWnaDMmz54AVlM+dh1Awb245WMGc2ckMOvMXQBQsXIRQsGghRMGC+ToMuouXgBUULl1WDJMvXrYUHDJFSxbrMujpLwdzVqxsT4MpSGtfuQKsabm+HoOB4arVECPWrF0HkV+3dg3EgNWrDA0YjIzXb9gICbhNm+cBbSmet3kTJGg3blhvbMRgYrpl6zZo0G7fsXPXrp07tkODftvWLaYmDGbmOrv3rIQmk5V79+3buxKadFbu2a1jbsbAaWFZ2bwfYknFAVCaPABhb9zfXGlpwcnAaGVkffDQYcwEc+ToQWsjK2CaY7Sx1Uk9Voie5Ap3HreztwGnWk4HR6cTbU0oKoqa2k44OTtwQpK9nIvryVOnNyKpKNp45tRJNxc5WMYQdPc4e+48UrovPH/hoIcnImtxenn7XNxTATeiqGLPRR9vL06kzOnrl5x7CZGzLl8R9fNFzd7+sslHr0JDY+PVo8myASjyDAyB9irX2q+DnVF4vf2aSlAgqjwDY3AIX30bKPkWFdy4yRcajGYAUEVYePKt26Cgvn0rOTwCQx6oQjKy8s7doqK79yojJbHIA4M8Knr2/QcP7s+OjrLBpgDojBi7h48ePbSLCcYqD1QRGzf98ePpcbE45IExH5/w5ElCvBUuBUBnJCYlJaI6AADXv7i4Kd/lawAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NDk6NDUrMDA6MDBhsioHAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACnVBMVEUAAAD////////////////////////////////////////////////////////7/fvy+fL////////////////////////////////////////////////////////////////////////////////////+/v7////6/Pr////////////////////4/Pj////////////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////r9uvo9Ojs9uzU69St2K1/w39gtWBPrU/u9+694L1vu28hlyEBiAEAhwD+/v7X7Nd4wHgalBoAhgAAiAD7/fvE48RKqkoCiAL9/v3D48M8pDzW7NZHqUd1vnUDiAO737sVkRUNjg1BpkFgtGBpuWkCiQJWsFa33bfa7drm8+bV69UblBtzvXPe796r16vY7Nj+//4FigWj1KP8/fzt9u1htWEsnCzG5Mbr9etYsVg/pT/R6dFitmIzoDPK5srx+PF3wHcTkBOx2rGh06EAhQDM58wPjg8UkRSQy5D0+vTl8uVOrE4dlR19wn3Q6dD4/Pim1aYIiwgJjAk+pD5qumqCxYLj8uNUr1QGiga837womij2+/aUzZQMjQwNjQ1ouGgBhwFquWrp9OnL5ssBhgGn1qcelR4elh6o1qj2+vZ+w373+/ff8N8EiAQwnjAxnjGVzZUVkhUJiwm03LQflh+IyIiJyIlZsVnT6tP8/vy53rn6/Pq97PRtAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAzFJREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/AAzy83JzspMkxMUYYfKSUoVFxSWlBQVlYFBQUFpSXFQoJQlRwSgtI1teUVkFlYWqqaqsKJeVkQapkJNXqK6pLUWRB6oora2pVpCXAxrAxZNUV48uD1JRX5fEw8XIICiumNrQCLO9FAhg7MaGVEVxQQYupeqm5gKo41pa29paW6COLWhuqlbiYlBWSW4vhQh0dHZ19/R0d3V2QFSUtierKDOoqvX2gfkF+f0TCpOAoHBCfz5EpK9XTZVBXWMimFtQmjVpchIYTJ6UBXZIQf5EDXUGTYEMiPIpU6clQcG0qVMgYhkCmgxa02eAOaUzZyXBwayZYGcVzJiuxZA0ew5Ewdx5CAXz5kIUzJmdxKA9fT5EwYKFCAULF0AUzJ+uzaCzaDHEviVLC2HyhUuXQMQWL9Jh0NVbBuEsb0+FKUhtXw4RW6any6BvsGIlhLdq9RqI/JrVqyAiK1cY6DMYGq1dBwnJ0vUbNgJDYvLGDeuhAuvWGhkyGJts2rwFGrRbt23fsWP7tq3QoN+yeZOJMYOpmfbOXcuhEbi8dPfu0uXQ6Fy+a6e2mSkDp7lF+Z69pbBUUABLd2Wle/eUW5hzMjBaGlrt238AM8Ec3L/PytASmOYYrW20Uw4dRk9yh48ctbWzBqdaTnsHx2Otx1ET7fHWY45O9pyQZC/n7FJ+4mQBkoqCglOny12d5WAZQ9DN/cyGLcgKtp495+6ByFqcnl7e53ddgKsouLDrvLeXJydS5vTxTcq5iMhZl3JEfX1Qs7efbNLlK9DQKL1yOUnWH0WegSHATmVRO8QZBVfbF6kEBqDKMzAGBfPVtYIyUEFjaxFfSBCaAUAVoWFJ166Dgvr6taSwcAx5oArJiPIbBwoKDtwsj5DEIg8M8sio2bemTLk1OyrSGpsCoDOibW9fvHjbNjoIqzxQRUzsnbt378TG4JAHxnxc/L178XGWuBQAnZGQmJiA6gAAFLyvxAL3bxQAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjQ5OjU2KzAwOjAwnPAwBAAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAClFBMVEUAAAD////////////////////////////////////////////////////////7//3y//n////////////////////////////////////////////////////////////////////////////////////+//7////6//3////y//r////////////////4//z////////////////////////////////////////////////////////////////////////+//7////////////////////////////////////+//7////////////////////////////////////////////////////////////////////////////+//7////////////r//fo//Xs//fU/+6t/95//8tg/79P/7nu//i9/+Rv/8Uh/6YB/5kA/5j+//7X/+94/8ka/6MA/5cA/5n7//3E/+dK/7YC/5n9//7D/+c8/7HW/+9H/7V1/8cD/5m7/+QV/6EN/55B/7Np/8NW/7u3/+La//Dm//XV/+4b/6Rz/8fe//Gr/93Y/+/+//9//8wF/5qj/9r8//7t//dh/8As/6vG/+hY/7w//7LR/+xi/8Az/63K/+rx//l3/8kT/6Cx/9+h/9nM/+oP/58U/6CQ/9L0//rl//RO/7gd/6R9/8vQ/+z4//ym/9sI/5sJ/5w+/7Fq/8OC/83j//NU/7oG/5u8/+Qo/6j2//uU/9QM/50N/53o//Zo/8MB/5jp//bL/+pB/7IB/5en/9we/6Qe/6Wo/9wI/5x+/8v3//vf//IE/5kw/6wx/6yV/9TW/+60/+Af/6WI/8+J/89Z/7zT/+25/+L6//2DMMmrAAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAMmSURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oBAMCvLzcnOSJcTFGGHyklJFxSWlZYWF5WBQWFhWWlJcJCUJUcEoLSNbUVlVDZWFqqmuqqyQlZEGqZCTV6iprStDkQeqKKurrVGQlwMawMWTXN+ALg9S0VCfzMPFyCAorpjW2ASzvQwIYOymxjRFcUEGLqWa5pZCqONa27Ky2lqhji1saa5R4mJQVklpL4M6rKOzq7u7q7MD6uCy9hQVZQZVtZ5eML+woK+/KBkIivr7CiAivT1qqgzqGhPA3MKy7ImTksFg0sRssEMKCyZoqDNoak2GKJ8ydVoyFEybOgUiNllLk0F7+gwwp2zmrGQ4mDUT7KzCGdO1GZJTZkMUzJmLUDB3DkTB7JRkBp3p8yAK5i9AKFgwH6Jg3nQdBt2FiyD2LV5SBJMvWrIYIrZooS6Dnv5SCKesPQ2mIK0dEpyFS/X1GAwMly2H8FasXAWRX7VyBURk+TJDAwYj49VroAG3dt16oC1F69ethQbtmtXGRgwmphs2boKq2Lxl67ZtW7dshspv2rjB1ITBzFxn+44yeGTu3AmPzrId23XMzRg4LSwrdu2GJQdQkoQxd++qsLTgZGC0MrLes3cfZoLZv3ePtZEVMM0x2tjqHDh4CD3JHdp62M7eBpxqOR0cnY4cPYaaaI8dPeLk7MAJSfZyLq4Vx08UIqkoLDx5qsLNRQ6WMQTdPfasO42sYPOZsx6eiKzF6eXtc27HebiKwvM7zvl4e3EiZU5fv+TcC4icdTFX1M8XNXv7yyZfaoEpaLmULBuAIs/AEGivsrAd4ozCze0LVYICUeUZGIND+C63gTJQYVNbMV9oMJoBQBVh4clXroKC+uqV5PAIDHmgCsnIimv7Cgv3Xa+IlMQiDwzyqOiUG1Om3EiJjrLBpgDojBi7mxcu3LSLCcYqD1QRGzft1q1pcbE45IExH59w+3ZCvBUuBUBnJCYlJaI6AABB269xUXFElwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NTA6MDYrMDA6MDDpi8pqAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACbVBMVEUAAAD////////////////////////////////////////////////////////7///y///////////////////////////////////////////////////////////////////////////////////////+///////6///////////////////////4///////////////////////////////////////////////////////////////////////////+///////////////////////////////////////+///////////////////////////////////////////////////////////////////////////////+///////////////r///o///s///U//+t//9///9g//9P///u//+9//9v//8h//8B//8A///+///X//94//8a///7///E//9K//8C///9///D//88///W//9H//91//8D//+7//8V//8N//9B//9p//9W//+3///a///m///V//8b//9z///e//+r///Y//8F//+j///8///t//9h//8s///G//9Y//8////R//9i//8z///K///x//93//8T//+x//+h///M//8P//8U//+Q///0///l//9O//8d//99///Q///4//+m//8I//8J//8+//9q//+C///j//9U//8G//+8//8o///2//+U//8M//9o///p///L//+n//8e//+o//9+///3///f//8E//8w//8x//+V//+0//8f//+I//+J//9Z///T//+5///6//8Ngdu6AAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAu1JREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/AAzy83JzspMkxMUYYfKSUoVFxSUFSKCkuKhQShKiglFaRra0rLyiAAVUlJeVyspIg1TIyStUVlUXYIDqqkoFeTmgAVw8STW1BVhAbU0SDxcjg6C4YmpdPTYF9XWpiuKCDFxKlQ2NMLGm5szM5iYYr7GhUomLQVkluQXmsNa29o6O9rZWmINbklWUGVTVOrug3u/uKUwCgsKebmiAdHWqqTKoa/RCuVl9YHmgir4sqJZeDXUGTYEMCK9/wsQkKJg4oR8iliGgyaA1aTKEM2VqEhxMnQIRmzxJiyEpeRqEM30GQsGM6RCxaclJDNqTZkI4s2YjFMyeBRGbOUmbQWfOXAhn3vxCmHzh/HkQsblzdBh09RbAfJ0KU5AKC5kFeroM+gYLF0F4i5cshcgvXbIYIrJooYE+g6HRsuVQ9StWrgLaUrhq5QqowPJlRoYMxiar16yFCqxbv2Hjxg3r10G5a9esNjFmMDXT3rQZEYVbtiDYmzdpm5kycJpblG7dhi26t20ttTDnZGC0NLTavmMnpnzTju1WhpbANMdobaOdsisfXT5/w25bO2twquW0d3Dc04ymIr95j6OTPSck2cs5u5Tu3YeqYN/+UldnOVjGEHRz375yLbL8ugMH3T0QWYvT08v70ObDCPnDmw95e3lyImVOH9+knCMIBUdzRH19ULO3n2zSMXjibjyWJOuPIs/AEGCnMqcF6ox1LXNUAgNQ5RkYg4L5aprBGai+uYgvJAjNAKCK0LCk4ydACk4cTwoLx5AHqpCMKD0JDPKdp0ojJLHIA4M8Mir5dH//6eSoSGtsCoDOiLY9c+TIGdvoIKzyQBUxsRPPnp0YG4NDHhjzcfHnzsXHWeJSAHRGQmJiAqoDAOgCnVLAYqeOAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1MDoyMSswMDowMG4J85kAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACu1BMVEUAAAD////////////////////////////////////////////////////////8/f3y9/r////////////////////////////////////////////////////////////////////////////////////+/v7////6/P3////z9/r////////////////5+/z//////v/////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////s8/jp8fft9PjW5vCwz+KEtdJno8hXmcLu9fnA2Oh1q80qfrIMa6cJaqYKaqb+/v7Z6PF+sdAkea8HaKULa6f8/f3G3epRlcAJaab9/f7G3OpEjrsHaaXY5/FOlL97rs8Iaab9/v6+2Ocfdq0Yc6tJkb1no8dvqMsIaaUNbKhdncS61ebb6fLn8PbX5vAle7B5rs7f7POuzuGFtdMPbainyt/8/f5oo8g1hbbI3utfnsVHkLzT5O/u9PhppMk8ibjM4Ozx9/p9sNAcda200eSlyN4La6YGaKVwqMvO4e0Zc6wddq2Vv9j0+Pvm8PZWmMIme7GDs9LS5O/+/v/5+/ypy98Rb6kTcKpGj7xxqcyIt9Pk7/VcnMQQbqj7/f0wgbQKaqf3+vyYwdkVcaoWcquZwdpvp8vq8vfN4e1JkL2rzOAnfLEofLGszOH2+vyCs9ITb6mDtNLg7PNbnMQ5h7c5h7jA2egfd66awtry9/pvqMoSb6kMbKe30+UpfbGNutaOutZgn8XV5vC81ub7/P0PF+8/AAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAANLSURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oLAICAoL8vNyc5IlxMUYYfKSUsUlpWXlhUUVYFBUWF5WWlIsJQlRwSgtI1tZVV1QU4EEagqqqyplZaRBKuTkFWrr6huKKlBAUUN9Xa2CvBzQAC6e5MYmdHmQiqbGZB4uRgZBccW05gKY7S3l5S0wdkFzmqK4IAOXUmtbeyFEqKajs6urs6MGoqSwva1ViYtBWSWluwci39vXP2HixAn9fb0QFT3dKSrKDKpqkyYXQYycMrU4GQiKp06BWFk0eZKaKoO6xjQwt6ghuwQsD1RRkg12dFHBNA11Bk2t6RDlM2bOSoaCWTNnQMSma2kyaKfNBnNa5sxNhoO5c1rACmanaTMkp8wDKyifvwChYMH8crCCeSnJDDoLF4EVNCxeglCwZHEDWMGihToMukuXgRUULl9RDJMvXrEcHDJFy5bqMujprwRzVq1ekwZTkLZm9SqwppX6egwGhmvXQYxYv2EjRH7jhvUQA9atNTRgMDLetBns5IqWLVu3bU9O3r5t6xaowOZNxkYMJqY7du6CBG3L7j179+3bu2c3RL5o184dpiYMZuY6+w+shkRg4erygwfLV0OirmL1gf065mYMnBaWh9oOQ/RUHAGlySMQdsvhtkOWFpwMjFZG1kePHcdMMCdOHrU2sgKmOUYbW53UU4XoSa5wzWk7extwquV0cHQ6c7YFRUVRy9kzTs4OnJBkL+fiWnnuPLKKopYLFyvdXORgGUPQ3ePS5SuFCAWFu68e9fBEZC1OL2+fa9cr4EYUVRy45uPtxYmUOX39knNvIHLWzVuifr6o2dtfNvnkbWhotNy+kywbgCLPwBBor3L33n2wMwrvr7mrEhSIKs/AGBzC13j2AdCSogdnS/hCg9EMAKoIC09++AgU1I8eJodHYMgDVUhGHnp8oqjoxJNDkZJY5IFBHhWd8nTGjKcp0VE22BQAnRFj9+zGjWd2McFY5YEqYuNmPX8+Ky4Whzww5uMTXrxIiLfCpQDojMSkpERUBwAAPAa7YJpbYIgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjUwOjM0KzAwOjAw8JvcoAAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACzVBMVEUAAAD////////////////////////////////////////////////////////7/Pzy9Pb////////////////////////////////////////////////////////////////////////////////////+/v7////6+/v////////////////////4+fr////////////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////r7/Ho7O/s7/LU2+GtusZ/lKdge5JPbIfu8fO9yNFvh5whRWYBK1AAKE8AKU/+/v7X3uR4j6IaP2EAJk0AKlD7/PzEztZKZ4ICK1EAKE79/f3DzdY8XHkAJ03W3eNHZYB1jKADK1EAJ067xtAVO14NNVlBYHxgepHr7vFpgpgCLFFWcou3ws3a4OXm6u3V2+IbQWMBK1Fzip7e4+iruMVPbIbY3uQFLlOjssD8/f3t8PJhe5IsT27Gz9hYc4w/X3vR2d9ifJMzVXPK09vx8/V3jqITOVyxvcmhsL4AKVAAJUzM1NwPNloUOl2QorP09vfl6e1Oa4UdQmN9k6bQ2N/4+fqmtMIIL1QJMVY+XXpqg5mCl6nj6OxUcYoAJkwGL1S8x9EoSmr2+PmUpbUMM1cNNFiUprVogZgBKE5qgpjp7PDL1NsBJ06ntcIeQmQeQ2WotsP29/l9kqUIMVV+k6b3+Pnf5OlUcIoEKlAwUnExUnG9yNKVprYVPF4IMFUJMFVBYH3X3uO0wMwfRGWInK0MNFiJnK5ZdI3T2uEwUnC5xM/6+/yAxxLtAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAA0hJREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/oBAICvLzcnOykyTExRhh8pJSRcUlpWWFheVgUFhYVlpSXCQlCVHBKC0jW1FZVV1TjgRqqqsqK2RlpEEq5OQVauvqGwrLUUBhQ31drYK8HNAALp6kxiZ0eZCKpsYkHi5GBkFxxdTmFpjtrWVlrTB2S3OqorggA5dSbVs7xP7Cmo7Orq7OjhqIkpr2tlolLgZlle6eBoh8b1//hIkTJ/T39UJUNPR0qygzqKpNmgzmF06ZOq0oCQiKpk2dAhGZPElNlUFdY3p+IdhRM2aC5YEqZs4AO7owf7qGOoOmQAZE+azZc5KgYM7sWRCxDAFNBq2588Cc1vkLkuBgwfxWsIJ5c7UYkroXghWULVqMULB4URlYwcLuJAbtuUvAChqWLkMoWLYU7LHCJXO1GXSWrwArKFi5qggmX7RqZQFYwYrlOgy6eqvBCtas7UmFKUjtWbsGrGC1ni6DvsG69RAnb9i4CSK/aeMGiMj6dQb6DIZGm7dAQrp167btQFuKtm/b2goJ6y2bjQwZjE127NwFCdrW3Xv27tu3d89uiHzhrp07TIwZTM209x84CI3AgwcPHTp4EBqdBw/s1zYzZeA0t6g4fKQGlthAAJqojhyusDDnZGC0NLQ6euw4ZoI5cfKolaElMM0xWttop5w6jZ7kTp85a2tnDU61nPYOjuc6z6OoKDzfec7RyZ4TkuzlnF0qLlysQVJRWHPpcoWrsxwsYwi6uV+5eg0p3dfsvn7D3QORtTg9vbxv3roNN6Lw9q2b3l6enEiZ08c3KecOzJLCmrv3RH19ULO3n2zSfWjiLq95cD9J1h9FnoEhwE5lec9DcCQXPOpZrhIYgCrPwBgUzNfYCcpAhS2Pn/CFBKEZAFQRGpb09BkopJ89TQoLx5AHqpCMqHj+orDwxcuKCEks8sAgj4zqfjVr1qvuqEhrbAqAzoi2ff3mzWvb6CCs8kAVMbFz3r6dExuDQx4Y83Hx797Fx1niUgB0RkJiYgKqAwC8prs7Sn3FCAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NTA6NDMrMDA6MDA/+es3AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACfFBMVEUAAAD////////////////////////////////////////////////////////8/P709P3////////////////////////////////////////////////////////////////////////////////////+/v7////7+/7////19f3////////////////6+v7///////7////////////////////////////////////////////////////////////////+/v7////////////////////////////////////+/v7////////////////////////////////////////////////////////////////////////////+/v7////////////v7/zs7Pvw8Pzc3Pm9vfOZme2AgOpzc+fx8fzKyvaMjOtNTeE0NN0xMdwyMtz+/v7f3/mTk+1HR+AvL9wzM938/P7Q0Pdubub9/f7Pz/djY+UwMNxsbOaRkezJyfZDQ+A9Pd5mZuWAgOmHh+t3d+jFxfXh4frr6/vd3flJSeCPj+zk5Pr+/v+7u/NycueYmO03N921tfKBgepWVuLR0fd5eeja2vmCgupcXOPV1fjz8/2SkuxBQd/AwPS0tPIyMt2Hh+rW1vg/P95CQt+mpvD29v3q6vtxceeXl+3a2vj6+v63t/M4ON06Ot5kZOWIiOubm+7p6ftSUuL4+P2pqfE8PN7t7fxnZ+W4uPNKSuFLS+G5ufM5Od2YmO74+P7l5fp2duhZWeNaWuOqqvBERN+rq/D09P05Od7e3vnDw/VMTOGgoO96eug2Nt3Hx/X7+/4Nm4E+AAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAM8SURBVDjLdZP3X9NQFMVfFIUWLJRpVcoeYlVEQEUExIUyFFFRcfJqqiyb12paDQQKpQXZorJXARcbFRC3oohb/yHTJIUW8fyU5Hxz7/3cdx4ArDBs2XK7FSvtHSB0sF+5wm75MgwDVsIEQkenVSJnF/mlS3IXZ9EqJ0ehwIrAxK5u7h644vKVnNzcnCuXFbiHu5ureJ7APL1Ww7z8gqtKAjEilFcL8vPgai9PzOJL1qjU166TCGlYIURev6ZWrZFwBLZ2nbf2xk0lobESobx5Q+u9bq2ZkPr4UoVFNNLYCNFFhZSvj5QpIHSC6uLFvpkoVkMnIQbEXn54idLSnWZkeVaW4H5eYiD0p3SlXH9ElOnLy/VlBIcQpTrKXwgCAuUGmv/FWFF561ZlhZEvSBvkgQEgKLiqGnF+TW0dZFRXW8MRqLoqOAiEhNazr4huUKsgK5W6gR0EKetDQ8D6sNsc3niHgryoO43ct9th68EG/C77Qt9rgvNquseOhe7iGwCUN7MAqW9ZAFr0JAs0yyGQ4a1chbb2BaC9javQisvAxo5OFiC6ulUWX9XdxW4GdXZsBJs297CAiezFLQDeS5pYoGfzJhC+pa+fG/n+g4ec//DBfe5Lf9+WcBCx9dFjbtN09cAg00U1OFDNrZZ4/GhrBIiMGhoe4Vc7Ojb+5Mn42Ci/+pHhoahIEL1N9tRI8gdIko2NJMkfJ2l8KtsWDQTbd2h1z/g4mcyZNPGheqbT7tguAFhMxM6Jyal/AzM1ObEzIobJHBa7S/bcQCyOHGF4Hhcfy6ZWkLA7sV1vGzpET7cn7kkQcLGX7t2nffGSMFn//+q1dv9eqeViiA8kTQy8sco9Mfr2XdLBhaslOJSc8v6DZr4J0nx4n5J8SGB1OVPTYP6MZVBEfMz3SEu1vd6HveGnWb4JMfsZeh+x8QFIjw+cM3xhCeLL+Fzg0XRbH2AZx0Rfp83xRcppteh4xqICDHEiE377bl71928w8+Q/PkNITml/TCFU9kN7SrKEz6z8dJb8569fP+VZp2OXApgxzsQpZmYUcWcylvQZ4uw56vdv6tzZ//jMyZ+/8OfPhfMx/wOYMS5mZ1+0HeAvs9msMpv5tz0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjUwOjU2KzAwOjAwoWvEDgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACTFBMVEUAAAD////////////////////////////////////////////////////////9/v/5+v/////////////////////////////////////////////////////////////////////////////////////+/v/////8/f/////////////////////8/P///////v/////////////////////////////////////////////////////////////////+/v/////////////////////////////////////+/v/////////////////////////////////////////////////////////////////////////////+/v/////////////2+P/09//r8P/Y5P/D1P+1yv+txP/3+f/g6f+7z/+Xtf+Iqv+Hqf/+/v/s8f/A0v+Usv+GqP/9/f/j6/+qwv+kvv+pwf++0f+Gqf/f6P+RsP+Orv+mv/+0yv+5zf+Jq/+wxv/d5//t8v/z9v+Us/+90P/v9P/X4/+Kq//U4P/9/v/2+f+cuP/k7P/1+P+xx/+lv//p7/+2yv+gu//m7f/4+v+Qr//a5P/T3/+FqP/n7f/L2v/6+//y9v+sxP+Vs//C1P/8/P/V4f+LrP+Mrf+6zf/F1f/y9f+vxv+KrP+atv/7/P/N2/+Nrf+Nrv+4zP/W4v+VtP+WtP/6/P/C0/+MrP/D0//w9P+euv+SsP+Ssf/N3P/c5v/I1//q8P/e5//8/f/tCMxjAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAyFJREFUOMt1k+db01AUxm+U1QKllT0KAlXUInsjoOICRREVFZGRMMrKTSFlBVoKKGgZUqZShiJDUUARFyrrHzPkJrRlnE855/09J+9z7jkAcIFhx47b2NrZO+C4g72drc3xYxgGLAITiR2dnCUuUqKkhJC6SJydHMUiCwKTnXB1cydKy8pVFRWq8rJSwt3N9YRsj8A8PL3wyqrqGhJyQdZUV1XiXp4emKB7+1Dq2jqalbiAkK6rVVM+3ojAfP3kmvoGkld5hmyo18j9fHcJ/4CTVH0jbaWzBN1YT50M8GcbiJ1wddN+fZdoUuNOYgzIPAOJZqE/ZGiaEb7JZiLQUwbEQVRLK+TNaXVtbTotbxa2tlBBYhCsIPQ0KrR3dD57/vxZZ0c7Img9oQgGp06XdkHUsvsFhbNBvehGv4RdpadPgZAzL7kU0hVqnA91BWcaki/PhICz0nKEG3p6BaC3x4Bq5dKz4FyfikuY/lf4XrzqZzhA1XcO4ANGDqAHh8zA0CDnGxoHcKDsG0bAyKgZGB1BwHCfEoSO1aL/vX5DCTr15jWq1Y6FgvNh4ygx6QkBIPQmVBsPOw/CIya0KGudnEL61CQaLdRORISDyKjpt5xlknk3w/kcmnnHF95OR0WC6Jj3s3NotMx848KHDwuN80iHc7PvY6JBbJzy46KJf0AT/ekTbeKf07T4URkXC0TxCZqWz4ywBVDYO5L53KJJiBcBLDEyaWl55eDCfFleSopMZHcOS76gLPkK968c1JekpCZzWytKu3hpVMdYLy2jG710OU2E1t4//Ypm9ZtlDwjXVjVX0/2Fw5Bdu/79x5wl8PPX0vUb5tMSZWTe/L1ovgxILv6+mZkhsjjOW1l41br5star3LNuWZ/3bTm+/IefBvP3Hy6/Y6UDkJ2qGNMjG3BOP6a4m22tAyznnkSt27UBSZ1acj9nXwOWeJCLb6ztjnptA899eEBnCe9Hms0VCFc2NY+8D9HZkT/OGzAaDMaBvMfJhwGsjScpW+vrWylPcg7VWSL/KbW9TT3NP0JnX76gcGensCDxKIC1UVRcXGRt4D+SPpTGEJHXggAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NTE6MDYrMDA6MDAGSaFUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAClFBMVEUAAAD////////////////////////////////////////////////////////9+//58v/////////////////////////////////////////////////////////////////////////////////////+/v/////9+v/////68v/////////////////8+P/////////////////////////////////////////////////////////////////////////+/v/////////////////////////////////////+/v/////////////////////////////////////////////////////////////////////////////+/v/////////////36//16P/37P/u1P/erf/Lf/+/YP+5T//47v/kvf/Fb/+mIf+ZAf+YAP/+/v/v1//JeP+jGv+XAP+ZAP/9+//nxP+2Sv+ZAv/+/f/nw/+xPP/v1v+1R//Hdf+ZA//ku/+hFf+eDf+zQf/Daf+7Vv/it//w2v/15v/u1f+kG//Hc//x3v/dq//v2P///v/Mf/+aBf/ao//+/P/37f/AYf+rLP/oxv+8WP+yP//s0f/AYv+tM//qyv/58f/Jd/+gE//fsf/Zof/qzP+fD/+gFP/SkP/69P/05f+4Tv+kHf/Lff/s0P/8+P/bpv+bCP+cCf+xPv/Dav/Ngv/z4/+6VP+bBv/kvP+oKP/79v/UlP+dDP+dDf/26P/DaP+YAf/26f/qy/+yQf+XAf/cp/+kHv+lHv/cqP+cCP/Lfv/79//y3/+ZBP+sMP+sMf/Ulf/u1v/gtP+lH//PiP/Pif+8Wf/t0//iuf/9+v/1rAt3AAAAY3RSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD++P3qw/2N+0j2GMcHYx68BOkMd/x2IKf+pjrS0WDvXxSL+Cy3TEsIdRyhoDXINOSK8rY72mnrhe2jCycJAAAAAWJLR0QB/wIt3gAAAAd0SU1FB+cFGQAhKwJH+lwAAAMmSURBVDjLY2AAA0ZGJmYWVjZ2juRkDnY2VhZmJkZGBiTAyMnFzcPLxy+QkpqaIsDPx8vDzcWJpIJRUEhYRDQtPSMzKzs7KzMjPU1URFhIEK6CUUxcIjknNy+/oBAMCvLzcnOSJcTFGGHyklJFxSWlZYWF5WBQWFhWWlJcJCUJUcEoLSNbUVlVDZWFqqmuqqyQlZEGqZCTV6iprStDkQeqKKurrVGQlwMawMWTXN+ALg9S0VCfzMPFyCAorpjW2ASzvQwIYOymxjRFcUEGLqWa5pZCqONa27Ky2lqhji1saa5R4mJQVklpL4M6rKOzq7u7q7MD6uCy9hQVZQZVtZ5eML+woK+/KBkIivr7CiAivT1qqgzqGhPA3MKy7ImTksFg0sRssEMKCyZoqDNoak2GKJ8ydVoyFEybOgUiNllLk0F7+gwwp2zmrGQ4mDUT7KzCGdO1GZJTZkMUzJmLUDB3DkTB7JRkBp3p8yAK5i9AKFgwH6Jg3nQdBt2FiyD2LV5SBJMvWrIYIrZooS6Dnv5SCKesPQ2mIK0dEpyFS/X1GAwMly2H8FasXAWRX7VyBURk+TJDAwYj49VroAG3dt16oC1F69ethQbtmtXGRgwmphs2boKq2Lxl67ZtW7dshspv2rjB1ITBzFxn+44yeGTu3AmPzrId23XMzRg4LSwrdu2GJQdQkoQxd++qsLTgZGC0MrLes3cfZoLZv3ePtZEVMM0x2tjqHDh4CD3JHdp62M7eBpxqOR0cnY4cPYaaaI8dPeLk7MAJSfZyLq4Vx08UIqkoLDx5qsLNRQ6WMQTdPfasO42sYPOZsx6eiKzF6eXtc27HebiKwvM7zvl4e3EiZU5fv+TcC4icdTFX1M8XNXv7yyZfaoEpaLmULBuAIs/AEGivsrAd4ozCze0LVYICUeUZGIND+C63gTJQYVNbMV9oMJoBQBVh4clXroKC+uqV5PAIDHmgCsnIimv7Cgv3Xa+IlMQiDwzyqOiUG1Om3EiJjrLBpgDojBi7mxcu3LSLCcYqD1QRGzft1q1pcbE45IExH59w+3ZCvBUuBUBnJCYlJaI6AABB269xUXFElwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyOTozNyswMDowMEpaoL8AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjI6NTE6MjArMDA6MDAnvJMTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAMAAABjq9sOAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACbVBMVEUAAAD/////////////////////////////////////////////////////////+///8v///////////////////////////////////////////////////////////////////////////////////////v//////+v//////////////////////+P///////////////////////////////////////////////////////////////////////////v///////////////////////////////////////v///////////////////////////////////////////////////////////////////////////////v//////////////6///6P//7P//1P//rf//f///YP//T///7v//vf//b///If//Af//AP///v//1///eP//Gv//+///xP//Sv//Av///f//w///PP//1v//R///df//A///u///Ff//Df//Qf//af//Vv//t///2v//5v//1f//G///c///3v//q///2P//Bf//o////P//7f//Yf//LP//xv//WP//P///0f//Yv//M///yv//8f//d///E///sf//of//zP//D///FP//kP//9P//5f//Tv//Hf//ff//0P//+P//pv//CP//Cf//Pv//av//gv//4///VP//Bv//vP//KP//9v//lP//DP//aP//6f//y///p///Hv//qP//fv//9///3///BP//MP//Mf//lf//tP//H///iP//if//Wf//0///uf//+v8BRUUXAAAAYnRSTlMAAAMQLWqp1fMBEUOe6Pn8/gUukuz+CU3EW9kGUNsCMsvxrzbuePq1/OD4/erD/Y37SPYYxwdjHrwE6Qx3/HYgp/6mOtLRYO9fFIv4LLdMSwh1HKGgNcg05IrytjvaaeuF7djGYAwAAAABYktHRAH/Ai3eAAAAB3RJTUUH5wUZACErAkf6XAAAAu1JREFUOMtjYAADRkYmZhZWNnaOpCQOdjZWFmYmRkYGJMDIycXNw8vHL5CckpIswM/Hy8PNxYmkglFQSFhENDUtPSMzKyszIz0tVVREWEgQroJRTFwiKTsnNy+/AAzy83JzspMkxMUYYfKSUoVFxSUFSKCkuKhQShKiglFaRra0rLyiAAVUlJeVyspIg1TIyStUVlUXYIDqqkoFeTmgAVw8STW1BVhAbU0SDxcjg6C4YmpdPTYF9XWpiuKCDFxKlQ2NMLGm5szM5iYYr7GhUomLQVkluQXmsNa29o6O9rZWmINbklWUGVTVOrug3u/uKUwCgsKebmiAdHWqqTKoa/RCuVl9YHmgir4sqJZeDXUGTYEMCK9/wsQkKJg4oR8iliGgyaA1aTKEM2VqEhxMnQIRmzxJiyEpeRqEM30GQsGM6RCxaclJDNqTZkI4s2YjFMyeBRGbOUmbQWfOXAhn3vxCmHzh/HkQsblzdBh09RbAfJ0KU5AKC5kFeroM+gYLF0F4i5cshcgvXbIYIrJooYE+g6HRsuVQ9StWrgLaUrhq5QqowPJlRoYMxiar16yFCqxbv2Hjxg3r10G5a9esNjFmMDXT3rQZEYVbtiDYmzdpm5kycJpblG7dhi26t20ttTDnZGC0NLTavmMnpnzTju1WhpbANMdobaOdsisfXT5/w25bO2twquW0d3Dc04ymIr95j6OTPSck2cs5u5Tu3YeqYN/+UldnOVjGEHRz375yLbL8ugMH3T0QWYvT08v70ObDCPnDmw95e3lyImVOH9+knCMIBUdzRH19ULO3n2zSMXjibjyWJOuPIs/AEGCnMqcF6ox1LXNUAgNQ5RkYg4L5aprBGai+uYgvJAjNAKCK0LCk4ydACk4cTwoLx5AHqpCMKD0JDPKdp0ojJLHIA4M8Mir5dH//6eSoSGtsCoDOiLY9c+TIGdvoIKzyQBUxsRPPnp0YG4NDHhjzcfHnzsXHWeJSAHRGQmJiAqoDAOgCnVLAYqeOAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1MTo0MiswMDowMHZMi70AAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAADj0lEQVRIx5WWO2xURxSGvzN7H7a0AdFRkFSQBovKqcCyBF0kmlDS0SHRpkJKEYmGEBeENImFRJMoLlLk4caJrCguEDSguMEijYMQAu+uwfZ672v+FHe93nu9fnCmO3P+f87jn7nXGDIBNPiAD5limgk+oglsssoyf/E3/7FBAcZIEzKd0CXd1yslPve+ULm897kSvdJ9XdIJmfaBhzqnu1qTL5QrUVeb2tCGNtVVolyF5LWmuzqnUCPg47qsJalQqi2tq63W0GprXVtKVUjSki5rfIfC+rWP8xlf6GNPSoLf3RruDo6YCIet8CU/s21llCDiU77S6YJtMvZtEgJCxmlgz/mceVLDAY4Jbh4OL3cytinQaW4ygQMnOM4NJv2h8GEKD5Pc4LhwhFzgiifZA9fQqlMkeLjCBUJHk2s6VpBW4EIYITExIVYhMSClQMe4RjPgDNMixVfgJdhhgCjz0yDC8KQ0sGnOBFxUU2S1XsfENAaeBg5Hb4gCMsZQ0y46pnBFZQuiCrykiIkqnRAFOKYcZ0uC4fQj3J7+OyKsEleA46zjpMzXTnMjhmm4WlYeGScd8d7Q0VoY6Y8dvu6rzv0Qv3e0rFaxx48IFb52lsOg5XiGH67N8GQjCbKKVqABnmeOR+YdrgLJSGsUIq1pxeEwzyPHApkjqOWQ0KMYeAp6JLXzAxxkLDie8NRqMzYKenTpss02Xbr0KGpSjzB4yhNHh1nzAWFtZCKj119ZTakQEmCeWTqOlAUWjZhG7draYHRWu+YNYgwWWSB1iJfcsdcBcaWMHZK6fIQjJsBec4eXyBnkLDFjPiKCfUS0C4eICCv4miVyw4HBFj8xZ4oJD6QoH9UIE3PMsWXQF6FY5RtbbhCPuIdV9cU0sH+4x2p5kitrxfOYGVsPR3RieHgxIbbODI/xxoAADHJ+Y5Zk5w0cBQ+JIWGW38ltkNNOx8UaD2zR9V+jupTLV8nJFnnA2u73dahkg2W+5XkwshPl8PiXeyxbxV+ZO3/wvXWiWhll+hHW4Tv+tBpx1Xr8wK+WjhEMKIQRMIal/MKP9DjYhD7RQylRRy211VZLHSWS9FCT4ggmdFUvvLr9f4S2uvLSC109EhyEmrqtd4U21FZbGyqkd7qt5hEJQOiU5pXnequ3yqVc8zp1ZHif4rxWvFKl8tKKzr8XHIQCXfdvvLz8G11X8J4E/U7cUkst3Tqo+v8BGqkQrMMFpyAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjUyOjAxKzAwOjAwKNkk2QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAAD/0lEQVRIx5WVP2wcRRTGf29u9/44a5/Pd2cHEagIEgoFRYSQHMtSQkVJOsoICUVKi+gokFIgghubArAipTHCBVL448ZBFiI0caQ4whGKFRoTx3aS89k+fL7b3ZtHcb7zzdkOyWyzOzPf99773jezQsdQgAS9vMIIo7zJqwTAvyyzyG/8zj9UaIBw6FBUNKfn9Kquad3GsY001FAjja2Nta5relXPaU5FO1DSEd3nDT7kAwZiiaixS0gMeCTJkMbHUzaYYpK/iMQlUMjwLp8wHFNli01C3DhJ+snSgwd/8Dk32JV9AoUM7/Opvl6nRInQTa6lDkny5EkhS3zGD00KAYUk7/GFvrbDKtvoUSKhCH28xDHkAR8zQygIqOEtvtbTO6xQ4UiN25n08jLHkNt8xIJYo5DlEqdrrP4vvLlaYZUanOYSWcXgc4bzMSW2D9S9/7gU25SI4Txn8A0BF7SvSsmpXVES9FGgQB8Jh0RQSlTRPi4QeJxktEGZyIELOfKkSAAN6pQodwQQIsr04I1y0uOsBhFbXVoPUSS5B/BJkSbJupPjFoMkAjlrGMHUiBydsxTa8JaNCmTbfgCIqIFhxHDKml2HW8iR6uqGkCLn7FF2sYZThuMqobM5cwDeosg4MyEqHDekwDoLCcyhHjAknG8LkDJYugDW6XunuLaLELCGkuA7C3WiQyiUiLoz4yNQMtwXm3ZqjdiicYCgwZbjFUgjlvuGW8am8RynldnoomiwQdmxmkcaY7llmCXyCZwcYtZYp9qeqbLOGrETP8CHiFmPBe567wywje2wasgaFTL4QMQuOx2roBgG8OAuCx5lJs3bgclSdrKwVKhgWu3qckaWAGOZpGwImWXOp0i669gKYLHt9/34aYr4MMcsoUF5xBV5HDBIoqt9sve47UwwSIA85gqPUCMQc5MxY3MMwBEm2odDnhymwZfcJBYMCOzwPdOeFuh9JkXzRszjKdNMsyMtP6IsMy6LPRRJHkmhQJIiPcifTLDc3Gb2FLbMMyab/RSOOErNzQX6kU3GmMcKbQIQiPmZSannySKHngWhnzxSZ5JfiKVN2lJceco1mUtRJHOgDAUyFEmpzHGNp/v/1458BRb5igd9FLrOJ4BPgV74mwkWOxvrFCxwg28p5+nHdOSgGPrJQ5lv+NX1RbdiNab4KREOEbSVUISAIRIhP/IdNZ5FIPCQCe6kGdxraLN5g6ThDhM87L4tD/RMYJ5xVrIU9+7ABEWysMI4tw9etoc3/TpTUimQxWDIUkAqTHGd5x2KntAZjat6T+9pVTXWGT2hz41vUgzrktVN3VSruqTDLwQHRT29aJ9YtWqf6EX1XpAAFA30spa0pJc1OBr+H/Nbm042akI7AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1MjoyOCswMDowMP9kZncAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAAEJklEQVRIx5XVT2xc1RUG8N+9M2M79tgxJDLR1MHYjosQrdRFVFUKUSToqsuy6xJVqpDYVuy6qMSiKmSTdNHWQmKTqllUon+yIFRRVbohSAQRgRxRJXWwSQzGjpzYnsnMOyzsOPPGNoX7Nk9P9/vO+b7z5yVdJ6Bi2FEnnfI9j6vjrnlX/cu/3bSmQ7LnCZHikXguXo9b0SzarWIzNmIjNqNVFO1oxq14PZ6LRyJFFyp1Ra95ys/9zKPNtOmuVeta6DNoVN2A/vClc2Z97H4qEwQH/NjLTrSsWrTonnKcIQ0No/r4j99420Z6SBAc8FO/iu+u+Z8b1iVlpYEw6AkThqVrfu0vWxSJoM9P/LY49qWP3RL7mSQkRzzlUfkTv3RBK0lE9gO/j+PLPrQk7QvfNtqY7zskvecXrqQiBwe95Piaj/4vnCRZ8pE1jnvJwZDVPOP5phtu98BDKBSix87kthuaPO8ZtazuhRhZdb2kPYSaMVOmjKmVSJJw3aoY8YJ61YxTLQs25S549h2ThlTRds91CwoPa79pwaj+U2aqno36psVS9GTGMYM73+qGDbrWlWOyaFpfPT2bnYy8ZqOUfMOkoS7KZMikRknIhjWRncye7uQ7Jf0V44Z3+T9sXKXkwx2d7OnsSKT1nqv1PYqZ1Hto10VyJOsPnVLx+rsidZ+K/lJBO4L+rEg9gLZiT4JCu4cwUWTLyUAp1bs2SpEeZLbhbknagMRyNpeLsram21q7CFpua/Z4lQtz2bu5GFHbiZkkN833pNs272ZXq4eaEbnwbnYx3T9grCSiac6c1Z0vq+bMaZYEjDkg3Xex6ooP+n501C2drj5bN2fJQQPYdMeKdqlXK47q4wNXqlbMVn54ODfMl3qvbcnS9izYNacNh1UKs1aylosuDZgy0jO2WdLR2X7rho+YMsAlF7WysOjVvHTYjGpP+dL2Uy5nzYzD8pJXLYqcaHvH6UoxboI9OqAMZ8K4Ssdr3tFOMol7/ux8f0wa+1qKwJgn9IfzzruX2N4iYd6ZdHXUtKF9KQJDpo1KHzprfuta3tKqcNnpvNowsc8oQcWEhrzqtMuKLW/yA7u0/d1sbk5qSHvOQtIwKTfN+of2A2t3FmEKX3gjXdpKsldGYNS0oUiXvOGLh//Xh5tU4qrf+WTMpP5dGQyYMsZ/nXW1u7C5+1LibX+0MuGoSlcOoWLc46z4g3+W+yL3BNp0zt9qrWMO7TgRkkOOqbX81Z9s+jqCxKfOen/EkwbZ3sODnjTC+876tHdb9mYgcdkZC4+ZVgVV0x5jwRnv7V62uwjAm87ltUkNWd4q3ppz3vRNT4jxuBDt1Xgr3orViHZciPH4xvgtihNxrYjP4rMoIq7FiW8FJ0Q1Xiw+70Qnis/jxah+SwJC1OOVWI7leCXq+8O/AuFKp/3c1qOQAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1Mjo0MiswMDowMJ17ML4AAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAAER0lEQVRIx5XVS2xV1xXG8d/evrbxC7CpMbVSECGg2qlRU5tXDEVNOmmHzazDqFIVKdOqsw4qZVA1RZGgg7ZWpEyoyqBS+qADgpxSOglYkIQE2aFCIuGNMcEOhsu9Z3WAgXts0yb7zI7O919nfevbeycNK6BJl2/YY69vWa8Tcy4445/+5VOz6iTLrhApuuPFeDOuxL167W4xF7fjdszF3aJei3txJd6MF6M7UjSoUkP1ZgN+4sd67qRZ110xYx5tuq3Tq0t7uOmgMWfdT2VA0Ob7fm503iUf+9iMcp1ugwb1a+PffuUd8+kxIGjzI7+ILTdMmHBLVu40UFht2LCvSVN+6c8PEImgxQ/9unjmgnFT6vLyJik02eJ71svn/Mxh1SQR2bf9rhi54B/OS0/y+KHRNvqB9fJJP3U6FTlY5VUjNxz9v3KS5LyjbjDiVatC1my3l+446ZNF8lAsPLEI8YmT7vCS3ZqzTi/HyosmRIM8FFbYbJttNltRgiRhwkWx0ss6Kzbbe8dHZhusC9mQYWu0oGrahA8VHs9+1kf6dey1ueKF6JxztlQ9222X7kfv1ui1yvES4qxd2jvTC9meIl/zecnnAdsb5A9itN2AaGjkc9cU2Z7s2Vq+Wuq/YsiaRdNI1hhSKflwVS17NltXTzMl73v1LBOlrEdvaR4z6sm6rDXUSoB2LctmoEV7CVATtGZF0lz62ar6soC6aqmxZokim846SoCbbpcqPfyz226WAB0y09lkpVhbAsyZMr8EMG/KXAmwVqUwmb3XVPRpa6iZfeCUakledcoHpai16dNUeC87ku6v9HQpqnOOedflhXfhsncdK9UPT1sp3Xek4rT323duNan26INsxjHn9enCrKs+VS3Vb7ZVO+87XTFjrLJ9Yx50WlNDG/edc25hL5BLySgM2qhSGDOTVR0x3mWHPkXJzCZZTU3WVDKv0GeHLsYdUc3CJa/naxs8r3XR+NLCUx7nCqM2yNe87pLIiZrj9jUXWw2zTALKcr5jSHPdbxxXSzKJL/zJoY4Ysam045bKwyYjOsIhh3yRWPAmXLA/nem3Q88TESH02KFf+tABFx58lh/0qnDCvnxr0PATthK0GDYo37LPCUXyCECi5m/GKveGfVNadi8kA4ZV7hnzd7XHmXnoeLjhrTTeY6evLzEz0G+nnkjj3nLj8f3akI/EGb917hnbdS4BdNpmE/9xwJnGwZaOnsQ7/mDmOUNaGhChxZDnmPF7R8u5WHx23XXQX1dUn7f+kRMh2WDUiqq/+KO7/hcg8ZkDTq31XasXRsdqe/RyygGfLb76lpyeiRP2u7jFTq2g1S5buGi/k0tvzuVv8rcdzLPbDGjSZMCIPOugt33ZFeKpOBy1y/FGvBGXI2pxOJ6KL61/gBiNqXpMxmTUI6Zi9CvJCVGJV4rrtahFcT1eicpXBBCiM16L6ZiO16LzyfL/AjzmtojnBFLlAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1Mjo1NCswMDowMDIBBRoAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAAEXklEQVRIx5XVS2xdxR3H8c/MuX5g/CBGTQzkATIggQt1K7fNgzgI5YVDWmjaRdsdrRQhsa2666ISi6o0m6SLtu6CRYIS1Er0EdGYEKV1GwlbTaxGRYkCgWAiYuKH4kaxfX3PdOHg3HPttDBnNXPm9x39/vObmaCqJci0WGOzLb5orWb8xyVnnfQ3H5pWIVRpQkEe3OUrvq/Piko2G8shR1SXGvKsYtJRB/3TlBSWAhJ1HvFD39N+LUz40EVjptFipQes0a41mXBIv3eUQxGQuMNWP7Zp2rtO+YcrKov0JLPKRht0auHvfuZNN8ItQOIO3/KT9PCoYwaMiUV3EnIrbbPdauG8n/r9AiKQqNfn55UH3/GqIRXR8i2X+arvekR2wY8cNRcEUtTtV3nPv/3WiFhYubYluS/5gUfFYXudCXlMtHlRz6iD/1dOEI04aJQeL2pLojpP2HPNG4Zr5EmuoiJfyEcVYtgbrrHHE+pKmj2ft15wTF7lPUnu9LBVuOK864JbG5c7pkd3a3zeYMlDtkwbNCGrkke9drhXI2Zc9hd/lS8iogmDOrVt8VDJU6l5yqnC6tEe39CxKLjXal/wuwLilG9qbQ5PRZsr8QNXC8436KuSE3Tos6FQjas+UIk2R11z8X2panq9XvfV7EZwn171Vf3kfXNRV9QxH8YKYVnrnmWiFN1jrbxqZMx80BE1JLOFqS0al81Ao5ZCf1aiIcpDjeCG8rKAshs1wEAejWfaCm4/Nl6IzqfFHfdxoTJtMsajc/X5uoLXScOmlwCmDZss1Gad+ty56O26fJ3mqjUzJx03U5DPOO5kIWrN1qnLvR0NKN/t8SpAMOU1h723OPKew14zVWUgedzdlA2UnDHSuv5JQ8pVObviiBEPaMeEi86ZKWS13pNaGXGmZFJ/3dceixu9pVRViVmnnb55FsgK7iu2eExdrt9kNGfAiXa73F+ISZDJlJVlskL1c/fbpZ0TBsxFyWUvZ2NdntVUc/JvfdXbeafndMnGvOyyFAPzBu1ryHttY5kEFNPANr0aKn5h0HwQCVx32JG70k7d0v9AJEm3HdqSI464HrhZm+SS/eFsp11W3RaRJB2e0Sn8ywGXFqbFBbdyQ/ZlUxtt13hbQKPtNsqm7DMkDxYBBOb9SX/97E5fF5c9C9F6O9TN6vdn87cy82nNk6teCSc67Na5xEaSPGi3jhROeMXVsPi7Kh+Bs37pwpf1WbEEsMLTunnXAWert7Vw9QTe9BuTW/VqqEIkDXptZdKvHS9edrV314xD/tg096xHFyuRRF2e0zTnD16tOaa1gMCoA06v9R0rb3pnpW9bw2kHjNY+fUtuz8CQ/T7q8Ywm0GS3Hj6y3/DSl3P5l/x1h7Lpp61XUrLeTtm0Q173WVuSVqejaf5i2pv2pospzaejaXX6zPoFxKZ0vpKG0lCqpHQ+bfpccpJUSi/kn5RTOeWfpBdS6XMCSFJzeimNp/H0Umq+vfy/0JikOgfvvUIAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjk6MzcrMDA6MDBKWqC/AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIyOjUzOjA1KzAwOjAwM1Rr9AAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAApCAQAAAD+fOO3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfnBRkAISsCR/pcAAADzElEQVRIx5WVTUxUVxiG33tnhmF0iJ0iCVF+NJpghTSUVNOoTTMrCS1qm4mJZVFSu+h048Jg2dCdSatb3TWkTaw2ISkbBY2waGBBJGmsoggkasEfyDhDsQjM33m6YGjnzgw4fmd1v++8z7nnnPecYykrkCSXylStD/WRGlQjv6RFTWtMv2tIM/pHacnK0lgOuaW31KQ2tSiQci3bcSstySUvPuNOa159+kV/6G9h5QOQPHpHX+lzvR21ZjWhO/pL85ICqtW7qlOlylFMl/WjxpXM/gtJCB+tDEOMQU6xEwtlNYudnGKQGMAwrfjIk7cxYRink20OaXbbRifjGJigLQuBKOEYU0mGacFeVy6ETQvDJGGKY5RkENg0MZpmiEMbitfaIYZIwyhN2KvjB+iG+xwuSi7EYe4DdBNAwkMrCy/owFU0wEUHL2CBVjwiQG+am1TkdSsjSDvtBCnLq1VwkzT0EhD7iUUI5y3WcfqZ5BnPmKSf43mLGyYCMfaLTpO4x/acXT/NQwxrYXjI6RxnbOceJkGnuJZI9eQUj/IgS76KeMDRnEF6SKS4Zqt+xR5Ttq88Cmm3nFa1tFsheRzmG9OKrXpblUlr2tG5TrvkUm64tEt1jsy0kpYqbXmNlh2Fcm1Wodiscsf3sozktWVsbXIUFhUvCIhr0fG9SbZkbEXdqnAUHuu5Y03W5vxcjx2ZCrmlqK0Jr9nrKER1XbE8QEzXFXVk9sprNGHrltfUa4uj1KNLeuXIvNIl9TgyW1Qvr9Et0czSU47k+KyaLm5nvGC4TRfVOT2O8BSWaLaoVG/8g9/0pVYcI/i0Tw2qlDSrMY3m7FSpuvWZvCP6VHg5SXqGUMFzV0JJwXyIGUhzEq+wqGEgyQB7ij7OexggCQPUYAnhppm5JS7gL0pexgWWYI5m3KzuMH6+JT3L1zmHqlCz+IY5SHEG///XqsUOrhgzSvA1CIsgoxjDZXZkvS4ImwPcSXKFmg0BNfxKEv7kAHbuy+ChnfkluihdV+7jO5Zhni/w5Jkdi62cNyuPCOEuKHcT4hFmhfNsxVJ+IBroh0EaCwLeYxAM/TSgdQLxCVNwscAdXcFFgCk+XlcuSZRyhtgC4ZyV8BFmAWJ0UKoNAaKKn4nfJ5j10LgIMg5xfqJqw/EziH2MwFVq/wPUchVghPdfK88g2niS5PuMtf38QBKe0FaUPGPtc7yMcAIPHk4QgZecy7JuEYgq+kjdpZFG7kKKviJmn4M4yGSKG9wgBZMcfCO5Vo0XNpEECUyEcObgviHCz1miRDm70ez/BYYI/lv2W3BZAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI5OjM3KzAwOjAwSlqgvwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMjo1MzoxNiswMDowMM4WcfcAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    }
  ],
  /**
   * api icons used by drawing control with a good ratio !
   *
   * @example
   * image size : [43, 32]
   * scale : 32 / Math.min(size[0], size[1]) = 1
   */
  drawing_api: [
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABapJREFUWMO1mGtsFFUUgL9zZ6bdbaEP2kpRCYj4wlciRMHEHxo0MdHEqDFG/aExvmJiYmJ8G2P0B8YYYozC+oivCAl/VMRqIkTBUIygCAiNlr6oQAttd9vS7bQ7c48/pq0QdtvZFU9yM5nZOfd895xz7zmzQomibwFlgACVCCPUI1QDCcAFAsBHydBDP2ejOEAlyN2l2XRLhaUcyCDUsoQsK4DrgCuBRmAWcALoAfbQyDaUn1nGAZrRUk1KSV59DwhpRLgLuAe4JsZMPwPrsGzA0CuP/M+wugYwCMJFKM+g3IVQEU8ZgCywAeF1LH/ioPJwfPvFpUGA4LEYeBW4DSlCP3JLBXAfSgXCC7i0TS0jhpjYXk0BHjXAE8BtaMn57gK3IzxBjhpdE18xNiyKg3ADcD/glpbtExJF5AGUGwDnjMJqChBqgccRZhVYTDTCk8bks/zvzwIeBWr1vXiwcUNpgCuAqwuCgtKwtIcFtzqU19Ywls5waGPI8d8aUeS0SET3KxAuB34kRu7Gh1VuRCjPDyqWhbcMsGI1VJ1fCRPH/wX3DrHjyX46N9XlBY5O65XAT0RFZEaPxYMVlpAvvxSoXjTIsteGqTp/LvAvbNXiuSx7dZiqRZkCfnOAy9B4HHFhhagy5d9WsxcmmXN5XZ75DHOunEPVecmC8ypz0XjbtZjjJ5H3qQLGcxHJb1CkHPGcghkpFFrIaRL/6ILBAsbA7zvBWLov7+/+QB/+8ZFpfJc5s7CKRWlFCfPCDhxI0JKyaDh8ql44TMtaJd2SLAAbAn8BNg5GvDRQLEIzUdNy6iYTIMgm+H3VXMYz3Vz8UAavqoHc0HEOpMZpSc0nyJYVgM0RNTixYGMltq5BEM4DvkdYlGcxkRg3xKsAcR1sEBJkwQbONFbaEVYCnfLwzOds3JxV4CiwLq8XZGLYwGFsyMEfgPEhZwZQC3xO1PPGamZiV3hNAcqFCJ8Ay+PqTSM7EO6/86PGv347Uo6xEFqD41isiepHhe9zXU8Pk71Ocf1sCg+4HVgNzCuVUpWjA1nz3B3vn7PxSNZ4AbjGYkJrjOPY0BqxAuNJ389eMjjk7204i3meLRoWop70ZeBJwIuvHLnGKnZ7R2LbU183fHVs2PFdo65G6SiR71QRUcCiBChpA/vFaGvRjd4E8EKUtcBNeSv+NLxtfV778011m3YeSmSciYyWU94QUJ24CIAVGLXo98UUBQAmvp26UFYDHcXoDo6azPrds5t3dSfSjkElArFMDYmuIhbEiqgVQRStQLWmaNgJYCXNZuAdou+qGSUXEvzQmty1fvfsDiMgseIhgqqoyBE1prUkWACOESJ8DHzJdEePRlHd31Pe8vb2mt3jgdgYoAIYBR/YY6DJJBKHS//f4BIA0sAbqlwMXJUXQuDYsNOb2lHd3JX2sqe/ogKCTjbwgkU1CxxE5E+gO51MnqjO5YpqZE5leGTSb+zNhawOleGpJydd/RxjX+yb1bzlYLJXmAp/FF7FqAqoBsAI0KmwxXHdzxS+u7mzswU4MT+Tof3gwf/02RcxpaCzz6ltqLKvJD19zAju5KYOlfCntsTOF7+t33pkyPUdE9U6VUVExoERVdKCdomY1hCOqxCM9veHlbW14Di0tbdP2So9DU7y8M7nTAbHfFBfGSyt8PRaI5FjuwbcQx/+Uv3r34Ou7xp1VMkBaRE5BhwVkW7Xcw+j5KwNkFyouA71Cxbwx759+TLqzEjHKo8yx97RUBm+7TnMG/Rl+N3tNU1rm6v3ey5pgaOo/q3QU5FI9I6OjfkiguN5nLt8OZs//XRmx5wpWIDvnp6duLR+9KXaZPjgjs7k1mebGtals6bDiPY7IpnusrKReb5PeVkZB1pbi57/P6fByVKXDPzOtPtmwtX1f/Qm0u3pRL/b0+VXL2xEVbm+r49v+vtLnv8f2Pk64kl5WH4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjAyOjM4KzAwOjAwnw8TLgAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABm5JREFUWMO1mFtsXFcVhr+195mLx3bshNghKWkNpCglPEBpUYSAKg88gGigUftARSJzkbiIB54QalQkKvGISkGQSkTQplJBKQgQbbmUW6CkTZuGVq0pjV3n4jSOnUzG47HHM545++fhjNs6npDjISzpaDQ6s9f69tr/XnvtMTo0fbYfAhACbN5knJ1ch9QHlseIgAZSHbMyhRsvUj0qvIPeHPbd6Y5iRp3CIkGjy8jUtnJ28mbgg8B7gEGgB5gDpoCXmD92GOxZ3pt/haN1dRrSOuLcvQYitwHpNsTtwE0gj5kAXeLfkGLgKGaPgPslIZ62A7P/X9hk6YMRuB5nX8PYBeoBiy+BbBfHA3OIXyDdh7NRXFP24/nU8VcnA3OG6R047QXtTACsmWaeQBNUAO7E6Ea6B984cYVJLjOXOqvD/aC4D/gSxk7MPFhY1WSx0Bq3E/gizVyf9vSmHp0aloBH3ALcCeZIakEnFkgk8RmCfQTkryqshvshoh/4AtBNu6WTjBAbzUWjUYfmYvJdWrkvDLX8fB58n/b0p4JNp1lhBG0D3k+yWZbDJkCBd95c5H0fz1LoX0u1VOKfv11k/Ln1SNaqFMuR4SaMbYgnSaHddLAmD+wAsm0zigI33lrh09/OMzDUD3QBxvY7Zvjp3lmO/aYX4ZYBmwHkEDswPQVccaOm1KwcaCuJ1i55FWDDlgq79i4yMLSJZHkd0M3A0CZ23bXIhi0V1FbiHtNWTKk4UsKagQ22/X0IMDhU4JobBlhZt41r3j3A4FCB0BbWgW1YSvOVLK1mAfKAtTbHm18Kn4kwy11mnll8RpeRpLX8prK0pUvALO0imjMqF+aols+3HTk/c4HZC3NJtVvhVUhlpFQHQ1rNCvQqEK/04GFiJMuhB+uEUFn2LoQKhx6sc2Yki2tbTptgY8hSwaY9bgNwBNMdYMujmkG9muPR7/RTnZ3glt095HsHWKic59CBOf68fwP1agbXLi9qAs9i6Q6YVMLWcK8hfx3oVxhvZ6UcDAl8pkmuYPjIEzdj6lURN6LW/mlXZ09g9knUPG0PzF0xu+k1GzSFeAQRt5mkMCBuRFTLnkpRVMv+v4KKGHEQaRrSySB1i6jdfeDYAuzD2E47/aY3j/Q0xpd3He0de74S4QLEweF9IDjDgEKtxofPnWNfa1DqFtEeKqPhNSeR7UNch/FWVtHMSK3EGIY0WWy4n9z2zJriVMMGWxyu9cQtv4uC6vmuQu1dA4NszIRVNt/DfRAoYHwd01fBMlz2TBfSG8VeyCRzTaF/lKKnvvHv7sfPL7paZIqUQFqr7VDrWA6IJqLkYMScRld9rdGePjBdC9wLfHTlVeYNyCC5gHmBCZmBjc378W8e7/79c+Wo7F2SLHvTWLCkUtpSf0QwWAjoifT97JIcDpTBwgTSD4Fxlu5ZCEkWZC4WviGyTcgE4aQkc6WGK/1sMvfMsdloxhuyBCTw+mPJp1kAC2YKZphQAal/1bAA9sCcmF74K/AjpPmlbAaZb4pMLKKAnLBkp5hoBGv8pZh5/ueTuVOOtN2AGZLJ7KycG+0IFoCLzZhgD4M9KpliETUhkuRkMsPUWlAk00jFH7//dP6FxWAhBagBTlADXnDwuMvnX+v8f4MtfVDIzlCvf09ia4x9QBKtZC5p2Awxtein9p/JH5lY8AsrOWVLZwqtNh+pCoxh9gowUerqmutrNFZxB7t06g+Xod4QxCO12H4Qi7IlZUnQSimiHlvt11PZI4eKmWnj9eVPlle4pHdXE5gHTgr+5KPoIcHvPnby5MvA3OaZGcbHxjr7k2NZXoZ7GatE/etzujvn9RVnconMZEEW/n4xc/Rbo4UnJ+uu7pcULGFmi8C8RMnQKTM3GsN5Gc2FYjHuXrsWvOfV8fFl2vif7fAn1tr6vG1bn42/3+X5kFlyLTgx70/eM1b4w+FSphglV6MGUDKzaWDSzCZ8FL2GaITQJG7EUuQp9PTw0osvrlzNqwELcPz2deRd+NS6rO7NODaXG1a6/1T+if1nci9nnJUMJpHOCM4V8vmphXq9Zmb4TIa3bd/OHw8cuGKMqwYL8NitA7kb8s27+jL63NOl6G93j/UcnGnYCYeK3mxmIpud31irkctm+dfo6Kr9d14N2thbolA/VbP7rnc6ODIXzZyqZy76M6cX1ly7EUnsuHCBx4rFjv3/B5an/+2QIsMIAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowMjo1MCswMDowMGqPVM4AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABPdJREFUWMO9mNtrXFUUh7+1z5nMmdhkkjZpE1RsWi1FqQWL0gp98EUQ7JP+AYJPPigIlvqgiIr4IFqxSFtQ1AqW4oMXUAreK7Zia0vv2Exz6SVNc5u0SZpJZ875+XBOa0oz6UwydcFimNln//a3195nrb3HmKPpxq8GtABZIAB8oAQUgFFgeHoXm+OY/lxhp417P7AOWA+sBtqABcA40A8cBvYAfwInbp7nbTbF3iZ4QfCnQBX4PsHzgiX/C20CaYKVgk8EExWCXvOJpN/KROe2wprgPsGXgmKVoNe8KNgluFdz374VRbVZsGUeoNOBP0j0bgusJ3hKMDZP0Gs+luh5tyOqLYKfawR6zX9IdCuySlOXAx4EHpl1TmvW9LNhg0dzcxP5/Cjffhty8GAb5ffmOmAV8Cu1SmkCX/B22b1qFmrDhkHlcn2SxiWVJI2rs7NPTz45KIhm2btvaf75/gbYOsE3ZQddvnxEhw93SQp1o4U6dKhLy5aNlIGNEt26Spe3EjPiyjTzci5dmmHVqkUz6DlWr15IR0dmFt0lVJjCqgl/ULYllfIxm3lAszSp1GxvfIYKrdLIAlwq2zI0NE4+PzRj28jIEIODE7PojtYaNgI6gXDG1hMnArZvjwjDsRt+D8Mxtm0TJ0+Wi14InEr0a2NJQXhWMFk2Z2azU9q0Kadc7owGBiaVy53Rxo05NTZOzZJnJxPd2hWG5EywTHB61iTv+yU1Npa0cKHU2FiS75duURROCzpqekZIKlhG8KYgrFH1CgVvJLoVWcUzSgRXAJ8Ba2sQg33AM0+3tZ06mE7jIggjh+dFRM4woL5QYH1/P1uTDhWnLouBu4H3gc1A+zxW6sKIc9ufuvPOwT7nFiccLvGQ+IW7KrgymKkvrGhdTHsqqm6vJNGtB14DXgRS1YJGEP0RBHteam39ZsDzCr7kK4a0JCTCTECEKCHyDo6bU2dVNTmJ7hVgK/F963Gq3EpdqVTPlqamIwOe1+yByWyagGI5xa+cYv52QUcofqimKFwHBnqJt0J3NX0vOTe6s6Fh74EgyHsgg8jiJU/c4k+zCCwyU2SGCdUjNVUNmwAL+BH4kDjSt7QilH7JZA7sbGjodhUvhxmSyaxPznXOCTaxEPgU+JpbnEUFHE+nT25pajp01SyqANQAp/h/h8MOvndBcH6+58g88I5gJfBQOYgBz7u4PZvd25tKXbn5GRkYUjIvI0K6AuQw+wc4m89kxrPFYlUHmZumngTtSBE2hzA203MFmPpqwYK9P2UyF+2/fvHyCicZSCVgAugR/OT5/ueC3U/09JwExu8eHaUrl5t/mRPQ43nNrVH0ekZ6zk3L3SGEvwfB/ldaWn7r8/2CF7OaJMzsKjAhkTfUa+Y6QxiUUZocHg7vaG4Gz+N0V9f1seZ9nTBgv3OjOPdRS6m0pl561CWT6PX9Mx9ns3+f8/2CL3mCIpA3swHggpmd9VP+eUQxikpYMRS+R8s993Ds6NGbxqrJ3efhYlHdqdSRy869lw7DDgftl83GdjU0/LUnk7mYigEvIJ0T9GfS6YuTU1OFeLbGXevW8uOOHRUFpma2u6EheGBy8tXmMHx2X5D57eXFrV/knet20rBnNnq2rm6ivVAgXVfHic7OqvVrd6sEFpVKhR7ffzeItPNYOsh3BcGw39tbyLa1IYnHhob4bnh4zvr/AlFvZYTScGjCAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowMzowMSswMDowMGvaOiAAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABfxJREFUWMO1mF1sXEcVx39n5u5613btOIlrp0lEhBr6RSmKLUiQIkQFSH0rLSoI8VCE1DSqVKkIAeVDCPECQhChClKXB0qBRKpoQbQNRbSUNIoTKW1NmsZW6vgjNbHXjje79q7Xd33vncPDjYuc7qZ3t+ZIq5V27sz5zZn/mXPuCk2a7vwlZNNgBK5vE/JLm0E6UTIIHhCi+KBFSrk8nTcokYVqGzL85aZ8es3C0tkCI0Xhpq5byVf2AHuBO4BeoB0oAzngNNf1vorTk8z1D9MzqM26lKaiuusJMFEvTu4DvgJ88t2l6q2onAQOoe5pxMzKG/v+v7DafxAiI4jchOi3Qe8DaU04G5QK8DTITxF3DmdVhh5I7L8xGdhQcKkbgR8Dd6PiJd+ugNAKfBXVVlS+h3pj8S6SmUke1QEIUxsQHgbuBm0A9KoACfeAPIwEG7TvYOKJiWFRtSB3AvfH2d4caWziAV9D9E7Arius9g2AkS7gIZD2OpsBpxBEsBLF307j32vyajvwII4u7X8iEWwyzSoGx8eAT9QFBeW27hx7P2TpaNnAYrXIq+9EjFzqRVWQq09CQNiDyO3Av0ig3WSwggH9HEhLHVDHp3dc5ht7YFtHG/HRtnHXzkV+cSLP0clNUAuYFuCzKMeA8P0wkmrWgNxKLX05hW2dC+zvL7Gtowf4H+z2jh7295fY3lHE1QycBT4KmogjGawiKL3UyioFtl6X5caNm2qsZ9i5cSNbO7J1DllAe0ATZWtSGQBkam9EwTMeIrUdirRgxdZNNCSbiCFxZGNbqAMDBb/MYnW+5viiP0/RX0LqBq+4zrDqQEdBo/cMWYGxyxmeHXE4La0Zc1rimRFlrJDF1oBVIpS3UVwSioTlVh3IIHHTsjbJRMAPMzz57x5KK1N84eYibaluloJLPDu8wjMj2/HDNKYGrBAAJ2E9YQVHxCsYpoEPv2fcAKVqmj+c3sGfhsGKJXI34IcQOlsTNLZpVP6JTQabVLOKZQY4VDsKEkc4dJZy1bLgQ3nFEjp7Da06lD8COTRZM5O4wGv/AET6EUR+h7A76bxr2AlU7v/iwm/ffiOcxjiInMFahzOCAK2+z95cjtVWp7F+tm8gBdwDHAC2NEup6MxlV3n03uJv/jrtKqkQPOMwkTPGWhc5I05gJev7lVsWFv03u69nS8o1/FoTAM8Bu4BHgFQjiCA4VXc8mDj3zfJzXXOu/CUP4xkwGMSauMcw8cPOb8mEQ92ZgoGzM5GMNtznad8AwA5UH0f4PNcQZS3csWh+/LvlI8+fCt4pWonvM1nzhMSFRkDjwuYElh36j0aKAgDy+j6AC4geACYambvglouH/aHB14KpgsWoxCCOdz8Sf4s4ECeiTgRRtBXVDQ3DXgFWsoWXgF8BlSRzAo3CV4LR1w77QxMGqVudr/IkqIqKTKsxo03BAtA+F6HyJMpfrn31KKrK2Sg38ljl+NCKhi4BqABGwQdOGzhiMpmLzf9vcOkWWKFAmp8pejPKrtoQwpwrzQ5UTgxeiAqVGm2bgKz2OYrgUK0A5xE5B0wVstlyZxA01MisRXh9H6RQhDcDogMRq33BlSBf8e67oPrn6pnBl4PzswKrxx8fr2JUBVRDYAmYVHjZet7vFV68a3JyBChvLxYZP3/+A731xUx9A0xG813dpuNHWVL7jYi3mtWRanQsGDv1/fLfjk67Rd+KEUBUFRFZAZZUKQh6QcSMRnBJhXA5n4/aurrAWsbGx9do4wPbqTselc3Seftm03awldSnjAgKTIT5iR8u/f3IsWB83sNY4nu6ICJzwIyITFnPu4gSOBcSBZGqZ2ltb+etM2dqCGqdbOLjPyEt9t5uaXssJXbLgvNLv14+fuTx5cGzKfEKAjOo/kch15rJzC5Xq76IYFMptu3ezUtPPfW+PtYNFuDFXd/K3Kabf9Al2a+fCC4c/c7SC4cKrjJhkLwVKU6l00tbfJ+WdJrh0dGG12/+NqhhmzTrT0aFn2esd/itaLYwTiHvXcz5nVt3oKp8Zn6eF/L5ptf/L2sInRchOhqOAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowNjo0OCswMDowMJwhuk0AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABmRJREFUWMO1mF2MlFcZx3//887Ozs5O96OwZekupiq0ptJigFhaJaZNa9MbbTVBY5pYY0MlxiZ640XjhfHGxtheGFNFL7AIGmIbEy2Cix8sCSWxSCiyKyy7QGGXhd1hZnc+dnbfec/jxSwI7ADvjvhPJm/yvufj93ycc54zokHt+tYqMnMtOHN0lu7RdGt2KdBuWApTQqIKVgHy3d2F7PhYu7koork0y6d3DTQ0Z6JR2Ltn23m/Y1Crcw88OJ3OPgpsBNYA3UAGKALjwNHx8bv6kT+06r1LA/9+bJk1Oqca6fTnF9fiAtftzW8CvgI8IsAAzQ9p1yDNvzkE7DRnu5zXxSd/8c//L+y+l9bjfSRMDyB9V2ITRjrOKDV2Kwt2yXjVnE74yNvTvzwSe/5FpYESgRT6lQY/AJ4FS6B49tY8rzTG8yZLm9krvmrDV+2IIRe3Yd/m9VhY7QC9jHhWIrHYLJpPlYShL2C87JrUsfeldbH7x4Y1LDDjCeAFoYYX5nwgEoKvSXrCILijsHs3ryMw1wl8k9pKX2iMGeY9vhriwzl8NcS8x2xhlAWYlAG+EeA7+15cHws2pofMefzDwCdvBiqwtg9/fHzpwxuDRLqto1qezk8c7Y8KZwe7zUy6IbcFYHoU00PA34mRu7FgHXKIp4DmeqCAX7rmM5fv3/Qd0l29rdRC29r9yDPTJ3e9lp04un+JGQuAgWaDJ4UdAKq354gh1do9SL38Mk/6nt6plZ/fUkh39S4DrsKmu1Ys++jnthTSXSvymK83dCBYjeJxxGpkmMC6qbP8zYyWJT0trT0rl9QZz2V6V93dsrSnpV7uIoRYdvUkuY1i5qwAUvUtMRQkEvViDCCpWUEQYDdNyZZ4DHE9a2DGVH07xFwxVwzL05P1Poel6cm5Yr50i8Mjf0dhJbzEEBAt+OYCSmPDqdH+t715X7jOSO8L5/vfstLocItcve3UIjM7aVY/oW9UvDQQHuMgtaLlulklEc1VUmf2bFsWlgvnejc+lw9SrV1RpTRxvv/tufMH3loRhZWktNAvZgqBQ8CdgzXkRfQ3cGPARxZ63hGWC8kP+n593+j+30EQBETRvdFcBR9Vg3qg8xrD7K9GEAs27tZlEFww2HkzL0jCR9UgnCkGYXGKcKYY1EDr56oZHmyHwTi3WH03cMRT3+b1eKL7hX4ltCFuv1voXcle+OG7UyeHp6o4D5F3BIHHu9pelq5U2Dg+zhvzHWIXEdsPj/HVtT3TkqaATwF3NUppxoVC6F99pT9/ZLIctXlol9Fupg7nLGNSRtCcqFZJRz6q3tuj1UvbFlk9iRD4A7AW49smmuKGpnaLAG/mB7PhiW3Hip3Ts/5LgUg4cDgUOAMwV2vuK82p6pGuVM7B8QuRhhZ9renbvA7gPsN+BvqsFlnUjhejke0DxT8OXQ7zgZOuGHGdSWbzDwF4wYzH+mLXs1f01NbDeDiL9DpwOn6dD6U5n99/vnLwVC7MOdW8p9qCnf+p9pQ8yEvmJWRYGrOORcMCPL31sCU6W/YJfgqU4/SJvFWPTYbvHThXOS1qu8ftJWEmk8bMuaGGYAHC7kwkbBuy399q6zFqxc7ZQjT4znD5SNWbjwEqwBlUgKMOdrtUarTh60lyYAKfnMvZXPJHGB8zbG09CAH5WX9x70j54KVyVF7YwgS6Yq7VTksrA6eQTgDnci0txfYwjH8Hu1GPbz2MhU0m0/tV43UPBfivj6+UhGHkZw+NzR48NhFevCb8tfAazkxgVgVKwBmDvwSJxHaDPc+cOTMIFFfk84ycOtXYnxzXat/mdVyaiTrbku77TY4tTkqY1S6GZhYdnwz/sWOguP9yxVdcjVRWuzbMASUzcsLOSm4oggkT1ZlsNmrt7IQgYHhk5Loo/c/6+ZfXKJPQQ21J90ZzwGNX0mG8VD3928HS7uOT4WQgAiAEcpIuARcknQsSiVGM0PsqURiZJQLSmQz/OnasbkrdEe14/hM0SV+8q1k/STgtL4e+8KeRmd17Ts8cD5xygguYnTcYT6dSF2dmZyuSCJqa6N2wgX1vvnnbOe4YLMBrz61NLc/Y9zJN+vqJy+H+7cdLOwuhP+0gG0j5c8lkaXmlQnMyycDQ0KLHb3g3qKdMk1UuzUQ/TrrEbz4o+NzFClmNjlZaP9SDmfH45CTvZLMNj/8ffOgG6JpOcn4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjA3OjAwKzAwOjAwxEaR7gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABZ5JREFUWMO1mF1oXFUQx39z7r3Z3aQx2TYxCVo1aaviJyhqK/TBUgVBRVT6oD4oIiqFgiAoqIjogyIaoYgGFGrFVuuDWloRrWgrxmKrYmtbbZovY76z2e0m2W6ye8/4cLe1obvN3bUOHO7DOTPzP/+ZM2fOFSoUHQaygAVyCB4NKHUIUcAF8ihZIMUUCepQCGbkosp8upWCJQM0IoxxBS6rgNXAtUAzsAiYBkaA36hlD5a9xDlMsgC6ApGKWO0GhGaUdcD9wE3ogtb2AluAbSijsvx/Bqs9gEUQLgOeBtahVJdhJYOyDXgV5U9AZUV4/+WlgUFQlgMvodwNuGXGphp4sPB9ljzdED4tTFms+tQDG1DuRsoGGojgAvcgbMCjXrvL4Sq8EwdYAzxUcFi5BPoPI6wBnHMKtsBqHFhPcNKLLCoxSgNehPI4lnhYdsMyZBCuQbmxaOiDSqBErh8hdqeDE6/HJlPMbPeZ/aUZkBIpswrhapTvCJG74cAqBrgVIVIUKGKpuWOSxe3gLashCG0Nix5Ik3gywcyOJWgRwIG9tcD3QH5hxsKCVa6gVH55bcepf3kKb1kT8C9Yb3kT8Zem8NpSJSw7KFcVyFhQwh4wIbiZigfTuyRG1dVLitgzVF27GLc1VoIEAZoIWe/DpUFgKlp6geciUtyhSATxikdEACVGSAlfuuB4yRl/Yho/OVF8bnICOz5zFiJSYet12Jy1KF0oftH53OEo6Q6L+lPz9fwp0u8oc0dKsecDRwl6twUlbOmyQCdB0zI/pALYTJTUK03Y1ADnPZrCnNeITY+T7pgj3bEUm6kqwV6OoMEJBTZUALQLAVoRvkZoK8E+iOsj1SCug+Z9NAOad87ipQfDWpQ+aVu4zobNWUUYRthSkgUhAGbTDv4k2LSzAFALfIhlhJDNTOhWpHAlXgq8D6wMq3cW+RGHh+57rPnoL39EMBZ8a3AcizXB/VGdzbJ6ZIS3CwqhGxJZBnqMXoQ3gXagpVKUqgxPpkzHvesvGB8aMecXcJjC8AuszylkxmPV2Usbz6fFs2U23wG71cALwJOAF14ZELAW+8PP0T1PvdL4+VjCybpGXQ1ASiGXFBEFLEoeJWngkBjtKqvVk2Wg3WSAtwneW7cRNpUkwNsz4PVt3Fx/YGzCiTsOonJ6y1DYkWphvYDQotDqK1+XcymcAgz0o7Sj9JajezxtUlu313buPxhNOg4qgpUg5IUhwVfEglgRtSKIotWo1pcNtgBYGWMX8BbBO3dByeXJf7s3tn/rjtpeY0BCxUMEVVGRITWmqyKwAEzio2xC+Qw9S+nRIKqHjkaObNxc/+tcTmwIoAIYDf5M/GbgCxONDlb+PFkOKEmE1xQuR7muKAiBsQlntOOjus7+QS9z5hoVEFQLWxMsqhngGCJ/AgPJWGy6Lpcrq5GZj+FygteBcCCXo933mTrJ5Onf7Cyzn361qPObztioyKnwB+FVjKqAah6YAfoUvnFc9wOFL2/v6zsCTC9Npeg5dqyynxzzeOmGvkEn3rjYvhiL6BPG4J481L7F/35fdN9zrzfsHhpzs05wn4mqIiJzwIwqSUH7RUyXD+Mq5E8kEn5NPA6OQ3dPzylf/+2VSlAd9m03KdS827A4f311VG82JiC2f9D9671P6n7+e8TNuq46quSApIiMAcMiMuB67iBKzto8kvMV16Hh4ov5/eDBM3z9Z7AAN9yV097d3oH0lHkj4vmtxtCSnpapj3fW/rTnp9io55EUZBjVvxVGYpHI6InZ2WywW+HCVSvZtXnzwsScC7An5ctNtdErV5x4Pl7nP/Ljr7Hdz7zWuCV53PQa0YQjkhqoqpppyWaJVFVxuKurbPvnhNmTsiSez/YNua9HI7r1965osmcgmnCT/dm6S5pRVW6ZmGBnIlGx/X8AIXpAQWXTlG4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjA3OjE0KzAwOjAw/KO1YwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABh1JREFUWMO1mH+MXFUVxz/nvje/3s7+mLa72wqNSykIxEKCqKUJf0jQgGJCIGKC/AEaUSEh4R+NGv8wEMUY0xgjTI2J2Go1/EWA7hbBxELcboKh0tItZZfd7a50Z3dmdmZ3Z2dndt67xz9mt7bd2fbNUE/y8jL35d77eed83znnjtCqvfRrcKPgCBS7ha7sFtBOkDioC+KDVFAt0lXKU0wqvgu5Tvjm11ra0m0ZNhqDXFXYHLuJzuztwB3ALcBWIAmUQDPAu8y3vYnRId6+bZg9R7XVLaWlWf1pUN2K8CDIQ8DnEb1oufOZBGAI5SDoixgzw93f+T/DHkqDEUH1U6A/AHkQUS/UMgqIlkFeROQXqJ4Gq9zzeOjtm5SBFdTsBJ4G7kNwQ7+vAIqH8DCqHuiPwX7IhSG4pJnQnANpwHQBTyLch0jzehcBVRflfuBJ1HTV173SsKiDcCfwCB/nwxShHhEeBbkTxbmysAP7wJoU8ARCsvG7aP2ywf+utbHG1EmE72I0xeHnQmGE9ZBB9GbgcxuCCvqZjp7MV3s+6aTcaFehVi2+nJ0M3lnIbkVVkIbavh3YBfyDENoNCasG4YtArBGogL23p29u7w17uNbraAMcoO0bV12/8NT7g/lXZyY2bwAcQ7kLkbcA//IeC+tZuGkV4mJadnid889c99nFa72OXuAc7E6vo/fpnbct7vA6ihs4zgE+jYbjCAsr1CvT+lgq9HntiV3JTZsbrGduad+86RqvI7FBkAWlFw2X/5r5quONh5WIGFeksShFJBYR4zT2rIBoIixAE6mL+cbDQm6lUirUqrlGT+dqlVx2ZXmpYfFQQCmGLQvhYBWLMgIEDVzHcGkuvm/qlA1UF89/FKgupieH9VSpkGiYDYQAkQ8QsWEwwsrAgg6i8hBy0UcmQjnw48+OH+st+tWpb199Y7HDjXQv+LXsvqnhlX1Tw9vLgR9tnLq0BgwhhIINV9gPpQVHr0F5HWTH+j3rcXSNCTwngivi+KpBOajhW+tskGMBxkDuQvwJ7n7ismIIq1kFpoGDqK73ggiI4FvrLNSqztxKhYVa1bkkqKpF9c/1nldCqTZ8i3g4DVavR+SPwO7Q8za2o4g8sv3nL3zgTpzFWAiswXEs1ggCeJUKd2QyPN80LMBrv4sQBPcDexHZ1jKm6rQpLf/wqmd+/3J8finig2ssJrDGOI4NrBErsJKoVMo3zi9Ujnf3sC1im+yeVGuovoKRW4GngEgTc+tysWq99ydO9/zhlZQ7v/h1NcY1YDCIYxRATV12thKL+8e64wUDJ6cDGWn+WHPoOTCmDyUNfAlpLjqRTH6s50D/q4mRySKOc9FhaPVXvTFCVQCswLJFX2+mKNTtK4+DmjOI7kV0vJmpprRc7DzyzmBidKqAMboKYjl3Sf0uYkGsiFoRRFEP1a7mYQG+/JgSLbwB/BYoh5oTBH7bidF/db717/G17HF5E0FVVOSsGjPSGixA8myAygsoL3GpXnS1AY9PZk5t6v/nMfF9GwJUAKNQAd410G/i8Y9aP55kb4aIKWD9X6J6A3Br45IqOMXFma7XhgYjs4XyeoWrgKzVFUWwqJaBUUROA1OFRKLUWas11chcaPc+BjZQ0OP4di92tS9YO8as3mWlVm0fOjHYdnx0BmEt/PXwKkZVQNUHloAJhb87rntA4fA9ExOngNL2YpGx0dEW/+Q43wbSOLm5lG1P/lQjke9hxD2XplQD7+TY2z1/GjjiFhYqGCOAqCoisgIsqVIQ9IyIGQkgq4K/nM8HbakUOA4fjo1doI2PbZH0jwQvuctvb3teY9E9a3KIZPLj3X/9W793ciynjnGAGlAQkVlgWkSmHNf9CKVmrU9QC1RdBy+Z5L0TJ9Yr6krAAkT2/wzruA8EnW2/wXG2mXJlMTUw2J86fPQkrlMAplH9j0LGi8dnlqvViojgRCJcvXs3b+zff9k9rhgsQPuz348vb9/yk8CLf8s7feZI74H+g6ZUHkck74gUp6LRpW2VCrFolOGRkabXbz0bNDC/PVFxZwu/0k9s+UtscrYQny3ka9lMRfv6UFW+kMtxKJ9vef3/AgyZp3iOwsFtAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowNzozMyswMDowMHshjJAAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABjBJREFUWMO1mFFsXFcRhr//3F1713biOCVxotiolJiUlpLKtiBFiiqqgpS3tkhFQjwU8QBRpUr0BSHEA+IFVNoIIVQeQ4CAKiVCoUSIFokEKUSENGpCYxJnnUQmteN4u+v12r7ru+cMD+tESbOO727DSFfn4dwz852ZOXPmXtGmDE0NkY/zuODYnGxWMVv8GEavyXJCGaBuZjFQnp+fL/b29prHU8vUOP/x823ZzLQL27vYy9imMe2Y2fFIMVN8AtgN7AS2AD1AFZgG3l23bt3xEMLJmb6Z8/2lfmvXptpZNFwYxsltCRaeB74GfB5raNMqKg07CRw07A2Zrr+z/Z3/L+zoxCg+eEnaIfRd4HmMrrRaDFvEeAP4iUwXAsHODJ1Jbb+lNIhcpGBhO/AjjGcMy0jp9yvUBXzdsC7Dvm91KwCp08K14tW6r28QegnjGURLoLcRZ4SeQ7ykrDaMFEZSL00Na7IIeAp4QVLbB/MmMPANSU8B0X2FHZkYwXnXB7xI46TfvRkzggUSS1i2ZRJLCBawVaIsqQfj2yGEvtHCaCrYVB4yzAWFz2J8rtlhMjMQ9mjno9O787uj9dH6DZVQKR9fOO7HamNbDFOzlBF6QtJjGH8jRe6mgpXJAV9CdDYFhfBk95MfvLzxZQayA900Qtu9p2dP5bXia8VjC8cewLgbuKHvacP+DtTX4kiXs4bDeIQm+RUIDGQH5vZu2Ds/kB3oB27BDmYH+/f27Z0fzA6WA6GZ5gjjM1g6jlQvGSbDttCkLhvGtuy2/PaO7Q800eeGOoY2bstsyzfNXUNAPynrfbo0aIQvt8pGyJDJaJU6JqkzUhQ1hRVg5NMwpPbsisw1hUGUfKla8ZXZZvMVX5kth/LCatcwopz2BkybswFjHMN/eCoiopAUcocrh0OwMH/7XLAwf6hyyArLhXzUpJwa5g27aFgghaQt7gE4QaNpucOqJOIQ5/aX9/fPh/nJZ9c/W+523ZsWwsKNw5XDy4cqhwbjEHc43e0XoQQ4uaJ/TUkVgNHxUXn8J5zcW4iHmjrfjIwyPqcckaLIm/exxdStHt3jWp4wZ09HFl059dCpNets2py1SNEU4uBqXpBE3epRNVSjOT9HNVSjNUCDYb8lMG1YqmYmdScyWhjF4z8l9CuhXWnX3UP+YZG9sPituYu1/9RxAXxwRFEguMZx7Ipjdk9P83qrsAAjl0ayiOeAfcDWtjGNqVAO35t7sXwkmg7ZOmRcwPngXBQFH5yCYDkfx4ufnqvEZzdtZms2tPhZIxLgj8Aw8B0g2wIgCCxYqJ9OLiz9uNqnYviqOTIOHA5FzgDMNd4OcWeufmZTruTgvSmv8ZYb0pX+80HDfin05Vaj46/6icWfVt/0Z5OyIsl0u4KbO7KVQQBBsBSwt1q5FAA4/cnTAFdl2odxuZW1Vgnl5SPxCX8uKRFhiKDGgV151BilAAqSBQkZ1oXZhpZhV4AtP5N/G/gFsJgKtG715GTyr+U348u4W1f4GiJhJpPeN+fG24IF6Pmgx5vZfjP7g9k9So81arC/6MfiA4tnLLGQAlSAM4iBdx0cdbnctbY/T25sv8GyLZc61PEK8LCZDTeFENhsuF77/eKJcM0vNunbBLpZaQ0RMFsELiFdACZL+Xy1N0laamTukNMPnyarrEk6S8I+PPM3PdkYV6zXQm35L7UTyYnkOroV/kZ4DWcmMKsDC8AVg79GmcyvDf6858qVMaA6WC4zcelSez85bpeRwgj+mu9zG90P6WSvnDK3lSlfP5WcWnq1eizMhFiRBMjMkLQMLJhREnZVcuMebpioLxWLvruvD6KIwsTEHbnxkWXnkZ1Srx5zG93r5PiCnBqFcrJ+eelnC0fr/0xmyRABCVCSNANMSZqMMplrGEkIdXzizTIRXT09/PvcuWYZdX/k8WOPo6y+oo36ubLaatUwH/9m6Wjt4NJ7yqoETGH2X4Pprlzu+lKtFksiymYZ2LWLtw8cWNPGfYMFGN4/nLMh+4F69c36meRY/MrCQT8XLksUI6k82dGxsDWO6ezo4Pz4eMv6P9rPig+J9Vns3/evRp2Z3/nxULJJila6FuvBbZgZX5yd5U/FYtv6/weDRwGc3Jre9AAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyODo1OSswMDowMDPIuVsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjM6MDc6NDkrMDA6MDDVlNrHAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABmJJREFUWMO1l1tsXFcVhr9/7zPjGY/jSy6NXVHVScsttCBVqElBFU0FFYiXqkitVPEQBA8ERBFPqCIUIZAQApSHFgchSEorAuoTUJJSNalTUNNQLs0FO0qcOE6d+D6ecXwbe+bsxcPYpYknyvE0LOloP5yz1/r22v9Ze21Rpz3zxlrcYgULMes2NCk/Prte0AJkDEWCCkbJsOKVcnu+OT1sFfNMqYGnto/XFTOqF1bzC6Q2NKuSn9kyOT53H3A/8DGgHWgCZoAR4ERzeuSvoGP/mr21d2tu0OqOWc+krldzBNEuuUdlPA62FRP2bqfLng2QYXAMtN9CeMF7Rnc+MPv/hX2mO4cHmfFBQ99GPApqvKETq0YybE7wgmQ/DsYZ55zt/NR04virk0GIZfJ3gn4APCxTlGjJqgILNSL7opkaZXzHOzu/tJRE5pJ+2HV4Dbio1aQnEA9LilAC0HcDCwxFZjwCPFGJ1dp1eE3iXCWGNTMv9CCwg+WM1mFVZkWgL2E8iJm/qbBdR3I479pkfF2mplrZNDPMYuKwSBwWiMMiZjFmNXZZgKzJsK+ad217DucSwSbNkDPCRxH31tp3MwNht6z5+Ejnus/6dNTaulgpFgcmXorHZo63m5mklfME92HhbuAICbSbDNbkDD4jaLgOaOhc//nJT97xI1qym3KAB3Lv3/jYldfPPZkfmDi4biWwABqQfdqkvwGVG2YsKaxMW0Ar9GUEWjKbp7Z27ppuyW7aCLwD25LdvPHeTbumW7KbikZY6Ra8obsMJeJIBiuEaKeGBswCzdnbs2tzH1lXw59bl7tr7ZpsZ9Ys1PYMG1GymrKavzpznbQjRVFNUQKSGpwiX0uSSxOySSttosxa9ZmqDeMolfMzC+XiRK33pXJholTOz6rWTlcdF28qrCAI+oB45TvP5OzpTO/w3mAWrjo7zcJ0z9Bem5ztzYqV5dREbOKsiUACSyQDCwTEUeBxXRNVEpV4LvPvt3dvXKhMDW7p2FFM+TUbyvH0eM/QvsXeob23VeL5dK3MCsrAMW4mbEDBQTeEIUybr/0dJMdCuZg+Pvh0Z8/lXyN5bxbfWg5zhFD215OAiSEz92okSwSbVAaG4mGJ/chCLY1JEELZL1SmfKk8yUJlyldBax13gCwIfisXRixhM5O4RezqzoHcBzB+g7Gtvk74KntDnh37v9d89lJ/hAsQB4f3geCqtayxVOL+kRH2rBYWoOtQcwofHgF2Y+qoF9jMhuem3ZP7nmr9U7moVAUiF3BxcM77EAenIFjMlkpzH566Ujq54RY6UmGV/awoI3uR4O4x8S1BKjkgSIYFhYu96TMv/bKpbb7oHvPOIgcOh7wzAHNVWYRSQ6by1oZMwUHPcKy+Veem60gOC64T+IXgoaSnz7IsJ4ei/pf35f586Uyq6L3JrnKwfKWwpUFQLZvzAXslcT+7bF97YJYguwi227ALq5k7P+OKJ7ozRy+fTRWcw0BBEHjnUXWUAihIFiRkWCNmrauGBfjG9hmb0vwhoZ9jzCXJaohV6T+R+ufJ7oYLUrV63NgkzGTSkDnXVxcswIVMHDvTs8AfanfYS5hW3c7RAX/62B8b36pUFBKACnAGJeCEg4Muk7lc9/Vk63Qb026+kFbqJ6APYdxTC0IyZgp+9M0DjUeLo36uRt8mEEvLNUTAbA44h3QGGCxkszMt5XLyO9i19pWHCjQoZZI7GSrstsA02HLQpdGoLGqh5/WGo+ePp0b53/ZXt9dwZgKzCjALDBgc9lH0vMFfPjcwcBqYua1YpP/cufde2ru6mymOubbG5vj7qTQ75SwyU7VMmeKBk6l/vPJs7rUrk77k3NLtywxJi8CsGQVhFyXXF8O4icp8Ph/n2trAe87391+ljfdsu361Vpmm+O5cc9iTzvAJaalMDfsLh5/PHRw4lZ5w3jzVxqUgaQwYljToo+gyRjmECnE5Nos8jU1N/OfUqZWSuhmwAD/8fQtRxBdyLeFpH1lHadZN//3FzME3DzT2uIiCYBizSwYjjZnM6PzCQkkSPpXifdu2cei5524Y46bBAnzzp+sz7beXv5ttCl8e7E2/9vLepv3zM+6CZHkvFQfT6dmOUomGdJrevr5V+6+7GtSyXHMoFcf8z1Jp+93Y26lCYawhz/jFUrazAzNj+8QEB/L5uv3/F2k1+QZ70J2JAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowODowMiswMDowMKLS20oAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABdtJREFUWMO1mFuMFFUax3/fqarp7ppLdzMDDCwmzAxegrIka7KLF2JkITFGE5NNfFAeNPuwGh8ML2rcbDYbXMNkszFmH7w8qYmYGB92jcuDwkYwQYzILEFmggODgDANc+menkvX0FXn24dqFJZuprrVf1KpTup85/zP/7uc77TQKv4KmNrvKoJHD0IWSAMuEKIEQIlZpsihGKAT+ENrS7otk3WBACHFejzuAjYDG4FeoAOYAwrAUTo5gOUQ9zLMAbTVJaUlq12A0IvyKMpjCL9JYHUI2I3wPsJFnvu5yQ7WbJRbgeeBRwE/ka0CwgLwPoZBLCewKC8mX77ZMBBgHbAT5RHATbxdARQfYTsWH+WPWE7VtpEITpOq5lFeALYjTRC9lrABbgUcDIf4LQH7kpmbZMO+39gW4Al+TGIKILjAk8AWJLlgyci+DCh5lGeIM/16KGCBCAhrb8uNnNwBPIUlz8vJyCZVyKD8Evh1XdfHyaN3rrqz8PC6h518Kp8rLhZLH45+GB0pHOlFkevs4pC4C2ED8CkJYjcZWcEA24BUPaKC2Idufmj6lS2vMJAbaCcOmfbH1z9e3rFvx9RHJz/qrksYUghbgc9q/lhCsaRkhfV140uhP98/89Lml2YHcgMrge/JrsuvW7lz887Z/lx/qa5ugoNwR02MJZE0wYT4ZLpeG4W12bWZDT0buuvMZzau2LisL9eXaeBkAVaSsN43k9XpRh88x3NFpO6CIpLyjNc445VMUgLNlK6ZRtpMLkzOFYPiZL3P08H05ERlYr6hdkIpab1OStYCo8QF6TqywxPD6Tf++4aNNJq9+lOk0ezrQ6/ryMRIpgGhCPimNv+SSFaQtyIo3cADtYJ+DdmqrbqHC4cz5cXyeF+ubz6yUaowXxgf/GKw/OpXr66euzyXakD2MvAmMMTepUtXMgfsQrD0IXyC0F93jILruJHv+bjiOqGG0UJ1gTAKnRusMlaT4lueX5ps0jBQhHFgN41cJhBGoVMOys50ZZpyUHaWIGpR3iXueRM1M8lbkV2AcgvC28CmxHaN8TnCEzd90PuNeymFsRBZg+NYrInPDz8I2Fwo8FrNIHnXtRfYRpm4KtxDfEFpDcq4qZjBNe+uGUrPeF0WsqJkVSVnjHaoSIdAyg1D/MhG4epfyB09XdJck7cLiJvtPwM7AK8Jglf6Aet/lz6wYt/yf7kLToCoq3E4Sm2AIhK3RUqIUjRwXIyOJlf2irpbqQInUW4HBuqe+PVQG+WVvNM9B5d9liq2CYYuFWkXET9+NH6rtovQAdKF0IPQH8Fcc2R/IDwDTAD3IOSTmprAlPJHs/s6T7VfqPW1KrHmtUfit4iCqIiqiIiiHqoXmyd7hfB9fIuLIb7VLh0OlrBjzD/YfTh/TFQ0mT9EUBUVuaAiXzRz3F6LEhHCWyj/RG9QemqapSdSI8u+yg1JJDYBUQGMQgAcNbDHpNPnW7+erAZmKOLzN4TbUH5Vl4SAM+dczA1lD3oz3kKd3QgIqrWtCRbVBeAkIieAc8VMZi5brTZRuv4fHwMPAB6XiJgHtiGkrsr6OL9DFrtGuv6THe4cE5UriRa7FzEgCBqCVIDzKhx2XfdTa+3xB8+cKZzM5S4vn59n5OzZFv/kuBqD4JScvPXtX9TVpxHcqwhH/tn0lyv29+x359wAE6eVqiIil4F5VYqCnhExoxFMqBBWpqai9nweHIdTY2PXxMaPhvesJ2TYEPrha+rp3T+UKff08gPde/xzmUk16gBVoCgil4BxETnnuO55lKq1IVE1UnUd/I4Ovj52rF5E/TTwXvCwrv1dlIn+gcMqsyiz+SO5Pfkj2eM4FIFxVL9TKPjp9MXK4mIgIjiex5pNm9j7zjtLrvGTkQXofLozXVlW+VOUin7vn8/sX7l/+W5TMacRnXJESufa2uZXBQGptjaGR0ebnr/1alAHYToM3JL7d+3W91KT6WK6nJ6qXjgT6NpeVJX7Jyf599RUy/P/D0pQLH84wUhqAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowODoxNiswMDowMJo3/8cAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABapJREFUWMO1mF1sFFUUgL9zZ6bd3ULbBUpBJVTwB1E0UaJg4oNGTUw0MZoYoz5ojKAxMeFFQ4wxBh8wxhB/sWriPyY+GH+RBDT+FhQVFaSBQrtQhRba7ral22l35h4fZosou3R2qSe5mWTm3nu+e+6555w7QrWizwI1gAB1AiOzQBqABOACAeCD5qCnH85QcIA6kNurUulWDUstkBNIL4b8cuAq4BJgDjANOAb0AL/BnG9At8HS3dCm1WqU6qz6ChDOAbkNuAO4IsZU24ANYN8H04us/J9hdT1gBOR80EdAbwNJxRwMkAfeB3kK7B5wFFkRW32FbhAIeOcAa4CbQSoYLwAp4C7QFMij4O6fWEUcMfGt2gp4jcBDEahW6+8ucAvIQ1BojHZrqmFRB+Qa4O5IYXXuHom4wD2g1xCFiCmE1VZA0sCDINPKdCq28IQ28a5k/2nA/UA6OrCTS9ytNMDFwOXlQdHLaOq5iflOmtrGLGO5jzkY/sLROaBy8k4IwHKQJcBXxPDdCmD1OpDaUqAC9kZaBtaxnIXU11GM/ndy7tAqtvZ/SmZmaWBqgWuBb4mSyKQWiwkriynpX8oCGgafZOnwQuqbgeOw51DfvIalwwuoz5UxnANcBBqLIy6sEGWmkqeqhenJJcyYWWI+cwkzZpxNfbL8vNocWX1yqST8JEq/VjyMK0hJhYLUeohT3iWl3EJOkgpCF4PljNOHfyzLWF+prwP4fUfxR04R6nJTDKsWtAM0LAW7m4FEK+02RIdP/BKiwy/Tru1kk2VgQ2AvYONQxHQDtSBtREXLfw6ZkCdIrOXX5hzj3fexKFeP1zRE4Wgru8dbaZ+XJ6gpA1sgKnBiwcZLQ7peQM4GNoMsKNGhuHITpvBwESfAhnkCAqxzCjWdINcCGWTFpHE2rs8qcBjYUNoKAggB1hlizBnAZ4hxZxJQC7xLVPPGKmbiJ3htBfQ8kDeBZbHHlZetIHfPu/n1ve6vhzAWQmtwHIs1ggAp3+eqnh4mSp0K69lWD7gFWAfMrRpT9bAZyK8+89ZXP05k8l4ArrGY0BrjODa0RqzAeNL38xcMDvm/N81mrmcrhoWoJn0cWAV4FQyObGPVpr7r+mb2qk8+co8M+zjG1cgdi+lYFREFLEqAkjXwhxjtqLzOi4BbQF8GrqdMMijH6+3v65z9yMZPkz8czOE68u+Kobgg1eJDAKzAqEU3V5IUIonuTgdA1wFdlQw1udFcwzs72pLbu7O4RhGsRAet2CR6ilgQK6JWBFE0hWpj5bARsEJ2C/Ai0b1qcimEQd2XHT81bNjRFV3j4myICKqiIofUmI7qYAE4EoK8AXzIKUOPgiqJXT3tM577foeMBzYGqABGwQd+M7DRJBJ/ncZ/gwsAssDTqC4CLi0NITi9w72N67e2eZls/uQjHXmtanFlgkU1D+xDZA/QnU0mjzUUChUVMv9hWFk0G79TCNcRTtQFE0aOnuIXxqZ/sLOt7ot9vVHukGgFqqKKURVQDYARIKPwheO6bytsuiGTaQeOzcvl6Ny377RufUWmVpxMX9o21T+hSe8BjLjHT3WgYerb/dtnr/78a/fQkI9jBBBVRUTGgRFVsoIeEDEdIRxVIRjt7w/r0mlwHPZ3dh5XdRpu8I+FzfbVOYPzWjCr7jJNeVdiJApTBwYONr7648/un4O+usZBtQBkReQIcFhEul3P/QulYG2AFELFdZg1fz67du4s4VBTJF7XWmyNc2vYVPc8njPXDPrD6Re+35h+qe0PatwscBjVPxV6UolE7+jYmC8iOJ7HWcuWseWttya3y1TBAkzf9HBi9MJZj4WNyXtTWw983fzwZxvMQL4LI/2OSK67pmZkru9TW1PD7o6Oiuc/fTc4QYKZSd/NZJ/RRe57tbt6s4nObH9hqMfXlhZUlav7+visv7/q+f8Gb188Ax2DNawAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjA4OjMyKzAwOjAwLF3cqQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABQ5JREFUWMO9mNtvFFUcxz+/M9N2d1HaQgEbNVy8hEiURIIBEx98MTGRhIR/wMQnHzThQXwyPhkfjBcwBg0mKiJiTIiYoCQKEWOoEZWLXCIt2+VWWnrZddvSLTszXx9ma8tll9m2+EtOJrtnzvd85nd+8zu/M8Z0TZr6y4A2oBlIAT4QACWgAAwCkwPMpjWlP23YSchHgLXAU8BK4B7gLmAE6AWOAT8DvwKnroP+X0wC6R6kl5F+RVKC1oH0EtKiG1bljkIa0nKkT5BGE4JOtNHKuOUVnTsKa0gPIX2NVK4TdKKVkb5CehBpesGb0KutSO/PAHQq8JaK3h2B9ZA2IA3PEHSiDVf0vDvh1TakA7MEOtF+qOgmwkiauhzwGPBErUdaBb3rwGuFljwUvoXwzziVVYvNtcCjwE/MWkqTfKQ3q8WqSeE6qb9L6pE0IimQNNIp9Twn9SNFNWL3DaSZ5vvrYBuR9lSb9AFp6JiUlRTqeguPSNll0lAV2Kii25h0eZOYUWM5l0D6UZh/Cz23EuYthXQN3UVUD5PrrB73p6p1NIBvVSY0aGqAWm98moSW1LMA/1TrGICRPAzcqm8IBvphtIZuYbZhI6ATCG/VeQpSH0EUwvDU/0MY/hB0urr3QuBMRX+WLN4QXkAaq5Yzm6XxV6WuLun8FWmsSzr/itQ1VxqvkWfHKrqzuDHENcEypLO1krwvBXOlYJ6kuVLgS8FtNoWzSEuT1ghJw0DAZWBnrSULwCuCNwQUwQtqv1gR8AVxzZtoQ0he9cRb4sPAZ8Ca6S7SFOsAnr9//foz/tGjuAjCyOF5EZEzDMiUSjzV28vWyoDkqcsMpG7gPeBdoH3amNJlNzT00b0bNvSncrmFQczhKi2seP2a4Gp/OlN6eMFC2huiOjw76d0M8DqwEWioGzSKoswvv/y8cOPGPf6VKyU8z1cMWUnVEmYCIkSAyDs4aU6d9e3JsXevAluJz1vPUGcoNWSzudbNm4/7fX2t+L7JbIqAYjkpvsT87YKlofihnk1hEhjOEYdCdz1DXaFQaN6x41D68OE8vi/MIouXvNIsvppFYJGZIjNMKIPUUj9sDCzgR+AD4GqiMeVyMOfAgd+bd+7sxrmEx3EzJJNZj5zrnB5sbCHwKfANt0s9EqkTJ07P27LliF27FiUANcAp/u5wzMF3LpW6NNM6Mg+8hbQceLwahNfX19eydeuhhlzu6s33yOC/g64wosp70YXZ38CFfDo90lwu11XI3PDsRsWjxymX3yUMh295W6k0fvfu3Yfm7N/fh9nEuHh5hZMMpIC42MkJ9nu+/7lg37O53Glg5P5CgWxX1wy/yMTZIfJ6evZGCxZ8KudexLlJzSAI0x0dR1q2bz9j5bLwPANMEmZ2zWBUIg+cc2adIfTLCIr9/eGc1la+X7aMs9nsf3IzP06Y4Q4fLjj4OGhrW6VM5kmci9PUuXPnW7Zt+8O/eLEk3/eQykDezK4Al83sgt/gX0KUoyjAyqHwPdoWL+bEX3/dNNWsnH3Kq1erobv7uCsW3wmbmpbiXLsrFofn7tr1W+bgwT4aG/MGl5EuCnrTTU19Y+PjpYmHvW/tGn7cvv32fpkN2Am7e9++1NiKFa+FLa0vZDoOHVy0adNONzTUjXODnlnhQmPjaHupRFNjI6c6O+vWn8VTJQTz55f8XO5tLU992XTiZD6VzQ6Wi8WSlixBEk8PDLB3cHDa+v8CFsk24crxS5QAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjA4OjQ3KzAwOjAwdKD6FwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIosGP4JQAABm5JREFUWMO1mFtsXFcVhr9/nzMXj8ceu4mVG1VSFwiq4iIqKClVHygFqQgkRKNAqjyk4gFC+gBPRYI8IISgIKgQjdKXiFKUi6IGVQKiirb0kjakCiJtrk0dO26cxHbsiWdsjz23sxcPdkJIxs3xpGxpdGZ0zt77m3/9a+01I5ocXd99lrJLUnfQPXGnBtr6FxuWk5QGC5HqZpRlVlgzkckfzU1b6Opks5cZ+sUPmtozbBZ2OkjRVaxotD1910Bb/33AA8CngaVAFmMKGAbePd4+84ZDhz6x+sDJ0ye+ZM3uqWYmtXx/D4H5pSbWgx41+DwyhOAqyuwbk+Y2skPALnm3N8JGZrZv+P/CZjfvJgIhrRb2hLD1JjKKsYwBMqYN9prxJI7THqyyLT70gmygyEmB/zjYzxDfAMI4oFdVERnMNkrKGPy4Cn1cE4ubjSDug61bdoKzTqQfgW2UCJtxkSSHbLVQEJodSt27rlw7vC/WXBd3E5MFJnsQbJOkpkD/q7JC4DEHD3ostmCxYLOP78HVw05MWxDZhl/GjMgb1bqnUo+o1j2RN8waR1mQRfpeaOrMPr4zFmxczzocdyPdOx+okH125W3DD/csDzoyyY7CdLWw/9iF6J1zl5eamaRGkbD7TPQArxHDu7FgzZsDvoyRuj76c8r5r9694vIvv/kZuruyrczmQuu3P7dy4onnj+T3H7+waB7glMFDwAGgfnPF4sAKZ+IudGNCeoPurrbi1q/1THZ3ZZcAV2G7u9qWbP16z+Qdi7MF31i3wGCNmWJxxHpIIM2eTDdI481Yuai1Zc3y3KIG67meFR23rVqcbfENvSvJtESmWNm6kDqbbqi6QSJw4TymRFIqESiw+R3ZEhcgZukywIqNcsAJ8lOVqcJ0dazRzPFSZWxsslJy82knCnGrYDxYw2P0AtH1twInTl4spHe8ecZ7b5PX3vPeJne81Wcnh4otQWPaCHgf8HEwYtrAebCDGI9en2SSmK5F6d/+/dSS4kxt8LH77yy0pRNdE+Xq6B/e7KvueKvv9plalHQNXGJQAzskUyzYWAFo3bxHTnaHh5cQ3Q3FNyMRuCiTDAmcgshbNF2tU4t8MI+dMazfyx4KzA2Utm24aZ2Ne9yaR0PALmyekEnUIh8UZ6rB5VKF4kw1+DBQzLyMnc4YJmYzE/uAb92yB8x/EumPGGtvoTWYU5V/Stq0+MDT77vCIM5D5B1B4PFutpfLlMs8MDzM9rk5sZuI2uHnSaxdNyGjCNyPaGue1IZctfTkon/86kiqNNbuIScjZ6YO5yxrUlaQCut1MpGP6stXaM3idi2snzVqGH8B7gH7ISixEC1nOwjzqbHe0x3v7O105YlvmVzoZnsPBc4AzM3awpdT6fqRrvS4gxNDkXoXHMzWLbuR2SqDZ0z6imJa6YopE5OX+nPH9v01mT9bwAUyrl1g7pPZ3EUAXjDjsZdi97NXRmnbBgLvPzDpKeBsnNS48oirThcy594+mLw8MI6czYF4rr40e5U8yEvmJWRYBrOOBcMCFJ/ZaJVc58uCbcim4ySzfFRPX3rvX5lzb5+92m3cfJYwk0kXzbnepmABokwucuJZgxfsQ2kNmZEoXjiV7X3liKK6jwEqwBmUgXcd7Hfp9IWm/zdYNDpIXonxjNV+LbNPgd1Dw1NKhJXiSLbvtYNhaWz6RoubQMw1OobwmE0DZ5BOA4PjLS1TuVot/m+w60f+d+tpsbrJ7Cg+egpscjaX50Q2wwBXr1XS5/99MDXy3sg14Z8Nr+HMBGZ1oAQMGLwShOGfDF58eGDgFDB1e6FA/5kzt1raZ6uDK412+lT7TwmSm00KZYZJyCxKjZ4+nDv659eDcrGMnACZGZKqQMmMcWEfSK43glET9Zl8Pmrt7IQgoK+//3+8ccujfcPPRSrXE6Wy2wmSX7jSS4dTo2dzx1/YnxrtHTO5AKgB45IuAUOSBoMwvIBR875OVIvMwoBMNsvxY8du2OcjgQVo3/Q05oJHfCr7e3PhMledmcyeeXV/tu/VE7hwHBjC7LzBcCadHpmpVMqSCBIJPrZ2LS8/99xN9/jIYAG61v0kXWlftjVKtH4nNdb3eufRfbtUK50F5QOpMJhMlpaVy6SSSU729i54/aarQaMRJbNlVxr7jW9L7E5MXBxPlvP52vmRMitXYWZ8cWyMv+XzTa//H6b399ILDmv5AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowOToxMyswMDowMCfNu14AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABhBJREFUWMO1l0tsXGcVx3//e+94xmPHzsSxPXm4NK/adRKKQISUKjz6QIBKFIQUpMCiwIoFSF3RDQsELCIWCLEosKiggiyyQKWQSFV5pJRHUKpaVbDj2HnUedmOPR57xmOPPfd+h8Wk1JbH9Z1p+kmf7uK795zfd87/nu98otHxkScgbAYLYM4XbdFWsHZQCiNAhIgy2CwtTTmKy0YgaHfwj5cbchk0DLvcCh23xcyOftqiRzGOIB4BskArMI8xAbzFfOXv4J1nb2KIkWVr1KUa+qr/GMhlMR0HToA+gRlohbm1SOcRp/B0GucmGfrDBwy7/yg4T4he4HtgxzGl41kyQAvAabCTOF0GZwzHl4RfF2zXPoH2gn4MHMeURHG3LDASyA5gZIEBQsszM/IBwO4/CngZ4DlMXwcLVqU9Ji/IA/UifHzO0/VwmanhWJ97dbjyMR4HnkHUD7oaOgC+gfQ4ZrEDFu/F/i8DdAA/AXpr5t2sOsMIogicvftarY1JTaAtyDtDV99CnOjGLV0epg8jDtVcNQOwjx3cN/Glz3zcz7S1bM4XSrMvn7sQvTl4JYuZ1snEo2AHwc5Rq340Bmse4imM5JqgmiFwT3/20MxPn/sme3qyLVQz1vK1pz9VePbkC7k//e1CxzrASeBJ0OtAuHHE4sJi/aiGbJyx+4Hs3I++e6K4pyfbDfwfdu8D27p/+J0Txd092VlcjcAZPsYBXDyOmLASKEstsTrHgzu6mw8+9KGOGva8R3of3LJrZ3czztU0DNYNFutvree4Ta23kAj8QKotSknJRODX/pGrpaw5LkA9pWuutkMxnS/O5wvz07WWZ+aK01P5Quk9St3s/YU1c5iNAtGaNd9j6MpY6penX3GRc8WVS5FzxV+cfsUujd5oxq/pKsIYwXDEGPHqbGefgA7E50GrpSNRqYTBG0NXmwvFhfFdO7OlyLnkxHR+/OQLvy/87Ldnts+XFpN4tWBtGfgVaIDp4Q1LV7xjqO+o8LxdwKvA7nWiTxAEUbo5SeB7fhi5aGGxTBhG/voSsGvIniTy3mb4pQ1h42rWEONgp9ZPmQjD0C8US/7MbJFCseS/J2jVzu8wTRDjQIgfWYD9x8DcQ6DfYDrcYCe8kvbfwDM9iyMjgVvAcxA5D99397pQSJfLHJmY4Pl7X8TvuqaGoau3AJoDPYbY1DinjXsWntxZHhpIuaU2B+0y2s202fOs1aRWQTIIQ9KRi8LtO3Rga5vqvdZUMP0R+CjwLJBogNSlXfFy19JYJrDwqwaBBx4e8r1qj+FVZeHKyVQ40JnKezA4Hmm0vuZ76jJ09VUQV4D9wB4M1SOJhCtf31q583rSLQmpzaQWSenqtOrTrEWiFdSG2IrYHcF8fbBQlUN3/xzmpoDHQJm4sJ6Fs5lw6i+bwtk7AEimahTvTVWfkoFMMpMkwxKYTdYPC3D3EuzreZtyk4d0hDhyMAtbo7l/dVQmLgqzeM27hJlMumPSf+o5blePlrkI6dfAS2xUesxIuYVLWyoTAzLnYoAK8AzKwFsenPVSqduNRRag9RBAGeMqZocQ29arhL5VJjsq4682u1L+nYCt2IlAqrbFgHCYlYBBpH8K3syn09PJMIx//1kzJoehsw+Mu2Al0FNIyRUQgJC5pbYo99f2KHdN74JW01u9PCIsBC0Ct028EQTBOefc4BfHxiaubN683FkqcenGjfdf2uk/hh8uZZwf/MDkfbvaO1RBMYvSUfFC1/KN1wKrlKm2kTIzJC0DJTPywsYkbzSCKRPhYi4XtWQy4PtcvXZtlTbe90js/ZxI+AdDgucN75PvpDnhytc7l26dTbvCtCEfqAB5SXeBcUk3/SC4jVFxLiSqRGaBT7q1lf9evLjGz32BBUj0fwHn+ErkNf0ctM2zsJipTJ7NVCYHkZcHxjG7ZTCRTqUmF5eWypLwEwl2Hj7Mn198cUMf9w0WYNPDn04tkv5+RPCtdDT/Wnfl5inPwutAzpdmbzY1lbaVyySbmhgaHa3b/n2Fbe57AnO2peI3b2+v5PJZG89Vbtwq244ePGBfsciZXK5h+/8DFYWTIIiuQPwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjA5OjIzKzAwOjAwqUK8vQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABilJREFUWMO1mF9sXEcVh78zd9fetZ04TkmcKDYqJSalpaSyLUiRooqqIOWtLVKREA9FPEBUqRJ9QQjxgHgBlTZCCJXHECCgSolQKBGiRSJBSiNCGjWhMYljJ5FJ7Tje7np3bd/duzM/HtZFCazju9twpNU83J0z3znzmzN/jA5tZGSWfD7GucDWrYkVCtmPgPoly5mRARqSYqBUqVQK/f398h5qtQwXL360ozEzncL29y8zMbHFdu2af6hQyDwG7AV2A9uAPqAKzAHvbNiw4WQI4fT8/MDFwcGiOh3TOuk0OjqFc7YtBD0LfAX4LAgwbA2PEqeBwxKvmenm22/v/P/Cjo9P430wM9tlxreBZ0E9ad1ILINeA35kpkshoHPnRlKP35YMoshZCNoJ/AD0lETGLH28ZvQAX5Xokfiu1JiiOSWpzLWT1UbDbzLjBdBTYG2B3oacMeMZsBfMspvGxqZS90wNK1kEPAE8Z2YdL8wPgIGvmdkTQHRPYcfGpnHODwDP01zpLYIRIYgkEfV6sw1BaI1JNrM+0DdDCAPj4+mymypDEi4E+zToM60WkyTA9PDD3XN79+ajjRujTeVyKJ08ueQnJmrbJKyVZMx4zMweAf2FFNpNBWsmB3wBrLs1KOHxx3vff/HFzQwNZXtpTm3vvn195VdeKRROnFi6D9QC2LqBJyX+CjTW40ipWTnQQ7TQVwgwNJRd3L9/U2VoKDsI/Ad2eDg7uH//QGV4OFsKoaXjCPSppv/1LdWfJExiGy00IMGOHdn8zp1d97Xw50ZGujbv2JHJt9auDBgkZaFOKQMDyK0RCJkMGVujjplZdxRZ1BrWAOXTMKTO7KottoaBYtFXy2W/0Op7uewXSqWwtHZJtlLaHTCtZgNoEuT/+0sUwdRUkjt6tBxCUOX2byGocuRIWVNT9XzUoppKeInLEoEUlra4B+AUzUPLHcOaGXEccgcPlgYrlTDz9NMbS729bsvSUrh19Gi5fuRIeTiOQ5dzLUtXApxe9b+upcr/+Pikec/HnLM3wB5omXuJTMZ8LmdEkUXey8exaDQU3WVbnpbck1Gka2fOPLBunU2rWUWRzYIdXisLZkajoahaDdHioqdaDdE6oEHi1xDmpHSHmdQnkfHxKbznE2b8wow9afvdxd6SoueWF79xudb4Jy6AD44oCgRnGNATx+ydm+PVdmEBxsauZMGeAQ4A2zvn1GwIpe8slp4/FoW5bAMyLuB8cC6Kgg/OgkE9H8fLn1wsx+e3bGV7NrR7rbEE+D0wCnwLyLYBCBhSCI3k7KWV6g8HLBS+LFzGgcNhkROsbpdAiLtzjXNbckUH7856m2z7QLp6/rxf4udmfLHd2fH++vRy9cev++R8ySwyYbc5aAaEtNoYQDBYCeiNdjYFAM6e/TjAdTMdAF1tp69CuVSPj53yyYUiRAIL1lywqz9rtmYBLJgpmGFCPUib2oZdBVY+P/8m8DNgORWoGo0kOf33evz6VXCku2WYIZnM3pNzkx3BAvT1ve8lHZT0O0l3KT1CEt5fnoiXD52TkpAC1AAniIF3HBx3udyNjq8nt27tpF5XsavLXgIelDTaGsJQWLhZW/7tqeBvLP+vxGXNhbcamRGQloErmF0CZor5fLU/Sdo6yNxhZ88+SDZrMrPzkBwAX/kgk81mdfRQq9VrfzqVJKduNt8VbDUCmYSTDKQGsARcE/w5ymR+KfjjvmvXJoDqcKnE9JUrnT1y3G5jY1N4f2PAuc3fh+79Zi5zW5nyjeTMmZXqyydCmI/NIgNMzXtOHViSKBq6buYmPdyS0VgpFHzvwABEEVPT03do40Pb7t3HzKz/Eec2vwq5z5m5ZqFszFxdWfrJ8UbytwXIREACFM1sHpg1s5kok7mBSEJo4BMvZSJ6+vr4x4ULLQR1j+zRR09glv2S2eafmmW3K1Qr8cqvjtdWDr9rli0Cs0j/Esz15HI3V2q12MyIslmG9uzhzUOH1h3jnsECjI4ezEkj3zPr/3ojOXciXnrpsA+LVw0rRGalma6upe1xTHdXFxcnJ9v2/yEfK+40aSD2/r2Xo6j7N95fKYqZgm4UY9txP5L4/MICfygUOvb/b4OFAZuQsv++AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowOTo0MSswMDowMPiypBMAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABfxJREFUWMOtmF1sHNUVgL9zZ3a9u97gXRITO4CwImhpAqXioQ2oeWgESPAUgRQk4AHEQ4uQqJAQP614QFVRItSi/tD0CRVo08gR/xAhkQRIIhMURJxAfm2vHdzY63g3Hv/P7s7c04dxCm7WYXbJkUZXmtl7znfPOffcc1doUn7/smJSgIHalUiiyApR2lBSCC4QKPiAN62Uc4IaB5al4Zd3SVM23WZh3Sz4g0hLF2sSo9wCrAduAjqALDADFIHDy4S9Fg78fC3H9h5Bm7XZ1BI3dyuidChsUrhP4GcxNB4AtonQLZaxJ+9t3HRDM7Z0Kwiiyg9RnkLYBGTizFUFEeZQug1ssYaTVtHfbIqP0FgaWATDtcDvFDYCblxTIqCQEXjAChlVfmuFAYifFqYhrxpyCo8BG0Xig/4PGFDBVbgbeMyx5J7fHj+FY8OiOMAG4EG+x8aU6HFRHgI2CDiXFPb5HYoa8gqPEu30C9eiYBVCC0EYjVaj90tIFviVFfJxvRvXQ0bhx8BP64V+YfNoZ57itZ04LUlylSpe3yhh8Rwdqoj830QRUOUWgRuBj4mRu7FgBQzK7UBLPVDAXreKcxtuglyWVqLQtq65hqndvZT7R1heDxhoEbgN2AcE3+mxWLCKEVhTL78UyGeZXL+W6VyWlfANbD7LyvU3MJ3L4tVzm4AjcINIPI54G0wRlA7q1GVVaGslvaKN5XX0mSvauDzXSlrr0wrCSiRevY+Xs5Gq1FKfHYMrSxgUocWYpXe8QjoWQ2zPRjK51DrmKsz4VUr1vvtVSvMVZpdynSiexCy1cWEt0AeEdTzH+CSp3gJWlelFXlOmDw2g45OkpT5tiHAKwcaBiFu6rEIPUdOyKKQiEISkDpxgpV9l+Cer8ZIJ2qs1xnsLVHsLXB2EJJeArRE1OJcQVrCqfCTKCMLqet71qyQPnqKrdwDE4KhlVS06HBxZKgeUEZQ9EtOzcdNAxTIKbEPrKxaJwPwaznwF/BrORUGjaP0LoYjEa2Zi9yKbtysq/EDgFYR1ceddRD4V4cG3/7Tx1OhwL8ZCaA2OY7EmKi0Z32d9scjWRmEBNndrgqhjehHobJZSVUfnZ849s+OP97wTzAwlAnCNxYTWGMexoTViBapp35/70eSUf6T9CjoTtuHuqQa8C9wMPA4k4gOe7wesPXNq/8mPtz+er0ydvdcYxzVgMIhjFEBNdDBavyUVHGpPTRg4OhpKX8N3i83dCtClyt+BOyTm6bOAjHd2oLB3x1PvFQufecZxRRcdXwrIwspAVQCswLxFP2zkUADg6egacpooFQYbmevPet6xT//ZUxw8OCHGVRArUdlaeCQaRSyIFVErgiiaQTXXMOwCsNZy7BJ4CWUuzhwb1oKvj+/5/MSBbYMipm4LdqGIoCoqMqLG9DUFC+BdSSjKPxTe0ov0oqqgqpTOfHX80K4/HwqDqo0BKkQ9tA8cNrDTpFJnmr6erDoMk2kmMgEviOr1CjfXgxCB2cmxscMfbe2ZKg3NccFvVEDO98WKYFGdA/oROQkMT6TTM221WkONzCJ54n4hHaAuHLFB7UW14fR5T357DGt+pe+LN3pOH9s9hsj58EfhVYyqgGoAzAJDCrsd131N4YM7h4aOAzNXex6F/v7m/uT4tmzpVrzSUD6zrP05N5F+RIxxvylTQTh8Yt/B/a8/88mMN+Ib4wggGl0bqsCsKhOCnhYxfSGMqxDMl8thaz4PjsNAobAoN763/PqFg5LOrLgxc9mKrYlk5lYRAyjeeGGw581ndw6f2FsyjusQ1ekJETkLjIrIsOO6Z1Bq1gaEtVDVdchks3z15ZcXptSlgAV4+qVB3GTynnS2/S+Ok+iszE1O9+75687ePX87atzkhMAoqv9RKGZSqbH5SsUXEZxEgqvWrWPXq69+p41LBgvwyHMfpC7vWPtsSyb/8Eh/zyf7dzy5bX723KCIKTsi3nAyOdvp+7Qkkxzr62tYf9PVoJ6kWpf7XnnoD8vd1L9LI0cnvFKhzNkpP9XVharyi1KJ98vlpvX/F5vAnOxV5r8nAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzowOTo1MiswMDowMAXwvhAAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABa9JREFUWMOtmGtoHFUUx3/nzkyym7R5tIlNfdCH9f0CLdoK/aCoICiUFkTUDxWxKoLQL0oREdEPikjxGaP9oLVW8IOo2GqpilqJlfporU2oaZKNaW3SZrOb12aSnbnHD7PV1O42s2sPDBdm773nd8/933PurFChvYxSBQhQCzIBTQL1QAJwgQDwFbIDkD4X1In6cjdSkU+3UthqIAvSCJfnYCWwCrgGaAHmAOPAALC/Bb5T2LMcOtpBK/VZ0RLfQgmhReAu4B7ghhgT7QG2WfjQwOBDFbgua0QrigERuEThCYW7BGrijC2EMwd8KPCChUMO6PoyEMqSQQDiwTLgWWC1lDG+gFQD3KdQI/CkC92UIQsTt2MbigcNwGPAaq1c7y6wRuCxPDS0liHh2LAKjsDNwDrArew8R1bYkfs1ms85q7BtKAKNwKMSnfRii0GBcMZz8l2J/nOAh4HGt2JGN+5WGuBq4PpSoIA2X8fAojtxqhtpmMqQ/fNTwhO/0KLRofxvdAFWClwFfEMM7caGVbhVovR6OqhgF9/B8MpNUHchtURbW3vRvYz+sIF06jPmFwMmmu8WYDdREZk1YrFgBS6niL4UqF/KyPLnGKu7kAXwL2zdMhYsf5axuqVkS4TNAa7UmBxxYYWoMhU9V3MXk5x3FfOLzGfmXcO8uiUkS82rsEBj5vty0k+i2EsFjIcrUtyhCNXi4ZQSpFByIadZ7NQFjJRwhj/E+FSGoWK/+8MM+SeYOEPosmcVVsEqdGmUkU6DHe4g0dmG1ZCxU8aFjHW+iWY6SZaADYE/ABuHI5YMFKxAO9Gl5ZRDJkCQI7HveRZMZ+m/9EGyXh3N+VFOdLQx3dnGBUGOqhKweaILTizYWMJuRUVgCbBLYGmRxQBgXEKvBsTFsQFhkAMb4JzBSY9EqSu1Hpk1z8bVrALHgG3FoiCFxwY4U6M4/jBMj+LMAmqB94nuvLFKWOwS34aicLHAu8CKuOPOYD8IrNvasvqP/up9GAuhNTiOxZootdT4PqsGBmgtF7YA7AFrgE3AwkopFT2WM8MbN5+39tO8SXkBuMZiQmuM49jQGrEC00nfz102Mur/1nwOCz1bNixEd9KngQ2AFx8wioxibSrx/Xfbmzd8Mu4c9x113EIFk0IPRUQBixKgZAwcFKNdZd/0CsCLFd4EbpOydkdJe909n89/4rMjiR+zDq4oM6tJYUmqhUYgykSTFt1VTlEAoPDt1KeRFHrLGTtpstl9c7e2H03szRhcBbESHbTCI1ErYkGsiFoRRNEaVBvKhi0Aawa+BF4n+q6a1ULyQXfy65/2z93WKxgk1oaIoCoq8pca01URLMBxCAXeAT7mDKknuoArg9W/d7Y3vPJrINM2BqgQXUt9YL+BHSaROFrx/waXRU0GeFHRS4Fri0EIMO4MDv5Y39qe9VK50yWuAoJqYW2CRTUHHEbkENCfSSbH6/P5si4yp1hBuwr8FpLfpIRjJ1/MbPP4UwfmfNR+OPnVIMjJ7Y+2VzGqAqoBMAGkFL5yXPc9hS9uT6U6gfELsll6Dh+u8H+cGdaGMuSkGuts8zOeJh8RjPtvmgrC3sTuvTubNn476v7lm6igiaoiItPAhCoZQftETFcIJ1QIJtPpsLaxERyH7p6ef3xVLIOZEd5o9mYdw+baoOk6T2tuFAygDLt9f+6tf/vnEfeIb9R1FM0DGRE5DhwTkX7Xc4+i5K0NkHyouA5Nixbx+4EDRSV1Vux5rxfHVq2tDZtfdfAW+jIytqfhtR176t84aKjKCBxD9YjCQE0iMTg5NeWLCI7ncf6KFXy5ZcusPs4aLMDjc79INE1e8VQybHygL9H+7c5zHt+WM8O9oibtiGT7q6omFvo+1VVVdHR1lT3//5bBTEsG8/2Mm3rJtYkPBqsPZoYTPWn6Rv1ky2JUlZuGhtieTlc8/98L/TvfZZ49dwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyODo1OSswMDowMDPIuVsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjM6MTA6MDQrMDA6MDATW3FEAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABQpJREFUWMO9mNtvVFUUh7+1z5nOTKWUSsE2ahRUQiRootGIiQ++mJhIYoJ/gIlPPmhi4u3F+GR8MN4gBokaFRU0Jt4SlYSLQhSIKAhyibRMWy6l9xl6nTLnnJ8Pc4pFmOFMW1yTlZMz++y1v73WPmvtfYwZitD0WwOagUYgA/hAABSBAjAI/3YwbEZj+jOFnQZ5O7AKeAC4E2gB5gGjQA9wENgF7AWOTof+X0TlX4vQ00J7hZRA9wg9JXSd/g/eGNKElgt9KDSWEHRKx+J+y2M7VxXWhG4T+lKoVCPolJaEvhC6VWhmizehV5uE1s0CdDrw2tjeVYH1hNYIjcwSdEpHYnve1fBqs9COOQKd0q2x3UQcSVOXA+4A7q06p7vpYTUeTSwgT4HvCNlPC1RMrKuAlcDPzFVKE/KFXq24Vk2hVqtf7eqWNCopkDSqNnXrEfULRVXW7itCs833F8HWCX1bcdBbNKSDykkKdbGEOqCclmqoAmwU261LGt4kYlAlnDeTZSULL2PPcSfXsoRsFbvXQbL6W4v7MxVbUvgVC76RJkW1Nz5LQknqWYBzFVsGGCXPwGXbhhign7EqdgtzDRsBbUB42dajZNhARMjIRf+HjPAu4lhF74XA8dj+3EhcEJ4QmqiYMxs1qRfUrnadVJ8m1K6Tek7tmq/JKnl2IrY7d4Uh3hMsFTpRNcn7CjRfga6VNF+BfAVXKAonhJYk3SMkXQYCzgKbqoYswGMYjyFgGI+g6osVAZ9R3vMmKgiJdz1xSVwGfAzcN9MoTZM9wOOPtTx6fH/6T1wEYeTwvIjIlVNLfbHIAz09rI87JE5dhiHUAbwFvAm0zpRS6OyQG9qw5vo1/d2uc3HM4WINY6+fF4z3Z+uLyxYtpjUV1XYYir1bD7wMPAOkagWNiKJfM7/senbRM9/2eX1FX56vMqSVAy1hJiBCBIi8gyPm1FZTTY69Ow6sp3zeeogal1Iuletct+DtQ31eb5OHb7Lp1URlc1L5UuZvFSwJxdZaisIFYKCL8lLoqKXvOVcobG74dPfvmX15D1+GRVYOeaxWvppFYJGZIjNMqB5pQc2wMbCAbcA7wHiSPiVKwU/ZHb9vbtjU4XAJj+NmSCazbjnXNiPYWELgI+AbrpB6hDiSPnxs3YK1B87b+SgBqAFO5e8OBx384DKZM7PdR+aB14SWA3dVgujzens3NK7f3ZXqHL/0GRkYUjwvI0IaB9ox+xs4lc9mRxtLpZo2Mv+ZuhF79FCJ0psh4cjlnitSnPx63le7t2e39xo21a8cXuEkAykAxoBOwXbP9z8RbHm4s/MYMHpjoUCuvX12X2Ti7BB1e93fL4oWfeTknnS4CzZDgnBvZs+BTxs2Hg+sJA/PAJOEmZ03GJPIA13OrC2EfhnBcH9/eE1TEz8uXcqJXO7CeLM+ThjGPrevgOP95qD57nrV3+9wCNHld538oPG9P077p4u+fE+oBOTNrA84a2an/JR/BlGKogArhcL3aL7pJg7/9dclY83J2eee0j3qSHUcGnbDb6TD9BKHax224ZEvGj7/bVd2Z2+KurwZZ5FOC3qy6XTvxORksTxb44ZV97Ft48YEjplD2dKwJbNiYsVLTWHTE3syu3e+uPj5TXk31OHkBj2zwqm6urHWYpF0XR1H29pqtj93p0pgYbCw2Ol3vp6JMpsPp4/kc5ncoN81XGxsuRlJPDgwwPeDgzO2/w/IRTXCFJZFPwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyODo1OSswMDowMDPIuVsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjM6MTA6MTMrMDA6MDAaVk9UAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABfVJREFUWMO9mE1sXFcVx3/nvnn2PI/leEZDHSNQ04gUUgGVQIIGqQuqgMSuYtEFRUoqNlRIlVixoKiqukIIwgZVhEr9CAS1Vj+Q2oJE+EijpmnTNiRNaxKnSWyntmM/z0wyiXnjmXf/LGZchXbGvHECR7q6i3vPub93znnnnveMDUq9XqfVaiGJarVqo6OjZTPbBOSBHNACEkm1hYWF5fHxcQE45xgdHd3QmbZR2DiOGRkZsXq9fhuwA7jTzG4HNgPDwBVgQdJx4BXgSD6ff6/RaKhUKv3/YKvVKmmabnbO3QN8B/hqBrUjwH4zewa4WCwW/7ewcRwTBIEBn5X0I0n3mNlQHyZWgGfM7KfAKUD9QOf6gfXem3PuM8AjwN1m1pe+pCEz+25n/rFz7n1AWfVd1o2VSoUgCEYlPQDcLakvUAAzo6P3bUkPeO9HK5VKZv3MsEBgZncBu4Gc2cbezY5eDrhP0l1AcENh4zhGUlHSD8xsuNseST1HDxmW9H1JxTiOM8FmDaUDvgh8pReomSkIgoUwDAMzG5VUazabaZqmmyVZj0jsAL4A/J0MuZvJs2bmgG8Agz1AfRiGy4VCgSiKCvl8PoiiqFAoFAjDcNnM1MPDg8BOM8uUCplhzey2Xkadc5eiKKoHQTAGFGjnYSEIgrEoiurOuVoP0wHw+awcWdPAaN9MXWPpnIucc0GXQ51zruScG0zTtJfdMTLW+37KT349O72S0swG6fHGd1SirAD9lK5LvRYkXZEU91iLJV1dR7e2TsXoH1aSlzQlqWss0zTNNxoNL6n+Eb16o9FQmqa9vJea2Wkz8zcM1sy8mR02s2aXNSTlkyQZS5Jk0Xs/671PvPezSZIsJkkyJmmwh+kmcCQrbKacdc75NE3/BsyZ2dZuwN77gSRJtjQaDWjn6Cc7l0KwtqeLzEn66w31rNoyD+yX1NVwx8OB9z7w3uO9DyQFZtYVtGPnd865BTI2M5kv+DiOMbNbgSfN7I6seus44LUgCHbvvvfe08dPnsR5SL0jCDzeGQYMJQl3LizwaEcnc+kql8tUKpVzwC+BPcD4dYDOV6vVX+/atWtp8cKFmzocrjNSwAOrgpWlaCi59RM3MR76/prvTjs3BDwE/BAI+wBcy23/xuuvv/LQgw/+YSmOk5xzObUhrR1oCTMBHtFCVB28a05TffWkpVKJSqWyAjwq6XYz+yYZU2ktb6enp8//Zu/eE0tLS8UgCExm1xhQ25zUntr844JbUvHnfi6FD4GBaTPbA5zLWtABLtVqtecmJg7/4+23q0EQyMy8tUPeGdaezTyYN5M3w4SGkEb7hu0Aa3h4+ADwKzNbyaLTarVahw4devO5Z58955wjW/NuhmQym5NzUxuCBQjDMDWzJ4AXtI571xrwycnJycf27j22urrqM4Aa4AQJcNzByy6f/6Dv76g1qdfrrK6uVsMw/JmZfU7Sl7pBmBmLi4sXn3z88cMXZmdXPr5HBkbncYXhkVaAM5idAmarUXRlU7PZVyPzHzIyMkIYhnLOnWg2m3vSNK2vefLaudFoNF5+8cXDhw4evHjNBdEOr3CSgdQCrgLnBX8Jcrl9gj996/z5SeDKp2s1zp4509+n+EelVCpRrVb9/Pz8S+Vy+Qnn3P3Oudw1ZSp96+jRYxNPP3261Wqp88/BOuurBlclqsC0M5tKYUlG6/LSUlooFvnj1q28f/bsh+ddFyxAsVjkwIEDNUmPlcvlL0dR9DXn2gGbnZmZ+e2+fW/Nzc0luVwukNQEqma2CMyb2WwuzH2AaHrfwpqpyAWUb76Zk++887GzrhsWYOfOnTp27NiJer3+i4GBgVucc+OXL1+uv/D882+89uqrF3MDA1WDeaQLgoVocPDivxqNBAAzPrXjDg489dR/PWfDP+a6ycTERH779u0/2bRp0/fePHr04CMPP7y/Vqudc2bLgVltdmDg6niSMDgwwHtTU33bvyGeXZNSqZTMzMz8fNu2bb//5+Sp6vT09HJQqyUjW7Ygia/HMS8tL2/Y/r8BRVECE4yt2dgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjEwOjMxKzAwOjAwz+xZAAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABihJREFUWMO1mF9sW2cVwH/n+6597aRVbLykf0S0iiJGpwLSGkGHtAcmQOINDWlIEw9DvIAmTeKhoAnxgHhCCFVa1UIRDxBEkaZ1He2YUCnQDalUqdextmvnpUs60sVxbMdO4tROfO93eMhNadO4vXbLka6u7v3uOefn853zfeez0KMUCgWazSbOOWZnZyWXyz0EDIhICvBUNRCRFlDPZDLVubk5tdbi+z67d+/uyafXK+z8/Dy7du2SQqHwaC6Xexx4AvgcsBXYBDSAGeCder3+pjHm7NDQ0OVSqaS9+pRelPL5PM65rcaYp4FngC9s9J3q/7hE5CxwREReUtXSyMjI/xd2bGwMa62o6iOq+kPgaaBP5N5mVBURuQG8BPxMVQvGGN2zZ09s/12lQRiGYoz5JPBT4OsiEls/+kF9qvotEekTkR+JyAdA7LQw3UTV87yMqj7fLeg6aE9VnwKeV9VMPp+PrRsbVkQs8CTwLPdRmGvAwLdV9UlVtQ8UNiqoLPAcq5V+h6gqqopz7ua19q6DbAK+a63Njo2NxYKNGyFjjPmsiHy+Eyig/f39MwMDA9bzvEwQBPX5+flwaWlpq6pKhyJ8PAzDzwCniZG7sWBV1QBfUVV/vdMI1GUymbnh4WF83+8HLNCfy+UWpqamqvV6PbcRsKr6wJdF5J9AcM+IxY0s8GgEcYekUqn57du3L/q+vwW4Cev7/pbofb2DXQvsjssRK7JRSLbSYV1OJpPpdDptN3Bq0un0x3zf95eXlzc0DWwh5nrfTVWnNnoZLfZep6QUEV9EbPTd+jGAdFyA2EsXMN8BhiAIGkEQVDYaD4KgEgTBUqddTlXrd1kxuodVVaeq40C40Xiz2UyVy2Wnqovr9BbL5bI2m81O0QtF5H0RcXE44qaBA86o6jPR5nBbZJ1zqVKptCUMw6nBwcG6MWbQOVcul8srlUpl2DmX3CiyqtoGzkb2Hwysqjpr7T+cc9PAJ9aPR6mQLJVKOyqVCqxW+fYwDFFV2ykFRGQa+HsYhrFg4+ashmFYBI50ioKIoKo2CAIbBAFBENi7gUZ2/gDMiEispI3dIkbt4adU9XfA3rh6d5F/WWuffWHfvvcL4+MYB6EzWOtwRhCgr9XiiZkZftktLMC5c+cSIvIUsB/Y1iulqhYXFhZe+MG+fccXqtVEAJ5xmNAZY60LnREnsJJutW7sml9oXRgcYlvCddc9iUgbOAE8BnwfSHQBuFaM7uKFC4WDL76YrdVq37TGeAYMBrFmtccwq32Ca/mp4O3BVM3Au8VQxrs+1kT95w7gV8BXu52d69evTxw+dOi1K5cv1z3PE73NQPSkGt0EwAk0HfrXbjYFAKKz04equl9VJ7vRXVxcrJ86efJM4b33atZajUAcNy9ZvYs4ECeiTgRRtA/VTNewEbA2m81TwEFVvRFHJwiC4Hw+nz918uSkiBDn3AYiqIqKTKsx4z3BAjQajVBEfisir3KXXnStAZ+cmLhy9OWX32632y4GqABGoQW8Y+B1k0p91PPxZGhoiGQyWVtZWfm5qn4aeGwjCBFhbm6u9Kdjx87MFIs37vxGBYSoPVAEx+psXUWkAEzV0unGQLvdVSNzm4yMjNBut1VVLwRBsN85t7gWyVvvK8vLy2+ePn3mrXy+dMv0r06vYlQFVANgCbim8Dfreb9X+MvXrl27AjSG63Umrl7t7U+OWyWfzzM9PZ3NZrM/8X3/e8YYb22ZUtXw3+fPn/v14cNvVCuVljFGAInGV4AlVWqCfihixkMoqxA0q9WwP5sFa/lgYuKmr/s6pa5FeHR0tC4iv8lkMntSqdQX16a6WCz+57UTJ94qz862rLU2alxqIjILFEVkykt4H6G0nQuQdqh4locefphLFy/emVL3C7smx48fJ5FIfCObzR7wPG9bo9FYfPWVV14/dvTou14iURMoonpdYaYvlSo1l5dbIoJNJPj43r2cGh29p48HBgtw4MCB1M6dO3+8efPm71y6eOmNw4cOHllYXJw0IlUrUp9KJpe2tVr4ySSXx8e7tn/faXCrZDKZVqlU+kUymfzj5ORkbbpYrJpqtbVpxw5UlS9VKvy5Wu3Z/n8BcY8RVtNG93EAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjEwOjQwKzAwOjAwY15brQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABh5JREFUWMO1mF9sW3cVxz/nd23Xf26bhFGaNEyNKrTB0lFpD9Ah7QEESPRpAimVKA9DvIAmTdoTQoiHiidUsWpCZTxVMESJHG3lb4VEl64gteWPuiZjTZrUdqZQ203sxk7s1H/u/R0e7FTpZqfXXvlK1pX98zm/zz3n/H6/c6/Qp86cOUM0GsUYw+joqOTz+Y+r6oCqRkUkBHhADSipalFE1HEcYrEYR48e7WvOUL+wruuSyWRkbGzsqVwu9yzwHHAYGAZcoALkgRkR+RtwdXx8/Mbs7Kz2O6f0Y5RMJlHVYWAC+Cbw+fsOpavLq8BZEUlaa+8cO3bs/wubTCYREVHVJ1X1+yIyAcSD2KoqIrKpqkngJ8aYm6qqExMTgefvqQystWKM+RTwY+D5XuzbEY8D3xKRuKr+UERSQOCyML1E1RgzCLwEPN9eRD2rbfd14CVr7eDk5GRg28CwquoAXwJe6CWiXRRS1W+3/TmPFHZqagpjzBDwIq2V3ulmUFWstfi+j7X2/m9d5ALfFZGhoNENGiEDfBb4XDdQEdGhoaH8yMiIE4lEBhuNRimXy/l3794dVlX54C4hIqjqs8DTwNsEqN3AsKr6FWBXJ1DA7t+//+7hw4dxXTdBK7WJAwcOrF+/fr2YzWYf6wTc9vdl4O+0DpGHRuyhUlUDPEWX+nJdtzw+Pr7huu4+4D6s67r7Dh06tOG6bqmLawc4JCKBOILCSvsQkA5jJBKJ2MDAwGMd/JmBgYGPJRKJWKfalZb2yQ4nyXYFKoO2r2jXOzYm1G1CEdlljNlpxceCMASObFvlbgP1er3SaDQKncYajUahXq9Xu9mqammHHaMvWAssAn6HyFEul6PpdNqq6sYHQDZSqZSWy+VYl8D7IrIgIjYIRNDdwAKXaTUtD6RURPB9Pzo/P7+v0WgsHzx4sBQOh/c2m83VdDrdSKfTj/u+H+kC26TV4Dw6WBGxqnpRVbMicrBTdBuNRmRhYWEslUphjHGstfvbh4PTbf2oalZVp4NGNmgZqLU2B5xV1Y6ORQRrrdNsNp16vU6z2XR2Am1H8zcikheRQEUbuEWcnJxERJ4AfiUiR4La7aArIvLCz199dWFpeRljwbcGx7FYIwgQr9V4Lp/ntV5hAZLJZJhWx3QKGOmXUlVzlUrlB6deeeUP9Uol7EHIWIxvjXEc61sjVqARq9U2P1Ner83u/QQjYdtz99QE/gg8A7wMhHsA3OoH7OLCws2pycmh6vr6MceYkAGDQRyjAGpafYKt7Yp67+yNrhl4L+fLYs+PNclkEmBMVX8BfDXo6bOllZWV9JtTU3/KpNMlx3FE2Z7e9jfV9kUArMA9i/61l0MBgPZjyPu0SiHTi+1mtVr655Url5cymTVjjLZBLPc/0rqKWBArolYEUTSO6mDPsG1gHRwcvACcVtXNIDa+73vzc3P//sfVqxkRIVhCRFAVFcmqMYt9wQKMjo76qvpL4Hfs0ItuNeDZ27fn3rpw4R3P82wAUAGMtt47zBg4b6LR230/nszMzBCLxdY8zzupqp8GnukEISKsl8t3Ll28eLlYKGx++D8qILTbA0WwtLJ1C5GbwPJaLFYZaDZ7amQe0PHjx/E8T4FZz/NOWWs3tiK5/dpsNuvXrl27PHfjxp1t6W+lVzGqAqoeUAWWFN5yQqFfK/zla0tLc0Dl8VKJ9K1b/b3k2K5kMkmhUBjavXv3iXA4/D1jTGjbNuUvzM//69wbb1wqlUo1Y4wA0h5vAFVV1gR9X8Qs+rCqgnevWPQTQ0PgOKTS6Qdq4yPr5MmTEo/Hn96zZ89rkUjkC1upXl1dzfz+3Lnzi/PzBeM4Dq19ek1EVoCciCw7odBtlKa1Hn7TVw05xF2X/7z77odL6lHAApw+fZpIJPIN13V/5jjOyL3NzY2L09Pn356efs8JhdYEcqj+VyEfj0bv3KvXayKCEw7zySNHuPD66w+d45HBApw4cSI6PDz8o3g8/p3UrdSlN6eSZyvVasaIFB2R0nIkUh2p1dgViXBjcbFn/x/1ZcUDSiQStWKx+NNQKPTbbDa7tlooFGVlpRYfG0NV+WKhwJ+Lxb79/w9bQvQtKYEySwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0yNVQwMDoyODo1OSswMDowMDPIuVsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMjRUMjM6MTA6NTArMDA6MDCv9FszAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABjJJREFUWMO1mE1sFOcZx3//d9beXePixQvCpFSp0qopNGlFKlGn2EhF5VIulSqlUsQhqDduPfClqqdeiEJPPeTApY1UKuVUCcIhaikpBrxRKEmJ7RrMR7CNd8GuP3a9O/bszNPDrhE4Xjy7oY80GmneeZ/nN8/832eed0SLduLECaIoAqCtrU1BEGw2sy5JKSBhZlVJPjCXyWRmZmZmLIoiisUip0+fbilmolXYarVKKpXS0tLSziAIXgf6gR8APUAnUALywGdzc3P/dM4NDgwMDO/du9dajalWJh09ehQz65H0hqQ3gR+ZGdLT7sye4hoEzpjZ+2ZWOHXq1P8X9siRIwCS9DJwDHhDUkfc+WZWBt6Pouht59yoc85OnjwZO36zMhDwbeB3kn7e7HxJHWZ20DnXIek3zrnbQGxZeE1mdZOk48BBSS3pXZKrvxnPzAb7+/v9gYGBWHNdE3E8YB/wVqugT1gCOATsM7PYCYt14/HjxwGykt4BXl69kKC2mMyMMAyJouhxWatncy237UC3c+6Dvr6+cpzsxs2Qk/R9YPdag/VKYNu3b8/v2LHDS6fTmUqlMjcyMhJOTEz0mJkaAL9uZq8CF4mh3ViwZuaA/UByLVAg2rlz538PHDhANpvdQO2Nbdi1a9fCuXPnZoaHh7MNgJNm9lPgElBdN2NxYc1sJ2vIxszIZrPz+/fvL2az2a3AY9hsNru1fn1uVc1dMc/MXqknY12LdZNq1sMaddnM6O7uTvf09GTX8Oe2bdvW3d3dnW4AK0lbG2lktTWzqlMNn9i5RKOAkpLOuWct5HRcgGZK13yjgXK5XKpUKtMNxqYXFxcX1xqrV5BGEmkZNgJuAeGXHDhHPp9P5XK5KIqi4lOToqg4ODhohUIh7dyaoULgZt3/uhZXBhFwBXiTVYtMEkEQpC5evLi1UqmM7969ey6VSm3xff9RLpdbzuVy3wiCoL2BSgJqDc7zhZX0DzN7ALy0elASlUql/dKlS98cHBzEOedFUfRCEASEYeg9Y/08AC6YWSzYuDIwM5sCzjTKgiTCMPR83/fK5TK+73vrgEaS/kyt540l2tgt4rFjxwC+A/wJ6I077xl2VdJbFz788OajmRlcBGHk8LyIyAkBHb5Pfz7Pu/UJsZuIy5cvs2fPngVJ88Ae4GutUprZ1NLS0tvnzp69XikWN0bQJaPLTBnnrNOkTkEyUa3SEUZh9YWv65XNG5vrniQFwFngNTP7taS2FkCjQj4/+kkutynw/V86KeHA4ZDnDMBcTRaRn0xVr29JzToYmgp1K3ZmV7Lb19cXAGOSvgd8iyZ3G8WFhbv//vTTSwvz83LObTRpg6SO2mG1s9kGiU7QRsRmxEshlJqCfQJ4HngE7DGzTTG/liwvLc3dGh39+8T4+ANJSDLVslg/VDtLBjKp1v0Y1oZZoWnYFeB9+/bdq1arDuiPI4coiqqTExNXhoeGblitBYsRScJMJj0wKdfM5/Ypy2QyoZn9UdJfWaf0mBmzs7Mjw8PD18MwjGKACnAGPvCZg/MulZpseXsyOTlJV1fXbLlcfsfMvgu81gjC9/3CzZGRK4vFYnmNRxGIentgiIjaLngMaRQYn02nS11BEL90rbarV6/S29uLmT2MomgR2C8pufL/YOUcVqtLd27fvnBnbOwOPN7i1F4vciCEVUEVYNLEJ4lE4mIURUM/++KL/Fgms7xlcZGR+/dbhwUYGBigr6/PSqXSuOd5m5xzP5TkngAOHxYK14Y///xfQRBU622kq+8aAokFYEpww8l9FEk5k+4vTk8X29Pp6lg2y+1798iXSo+18ZXt0KFD6ujoeDWZTL6bSCR+vCKH4sLC3evXrp0v5PPTkjxqjcuspIfAlKRxL5GYxAiiqEoYhGYJj47OTj6/ceNLcZ4LLMDhw4dxzv0inU7/wTm3bXl5ufifoaHzoyMjQ87zZoEpzCYM8h2pVKGytORLwmtrY3tvL3977711Yzw3WICDBw+mMpnMb5PJ5K8eFgofXfv44zNLy8t3BTOeNDfe3r64zfdJtrczfOtW0/6/6s+KpyyZTPqlUun3nuf9ZW5ufnaxXJ6JJif95IsvYmb8ZHqaD2ZmWvb/PzZaBDRi9tDdAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzoxMTowMCswMDowMAjWPmkAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABixJREFUWMO1mE1sVNcVx3//+549Y2MMDkTMTBHCNgpVmlApi2IagVQ0SFVXlYpSKcoC1BXLrlKp6qLqKoq66gKpqzZSqciGSnXYuEVJIwWjVkIRkAhMBtt82MYej8fz4fHMe/d0MQZR8Mcbhx7p6S3uu+f87rn/d+55T2zTTp8+TbVaxXtPqVRSf3//XmCXpDQQAhHQMLOl2dnZYjabtTiOWVlZYXx8fFsxw+3CLi4ucuTIEd28efP1/v7+Y8Bx4PtABugDqsAs8GUmk/mXmY1PT09/NTg4aNuNqe1MyufzeO8zzrl3gHeBo1vNMbNx4IKkj733c1euXPn/wp48eRLnnIDDwPtm9g7QKyV2Uzezj83sA0m3nXM2NjaWOH5HMjAzmdkhSb8DfiqpUxn1Au9J6pX0a+AbILEsgqQP5vN5gAFJv5L0npmFHWT0qUlykg4DgaTx4eHhRqFQSDTXdRAkkHQSOANsC/QZC4GzwElJiROW6MFTp04RRdEeSR+uZeUFMzPMjCiKiOMY7z1PFrTBwrqBV7z3nwwPD9eTZDep5pxz7oikH2wECtjhw4dnR0ZGgp07d+6uVCpL165di+/cuZMxM60HbGbHgDeBT0mg3USw3nsHnDKz1PNB10D9sWPHFs+dO0cul9tBe8d25PP55fPnzxevXr26Zz1gSSkgD3xO+xDZPGNJMwu8zjqyMTNyuVz57NmzlVwutw94CpvL5fadOXOmks1ml9YW9bwFwBtJORI9pLZl1ttL7z2ZTKZncHBwzzr+3NDQ0CvZbLbHe7+ua2AfCet9J3UyvaGTMAy1wVskKRUEwWYvck9SgMSlCyhvAEO5XK5Wq9WF9cYrlcpCuVyubVLqll4qrJl5M5sws/gFB84xOTmZHh0d9d77yrNj3vvK6OioTU5O9ji3bqgYuAN4EliiOjs0NCRgD/Dj549YSbRarXBiYqKnVqvNZDKZmvc+tbi4OHPx4sXlS5cu5er1emoD2CbwR+B6oVDYsnQlEnY+n5eZDQJjkoY2yD5hGMapVIogCII4juPV1VWiKAo2kUAByEuaHBsb2xI2qWYNmJF0gU22LIqioFarBcvLy9RqtWALUA/8RdIsCZuZxAd8Pp9H0mtm9mdgJOm8TeyqpDOPpqfv1BsNnIfYO4LA450Q0NtocHx2lvNrExI3EYVCgcHBwWVJZeBtYOe3AJ2J4/iDyXv3rvtWq9/DLhm7zLTbOeszqU+QCqOI3tjHUe47emNvf2f9qKQW8Hczewv4paSuTinNzDdWVm7Pz80NEMc/NwgdOBwKXLvHcG1Z+EYqHV1/NV1ycGsm1kTizD7J7tDQUAu4K+l7wDAdSMmAVrN5b7FY/LzVbEpSv0k71prxXsnad7MdEn2gfsRexFAM1Y5gnwAfOnSoDMwDb5vZQNLe1sfxUmVp6Z+1avXR2k6Z2mtYu9S+SwYyqd39GNaF2VzHsE+ADxw4MCnJAceTyMHMolq1+kW5VLph7RYsQSQJM5n0yKRrnRy3/2NdXV2xmf0J+BtblB4zY3V19eulUum6994nABXgDBrAlw4uu3T64bb/GzSbTXp6ekpRFH1oZt8F3toIwsfx3HKp9EXUbNbXWYpArHWQhvCY1YG7SLeB+6WenuquVit56XrepqamOHjwIMBjM6tJOrXWTD/NpiTM+9Xl5eUrlXK5AE8/cdrbixwIYRFoBXho4j9hGH7qvb/1k6mp2bu7dzdfrdX4enp6ez85nrV8Pk+j0Rjo6ur6rXPunKTwKahZ3KjX/73w+PFnURQ11tpIrY03gZoZJWFTkpuIYd5EtFIsxjsGBiAI+OaZb7NvDQswMjKi7u7uN8MwPC/ph0/k0Go27xXn5y+v1OsLtA+gFlCS9Jj28X0/CMOHGC3vI+JWbBYG9Pb1cfPGjRfivBRYgBMnTiDpZ2EY/kFSNo7jSnlx8fJSqXTLOVcCZjB7YDDbm07PrayuNiQRdHWxf2SEf3z00ZYxXhoswNGjR9PpdPo3QRD8olFf+aw4//hCFMf3BMVAWrrf3V3LNhqkurv5amKiY//brgbrWRAEjVar9Xsn99dms1WKvC/6Bw8awf79mBk/Wljgk2Jx2/7/C8D87PcyjeWGAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIzLTA1LTI1VDAwOjI4OjU5KzAwOjAwM8i5WwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMy0wNS0yNFQyMzoxMTowOSswMDowMJ1Oe7oAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC",
      anchor: [0.5, 1]
    },
    {
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAAgCAYAAACLmoEDAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH5wUZACIpx2TIswAABNVJREFUWMO9l8trXHUUxz/nd+/NPJK5k5kmzbRG2iRWijZmESit0qUbaVb+A0JXLhRclK5EVETcuNCFLQhiF4K4asFVtbT1UZ8JsSbBzjQ1qU3zntQkzCRz7z0u7kRazKSTzI0HDhd+j+/5/n7n/M45V4hGBGgD0kAcsAEPKANLwAKgURhpdP9TwHHgBNAH5IAWYAWYBoaBa8APwGgUpHciOeDVKgmtQ68DrwAd/ydJAQ4DnwCrdRLd0NXqvsM07tW6iB4CvgAq2yS6oRXgc+CJ3SacAT5sgOiDhD+o4u2KWMCLwHKDRDd0uYpn7QbZNuByREQ39FIVty6x61xngGeAo1us0f7+/umBgQErk8m0FovFpYsXL/qDg4M5asfmcaAXuEKEKc0G3qVGrIqIPzAwMFcoFKZUdUVVPVVdyefzUydPnpwDAmrH7jvbuLS6pAm4UMtoT0/P4vDw8Liq+vqw+ENDQ+Pd3d2LNcgGVdymekiYOskKYRHY1J0HDx5M9Pb27tkEz/T19WW7uroSW+B2UGcK2871x2tNOI5ji8imBkUk5jjOVi8+QZ1S780C3K81MT8/v1IsFuc3m1tcXJyfm5tb3QJ3KWqyAZAH/M0mR0dH4+fOnQt8319+cNz3/eWzZ8/q2NhYrdvzgZtV/MjEAk4BJWrkzHQ6vXbmzJlCoVCYnJ2dLRUKhcnTp08XXNddo3aeLVVxIy0MAnQDt7YwrLZte67retlsVl3X9Wzb9ti6KNwCutiFHiEBvE3ouiiqlw+8xTYe2HZP9CTwKXAsgsNfB156PJe7acdimAD8wGBZAYERBEiWy5yYnuaj6obtxsrfhFnhOSDVANF7xpj3Ojs7h+KO4waQFiWtKq3GaIuKtAjEbM8j6Qe+t/8xOdLmyk5iJQm8AbwGODvYHyTj8Wt729sv2JZVRtXWMCtJ6GhVRMLqpngoRQMjYjS/k1dYAQrA00AP2wwlx3Fut2Wz38SamgRwVaRZRJKhavhVbRahBcRFaEPo9mFlpynjPjBHGA51N9DGmKVMOv11qrl5qjqk8tCjk/AroiAqoioioqiD6kwj+e1PQvedoL5w8FqSye/3ZDI3JHRzHSKCqqjIlIr82AhZBf4gzL9HeEQ4xGOxkfZs9lvLstbrYQkYhbLAqIhckXj8bqOVo0yY2I8C+2otsixrZk8mcykRjxc3ObOAiGr1sEKA6iowgsh3AoPFZHI+5nkaRZmbJfzFfh6IbXJFa67rXk6nUuMPNGahexEDgqAeSAm4q8Ivtm1fCYJg5IWJielCa+t6++oqY5OT0ZQ5y7IyQRC8qaov83Db6Sfj8Z/3trVdtW27HHJHVBURWQdWVSkKOiFi8j7MqeCVFhb85kwGLItb4+P/gkXyO2GMWTLGfOx5Xr+qPrsx7tj2ZGs6/att22VVtQjTXlFEZoF7InLHduy7KJUg8JCKr9gWbQcO8PuNG/+xEwnZSqWijuP8Zox53/f9LmCfEVl2U6mfkonETJXgPVT/UphOxGIzpbW1chgQQufxY3x1/vwj7UTa7aRSqXipVHrd9/1TyXjiasfe9s+MMbdRXbBElu40Na3uK5eJNTUxms9vGz9SsolEAlXNVtYr+9NuupjraF+oTEyUNZfDAIeWl/lyYWHH+P8AZ0RW2q2R2psAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDUtMjVUMDA6Mjg6NTkrMDA6MDAzyLlbAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA1LTI0VDIzOjExOjE5KzAwOjAwUeR7JAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=",
      anchor: [0.5, 1]
    }
  ]
};
var MarkersOther_default = MarkersOther;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Drawing/DrawingDOM.js
var logger16 = LoggerByDefault_default2.getLogger("DrawingDOM");
var DrawingDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPdrawing");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show mouse position control
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowDrawingPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowDrawingPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowDrawingPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-drawing");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", this.options.labels.control);
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowDrawingClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowDrawingClick(e);
      });
    }
    return button;
  },
  /**
   * Drawing panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createDrawingPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPdrawingPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createDrawingPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  _createDrawingToolsDivSections: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__content fr-px-3w fr-modal__content";
    return div;
  },
  _createDrawingButtonsPluginDiv: function() {
    var div = document.createElement("div");
    div.className = "container-buttons-plugin fr-mx-2w";
    return div;
  },
  // ################################################################### //
  // ####################### Panel container ########################### //
  // ################################################################### //
  /**
  * Creates drawing Panel header DOM structure
  * @returns {HTMLElement} DOM element
  */
  _createDrawingPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header fr-m-1w";
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    divTitle.innerHTML = this.options.controlLabel || "Annoter la carte";
    container.appendChild(divTitle);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPdrawingPanelClose");
    divClose.className = "GPpanelClose GPdrawingPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer le panneau";
    var dtObj = this;
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(dtObj._addUID("GPshowDrawingPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(dtObj._addUID("GPshowDrawingPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Creates drawing tools section.
   *
   * @returns {HTMLElement} DOM element
   */
  _createDrawingToolsSections: function() {
    var tools = [];
    this.dtOptions = {};
    if (this.options.tools.points) {
      this.dtOptions.points = {
        label: this.options.labels.points,
        active: false,
        panel: "draw",
        id: "point"
      };
    }
    if (this.options.tools.lines) {
      this.dtOptions.lines = {
        label: this.options.labels.lines,
        active: false,
        panel: "draw",
        id: "line"
      };
    }
    if (this.options.tools.polygons) {
      this.dtOptions.polygons = {
        label: this.options.labels.polygons,
        active: false,
        panel: "draw",
        id: "polygon"
      };
    }
    if (this.options.tools.holes) {
      this.dtOptions.holes = {
        label: this.options.labels.holes,
        active: false,
        panel: "draw",
        id: "holes"
      };
    }
    if (this.options.tools.text) {
      this.dtOptions.text = {
        label: this.options.labels.text,
        active: false,
        panel: "draw",
        id: "text"
      };
    }
    if (this.options.tools.edit) {
      this.dtOptions.edit = {
        label: this.options.labels.edit,
        active: false,
        panel: "edit",
        id: "edit"
      };
    }
    if (this.options.tools.display) {
      this.dtOptions.display = {
        label: this.options.labels.display,
        active: false,
        panel: "edit",
        id: "display"
      };
    }
    if (this.options.tools.tooltip) {
      this.dtOptions.tooltip = {
        label: this.options.labels.tooltip,
        active: false,
        panel: "edit",
        id: "tooltip"
      };
    }
    if (this.options.tools.remove) {
      this.dtOptions.remove = {
        label: this.options.labels.remove,
        active: false,
        panel: "edit",
        id: "remove"
      };
    }
    if (this.dtOptions.points || this.dtOptions.lines || this.dtOptions.polygons || this.dtOptions.text) {
      tools.push(this._createDrawingToolSection(this.options.labels.creatingTools, "draw"));
    }
    if (this.dtOptions.edit || this.dtOptions.display || this.dtOptions.tooltip || this.dtOptions.remove) {
      tools.push(this._createDrawingToolSection(this.options.labels.editingTools, "edit"));
    }
    if (this.options.tools.export) {
      tools.push(this._createSavingSection(
        this.options.labels.export,
        this.options.labels.exportTitle
      ));
    }
    return tools;
  },
  /**
   * Creates drawing tool section DOM structure.
   *
   * @param {String} sectionLabel - section title
   * @param {String} panelType - Drawing ("draw") or editing ("edit") tools panel
   * @returns {HTMLElement} DOM element
   */
  _createDrawingToolSection: function(sectionLabel, panelType) {
    var container = document.createElement("div");
    container.className = "drawing-tool-section fr-mx-2w";
    var p2 = document.createElement("p");
    p2.className = "drawing-tool-section-title";
    p2.innerHTML = sectionLabel;
    container.appendChild(p2);
    var ul = document.createElement("div");
    ul.className = "drawing-tools-flex-display";
    var context = this;
    function liClickHandler(e) {
      context._handleDOMToolClick(e, this.id, context);
      context._handleToolClick(e, this.id, context);
    }
    for (var type in this.dtOptions) {
      if (this.dtOptions[type].panel !== panelType) {
        continue;
      }
      var li = document.createElement("button");
      li.className = "drawing-tool fr-btn fr-btn--tertiary gpf-btn--tertiary";
      li.id = this._addUID("drawing-tool-" + this.dtOptions[type].id);
      li.title = this.dtOptions[type].label;
      li.addEventListener("click", liClickHandler);
      ul.appendChild(li);
    }
    container.appendChild(ul);
    return container;
  },
  /**
   * Creates drawing tool section DOM structure.
   *
   * @param {String} buttonLabel - Button label
   * @param {String} buttonTitle - Button title
   * @returns {HTMLElement} DOM element
   */
  _createSavingSection: function(buttonLabel, buttonTitle) {
    var container = document.createElement("div");
    container.className = "drawing-tool-section drawing-tools-flex-display fr-m-1w";
    var button = document.createElement("button");
    button.title = buttonTitle;
    button.className = "tool-form-submit drawing-button fr-btn fr-btn--secondary gpf-btn--secondary fr-m-1w";
    button.id = this._addUID("drawing-export");
    button.setAttribute("type", "button");
    button.textContent = buttonLabel;
    var context = this;
    button.onclick = function() {
      context.onExportFeatureClick();
    };
    container.appendChild(button);
    return container;
  },
  /**
   * Creates input for color choosing
   *
   * @param {Object} options - options
   * @param {String} options.defaultValue - defaultValue
   * @param {String} options.className - input className
   * @returns {HTMLElement} - created li element
   */
  _createMarkersChooser: function(options) {
    var li = document.createElement("div");
    li.className = options.className;
    var globalHiddenInput = document.createElement("input");
    globalHiddenInput.type = "checkbox";
    globalHiddenInput.className = "gpf-custom-dropdown-toggle";
    globalHiddenInput.id = this._addUID(`gpf-custom-dropdown-toggle`);
    li.appendChild(globalHiddenInput);
    var span = document.createElement("span");
    span.innerText = "SÃ©lectionner le pictogramme :";
    li.appendChild(span);
    for (var i = 0; i < this.options.markersList.length; i++) {
      var hiddenInput = document.createElement("input");
      hiddenInput.type = "radio";
      hiddenInput.name = "gpf-dropdown-radio-style";
      hiddenInput.value = this.options.markersList[i].src;
      hiddenInput.className = "gpf-custom-dropdown-display";
      hiddenInput.id = this._addUID(`gpf-custom-dropdown-display-${i}`);
      li.appendChild(hiddenInput);
      if (i === 0) {
        hiddenInput.checked = true;
      }
      var labelToggle = document.createElement("label");
      labelToggle.htmlFor = this._addUID(`gpf-custom-dropdown-toggle`);
      labelToggle.className = "fr-select GPselect gpf-select";
      li.appendChild(labelToggle);
      var selectedImg = document.createElement("img");
      selectedImg.src = this.options.markersList[i].src;
      selectedImg.alt = `Option ${i + 1}`;
      labelToggle.appendChild(selectedImg);
    }
    var dropdownOptions = document.createElement("div");
    dropdownOptions.className = "gpf-custom-dropdown-options";
    li.append(dropdownOptions);
    for (var i = 0; i < this.options.markersList.length; i++) {
      var label = document.createElement("label");
      label.htmlFor = this._addUID(`gpf-custom-dropdown-display-${i}`);
      label.className = "gpf-custom-dropdown-option";
      dropdownOptions.appendChild(label);
      var optionImg = document.createElement("img");
      optionImg.src = this.options.markersList[i].src;
      optionImg.alt = `Option ${i + 1}`;
      label.appendChild(optionImg);
      label.addEventListener("click", () => {
        globalHiddenInput.click();
      });
    }
    return li;
  },
  /**
   * Creates input for color choosing
   *
   * @param {Object} options - options
   * @param {String} options.label - label
   * @param {String} options.type - input type for element ("color")
   * @param {String} options.defaultValue - defaultValue
   * @param {String} options.id - input id
   * @param {String} options.title - input title
   * @param {String} options.className - input className
   * @returns {HTMLElement} - created li element
   */
  _createStylingElement: function(options) {
    var li = document.createElement("div");
    li.className = options.className;
    var textNode = document.createTextNode(options.label);
    li.appendChild(textNode);
    var inputElem = document.createElement("input");
    try {
      inputElem.type = options.type;
    } catch (e) {
      inputElem.type = "text";
    }
    if (options.type === "range") {
      li.dataset.frJsRange = "true";
      li.title = options.label;
      var value2 = options.defaultValue;
      value2 = Math.round((value2 - options.min) / (options.max - options.min) * 100);
      li.style.setProperty("--progress-right", value2 + "%");
      inputElem.addEventListener("change", (e) => {
        e.target.parentNode.style.setProperty("--progress-right", `${(e.target.value - options.min) / (options.max - options.min) * 100}%`);
      });
    }
    inputElem.id = options.id;
    inputElem.value = options.defaultValue;
    if (options.title) {
      inputElem.title = options.title;
    }
    if (options.checked !== void 0) {
      inputElem.checked = options.checked;
    }
    if (options.min !== void 0) {
      inputElem.min = options.min;
    }
    if (options.max !== void 0) {
      inputElem.max = options.max;
    }
    if (options.step !== void 0) {
      inputElem.step = options.step;
    }
    li.appendChild(inputElem);
    return li;
  },
  /**
   * Creates Styling div to include in popup.
   *
   * @param {Object} options - toolId selected
   * @param {String} options.geomType - gemeotryType selected ("Point", "Line" or "Polygon")
   * @param {Object} options.labels - values to title
   * @param {Object} options.initValues - values to init fields
   * @param {Function} options.applyFunc - function called when apply is selected
   * @returns {HTMLElement} DOM element created
   */
  _createStylingDiv: function(options) {
    var dialog = document.createElement("dialog");
    dialog.className = "gp-styling-div gpf-panel fr-modal gpf-visible GPelementVisible";
    var mainDiv = document.createElement("div");
    mainDiv.className = "gpf-modal__body fr-modal__body";
    dialog.appendChild(mainDiv);
    if (CheckDsfr_default()) {
      var header = document.createElement("div");
      header.className = "GPpanelHeader gpf-panel__header fr-modal__header fr-m-1w";
      var divTitle = document.createElement("div");
      divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
      divTitle.innerHTML = "Modifier le style";
      header.appendChild(divTitle);
      var divClose = document.createElement("button");
      divClose.id = this._addUID("GPdrawingStylePanelClose");
      divClose.className = "GPpanelClose GPdrawingStylePanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
      divClose.title = "Fermer le panneau";
      var dtObj = this;
      if (divClose.addEventListener) {
        divClose.addEventListener("click", function() {
          options.applyFunc.call(this, "cancel");
        }, false);
      } else if (divClose.attachEvent) {
        divClose.attachEvent("onclick", function() {
          options.applyFunc.call(this, "cancel");
        });
      }
      var span = document.createElement("span");
      span.className = "GPelementHidden gpf-visible";
      span.innerText = "Fermer";
      divClose.appendChild(span);
      header.appendChild(divClose);
      mainDiv.appendChild(header);
    }
    var div = document.createElement("div");
    div.className = "gpf-panel__content fr-px-3w fr-modal__content";
    mainDiv.appendChild(div);
    var ul = document.createElement("div");
    var li = null;
    var geomType = options.geomType.toLowerCase();
    switch (geomType) {
      case "point&text":
      case "point":
        li = this._createMarkersChooser({
          className: "gp-styling-option",
          // defaultValue : this.options.markersList[0].src
          defaultValue: options.initValues.markerSrc
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option fr-range fr-range--sm",
          label: this.options.labels.markerSize,
          title: "petit, moyen ou grand",
          id: this._addUID("markerSize"),
          min: 5,
          max: 15,
          step: 5,
          defaultValue: options.initValues.markerSize * 10
        });
        ul.appendChild(li);
        if (options.initValues.markerCustom) {
        }
        if (geomType === "point&text") {
          li = this._createStylingElement({
            type: "checkbox",
            className: "gp-styling-option",
            label: this.options.labels.labelDisplay,
            id: this._addUID("labelDisplay"),
            checked: options.initValues.labelDisplay,
            defaultValue: options.initValues.labelDisplay
          });
          ul.appendChild(li);
        }
        break;
      case "text":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.fillColor,
          id: this._addUID("fillColor"),
          defaultValue: options.initValues.fillColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option",
          label: this.options.labels.strokeWidth,
          title: "1 Ã  10 pixels",
          id: this._addUID("strokeWidth"),
          min: 1,
          max: 10,
          step: 1,
          defaultValue: options.initValues.strokeWidth
        });
        ul.appendChild(li);
        break;
      case "line":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option fr-range fr-range--sm",
          label: this.options.labels.strokeWidth,
          title: "1 Ã  10 pixels",
          id: this._addUID("strokeWidth"),
          min: 1,
          max: 10,
          step: 1,
          defaultValue: options.initValues.strokeWidth
        });
        ul.appendChild(li);
        break;
      case "polygon":
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.strokeColor,
          id: this._addUID("strokeColor"),
          defaultValue: options.initValues.strokeColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option fr-range fr-range--sm",
          label: this.options.labels.strokeWidth,
          title: "1 Ã  10 pixels",
          id: this._addUID("strokeWidth"),
          min: 1,
          max: 10,
          step: 1,
          defaultValue: options.initValues.strokeWidth
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "color",
          className: "gp-styling-option",
          label: this.options.labels.fillColor,
          id: this._addUID("fillColor"),
          defaultValue: options.initValues.fillColor
        });
        ul.appendChild(li);
        li = this._createStylingElement({
          type: "range",
          className: "gp-styling-option fr-range fr-range--sm",
          label: this.options.labels.fillOpacity,
          title: "0 (transparent) Ã  100% (opaque)",
          id: this._addUID("fillOpacity"),
          min: 0,
          max: 10,
          step: 1,
          defaultValue: options.initValues.fillOpacity * 10
        });
        ul.appendChild(li);
        break;
      default:
        logger16.log("Unhandled geometry type for styling.");
    }
    div.appendChild(ul);
    var divWrapper = document.createElement("div");
    divWrapper.className = "gpf-flex-row";
    div.appendChild(divWrapper);
    var applyButton = document.createElement("input");
    applyButton.type = "button";
    applyButton.className = "gp-styling-button fr-btn fr-btn--secondary";
    applyButton.value = this.options.labels.applyToObject;
    applyButton.onclick = function() {
      options.applyFunc.call(this, "apply");
    };
    var setDefaultButton = document.createElement("input");
    setDefaultButton.type = "button";
    setDefaultButton.value = this.options.labels.setAsDefault;
    setDefaultButton.className = "gp-styling-button fr-btn fr-btn--tertiary";
    setDefaultButton.onclick = function() {
      options.applyFunc.call(this, "default");
    };
    divWrapper.appendChild(setDefaultButton);
    divWrapper.appendChild(applyButton);
    var cancelButton = document.createElement("input");
    cancelButton.type = "button";
    cancelButton.className = "gp-styling-button closer";
    cancelButton.onclick = function() {
      options.applyFunc.call(this, "cancel");
    };
    div.appendChild(cancelButton);
    return dialog;
  },
  /**
   * Creates Text editing div to include in popup.
   *
   * @param {Object} options - options for popup
   * @param {String} options.geomType - gemeotryType selected ("Point", "Line" or "Polygon")
   * @param {String} options.text - text to fill input.
   * @param {String} options.key - property name called when text is to be saved.
   * @param {String} options.measure - measure to fill input.
   * @param {String} options.placeholder - placeholder for text input.
   * @param {String} options.inputId - text input id.
   * @param {Function} options.applyFunc - function called when text is to be saved.
   * @returns {HTMLElement} DOM element created
   * @private
   */
  _createLabelDiv: function(options) {
    var popup = document.createElement("dialog");
    popup.className = "gp-label-div gpf-panel fr-modal gpf-visible GPelementVisible";
    var mainDiv = document.createElement("div");
    mainDiv.className = "gpf-modal__body fr-modal__body";
    popup.appendChild(mainDiv);
    if (CheckDsfr_default()) {
      var header = document.createElement("div");
      header.className = "GPpanelHeader gpf-panel__header fr-modal__header fr-m-1w";
      var divTitle = document.createElement("div");
      divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
      divTitle.innerHTML = "Ajouter une description";
      if (options.geomType === "Text") {
        divTitle.innerHTML = "Texte de l'annotation";
      }
      header.appendChild(divTitle);
      var divClose = document.createElement("button");
      divClose.id = this._addUID("GPdrawingStylePanelClose");
      divClose.className = "GPpanelClose GPdrawingStylePanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
      divClose.title = "Fermer le panneau";
      var dtObj = this;
      if (divClose.addEventListener) {
        divClose.addEventListener("click", function() {
          options.applyFunc.call(this, "cancel");
        }, false);
      } else if (divClose.attachEvent) {
        divClose.attachEvent("onclick", function() {
          options.applyFunc.call(this, "cancel");
        });
      }
      var span = document.createElement("span");
      span.className = "GPelementHidden gpf-visible";
      span.innerText = "Fermer";
      divClose.appendChild(span);
      header.appendChild(divClose);
      mainDiv.appendChild(header);
    }
    var div = document.createElement("div");
    div.className = "gpf-panel__content fr-px-3w fr-modal__content";
    mainDiv.appendChild(div);
    var inputLabel = null;
    if (options.geomType === "Text") {
      inputLabel = document.createElement("input");
      inputLabel.type = "text";
      inputLabel.className = "gp-input-label-style fr-input fr-mb-3w";
    } else {
      inputLabel = document.createElement("textArea");
      inputLabel.rows = 2;
      inputLabel.cols = 40;
      inputLabel.className = "gp-textarea-att-label-style fr-input";
    }
    if (options.text) {
      inputLabel.value = options.text;
    }
    inputLabel.autocomplete = "off";
    inputLabel.placeholder = options.placeholder;
    inputLabel.id = options.inputId;
    div.appendChild(inputLabel);
    inputLabel.onkeyup = function(evtk) {
      if (options.geomType === "Text" && evtk.keyCode === 13) {
        options.applyFunc.call(this, options.key, inputLabel.value, true);
      }
      if (evtk.keyCode === 27) {
        options.applyFunc.call(this, options.key, inputLabel.value, false);
      }
    };
    if (options.measure && options.geomType !== "Text") {
      var inputMeasure = document.createElement("input");
      inputMeasure.type = "text";
      inputMeasure.readonly = true;
      inputMeasure.className = "gp-input-measure-style";
      inputMeasure.value = options.measure;
      div.appendChild(inputMeasure);
    }
    var applyButton = document.createElement("input");
    applyButton.type = "button";
    applyButton.className = "gp-styling-button fr-btn fr-btn--tertiary";
    applyButton.value = this.options.labels.saveDescription;
    applyButton.onclick = function() {
      options.applyFunc.call(this, options.key, inputLabel.value, true);
    };
    div.appendChild(applyButton);
    var cancelButton = document.createElement("input");
    cancelButton.type = "button";
    cancelButton.className = "gp-styling-button closer";
    cancelButton.onclick = function() {
      options.applyFunc.call(this, options.key, inputLabel.value, false);
    };
    div.appendChild(cancelButton);
    return popup;
  },
  /**
   * Handles drawing tool selection from a DOM point of view.
   *
   * @param {Event} e - DOM Event
   * @param {String} toolId - toolId selected
   * @param {DrawingDOM} context - Drawing control instance
   */
  _handleDOMToolClick: function(e, toolId, context) {
    for (var availType in context.dtOptions) {
      var availToolId = context._addUID("drawing-tool-" + context.dtOptions[availType].id);
      var li = document.getElementById(availToolId);
      if (availToolId !== toolId) {
        li.className = "drawing-tool fr-btn fr-btn--tertiary gpf-btn--tertiary";
        context.dtOptions[availType].active = false;
        continue;
      }
      if (context.dtOptions[availType].active) {
        li.className = "drawing-tool fr-btn fr-btn--tertiary gpf-btn--tertiary";
      } else {
        li.className = "drawing-tool drawing-tool-active fr-btn fr-btn--tertiary gpf-btn--tertiary";
      }
      context.dtOptions[availType].active = !context.dtOptions[availType].active;
    }
  }
};
var DrawingDOM_default = DrawingDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Drawing/Drawing.js
var logger17 = LoggerByDefault_default2.getLogger("Drawing");
var _Drawing = class _Drawing extends Control_default2 {
  /**
   * @constructor
  * @param {Object} options - options for function call.
  * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {Boolean} [options.collapsed = true] - Specify if Drawing control should be collapsed at startup. Default is true.
  * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
  * @param {Object} [options.layer = {}] - Openlayers layer that will hosts created features. If none, an empty vector layer will be created.
  * @param {Object} [options.popup = {}] - Popup informations
  * @param {Boolean} [options.popup.display = true] - Specify if popup is displayed when create a drawing
  * @param {Function} [options.popup.function] - Function to display popup informations if you want to cutomise it. You may also provide your own function with params : {geomType / feature / saveFunc(message) / closeFunc()}. This function must return the DOM object of the popup content.
  * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
  * @param {String} [options.layerDescription.title = "Croquis"] - Layer title to be displayed in LayerSwitcher
  * @param {String} [options.layerDescription.description = "Mon croquis"] - Layer description to be displayed in LayerSwitcher
  * @param {Object} options.tools - Tools to display in the drawing toolbox. All by default.
  * @param {Boolean} [options.tools.points = true] - Display points drawing tool
  * @param {Boolean} [options.tools.lines = true] - Display lines drawing tool
  * @param {Boolean} [options.tools.polygons = true] - Display polygons drawing tool
  * @param {Boolean} [options.tools.holes = false] - Display polygons with holes drawing tool
  * @param {Boolean} [options.tools.text = true] - Display text drawing tool
  * @param {Boolean} [options.tools.remove = true] - Display feature removing tool
  * @param {Boolean} [options.tools.display = true] - Display style editing tool
  * @param {Boolean} [options.tools.tooltip = true] - Display text editing tool
  * @param {Boolean} [options.tools.edit = true] - Display editing tool
  * @param {Boolean} [options.tools.export = true] - Display exporting tool
  * @param {Boolean} [options.tools.measure = false] - Display measure drawing into popup info
  * @param {String} [options.labels] - Labels for Control
  * @param {String} [options.labels.control] - Label for Control
  * @param {String} [options.labels.points] - Label for points drawing tool
  * @param {String} [options.labels.lines] - Label for lines drawing tool
  * @param {String} [options.labels.polygons] - Label for polygons drawing tool
  * @param {String} [options.labels.holes] - Label for polygons with holes drawing tool
  * @param {String} [options.labels.text] - Label for text drawing tool
  * @param {String} [options.labels.edit] - Label for editing tool
  * @param {String} [options.labels.display] - Label for style editing tool
  * @param {String} [options.labels.tooltip] - Label for text editing tool
  * @param {String} [options.labels.remove] - Label for feature removing tool
  * @param {String} [options.labels.export] - Label for exporting tool.
  * @param {String} [options.labels.exportTitle] - Title for exporting tool.
  * @param {String} [options.labels.applyToObject] - Label for apply to object button.
  * @param {String} [options.labels.saveDescription] - Label for save description button.
  * @param {String} [options.labels.setAsDefault] - Label for set as default style button.
  * @param {String} [options.labels.strokeColor] - Label for stroke color.
  * @param {String} [options.labels.strokeWidth] - Label for stroke width.
  * @param {String} [options.labels.fillColor] - Label for fill color.
  * @param {String} [options.labels.fillOpacity] - Label for fillOpacity.
  * @param {String} [options.labels.markerSize] - Label for markerSize.
  * @param {Array.<Object>} [options.markersList = [{"src" : "data:image/png;base64,xxxx", "anchor" : [0.5,1]}]] - List of markers src to be used for points with their anchor offsets See {@link http://openlayers.org/en/latest/apidoc/ol.style.Icon.html OpenLayers params} for anchor offset options.
  * @param {Object} options.defaultStyles - Default styles applying to geometries (labels, lines and polygons).
  * @param {String} [options.defaultStyles.textFillColor = "#000000"] - Text fill color for labels (RGB hex value).
  * @param {String} [options.defaultStyles.textStrokeColor = "#ffffff"] - Text surrounding color for labels (RGB hex value).
  * @param {String} [options.defaultStyles.strokeColor = "#ffcc33"] - Stroke color (RGB hex value).
  * @param {Number} [options.defaultStyles.strokeWidth = 2] - Stroke width in pixels.
  * @param {String} [options.defaultStyles.polyStrokeColor = "#ffcc33"] - Stroke color (RGB hex value) for polygons.
  * @param {Number} [options.defaultStyles.polyStrokeWidth = 2] - Stroke width in pixels for polygons.
  * @param {String} [options.defaultStyles.polyFillColor = "#ffffff"] - Polygons fill color (RGB hex value).
  * @param {Number} [options.defaultStyles.polyFillOpacity = 0.2] - Polygon fill opacity (alpha value between 0:transparent and 1:opaque).
  * @param {Object} options.cursorStyle - cursor (circle) style when drawing or editing.
  * @param {String} [options.cursorStyle.fillColor = "rgba(0, 153, 255, 1)"] - Cursor fill color.
  * @param {String} [options.cursorStyle.strokeColor = "#ffffff"] - Cursor stroke color.
  * @param {String} [options.cursorStyle.strokeWidth = 1] - Cursor surrounding stroke width.
  * @param {String} [options.cursorStyle.radius = 6] - Cursor radius.
  * @fires drawing:add:before - event triggered before an layer is added
  * @fires drawing:add:after - event triggered after an layer is added
  * @example
  * var drawing = new ol.control.Drawing({
  *   collapsed : false,
  *   draggable : true,
  *   layerswitcher : {
  *      title : "Dessins",
  *      description : "Mes dessins..."
  *   },
  *   markersList : [{
  *      src : "http://api.ign.fr/api/images/api/markers/marker_01.png",
  *      anchor : [0.5, 1]
  *   }],
  *   defaultStyles : {},
  *   cursorStyle : {},
  *   tools : {
  *      points : true,
  *      lines : true,
  *      polygons :true,
  *      holes : true,
  *      text : false,
  *      remove : true,
  *      display : true,
  *      tooltip : true,
  *      export : true,
  *      measure : true
  *   },
  *   popup : {
  *      display : true,
  *      function : function (params) {
  *          var container = document.createElement("div");
  *          // - params.geomType;
  *          // - params.feature;
  *          // Les 2 fonctions ferment la popup avec ou sans sauvegarde des informations
  *          // dans les properties de la feature (key : description)
  *          // - params.saveFunc(message);
  *          // - params.closeFunc();
  *          return container;
  *      }
  * });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Drawing)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Drawing";
    this._initialize(options);
    this._container = this._initContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * Overload of {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html#setMap ol.control.Control.setMap()} method, called when control is added to or removed from map.
   *
   * @param {Map} map - {@link http://openlayers.org/en/latest/apidoc/ol.Map.html ol.Map} object.
   */
  setMap(map) {
    super.setMap(map);
    if (this.getMap() && this.eventKey) {
      unByKey(this.eventKey);
    }
    if (map == null) {
      return;
    }
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
    if (this.draggable) {
      Draggable_default.dragElement(
        this._drawingPanel,
        this._drawingPanelHeader,
        map.getTargetElement()
      );
    }
    if (!this.collapsed) {
      this._showDrawingButton.setAttribute("aria-pressed", true);
    }
    if (this.layer) {
      this.setLayer(this.layer);
    }
    this.eventKey = this.getMap().getLayers().on("remove", (evtRm) => {
      if (evtRm.element === this.layer) {
        this.layer = null;
        if (this.interactionCurrent) {
          this.getMap().removeInteraction(this.interactionCurrent);
          this.interactionCurrent = null;
        }
      }
    });
  }
  /**
   * Export features of current drawing layer (KML by default).
   *
   * @returns {String} a representation of drawn features (KML, GPX or GeoJSON) or null if not possible.
   */
  exportFeatures() {
    var result = null;
    if (Control_default2.prototype.getMap.call(this) == null) {
      logger17.log("Impossible to export : control isn't attached to any map.");
      return result;
    }
    if (!this.layer) {
      logger17.log("Impossible to export : no layer is hosting features.");
      return result;
    }
    if (!this.layer.getSource() || !this.layer.getSource().getFeatures() || !this.layer.getSource().getFeatures().length) {
      logger17.log("Impossible to export : no features found.");
      return result;
    }
    if (this.featuresCollectionSelected) {
      this.featuresCollectionSelected.clear();
    }
    var ClassName = null;
    switch (this.getExportFormat()) {
      case "KML":
        ClassName = new KML_default2({
          writeStyles: true
        });
        break;
      case "GPX":
        ClassName = new GPX_default2({
          // readExtensions : function (ext) {/* only extensions nodes from wpt, rte and trk can be processed */ }
        });
        break;
      case "GEOJSON":
        ClassName = new GeoJSON_default2({});
        break;
      default:
        break;
    }
    if (!ClassName) {
      logger17.log("Impossible to export : format unknown !?");
      return result;
    }
    var featProj = this.layer.getSource().getProjection();
    featProj = featProj || this.getMap().getView().getProjection();
    result = ClassName.writeFeatures(this.layer.getSource().getFeatures(), {
      dataProjection: "EPSG:4326",
      featureProjection: featProj
    });
    return result;
  }
  // ################################################################### //
  // #################### user interface methods ####################### //
  // ################################################################### //
  /**
   * Collapse or display control main container
   *
   * @param {Boolean} collapsed - True to collapse control, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger17.error("[ERROR] Drawing:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    this.onShowDrawingClick();
    this._showDrawingButton.click();
  }
  /**
   * Setter for Export Name.
   *
   * @param {String} name - Export Name. By default, "Croquis".
   */
  setExportName(name) {
    this._exportName = name;
  }
  /**
   * getter for Export Name.
   *
   * @returns {String} export name
   */
  getExportName() {
    return this._exportName;
  }
  /**
   * Setter for Export format (KML, GPX or GeoJSON).
   *
   * @param {String} format - Export format. By default, "KML".
   */
  setExportFormat(format) {
    this._exportFormat = format ? format.toUpperCase() : "KML";
    switch (format.toUpperCase()) {
      case "KML":
        this._exportExt = ".kml";
        this._exportMimeType = "application/vnd.google-earth.kml+xml";
        break;
      case "GPX":
        this._exportExt = ".gpx";
        this._exportMimeType = "application/gpx+xml";
        break;
      case "GEOJSON":
        this._exportExt = ".geojson";
        this._exportMimeType = "application/geo+json";
        break;
      default:
        this._exportFormat = "KML";
        break;
    }
  }
  /**
   * getter for Export format.
   *
   * @returns {String} export format
   */
  getExportFormat() {
    return this._exportFormat;
  }
  /**
   * Sets vector layer to hosts feature.
   *
   * @param {VectorLayer} vlayer - vector layer
   */
  setLayer(vlayer) {
    if (!vlayer) {
      this.layer = null;
      return;
    }
    if (!(vlayer instanceof Vector_default2)) {
      logger17.log("no valid layer given for hosting drawn features.");
      return;
    }
    var layers = this.getMap().getLayers();
    if (layers) {
      var found = false;
      layers.forEach((mapLayer) => {
        if (mapLayer === vlayer) {
          logger17.trace("layer already in map. Not adding.");
          found = true;
        }
      });
      if (!found) {
        this.getMap().addLayer(vlayer);
        this.dispatchEvent({
          type: this.ADD_AFTER_DRAWING_LAYER_EVENT,
          layer: vlayer
        });
      }
      vlayer.getSource().getFeatures().forEach((feature) => {
        var style = feature.getStyle();
        if (typeof style !== "function") {
          return;
        }
        var featureStyleFunction = feature.getStyleFunction();
        if (featureStyleFunction) {
          var styles = featureStyleFunction.call(this, feature, 0);
          if (styles && styles.length !== 0) {
            feature.setStyle(Array.isArray(styles) ? styles[0] : styles);
          }
        }
      });
      this.layer = vlayer;
      this.getMap().getControls().forEach(
        (control) => {
          if (control instanceof LayerSwitcher_default) {
            var layerId = this.layer.gpLayerId;
            if (layerId && control._layers[layerId].title === layerId) {
              control.addLayer(
                this.layer,
                {
                  title: this.options.layerDescription.title,
                  description: this.options.layerDescription.description
                }
              );
            }
          }
        }
      );
    }
  }
  /**
   * Get vector layer
   *
   * @returns {VectorLayer} layer - isocurve layer
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  /** Disable interaction */
  disable() {
    var map = this.getMap();
    Interactions_default.unset(map);
    for (var toolsType in this.dtOptions) {
      if (this.dtOptions.hasOwnProperty(toolsType)) {
        if (this.dtOptions[toolsType].active) {
          var toolsId = this._addUID("drawing-tool-" + this.dtOptions[toolsType].id);
          document.getElementById(toolsId).className = "drawing-tool fr-btn fr-btn--tertiary gpf-btn--tertiary";
          this.dtOptions[toolsType].active = false;
        }
      }
    }
  }
  // ################################################################### //
  // ######################## initialize control ####################### //
  // ################################################################### //
  /**
   * Gets marker options in options.markersList given its src.
   *
   * @param {String} src - marker image URI,
   * @returns {Object} markers options
   * @private
   */
  _getsMarkersOptionsFromSrc(src) {
    var markerOptions = null;
    for (var i = 0; i < this.options.markersList.length; i++) {
      if (src && this.options.markersList[i].src === src) {
        markerOptions = this.options.markersList[i];
        return markerOptions;
      }
    }
    return markerOptions;
  }
  /**
   * Converts markerElement options into Openlayers IconStyles options.
   *
   * @param {Object} markerElement - marker element
   * @returns {Object} ol.Style.Icon constructor options.
   * @private
   */
  _getIconStyleOptions(markerElement) {
    var iconOptions = {};
    Object.keys(markerElement).forEach((key) => {
      switch (key) {
        case "src":
        case "size":
        case "scale":
        case "color":
        case "anchor":
        case "anchorOrigin":
        case "anchorXUnits":
        case "anchorYUnits":
          iconOptions[key] = markerElement[key];
          break;
      }
    });
    return iconOptions;
  }
  /**
   * Initialize control (called by Drawing constructor)
   *
   * @method _initialize
   * @param {Object} options - control options (set by user)
   * @private
   */
  _initialize(options) {
    this._uid = options.id || SelectorID_default.generate();
    this._exportName = "Croquis";
    this._exportFormat = "KML";
    this._exportMimeType = "application/vnd.google-earth.kml+xml";
    this._exportExt = ".kml";
    options = options || {};
    this.options = options;
    this.options.layerDescription = Object.assign({
      title: "Croquis",
      description: "Mon croquis"
    }, options.layerDescription);
    if (!this.options.tools) {
      this.options.tools = {};
    }
    Object.keys(_Drawing.DefaultTools).forEach((key) => {
      if (!this.options.tools.hasOwnProperty(key)) {
        this.options.tools[key] = _Drawing.DefaultTools[key];
      }
    });
    if (!this.options.cursorStyle) {
      this.options.cursorStyle = {};
    }
    Object.keys(_Drawing.DefaultCursorStyle).forEach((key) => {
      if (!this.options.cursorStyle.hasOwnProperty(key)) {
        this.options.cursorStyle[key] = _Drawing.DefaultCursorStyle[key];
      }
    });
    this.options.collapsed = options.collapsed !== void 0 ? options.collapsed : true;
    this.collapsed = this.options.collapsed;
    this.options.draggable = options.draggable !== void 0 ? options.draggable : false;
    this.draggable = this.options.draggable;
    this.options.markersList = options.markersList || MarkersOther_default["drawing_api"];
    if (!this.options.labels) {
      this.options.labels = {};
    }
    Object.keys(_Drawing.DefaultLabels).forEach((key) => {
      if (!this.options.labels.hasOwnProperty(key)) {
        this.options.labels[key] = _Drawing.DefaultLabels[key];
      }
    });
    if (!this.options.defaultStyles) {
      this.options.defaultStyles = {};
    }
    Object.keys(_Drawing.DefaultStyles).forEach((key) => {
      if (!options.defaultStyles.hasOwnProperty(key)) {
        this.options.defaultStyles[key] = _Drawing.DefaultStyles[key];
        return;
      }
      if (key === "polyFillOpacity" && (options.defaultStyles[key] < 0 || options.defaultStyles[key] > 1)) {
        logger17.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.polyFillOpactity. Must be between 0 and 1");
        this.options.defaultStyles[key] = _Drawing.DefaultStyles[key];
        return;
      }
      if (key === "strokeWidth" || key === "polyStrokeWidth") {
        var intValue = parseInt(options.defaultStyles[key], 10);
        if (isNaN(intValue) || intValue < 0) {
          logger17.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.strokeWidth. Must be a positive interger value.");
          this.options.defaultStyles[key] = _Drawing.DefaultStyles[key];
          return;
        }
        this.options.defaultStyles[key] = intValue;
      }
      if (key === "markerSize") {
        var floatValue = parseFloat(options.defaultStyles[key]);
        if (isNaN(floatValue) || floatValue < 0) {
          logger17.log("Wrong value (" + options.defaultStyles[key] + ") for defaultStyles.markerSize. Must be a positive value.");
          this.options.defaultStyles[key] = _Drawing.DefaultStyles[key];
          return;
        }
        this.options.defaultStyles[key] = floatValue;
      }
    });
    this.interactionCurrent = null;
    this.interactionSelectEdit = null;
    this.featuresCollectionSelected = null;
    this.stylingOvl = null;
    this.popupOvl = null;
    this.tooltipOvl = null;
    this.tooltipElem = null;
    this.layer = null;
    if (this.options.layer && this.options.layer instanceof Vector_default2) {
      this.layer = this.options.layer;
    }
    this._isDesktop = this._detectSupport();
    if (!this.options.popup) {
      this.options.popup = {
        display: true,
        apply: null
      };
    }
    this.ADD_AFTER_DRAWING_LAYER_EVENT = "drawing:add:after";
    this.ADD_BEFORE_DRAWING_LAYER_EVENT = "drawing:add:before";
  }
  /**
   * Creates empty layer to host features
   *
   * @private
   */
  _createEmptyLayer() {
    var features = new Collection_default();
    var layer = new Vector_default2({
      source: new Vector_default({
        features
      }),
      title: this.options.layerDescription.title,
      description: this.options.layerDescription.description
    });
    layer.gpResultLayerId = "drawing";
    this.dispatchEvent({
      type: this.ADD_BEFORE_DRAWING_LAYER_EVENT,
      layer
    });
    this.setLayer(layer);
  }
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @method _detectSupport
   *
   * @returns {Boolean} is desktop
   * @private
   */
  _detectSupport() {
    var isDesktop = true;
    var userAgent2 = window.navigator.userAgent.toLowerCase();
    if (userAgent2.indexOf("iphone") !== -1 || userAgent2.indexOf("ipod") !== -1 || userAgent2.indexOf("ipad") !== -1 || userAgent2.indexOf("android") !== -1 || userAgent2.indexOf("mobile") !== -1 || userAgent2.indexOf("blackberry") !== -1 || userAgent2.indexOf("tablet") !== -1 || userAgent2.indexOf("phone") !== -1 || userAgent2.indexOf("touch") !== -1) {
      isDesktop = false;
    }
    if (userAgent2.indexOf("msie") !== -1 || userAgent2.indexOf("trident") !== -1) {
      isDesktop = true;
    }
    return isDesktop;
  }
  // ################################################################### //
  // ######################## methods handle dom ####################### //
  // ################################################################### //
  /**
   * Create control main container (called by Drawing constructor)
   *
   * @method _initContainer
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var picto = this._showDrawingButton = this._createShowDrawingPictoElement();
    container.appendChild(picto);
    var panel = this._drawingPanel = this._createDrawingPanelElement();
    var panelDiv = this._createDrawingPanelDivElement();
    panel.appendChild(panelDiv);
    var header = this._drawingPanelHeader = this._createDrawingPanelHeaderElement();
    panelDiv.appendChild(header);
    var sections = this._createDrawingToolsDivSections();
    panelDiv.appendChild(sections);
    var tools = this._createDrawingToolsSections();
    for (var i = 0; i < tools.length; i++) {
      sections.appendChild(tools[i]);
    }
    var containerButtonsPlugin = this._createDrawingButtonsPluginDiv();
    sections.appendChild(containerButtonsPlugin);
    container.appendChild(panel);
    return container;
  }
  // ################################################################### //
  // ##################### handlers events to control ################## //
  // ################################################################### //
  /**
   * Callback de fin de dessin de geometrie
   * @param {Feature} feature - ol feature
   * @param {String} geomType - geometry type
   * @param {Boolean} clean - clean last feature
   *
   * @private
   */
  _drawEndFeature(feature, geomType) {
    var style = null;
    switch (geomType) {
      case "Point":
        style = new Style_default({
          image: new Icon_default(this._getIconStyleOptions(this.options.markersList[0]))
        });
        break;
      case "LineString":
        style = new Style_default({
          stroke: new Stroke_default({
            color: this.options.defaultStyles.strokeColor,
            width: this.options.defaultStyles.strokeWidth
          })
        });
        break;
      case "Polygon":
        style = new Style_default({
          fill: new Fill_default({
            color: ColorUtils_default.hexToRgba(
              this.options.defaultStyles.polyFillColor,
              this.options.defaultStyles.polyFillOpacity
            )
          }),
          stroke: new Stroke_default({
            color: this.options.defaultStyles.polyStrokeColor,
            width: this.options.defaultStyles.polyStrokeWidth
          })
        });
        break;
    }
    feature.setStyle(style);
    this._updateMeasure(feature, geomType);
    if (this.options.popup.display) {
      var context = this;
      var setAttValue = function(key, value2, save2) {
        context.getMap().removeOverlay(context.popupOvl);
        context.popupOvl = null;
        if (save2 && value2 && value2.trim().length > 0) {
          var obj = {};
          obj[key] = value2.replace(/\n/g, "<br>");
          feature.setProperties(obj);
        }
      };
      var popup = null;
      var popupByDefault = true;
      var displayFunction = this.options.popup.function;
      if (displayFunction && typeof displayFunction === "function") {
        popup = displayFunction.call(context, {
          feature,
          geomType,
          closeFunc: function() {
            setAttValue(null, false);
          },
          saveFunc: function(message) {
            setAttValue(message, true);
          }
        });
        if (popup) {
          popupByDefault = false;
          popup.tabIndex = -1;
          popup.onblur = function() {
            context.getMap().removeOverlay(context.popupOvl);
            context.popupOvl = null;
          };
        }
      }
      if (popupByDefault) {
        popup = this._createLabelDiv({
          applyFunc: setAttValue,
          inputId: this._addUID("att-input"),
          placeholder: "Saisir une description... (facultatif)",
          measure: this.options.tools.measure ? feature.getProperties().measure : null,
          geomType,
          key: "description"
        });
      }
      if (this.popupOvl) {
        this.getMap().removeOverlay(this.popupOvl);
        this.popupOvl = null;
      }
      this.popupOvl = new Overlay_default({
        element: popup,
        // FIXME : autres valeurs.
        positioning: "top-center"
        // stopEvent : false
      });
      this.getMap().addOverlay(this.popupOvl);
      var geomExtent = feature.getGeometry().getExtent();
      this.popupOvl.setPosition([
        (geomExtent[0] + geomExtent[2]) / 2,
        (geomExtent[1] + geomExtent[3]) / 2
      ]);
      if (document.getElementById(this._addUID("att-input"))) {
        document.getElementById(this._addUID("att-input")).focus();
      }
    }
  }
  /**
   * Creates Interaction for features removal.
   *
   * @returns {SelectInteraction} created interaction.
   * @private
   */
  _createRemoveInteraction() {
    var interaction = new Select_default({
      // features : this.layer.getSource().getFeaturesCollection(),
      layers: [this.layer],
      style: false
    });
    interaction.on("select", (seEv) => {
      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }
      this.layer.getSource().removeFeature(seEv.selected[0]);
      this.getMap().removeInteraction(this.interactionCurrent);
      this.interactionCurrent = this._createRemoveInteraction();
      this.getMap().addInteraction(this.interactionCurrent);
    });
    return interaction;
  }
  /**
   * Creates Interaction for features style definition.
   *
   * @returns {SelectInteraction} created interaction.
   * @private
   */
  _createStylingInteraction() {
    var interaction = new Select_default({
      layers: [this.layer],
      style: false
    });
    interaction.on("select", (seEv) => {
      if (this.stylingOvl) {
        this.getMap().removeOverlay(this.stylingOvl);
      }
      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }
      var valuesColor = null;
      var hexColor = null;
      var popupOvl = null;
      var geomType = null;
      var initValues = {};
      var geom = seEv.selected[0].getGeometry();
      var style = seEv.selected[0].getStyle();
      if (geom instanceof Point_default || geom instanceof MultiPoint_default) {
        if (style && style.getImage() && typeof style.getImage().getSrc === "function" && style.getImage().getSrc() !== this.options.defaultStyles.textIcon1x1.src) {
          geomType = "Point";
          if (typeof style.getImage().getSrc === "function") {
            initValues.markerSrc = style.getImage().getSrc();
            initValues.markerSize = style.getImage().getScale() || 1;
            initValues.markerAnchor = style.getImage().getAnchor();
            if (style.getImage().getColor()) {
              valuesColor = style.getImage().getColor();
              if (Array.isArray(valuesColor)) {
                valuesColor = "rgba(" + valuesColor.join() + ")";
              } else {
                initValues.markerColor = valuesColor;
              }
              hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
                hex: valuesColor,
                opacity: 1
              };
              initValues.markerColor = hexColor.hex;
              initValues.markerOpacity = hexColor.opacity;
            } else {
              initValues.markerColor = this.options.markersList[0].color || "#ffffff";
            }
          } else {
            initValues.markerSrc = this.options.markersList[0].src;
            initValues.markerSize = this.options.markersList[0].scale || 1;
            initValues.markerColor = this.options.markersList[0].color || "#ffffff";
            initValues.markerAnchor = this.options.markersList[0].anchor;
          }
          initValues.markerCustom = !this._getsMarkersOptionsFromSrc(initValues.markerSrc);
        }
        if (style && style.getText()) {
          var labelName = seEv.selected[0].getProperties().name;
          if (labelName) {
            geomType = geomType === "Point" ? "Point&Text" : "Text";
            if (style.getText().getStroke() && style.getText().getStroke().getColor()) {
              valuesColor = style.getText().getStroke().getColor();
              if (Array.isArray(valuesColor)) {
                valuesColor = "rgba(" + valuesColor.join() + ")";
              } else {
                initValues.strokeColor = valuesColor;
              }
              hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
                hex: valuesColor,
                opacity: 1
              };
              initValues.strokeColor = hexColor.hex;
              initValues.strokeOpacity = hexColor.opacity;
            }
            if (style.getText().getStroke() && style.getText().getStroke().getWidth()) {
              initValues.strokeWidth = style.getText().getStroke().getWidth();
            }
            if (style.getText().getFill() && style.getText().getFill().getColor()) {
              valuesColor = style.getText().getFill().getColor();
              if (Array.isArray(valuesColor)) {
                valuesColor = "rgba(" + valuesColor.join() + ")";
              } else {
                initValues.fillColor = valuesColor;
              }
              hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
                hex: valuesColor,
                opacity: 1
              };
              initValues.fillColor = hexColor.hex;
              initValues.fillOpacity = hexColor.opacity;
            }
            initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : this.options.defaultStyles.textStrokeColor;
            initValues.strokeWidth = initValues.hasOwnProperty("strokeWidth") ? initValues.strokeWidth : this.options.defaultStyles.textStrokeWidth;
            initValues.fillColor = initValues.hasOwnProperty("fillColor") ? initValues.fillColor : this.options.defaultStyles.textFillColor;
            if (geomType === "Point&Text") {
              var value2 = style.getText().getText();
              if (!value2) {
                style.getText().setText(labelName);
              }
              var checked = seEv.selected[0].get("checked");
              initValues.labelDisplay = checked === void 0 ? this.options.defaultStyles.labelDisplay : checked;
            }
          }
        }
      } else if (geom instanceof LineString_default || geom instanceof MultiLineString_default) {
        geomType = "Line";
        if (style && style.getStroke()) {
          if (style.getStroke().getWidth()) {
            initValues.strokeWidth = style.getStroke().getWidth();
          }
          if (style.getStroke().getColor()) {
            valuesColor = style.getStroke().getColor();
            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.strokeColor = valuesColor;
            }
            hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.strokeColor = hexColor.hex;
            initValues.strokeOpacity = hexColor.opacity;
          }
        }
        initValues.strokeWidth = initValues.hasOwnProperty("strokeWidth") ? initValues.strokeWidth : this.options.defaultStyles.strokeWidth;
        initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : this.options.defaultStyles.strokeColor;
      } else if (geom instanceof Polygon_default || geom instanceof MultiPolygon_default) {
        geomType = "Polygon";
        if (style && style.getStroke()) {
          if (style.getStroke().getWidth()) {
            initValues.strokeWidth = style.getStroke().getWidth();
          }
          if (style.getStroke().getColor()) {
            valuesColor = style.getStroke().getColor();
            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.strokeColor = valuesColor;
            }
            hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.strokeColor = hexColor.hex;
            initValues.strokeOpacity = hexColor.opacity;
          }
        }
        if (style && style.getFill()) {
          if (style.getFill().getColor()) {
            valuesColor = style.getFill().getColor();
            if (Array.isArray(valuesColor)) {
              valuesColor = "rgba(" + valuesColor.join() + ")";
            } else {
              initValues.fillColor = valuesColor;
            }
            hexColor = ColorUtils_default.isRGB(valuesColor) ? ColorUtils_default.rgbaToHex(valuesColor) : {
              hex: valuesColor,
              opacity: 1
            };
            initValues.fillColor = hexColor.hex;
            initValues.fillOpacity = hexColor.opacity;
          }
        }
        initValues.strokeWidth = initValues.hasOwnProperty("strokeWidth") ? initValues.strokeWidth : this.options.defaultStyles.polyStrokeWidth;
        initValues.strokeColor = initValues.hasOwnProperty("strokeColor") ? initValues.strokeColor : this.options.defaultStyles.polyStrokeColor;
        initValues.fillColor = initValues.hasOwnProperty("fillColor") ? initValues.fillColor : this.options.defaultStyles.polyFillColor;
        initValues.fillOpacity = initValues.hasOwnProperty("fillOpacity") ? initValues.fillOpacity : this.options.defaultStyles.polyFillOpacity;
      }
      if (!geomType) {
        logger17.log("Unhandled geometry type for styling.");
        return;
      }
      var dtObj = this;
      var applyStyle2 = function(action) {
        if (action === "cancel") {
          dtObj.getMap().removeOverlay(popupOvl);
          return;
        }
        var setDefault = action !== "apply";
        var fillColorElem = document.getElementById(dtObj._addUID("fillColor"));
        var fillOpacityElem = document.getElementById(dtObj._addUID("fillOpacity"));
        var strokeColorElem = document.getElementById(dtObj._addUID("strokeColor"));
        var strokeWidthElem = document.getElementById(dtObj._addUID("strokeWidth"));
        var markerSizeElem = document.getElementById(dtObj._addUID("markerSize"));
        switch (geomType.toLowerCase()) {
          case "text":
            if (setDefault) {
              dtObj.options.defaultStyles.textStrokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.textStrokeWidth = strokeWidthElem.value;
              dtObj.options.defaultStyles.textFillColor = fillColorElem.value;
            } else {
              seEv.selected[0].setStyle(new Style_default({
                text: new Text_default({
                  font: "16px sans",
                  textAlign: "left",
                  text: style.getText().getText(),
                  fill: new Fill_default({
                    color: fillColorElem.value
                  }),
                  stroke: new Stroke_default({
                    color: strokeColorElem.value,
                    width: parseInt(strokeWidthElem.value, 10)
                  })
                })
              }));
            }
            break;
          case "point&text":
          case "point":
            var labelDisplay = document.querySelector("input[type='checkbox']");
            var markerSelected = null;
            var scale = parseInt(markerSizeElem.value, 10) / 10;
            var markerChecked = document.querySelector("input[name='gpf-dropdown-radio-style']:checked");
            if (markerChecked) {
              markerSelected = dtObj._getsMarkersOptionsFromSrc(markerChecked.value);
              markerSelected.scale = scale;
            }
            if (setDefault) {
              dtObj.options.defaultStyles.markerSize = scale;
              if (dtObj.options.markersList.length > 1) {
                var idxMarker = dtObj.options.markersList.findIndex(function(mrk) {
                  if (mrk === markerSelected) {
                    return true;
                  }
                  return false;
                });
                if (idxMarker > 0) {
                  dtObj.options.markersList.splice(idxMarker, 1);
                  dtObj.options.markersList.splice(0, 0, markerSelected);
                }
              }
              if (geomType.toLowerCase() === "point&text") {
                dtObj.options.defaultStyles.textStrokeColor = initValues.strokeColor;
                dtObj.options.defaultStyles.textStrokeWidth = initValues.strokeWidth;
                dtObj.options.defaultStyles.textFillColor = initValues.fillColor;
                dtObj.options.defaultStyles.labelDisplay = initValues.labelDisplay;
              }
            } else {
              var text = {};
              if (geomType.toLowerCase() === "point&text") {
                seEv.selected[0].set("checked", labelDisplay.checked);
                text = {
                  text: new Text_default({
                    font: "16px sans",
                    textAlign: "left",
                    text: labelDisplay.checked ? seEv.selected[0].get("name") : "",
                    fill: new Fill_default({
                      color: initValues.fillColor
                    }),
                    stroke: new Stroke_default({
                      color: initValues.strokeColor,
                      width: parseInt(initValues.strokeWidth, 10)
                    })
                  })
                };
              }
              if (markerSelected) {
                seEv.selected[0].setStyle(new Style_default(Object.assign({
                  image: new Icon_default(dtObj._getIconStyleOptions(markerSelected))
                }, text)));
              } else {
                seEv.selected[0].setStyle(new Style_default(Object.assign({
                  image: new Icon_default({
                    src: initValues.markerSrc,
                    // on garde le pictogramme initial !
                    // color : markerColorElem.value, // on recupÃ¨re la couleur !
                    anchor: initValues.markerAnchor,
                    // on garde la position initial !
                    anchorOrigin: "top-left",
                    anchorXUnits: "pixels",
                    anchorYUnits: "pixels",
                    scale
                  })
                }, text)));
              }
            }
            break;
          case "line":
            if (setDefault) {
              dtObj.options.defaultStyles.strokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.strokeWidth = parseInt(strokeWidthElem.value, 10);
            } else {
              seEv.selected[0].setStyle(new Style_default({
                stroke: new Stroke_default({
                  width: parseInt(strokeWidthElem.value, 10),
                  color: strokeColorElem.value
                })
              }));
            }
            break;
          case "polygon":
            var opacity = parseInt(fillOpacityElem.value, 10) / 10;
            if (setDefault) {
              dtObj.options.defaultStyles.polyStrokeColor = strokeColorElem.value;
              dtObj.options.defaultStyles.polyFillColor = fillColorElem.value;
              dtObj.options.defaultStyles.polyFillOpacity = opacity;
              dtObj.options.defaultStyles.polyStrokeWidth = parseInt(strokeWidthElem.value, 10);
            } else {
              seEv.selected[0].setStyle(new Style_default({
                stroke: new Stroke_default({
                  width: parseInt(strokeWidthElem.value, 10),
                  color: strokeColorElem.value
                }),
                fill: new Fill_default({
                  // color : fillColorElem.value
                  color: ColorUtils_default.hexToRgba(fillColorElem.value, opacity)
                })
              }));
            }
            break;
        }
        if (!setDefault) {
          dtObj.getMap().removeOverlay(popupOvl);
        }
      };
      var popupDiv = this._createStylingDiv({
        geomType,
        initValues,
        applyFunc: applyStyle2
      });
      popupOvl = new Overlay_default({
        element: popupDiv,
        // FIXME : autres valeurs.
        positioning: "top-center"
        // stopEvent : false
      });
      this.getMap().addOverlay(popupOvl);
      popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
      this.stylingOvl = popupOvl;
      this.getMap().removeInteraction(this.interactionCurrent);
      this.interactionCurrent = this._createStylingInteraction();
      this.getMap().addInteraction(this.interactionCurrent);
    });
    return interaction;
  }
  /**
   * Creates Interaction for text definition.
   *
   * @returns {SelectInteraction} created interaction.
   * @private
   */
  _createLabelInteraction() {
    var interaction = new Select_default({
      layers: [this.layer],
      style: false
    });
    interaction.on("select", (seEv) => {
      if (this.labelOvl) {
        this.getMap().removeOverlay(this.labelOvl);
      }
      if (!seEv || !seEv.selected || seEv.selected.length === 0) {
        return;
      }
      var popupOvl = null;
      var geomType = null;
      var _textValue = null;
      var _measure = null;
      var geom = seEv.selected[0].getGeometry();
      var style = seEv.selected[0].getStyle();
      if (geom instanceof Point_default || geom instanceof MultiPoint_default) {
        var _label = seEv.selected[0].getProperties().name;
        if (style && style.getText() && _label) {
          geomType = "Text";
        } else if (style && style.getImage()) {
          geomType = "Point";
        }
      } else if (geom instanceof LineString_default || geom instanceof MultiLineString_default) {
        geomType = "Line";
      } else if (geom instanceof Polygon_default || geom instanceof MultiPolygon_default) {
        geomType = "Polygon";
      } else {
        logger17.log("Geometry type for styling not supported .");
        return;
      }
      if (!geomType) {
        logger17.log("Unhandled geometry type for styling.");
        return;
      }
      if (geomType === "Text") {
        _textValue = style.getText().getText();
      } else {
        var featProps = seEv.selected[0].getProperties();
        if (featProps && (featProps.hasOwnProperty("description") || featProps.hasOwnProperty("desc"))) {
          _textValue = featProps["description"] || featProps["desc"];
        }
        if (featProps && featProps.hasOwnProperty("measure")) {
          _measure = featProps["measure"];
        }
      }
      var context = this;
      var setTextValue = function(key, value2, save2) {
        context.getMap().removeOverlay(popupOvl);
        if (!save2) {
          return;
        }
        var feature = seEv.selected[0];
        if (geomType === "Text") {
          var style2 = feature.getStyle();
          style2.getText().setText(value2);
          feature.setProperties({
            name: value2
          });
          feature.setStyle(style2);
          return;
        }
        var obj = {};
        obj[key] = value2.replace(/\n/g, "<br>");
        feature.setProperties(obj);
      };
      var popupDiv = this._createLabelDiv({
        applyFunc: setTextValue,
        inputId: this._addUID("label-input"),
        placeholder: geomType === "Text" ? "Saisir un label..." : "Saisir une description... (facultatif)",
        text: _textValue,
        key: "description",
        measure: this.options.tools.measure ? _measure : null,
        geomType
      });
      popupOvl = new Overlay_default({
        element: popupDiv,
        // FIXME : autres valeurs.
        positioning: "top-center"
        // stopEvent : false
      });
      this.getMap().addOverlay(popupOvl);
      popupOvl.setPosition(seEv.mapBrowserEvent.coordinate);
      document.getElementById(this._addUID("label-input")).focus();
      this.labelOvl = popupOvl;
      this.getMap().removeInteraction(this.interactionCurrent);
      this.interactionCurrent = this._createLabelInteraction();
      this.getMap().addInteraction(this.interactionCurrent);
    });
    return interaction;
  }
  /**
   * Callback de fin de modification du dessin afin de mettre Ã  jour la mesure
   * TODO
   * @param {Feature} feature - ol feature
   * @param {String} geomType - geometry type
   *
   * @private
   */
  _updateMeasure(feature, geomType) {
    logger17.log(feature);
    var measure = null;
    var projection = this.getMap().getView().getProjection();
    function __roundDecimal(nombre, precision) {
      precision = precision || 2;
      var factor = Math.pow(10, precision);
      return Math.round(nombre * factor) / factor;
    }
    var type = geomType || feature.getProperties().type;
    switch (type) {
      case "Point":
        var coordinatesPoint = feature.getGeometry().getCoordinates();
        var c = transform(coordinatesPoint, projection, "EPSG:4326");
        measure = "lon : ";
        measure += __roundDecimal(c[0], 4) + "Â°";
        measure += " / ";
        measure += "lat : ";
        measure += __roundDecimal(c[1], 4) + "Â°";
        break;
      case "LineString":
        var measureLength = 0;
        var coordinatesLine = feature.getGeometry().getCoordinates();
        for (var i = 0, ii = coordinatesLine.length - 1; i < ii; ++i) {
          var c1 = transform(coordinatesLine[i], projection, "EPSG:4326");
          var c2 = transform(coordinatesLine[i + 1], projection, "EPSG:4326");
          measureLength += getDistance(c1, c2);
        }
        measure = measureLength > 1e3 ? __roundDecimal(measureLength / 1e3, 3) + " km" : __roundDecimal(measureLength, 3) + " m";
        break;
      case "Polygon":
        var measureArea = 0;
        var geom = feature.getGeometry().clone();
        var coordinatesAera = geom.getLinearRing(0).getCoordinates();
        measureArea = Math.abs(getArea(new Polygon_default([coordinatesAera])));
        var rings = geom.getLinearRings();
        if (rings.length > 1) {
          for (var ij = 1; ij < rings.length; ij++) {
            var coordinatesRings = rings[ij].getCoordinates();
            measureArea -= Math.abs(getArea(new Polygon_default([coordinatesRings])));
          }
        }
        measure = measureArea > 1e6 ? __roundDecimal(measureArea / 1e6, 3) + " km^2" : __roundDecimal(measureArea, 2) + " m^2";
        break;
    }
    feature.setProperties({
      measure,
      type
    });
  }
  /**
   * Handles click on drawing tools icons
   *
   * @param {Event} clickEvent - click event
   * @param {String} toolId - selected tool Id
   * @param {Drawing} context - Drawing control.
   * @private
   */
  _handleToolClick(clickEvent, toolId, context) {
    var map = context.getMap();
    if (!map) {
      logger17.trace("Drawing control not attached to any map.");
      return;
    }
    Interactions_default.unset(map, {
      current: "Drawing"
    });
    if (context.interactionCurrent) {
      map.removeInteraction(context.interactionCurrent);
      context.interactionCurrent = null;
    }
    if (context.interactionSelectEdit) {
      map.removeInteraction(context.interactionSelectEdit);
      context.interactionSelectEdit = null;
    }
    if (context.popupOvl) {
      context.getMap().removeOverlay(context.popupOvl);
      context.popupOvl = null;
    }
    if (context.stylingOvl) {
      context.getMap().removeOverlay(context.stylingOvl);
      context.stylingOvl = null;
    }
    if (context.tooltipOvl) {
      context.getMap().removeOverlay(context.tooltipOvl);
      context.tooltipOvl = null;
    }
    if (!this.layer) {
      this._createEmptyLayer();
    }
    const followCursor = (e) => {
      if (e.dragging) {
        return;
      }
      if (!context.tooltipOvl) {
        return;
      }
      const coordinate = e.coordinate;
      context.tooltipOvl.setPosition(coordinate);
    };
    const removeToolTip = () => {
      if (context.tooltipOvl) {
        context.getMap().removeOverlay(context.tooltipOvl);
        context.tooltipOvl = null;
      }
    };
    switch (toolId) {
      case this._addUID("drawing-tool-point"):
        if (context.dtOptions["points"].active) {
          context.interactionCurrent = new Draw_default({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new Style_default({
              image: new Icon_default(this._getIconStyleOptions(this.options.markersList[0]))
            }),
            type: "Point"
          });
          context.interactionCurrent.on(
            "drawend",
            function(deEv) {
              context._drawEndFeature(deEv.feature, "Point");
            },
            context
          );
        }
        break;
      case this._addUID("drawing-tool-line"):
        if (context.dtOptions["lines"].active) {
          context.interactionCurrent = new Draw_default({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new Style_default({
              image: new Circle_default2({
                radius: this.options.cursorStyle.radius,
                stroke: new Stroke_default({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new Fill_default({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new Stroke_default({
                color: this.options.defaultStyles.strokeColor,
                width: this.options.defaultStyles.strokeWidth
              })
            }),
            type: "LineString",
            handleMoveEvent: followCursor
          });
          if (!context.tootlTipElem) {
            context.tootlTipElem = document.createElement("div");
            context.tootlTipElem.className = "gpf-draw-linestring-tooltip";
          }
          context.tootlTipElem.innerText = "Double-cliquer pour terminer";
          context.tooltipOvl = new Overlay_default({
            element: context.tootlTipElem,
            positioning: "top-right"
          });
          context.interactionCurrent.on(
            "drawend",
            function(deEv) {
              context._drawEndFeature(deEv.feature, "LineString");
              removeToolTip();
            },
            context
          );
          context.interactionCurrent.on("drawabort", removeToolTip, context);
        }
        break;
      case this._addUID("drawing-tool-polygon"):
        if (context.dtOptions["polygons"].active) {
          context.interactionCurrent = new Draw_default({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new Style_default({
              image: new Circle_default2({
                radius: this.options.cursorStyle.radius,
                stroke: new Stroke_default({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new Fill_default({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new Stroke_default({
                color: this.options.defaultStyles.polyStrokeColor,
                width: this.options.defaultStyles.polyStrokeWidth
              }),
              fill: new Fill_default({
                color: ColorUtils_default.hexToRgba(
                  this.options.defaultStyles.polyFillColor,
                  this.options.defaultStyles.polyFillOpacity
                )
              })
            }),
            type: "Polygon",
            handleMoveEvent: followCursor
          });
          if (!context.tootlTipElem) {
            context.tootlTipElem = document.createElement("div");
            context.tootlTipElem.className = "gpf-draw-linestring-tooltip";
          }
          context.tootlTipElem.innerText = "Double-cliquer pour terminer";
          context.tooltipOvl = new Overlay_default({
            element: context.tootlTipElem,
            positioning: "top-right"
          });
          context.interactionCurrent.on(
            "drawend",
            function(deEv) {
              context._drawEndFeature(deEv.feature, "Polygon");
              removeToolTip();
            },
            context
          );
          context.interactionCurrent.on("drawabort", removeToolTip, context);
        }
        break;
      case this._addUID("drawing-tool-holes"):
        if (context.dtOptions["holes"].active) {
          context.interactionSelectEdit = new Select_default({
            stopClick: true,
            condition: pointerMove,
            layers: [this.layer]
          });
          context.interactionSelectEdit.setProperties({
            name: "Drawing",
            source: context
          });
          map.addInteraction(context.interactionSelectEdit);
          context.interactionCurrent = new Draw_default({
            stopClick: true,
            features: this.interactionSelectEdit.getFeatures(),
            style: new Style_default({
              image: new Circle_default2({
                radius: this.options.cursorStyle.radius,
                stroke: new Stroke_default({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new Fill_default({
                  color: this.options.cursorStyle.fillColor
                })
              }),
              stroke: new Stroke_default({
                color: this.options.defaultStyles.polyStrokeColor,
                width: this.options.defaultStyles.polyStrokeWidth
              }),
              fill: new Fill_default({
                color: ColorUtils_default.hexToRgba(
                  this.options.defaultStyles.polyFillColor,
                  this.options.defaultStyles.polyFillOpacity
                )
              })
            }),
            type: "Polygon"
          });
          context.interactionCurrent.on("drawstart", function(deEv) {
          }, context);
          context.interactionCurrent.on(
            "drawend",
            function(deEv) {
              var features = context.interactionSelectEdit.getFeatures();
              if (features.getLength()) {
                var feature = features.item(0);
                var hole = deEv.feature.getGeometry().getCoordinates()[0];
                var bHoleIsIncluded = true;
                for (var i = 0; i < hole.length; i++) {
                  if (!feature.getGeometry().intersectsCoordinate(hole[i])) {
                    bHoleIsIncluded = false;
                    break;
                  }
                }
                if (!bHoleIsIncluded) {
                  return;
                }
                feature.getGeometry().appendLinearRing(new LinearRing_default(hole));
                deEv.feature = feature;
                context._drawEndFeature(deEv.feature, "Polygon");
              }
            },
            context
          );
        }
        break;
      case this._addUID("drawing-tool-text"):
        if (context.dtOptions["text"].active) {
          context.interactionCurrent = new Draw_default({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            source: context.layer.getSource(),
            style: new Style_default({
              image: new Circle_default2({
                radius: this.options.cursorStyle.radius,
                stroke: new Stroke_default({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new Fill_default({
                  color: this.options.cursorStyle.fillColor
                })
              })
            }),
            type: "Point"
          });
          context.interactionCurrent.on("drawend", (deEv) => {
            var setTextValue = function(key, value2, save2) {
              context.getMap().removeOverlay(context.popupOvl);
              context.popupOvl = null;
              if (!save2 || !value2) {
                context.layer.getSource().removeFeature(deEv.feature);
                return;
              }
              var obj = {};
              obj[key] = value2;
              deEv.feature.setProperties(obj);
              deEv.feature.setStyle(new Style_default({
                // HACK : on ajoute un icone invisible de 1x1 pixel afin d'eviter
                // l'affichage d'une punaise google !
                image: new Icon_default(context._getIconStyleOptions(context.options.defaultStyles.textIcon1x1)),
                text: new Text_default({
                  textAlign: "left",
                  font: "16px sans",
                  text: value2,
                  fill: new Fill_default({
                    color: context.options.defaultStyles.textFillColor
                  }),
                  stroke: new Stroke_default({
                    color: context.options.defaultStyles.textStrokeColor,
                    width: 3
                  })
                })
              }));
            };
            var popup = this._createLabelDiv({
              applyFunc: setTextValue,
              inputId: context._addUID("label-input"),
              geomType: "Text",
              key: "name",
              placeholder: "Saisir un label..."
            });
            if (context.popupOvl) {
              context.popupOvl.element.querySelector(".gp-styling-button.closer").click();
            }
            context.popupOvl = new Overlay_default({
              element: popup,
              // FIXME : autres valeurs.
              positioning: "top-center"
              // par defaut, top-left...
              // stopEvent : false
            });
            context.getMap().addOverlay(context.popupOvl);
            context.popupOvl.setPosition(deEv.feature.getGeometry().getCoordinates());
            document.getElementById(context._addUID("label-input")).focus();
          });
        }
        break;
      case this._addUID("drawing-tool-edit"):
        if (context.dtOptions["edit"].active) {
          this.featuresCollectionSelected = new Collection_default();
          context.interactionSelectEdit = new Select_default({
            condition: singleClick,
            layers: [this.layer],
            features: this.featuresCollectionSelected
          });
          context.interactionSelectEdit.on("select", (e) => {
          });
          context.interactionSelectEdit.setProperties({
            name: "Drawing",
            source: context
          });
          map.addInteraction(context.interactionSelectEdit);
          context.interactionCurrent = new Modify_default({
            stopClick: true,
            // features : context.layer.getSource().getFeaturesCollection(),
            features: this.interactionSelectEdit.getFeatures(),
            style: new Style_default({
              image: new Circle_default2({
                radius: this.options.cursorStyle.radius,
                stroke: new Stroke_default({
                  color: this.options.cursorStyle.strokeColor,
                  width: this.options.cursorStyle.strokeWidth
                }),
                fill: new Fill_default({
                  color: this.options.cursorStyle.fillColor
                })
              })
            })
            // deleteCondition : function (/* event */) { return false },
            // insertVertexCondition : function (/* event */) { return false }
          });
          context.interactionCurrent.on("modifyend", (deEv) => {
            var feature = deEv.features.item(0);
            context._updateMeasure(feature);
          });
        }
        break;
      case this._addUID("drawing-tool-display"):
        if (context.dtOptions["display"].active) {
          context.interactionCurrent = this._createStylingInteraction();
        }
        break;
      case this._addUID("drawing-tool-tooltip"):
        if (context.dtOptions["tooltip"].active) {
          context.interactionCurrent = this._createLabelInteraction();
        }
        break;
      case this._addUID("drawing-tool-remove"):
        if (context.dtOptions["remove"].active) {
          context.interactionCurrent = context._createRemoveInteraction();
        }
        break;
      default:
        logger17.trace("unhandled tool type");
    }
    if (context.interactionCurrent) {
      context.interactionCurrent.setProperties({
        name: "Drawing",
        source: this
      });
      map.addInteraction(context.interactionCurrent);
      if (context.tooltipOvl) {
        map.addOverlay(context.tooltipOvl);
      }
    }
    logger17.log("interactions", map.getInteractions());
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPshowDrawingPicto' tag label
   * (cf. this._createShowDrawingPictoElement),
   * and toggles event 'mousemove' on map.
   *
   * @method onShowDrawingClick
   * @param { Event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowDrawingClick(e) {
    var opened = this._showDrawingButton.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    this.disable();
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
  /**
   * this method is called by event 'click' on 'drawing-export' tag button.
   *
   * @method onExportFeatureClick
   * @private
   */
  onExportFeatureClick() {
    var content = this.exportFeatures();
    if (!content) {
      return;
    }
    var link = document.createElement("a");
    var charset = "utf-8";
    link.setAttribute("href", "data:" + this._exportMimeType + ";charset=" + charset + "," + encodeURIComponent(content));
    link.setAttribute("download", this.getExportName() + this._exportExt);
    if (document.createEvent) {
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, true);
      link.dispatchEvent(event);
    } else {
      link.click();
    }
  }
};
/**
 * Default tools to display for widget
 *
 * @private
 */
__publicField(_Drawing, "DefaultTools", {
  points: true,
  lines: true,
  polygons: true,
  holes: false,
  text: true,
  remove: true,
  display: true,
  tooltip: true,
  edit: true,
  export: true,
  measure: false
});
/**
 * Default labels for widget
 *
 * @private
 */
__publicField(_Drawing, "DefaultLabels", {
  control: "Annoter la carte",
  creatingTools: "CrÃ©er",
  points: "Placer des points",
  lines: "Dessiner des lignes",
  polygons: "Dessiner des polygones",
  holes: "CrÃ©er des trous sur un polygone",
  text: "Ecrire sur la carte",
  editingTools: "Ã‰diter",
  edit: "Editer les tracÃ©s",
  display: "Modifier l'apparence des objets",
  tooltip: "Modifier les textes / infos-bulles",
  remove: "Supprimer des objets",
  export: "Exporter",
  exportTitle: "Exporter en KML",
  applyToObject: "Appliquer Ã  l'objet",
  saveDescription: "Enregistrer",
  setAsDefault: "DÃ©finir par dÃ©faut",
  strokeColor: "Couleur du trait : ",
  strokeWidth: "Epaisseur du trait : ",
  fillColor: "Couleur de remplissage : ",
  fillOpacity: "OpacitÃ© du remplissage : ",
  markerSize: "Taille du pictogramme : ",
  markerColor: "Couleur du pictogramme : ",
  labelDisplay: "Afficher le label : "
});
/**
 * Default styles applyied to drawn features.
 *
 * @private
 */
__publicField(_Drawing, "DefaultStyles", {
  textFillColor: "#000000",
  textStrokeColor: "#FFFFFF",
  textStrokeWidth: 6,
  // INFO : cette option n'est pas surchargeable via les options du constructeur !
  textIcon1x1: {
    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
    anchor: [0, 0]
  },
  polyFillColor: "#000091",
  polyFillOpacity: 0.7,
  polyStrokeColor: "#000091",
  polyStrokeWidth: 4,
  strokeColor: "#FF7F00",
  strokeWidth: 4,
  markerSize: 1,
  markerColor: "#ffcc33",
  // INFO : cette option n'est pas surchargeable via les options du constructeur !
  labelDisplay: true
});
/**
 * Default styles when drawing
 *
 * @private
 */
__publicField(_Drawing, "DefaultCursorStyle", {
  radius: 6,
  strokeColor: "#FFF",
  strokeWidth: 1,
  fillColor: "rgba(0, 153, 255, 1)"
});
var Drawing = _Drawing;
Object.assign(Drawing.prototype, DrawingDOM_default);
Object.assign(Drawing.prototype, Widget_default);
var Drawing_default = Drawing;
if (window.ol && window.ol.control) {
  window.ol.control.Drawing = Drawing;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Route/Route.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Route/GPFroute.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LocationSelector/LocationSelector.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/LocationSelector/GPFlocation.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LocationSelector/LocationSelectorDOM.js
var logger18 = LoggerByDefault_default2.getLogger("LocationSelectorDOM");
var LocationSelectorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.className = this._addUID("GPlocationPoint");
    container.className += " GPwidget gpf-widget ";
    return container;
  },
  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {Number} display  - display
   * @returns {HTMLElement} DOM element
   */
  _createLocationPointElement: function(id, display) {
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationPoint_" + id);
    div.className = display ? "GPflexInput GPlocationStageFlexInput gpf-flex" : "GPflexInput GPelementHidden gpf-flex gpf-hidden";
    div.style.cssText = "";
    return div;
  },
  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {String} text - label
   * @returns {HTMLElement} DOM element
   */
  _createLocationPointLabelElement: function(id, text) {
    var self2 = this;
    var buttonOrigin = document.createElement("button");
    buttonOrigin.id = this._addUID("GPlocationOriginLabel_" + id);
    buttonOrigin.innerHTML = text;
    buttonOrigin.className = "GPlocationOriginLabel gpf-btn gpf-btn-icon-label fr-btn fr-btn--secondary gpf-btn--secondary";
    buttonOrigin.setAttribute("type", "button");
    buttonOrigin.addEventListener("click", function(e) {
      var i = SelectorID_default.index(this.id);
      var points = document.getElementsByClassName(self2._addUID("GPlocationPoint"));
      for (var j2 = 0; j2 < points.length; j2++) {
        var tag = points[j2].childNodes[0].id;
        var id2 = SelectorID_default.index(tag);
        document.getElementById(self2._addUID("GPlocationPoint_" + id2)).style.cssText = "";
      }
      document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).value = "";
      document.getElementById(self2._addUID("GPlocationOrigin_" + i)).value = "";
      document.getElementById(self2._addUID("GPlocationPoint_" + i)).style.cssText = "";
      document.getElementById(self2._addUID("GPlocationOriginPointer_" + i)).checked = false;
      document.getElementById(self2._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show  gpf-input fr-input";
      document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
      if (document.getElementById(self2._addUID("GPlocationStageRemove_" + i))) {
        document.getElementById(self2._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary gpf-btn--secondary";
      }
      if (document.getElementById(self2._addUID("GPlocationStageAdd"))) {
        document.getElementById(self2._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary gpf-btn--secondary fr-mt-2w";
      }
      self2.onLocationClearPointClick(e);
    });
    return buttonOrigin;
  },
  /**
   * Create Input AutoComplete Point tag
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationAutoCompleteteInputElement: function(id) {
    var self2 = this;
    var inputOrigin = document.createElement("input");
    inputOrigin.id = this._addUID("GPlocationOrigin_" + id);
    inputOrigin.className = "GPelementShow gpf-show gpf-input fr-input";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse, un lieu...";
    inputOrigin.autocomplete = "off";
    inputOrigin.addEventListener("keyup", function(e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
        return;
      }
      var i = SelectorID_default.index(this.id);
      if (document.getElementById(self2._addUID("GPlocationOrigin_" + i)).value.length > 2) {
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("gpf-hidden", "gpf-visible");
      } else {
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("gpf-visible", "gpf-hidden");
      }
      self2.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("keydown", function(e) {
      var charCode = e.which || e.keyCode;
      var container = document.getElementById(self2._addUID("GPlocationAutoCompleteResult_" + id));
      if (!container) {
        return;
      }
      var curr = container.getElementsByClassName("GPautoCompleteProposal current");
      var list = container.getElementsByClassName("GPautoCompleteProposal");
      var length = list.length;
      if (!length) {
        return;
      }
      var current = null;
      if (!curr.length) {
        current = list[0];
        current.className = "GPautoCompleteProposal current";
        current.style.color = "#000000";
        current.style["background-color"] = "#CEDBEF";
        return;
      } else {
        current = curr[0];
      }
      var index2 = parseInt(SelectorID_default.index(current.id), 10);
      var next = index2 === length - 1 ? list[0] : list[index2 + 1];
      var prev = index2 === 0 ? list[length - 1] : list[index2 - 1];
      current.style["background-color"] = "";
      current.style.color = "";
      prev.style["background-color"] = "";
      prev.style.color = "";
      next.style["background-color"] = "";
      next.style.color = "";
      switch (charCode) {
        case 38:
          logger18.log("arrow up");
          current.className = "GPautoCompleteProposal";
          prev.className = "GPautoCompleteProposal current";
          prev.style.color = "#000000";
          prev.style["background-color"] = "#CEDBEF";
          break;
        case 40:
          logger18.log("arrow down");
          current.className = "GPautoCompleteProposal";
          next.className = "GPautoCompleteProposal current";
          next.style.color = "#000000";
          next.style["background-color"] = "#CEDBEF";
          break;
        case 13:
          logger18.log("enter");
          current.click(e);
          break;
      }
      current.focus();
    });
    return inputOrigin;
  },
  /**
   * Create Input Coordinate Point tag
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationCoordinateInputElement: function(id) {
    var self2 = this;
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = this._addUID("GPlocationOriginCoords_" + id);
    inputOriginCoord.className = "GPelementHidden gpf-input gpf-hidden fr-input";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = false;
    inputOriginCoord.addEventListener("click", function() {
      var i = SelectorID_default.index(this.id);
      document.getElementById(self2._addUID("GPlocationOriginLabel_" + i)).click();
    });
    return inputOriginCoord;
  },
  /**
   * Create Show Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationPointerShowInputElement: function(id) {
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = this._addUID("GPlocationOriginPointer_" + id);
    inputOriginPointer.className = "GPelementHidden gpf-hidden";
    inputOriginPointer.type = "checkbox";
    return inputOriginPointer;
  },
  /**
   * Create Input Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationPointerInputElement: function(id) {
    var self2 = this;
    var buttonOriginPointer = document.createElement("button");
    buttonOriginPointer.id = this._addUID("GPlocationOriginPointerImg_" + id);
    buttonOriginPointer.htmlFor = this._addUID("GPlocationOriginPointer_" + id);
    buttonOriginPointer.className = "GPlocationOriginPointerImg gpf-btn gpf-btn-icon-pointer fr-btn";
    buttonOriginPointer.title = "Pointer un lieu sur la carte";
    buttonOriginPointer.setAttribute("type", "button");
    buttonOriginPointer.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      var i = SelectorID_default.index(this.id);
      var points = document.getElementsByClassName(self2._addUID("GPlocationPoint"));
      var j2;
      var tag;
      var id2;
      for (j2 = 0; j2 < points.length; j2++) {
        tag = points[j2].childNodes[0].id;
        id2 = SelectorID_default.index(tag);
        if (i !== id2) {
          document.getElementById(self2._addUID("GPlocationOriginPointer_" + id2)).checked = false;
          if (document.getElementById(self2._addUID("GPlocationOriginCoords_" + id2)).value === "Pointer un lieu sur la carte") {
            document.getElementById(self2._addUID("GPlocationOriginCoords_" + id2)).value = "";
            document.getElementById(self2._addUID("GPlocationOrigin_" + id2)).className = "GPelementShow gpf-show  gpf-input fr-input";
            document.getElementById(self2._addUID("GPlocationOriginCoords_" + id2)).className = "GPelementHidden gpf-hidden";
          }
        }
      }
      if (document.getElementById(self2._addUID("GPlocationOriginPointer_" + i)).checked) {
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).value = "";
        for (j2 = 0; j2 < points.length; j2++) {
          tag = points[j2].childNodes[0].id;
          id2 = SelectorID_default.index(tag);
          document.getElementById(self2._addUID("GPlocationPoint_" + id2)).style.cssText = "";
        }
        if (document.getElementById(self2._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self2._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove  gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary gpf-btn--secondary";
        }
        if (document.getElementById(self2._addUID("GPlocationStageAdd"))) {
          document.getElementById(self2._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary gpf-btn--secondary fr-mt-2w";
        }
        document.getElementById(self2._addUID("GPlocationOriginPointer_" + i)).checked = false;
        document.getElementById(self2._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show  gpf-input fr-input";
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
      } else {
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).value = "Pointer un lieu sur la carte";
        for (j2 = 0; j2 < points.length; j2++) {
          tag = points[j2].childNodes[0].id;
          id2 = SelectorID_default.index(tag);
          if (i === id2) {
            document.getElementById(self2._addUID("GPlocationPoint_" + id2)).style.cssText = "";
          } else {
            document.getElementById(self2._addUID("GPlocationPoint_" + id2)).style.display = "none";
          }
        }
        if (document.getElementById(self2._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self2._addUID("GPlocationStageRemove_" + i)).className = "GPelementHidden gpf-hidden";
        }
        if (document.getElementById(self2._addUID("GPlocationStageAdd"))) {
          document.getElementById(self2._addUID("GPlocationStageAdd")).className = "GPelementHidden gpf-hidden";
        }
        document.getElementById(self2._addUID("GPlocationOriginPointer_" + i)).checked = true;
        document.getElementById(self2._addUID("GPlocationOrigin_" + i)).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).className = "GPelementShow gpf-show gpf-input fr-input";
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).disabled = true;
      }
      self2.onActivateMapPointClick(e);
    });
    return buttonOriginPointer;
  },
  /**
   * Create Remove Point tag
   * see event !
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationRemovePointElement: function(id) {
    var self2 = this;
    var buttonRm = document.createElement("button");
    buttonRm.id = this._addUID("GPlocationStageRemove_" + id);
    buttonRm.className = "GPlocationOpen GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary gpf-btn--secondary";
    buttonRm.title = "Supprimer l'Ã©tape";
    buttonRm.setAttribute("tabindex", "0");
    buttonRm.setAttribute("aria-pressed", false);
    buttonRm.setAttribute("type", "button");
    buttonRm.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      var points = document.getElementsByClassName(self2._addUID("GPlocationPoint"));
      var last = points.length - 1;
      var start2 = points[0].childNodes[0].id;
      var end = points[last].childNodes[0].id;
      var startID = SelectorID_default.index(start2);
      var endID = SelectorID_default.index(end);
      if (id !== startID && id !== endID) {
        var i = SelectorID_default.index(this.id);
        document.getElementById(self2._addUID("GPlocationPoint_" + i)).className = "GPflexInput GPelementHidden gpf-flex gpf-hidden";
        document.getElementById(self2._addUID("GPlocationOrigin_" + i)).value = "";
        document.getElementById(self2._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show gpf-input fr-input";
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).value = "";
        document.getElementById(self2._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPlocationStageAdd")).style.display = "";
        document.getElementById(self2._addUID("GPlocationPoint_" + i)).parentElement.previousSibling.classList.add("GPelementHidden", "gpf-hidden");
        self2.onLocationRemovePointClick(e);
      }
    });
    return buttonRm;
  },
  /**
   * Create Add Point tag
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createLocationAddPointElement: function() {
    var self2 = this;
    var buttonAdd = document.createElement("button");
    buttonAdd.id = this._addUID("GPlocationStageAdd");
    buttonAdd.className = "GPlocationOpen GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary gpf-btn--secondary fr-mt-2w";
    buttonAdd.title = "Ajouter une Ã©tape";
    if (CheckDsfr_default()) {
      buttonAdd.innerText = "Ajouter une Ã©tape";
    }
    buttonAdd.setAttribute("tabindex", "0");
    buttonAdd.setAttribute("aria-pressed", false);
    buttonAdd.setAttribute("type", "button");
    buttonAdd.addEventListener("click", function(e) {
      var lastStage = 1;
      var nbStages = 0;
      var points = document.getElementsByClassName(self2._addUID("GPlocationPoint"));
      for (var i = 1; i < points.length - 1; i++) {
        var tag = points[i].childNodes[0].id;
        var id = SelectorID_default.index(tag);
        if (document.getElementById(self2._addUID("GPlocationPoint_" + id))) {
          if (document.getElementById(self2._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPelementHidden gpf-flex gpf-hidden") {
            if (lastStage === 1) {
              lastStage = id;
            }
          } else {
            nbStages++;
          }
        }
      }
      if (lastStage < points.length) {
        document.getElementById(self2._addUID("GPlocationPoint_" + lastStage)).className = "GPflexInput GPlocationStageFlexInput gpf-flex";
        document.getElementById(self2._addUID("GPlocationPoint_" + lastStage)).parentElement.previousSibling.classList.remove("GPelementHidden", "gpf-hidden");
      }
      if (nbStages === 4) {
        document.getElementById(self2._addUID("GPlocationStageAdd")).style.display = "none";
      }
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self2.onLocationAddPointClick(e);
    });
    return buttonAdd;
  },
  _createLocationAutoCompleteElement: function(id) {
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationAutoCompleteList_" + id);
    div.className = "GPlocationAutoCompleteList GPelementHidden gpf-panel gpf-hidden fr-modal";
    return div;
  },
  /**
   * Create Results autocompletion to the point
   * see event!
   *
   * @param {Number} id - tag ID
   * @returns {HTMLElement} DOM element
   */
  _createLocationAutoCompleteResultElement: function(id) {
    var self2 = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationAutoCompleteResult_" + id);
    div.className = "GPadvancedAutoCompleteResult gpf-panel__list";
    if (div.addEventListener) {
      div.addEventListener("click", function(e) {
        self2.onAutoCompletedResultsItemClick(e);
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("gpf-hidden", "gpf-visible");
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function(e) {
        self2.onAutoCompletedResultsItemClick(e);
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self2._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("gpf-hidden", "gpf-visible");
      });
    }
    return div;
  },
  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   * TODO formaliser le contenu des reponse
   *
   * @param {Number} id - tag ID
   * @param {Object} location - suggested location result
   * @param {Number} n  - number of the point
   */
  _createLocationAutoCompletedLocationElement: function(id, location, n) {
    var container = document.getElementById(this._addUID("GPlocationAutoCompleteResult_" + id));
    var div = document.createElement("div");
    div.id = this._addUID("AutoCompletedLocation_" + n);
    div.className = "GPautoCompleteProposal gpf-panel__items";
    div.title = GeocodeUtils_default.getSuggestedLocationFreeform(location);
    div.innerHTML = GeocodeUtils_default.getSuggestedLocationFreeform(location);
    container.appendChild(div);
  },
  /**
  * Display Coordinate
  * @param {String} value - a Coordinate
  */
  GPdisplayCoordinate: function(value2) {
    var points = document.getElementsByClassName(this._addUID("GPlocationPoint"));
    for (var i = 0; i < points.length; i++) {
      var tag = points[i].childNodes[0].id;
      var id1 = SelectorID_default.index(tag);
      if (document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked) {
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).value = value2;
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).disabled = false;
        for (var j2 = 0; j2 < points.length; j2++) {
          tag = points[j2].childNodes[0].id;
          var id2 = SelectorID_default.index(tag);
          document.getElementById(this._addUID("GPlocationPoint_" + id2)).style.cssText = "";
          if (document.getElementById(this._addUID("GPlocationStageRemove_" + id2))) {
            document.getElementById(this._addUID("GPlocationStageRemove_" + id2)).className = "GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary gpf-btn--secondary";
          }
        }
        document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked = false;
        if (document.getElementById(this._addUID("GPlocationStageAdd"))) {
          document.getElementById(this._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm";
        }
        return;
      }
    }
  }
};
var LocationSelectorDOM_default = LocationSelectorDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LocationSelector/LocationSelector.js
var logger19 = LoggerByDefault_default2.getLogger("locationselector");
var LocationSelector = class _LocationSelector extends Control_default {
  /**
   * @constructor
   * @param {Object} [options] - component options
   * @param {String} [options.apiKey] - API key for autocomplete service call. The key "calcul" is used by default.
   * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
   * @param {Boolean} [options.displayInfo = true] - whether to display info in a popup or not (not implemented yet) Default is true
   * @param {Object} [options.tag] - tag options
   * @param {Number} [options.tag.id = 1] - order id number in a locations group, in case several LocationSelector are used. For instance in route case : departure tag id should be 0, arrival tag id should be 1, and other ones : 2, 3, ...
   * @param {Number} [options.tag.groupId = null] - locationSelector global component id (in case locationSelector is called by another graphic component, e.g. route control)
   * @param {String} [options.tag.label] - text to display in component (e.g. "Departure"). Default is ">"
   * @param {Object} [options.tag.markerOpts] - options to use your own marker. Default is a lightOrange marker.
   * @param {String} [options.tag.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
   * @param {Array} [options.tag.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see {@link http://openlayers.org/en/latest/apidoc/ol.Overlay.html ol.Overlay})
   * @param {Boolean} [options.tag.display = true] - whether to display or hide component. Default is true
   * @param {Boolean} [options.tag.addOption = false] - whether to display picto to add another LocationSelector (in case of route control)
   * @param {Boolean} [options.tag.removeOption = false] - whether to display picto to remove a LocationSelector (in case of route control)
   * @param {Object} [options.autocompleteOptions] - autocomplete service options (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options)
   * @example
   *  var locationselector = new LocationSelector({
   *      apiKey : "",
   *      tag : {
   *         id : 1,
   *         groupId : null,
   *         label : "DÃ©part",
   *         markerOpts : {
   *              url : "...",
   *              offset : [0,0]
   *         },
   *         display : true
   *      },
   *      autocompleteOptions : {}
   *  });
   */
  constructor(options) {
    options = options || {};
    super({
      element: options.element || document.createElement("div"),
      render: options.render,
      target: options.target
    });
    if (!(this instanceof _LocationSelector)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "LocationSelector";
    this.initialize(options);
    this._container = this._initContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * initialize component
   *
   * @param {Object} options - options
   * @private
   */
  initialize(options) {
    this.options = {
      tag: {
        id: 1,
        // numero d'ordre sur un groupe de locations
        groupId: null,
        // id du composant global contenant le LocationSelector
        label: ">",
        display: true,
        addOption: false,
        removeOption: false
      },
      displayInfo: true,
      autocompleteOptions: {}
    };
    Helper_default2.mergeParams(this.options, options);
    this._uid = this.options.tag.groupId || SelectorID_default.generate();
    this._map = null;
    this._inputsContainer = null;
    this._buttonLabel = null;
    this._inputAutoComplete = null;
    this._inputShowPointerContainer = null;
    this._inputShowPointer = null;
    this._inputCoordinateContainer = null;
    this._addPointElement = null;
    this._removePointElement = null;
    this._coordinate = null;
    this._suggestedContainer = null;
    this._suggestedList = null;
    this._suggestedLocations = [];
    this._currentLocation = null;
    this._initMarker();
    this._resources = {};
    this.listenerKey = null;
  }
  /**
   * initialize marker : url and offset
   *
   * @private
   */
  _initMarker() {
    this._marker = null;
    this._markerUrl = "";
    this._markerOffset = [0, 0];
    if (this.options.tag.markerOpts && this.options.tag.markerOpts.url) {
      this._markerUrl = this.options.tag.markerOpts.url;
      var offset = this.options.tag.markerOpts.offset;
      if (offset) {
        if (Array.isArray(offset) && offset.length === 2) {
          this._markerOffset = offset;
        } else {
          logger19.log("markerOpts.offset should be an array. e.g. : [0,0]");
        }
      }
    } else {
      this._markerUrl = Markers_default["lightOrange"];
      this._markerOffset = Markers_default.defaultOffset;
    }
  }
  // ################################################################### //
  // ########################## publics methods ######################## //
  // ################################################################### //
  /**
   * get coordinate
   *
   * @returns {Array} this._coordinate - point coordinate (EPSG:4326) : [lon, lat]
   */
  getCoordinate() {
    return this._coordinate;
  }
  /**
   * set coordinate
   * @param {Object} coordinate - Coordinate in the map projection by default, otherwise, the projection is entered in the following parameter
   * @param {String} crs - Coordinate projection
   */
  setCoordinate(coordinate, crs) {
    var map = this.getMap();
    var proj = map.getView().getProjection().getCode();
    if (!crs) {
      crs = proj;
    }
    this._setCoordinate(coordinate, crs);
    coordinate = transform(coordinate, crs, proj);
    this._setMarker([
      coordinate[0],
      coordinate[1]
    ], null, false);
  }
  /**
   * clean all and input
   */
  clear() {
    this.clearResults();
    this._buttonLabel.click();
  }
  /**
   * clear all results and the marker.
   */
  clearResults() {
    this._currentLocation = null;
    this._coordinate = null;
    this._hideSuggestedLocation();
    this._clearSuggestedLocation();
    this._setMarker();
    unByKey(this.listenerKey);
  }
  // ################################################################### //
  // ##################### init component (private) #################### //
  // ################################################################### //
  /**
   * initialize component container
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  _initContainer() {
    var id = this.options.tag.id;
    var container = this._createMainContainerElement();
    var inputs = this._inputsContainer = this._createLocationPointElement(id, this.options.tag.display);
    container.appendChild(inputs);
    var _buttonLabel = this._buttonLabel = this._createLocationPointLabelElement(id, this.options.tag.label);
    inputs.appendChild(_buttonLabel);
    var _inputAutoComplete = this._inputAutoComplete = this._createLocationAutoCompleteteInputElement(id);
    if (_inputAutoComplete.addEventListener) {
      _inputAutoComplete.addEventListener("click", () => this.onAutoCompleteInputClick());
    } else if (_inputAutoComplete.attachEvent) {
      _inputAutoComplete.attachEvent("onclick", () => this.onAutoCompleteInputClick());
    }
    inputs.appendChild(_inputAutoComplete);
    var _inputCoordinate = this._inputCoordinateContainer = this._createLocationCoordinateInputElement(id);
    inputs.appendChild(_inputCoordinate);
    var _inputShowPointer = this._inputShowPointerContainer = this._createLocationPointerShowInputElement(id);
    inputs.appendChild(_inputShowPointer);
    var _inputPointer = this._inputShowPointer = this._createLocationPointerInputElement(id);
    inputs.appendChild(_inputPointer);
    if (this.options.tag.addOption) {
      var _inputAddStage = this._addPointElement = this._createLocationAddPointElement();
      inputs.appendChild(_inputAddStage);
    }
    if (this.options.tag.removeOption) {
      var _inputRemoveStage = this._removePointElement = this._createLocationRemovePointElement(id);
      inputs.appendChild(_inputRemoveStage);
    }
    var resultsPanel = this._suggestedContainer = this._createLocationAutoCompleteElement(id);
    var results = this._suggestedList = this._createLocationAutoCompleteResultElement(id);
    resultsPanel.appendChild(results);
    container.appendChild(resultsPanel);
    return container;
  }
  // ################################################################### //
  // ###################### handlers events (dom) ###################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPlocationOrigin' input
   *
   * @private
   */
  onAutoCompleteInputClick() {
    if (this._inputAutoComplete && this._inputAutoComplete.value.length > 2) {
      this._displaySuggestedLocation();
    }
  }
  /**
   * this method is called by event 'keyup' on 'GProuteOrigin' tag input
   * (cf. this._createRouteAutoCompleteteInputElement), and it gets the value of input.
   * this value is passed as a parameter for the service autocomplete (text).
   * the results of the request are displayed into a drop down menu.
   * FIXME
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onAutoCompleteSearchText(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    var serviceOptions = this.options.autocompleteOptions || {};
    var _customOnSuccess = serviceOptions.onSuccess || null;
    var _customOnFailure = serviceOptions.onFailure || null;
    this._currentLocation = value2;
    if (value2.length < 3) {
      this._clearSuggestedLocation();
      return;
    }
    var context = this;
    this._requestAutoComplete({
      text: value2,
      maximumResponses: 5,
      // FIXME je limite le nombre de reponse car le container DOM est limitÃ© dans l'affichage !!!
      // callback onSuccess
      onSuccess: function(results) {
        if (results) {
          var locations = results.suggestedLocations;
          context._fillAutoCompletedLocationListContainer(locations);
          if (_customOnSuccess) {
            _customOnSuccess.call(this, results);
          }
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._clearSuggestedLocation();
        logger19.log(error.message);
        if (_customOnFailure) {
          _customOnFailure.call(this, error);
        }
      }
    });
    var map = this.getMap();
    map.on(
      "click",
      () => this._hideSuggestedLocation()
    );
    map.on(
      "pointerdrag",
      () => this._hideSuggestedLocation()
    );
  }
  /**
   * this method is called by event 'click' on 'GPautoCompleteResultsList' tag div
   * (cf. this._createAutoCompleteListElement), and it selects the location.
   * this location displays a marker on the map.
   * FIXME
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onAutoCompletedResultsItemClick(e) {
    var idx = SelectorID_default.index(e.target.id);
    if (!idx) {
      return;
    }
    var position = [
      this._suggestedLocations[idx].position.x,
      this._suggestedLocations[idx].position.y
    ];
    this._coordinate = position;
    var info = {
      type: this._suggestedLocations[idx].type,
      fields: this._suggestedLocations[idx]
    };
    var label = GeocodeUtils_default.getSuggestedLocationFreeform(this._suggestedLocations[idx]);
    this._setLabel(label);
    var view = this.getMap().getView();
    var mapProj = view.getProjection().getCode();
    if (mapProj !== "EPSG:4326") {
      position = transform(position, "EPSG:4326", mapProj);
    }
    this._setPosition(position);
    this._setMarker(position, info, this.options.displayInfo);
  }
  /**
   * this method is called by event 'click' on 'GProuteOriginPointerImg' tag input
   * (cf. this._createRoutePointerInputElement), and it create or remove the event of click map.
   *
   * @private
   */
  onActivateMapPointClick() {
    var map = this.getMap();
    if (this._inputShowPointerContainer.checked) {
      this.clearResults();
      this.listenerKey = map.on(
        "click",
        (e) => this.onMouseMapClick(e)
      );
      this._setCursor("crosshair");
    } else {
      unByKey(this.listenerKey);
      this._setCursor();
    }
  }
  /**
   * this method is called by event 'click' on 'GProuteOriginLabel' tag label
   * (cf. this._createRoutePointLabelElement).
   * this point is erased.
   *Missing
   * @private
   */
  onLocationClearPointClick() {
    this._setCursor();
    this.clearResults();
  }
  /**
   * this method is called by event 'click' on 'GProuteStageRemove' tag input
   * (cf. this._createRouteRemovePointElement).
   * this point is deleted
   *
   * @private
   */
  onLocationRemovePointClick() {
    this._setCursor();
    this.clearResults();
  }
  /**
   * TODO this method is called by event 'click' on 'GProuteStageAdd' tag input
   * (cf. this._createRouteAddPointElement).
   * this point is added as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onLocationAddPointClick(e) {
    logger19.log("onRouteAddPointClick", e);
  }
  // ################################################################### //
  // #################### handlers events (control) #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on map
   * (cf. this.onRouteMapPointClick), and it gets the coordinate of click on map.
   * this point is saved as a parameter for the service route.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onMouseMapClick(e) {
    var coordinate = e.coordinate;
    if (!e.map || !e.map.getView()) {
      return;
    }
    var crs = e.map.getView().getProjection();
    this._setCoordinate(coordinate, crs);
    this._setMarker([
      coordinate[0],
      coordinate[1]
    ], null, false);
    this.onActivateMapPointClick(e);
  }
  // ################################################################### //
  // ################# pivates methods use by events ################### //
  // ################################################################### //
  /**
   * this sends the label to the panel.
   *
   * @param {String} label - label suggested location
   * @private
   */
  _setLabel(label) {
    this._inputAutoComplete.value = label;
  }
  /**
   * this change the cursor of the map when entering a point.
   *
   * @param {String} cursor - cursor style
   * @private
   */
  _setCursor(cursor) {
    var map = this.getMap();
    var div = map.getTargetElement();
    if (cursor) {
      div.style.cursor = cursor;
    } else {
      div.style.cursor = null;
    }
  }
  /**
   * this sends the coordinates to the panel.
   *
   * @method _setCoordinate
   * @param {Array} olCoordinate - ol.Coordinate object [lon, lat] ou [x, y] (proj = map proj system)
   * @param {Object} crs - coordinate CRS (ol.proj.Projection)
   * @private
   */
  _setCoordinate(olCoordinate, crs) {
    this._coordinate = transform(olCoordinate, crs, "EPSG:4326");
    var lat = this._coordinate[0].toFixed(4);
    var lng = this._coordinate[1].toFixed(4);
    var value2 = lng + " / " + lat;
    this.GPdisplayCoordinate(value2);
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   * and set center at given position.
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] (en lat/lon : "EPSG:4326")
   * @private
   */
  _setPosition(position) {
    var view = this.getMap().getView();
    view.setCenter(position);
  }
  /**
   * this method is called by this.on*ResultsItemClick()
   * and displays a marker.
   * FIXME : marker IGN et informations ?
   *
   * @param {Array} position - ol.Coordinate object [lon, lat] ou [x, y]
   * @param {Object} information - suggested or geocoded information
   * @param {Boolean} display - display a popup information
   * @private
   */
  _setMarker(position, information, display) {
    var map = this.getMap();
    if (this._marker != null) {
      map.removeOverlay(this._marker);
      this._marker = null;
    }
    if (position) {
      var markerDiv = document.createElement("img");
      markerDiv.src = this._markerUrl;
      this._marker = new Overlay_default({
        position,
        offset: this._markerOffset,
        element: markerDiv,
        stopEvent: false
      });
      map.addOverlay(this._marker);
      if (display) {
        logger19.log("marker information : ", information);
      }
    }
  }
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */
  _clearSuggestedLocation() {
    this._suggestedLocations = [];
    if (this._suggestedList) {
      while (this._suggestedList.firstChild) {
        this._suggestedList.removeChild(this._suggestedList.firstChild);
      }
    }
  }
  /**
   * this method is called by event 'click' on map
   * and it hide suggested locations
   *
   * @private
   */
  _hideSuggestedLocation() {
    if (this._suggestedContainer) {
      this._suggestedContainer.classList.replace("GPelementVisible", "GPelementHidden");
      this._suggestedContainer.classList.replace("gpf-visible", "gpf-hidden");
    }
  }
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and it clears all suggested location.
   *
   * @private
   */
  _displaySuggestedLocation() {
    if (this._suggestedContainer) {
      this._suggestedContainer.classList.replace("GPelementHidden", "GPelementVisible");
      this._suggestedContainer.classList.replace("gpf-hidden", "gpf-visible");
    }
  }
  /**
   * this method is called by this.onAutoCompleteSearch()
   * and executes a request to the service.
   *
   * @param {Object} settings - service settings
   * @param {String}   settings.text - text
   * @param {Function} settings.onSuccess - callback
   * @param {Function} settings.onFailure - callback
   * @private
   */
  _requestAutoComplete(settings) {
    logger19.log("_requestAutoComplete()", settings);
    if (!settings || Object.keys(settings).length === 0) {
      return;
    }
    if (!settings.text) {
      return;
    }
    logger19.log(settings);
    var options = {};
    Helper_default2.assign(options, this.options.autocompleteOptions);
    Helper_default2.assign(options, settings);
    var resources = this._resources["AutoCompletion"] || null;
    if (resources && Array.isArray(resources)) {
      if (!options.filterOptions) {
        options.filterOptions = {};
      }
      options.filterOptions.type = resources;
    }
    options.apiKey = options.apiKey || this.options.apiKey;
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    logger19.log(options);
    Gp_default.Services.autoComplete(options);
  }
  /**
   * this method is called by this.onAutoCompleteSearchText()
   * and fills the container of the location list.
   * it creates a HTML Element per location
   * (cf. this. ...)
   *
   * @param {Object[]} locations - locations
   *
   * @private
   */
  _fillAutoCompletedLocationListContainer(locations) {
    if (!locations || locations.length === 0) {
      return;
    }
    var element = this._suggestedList;
    if (element.childElementCount) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    for (var i = 0; i < locations.length; i++) {
      this._createLocationAutoCompletedLocationElement(this.options.tag.id, locations[i], i);
    }
    this._suggestedLocations = locations;
  }
};
Object.assign(LocationSelector.prototype, LocationSelectorDOM_default);
var LocationSelector_default = LocationSelector;
if (window.ol && window.ol.control) {
  window.ol.control.LocationSelector = LocationSelector;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Export/Export.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Export/GPFexport.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Export/ExportDOM.js
var ExportDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  }
};
var ExportDOM_default = ExportDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Export/Export.js
var logger20 = LoggerByDefault_default2.getLogger("export");
var ButtonExport = class _ButtonExport extends Control_default {
  /**
   * @constructor
  * @param {Object} options - options for function call.
  * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {String} [options.download = "true"] - triggering the download of the file
  * @param {String} [options.format = "geojson"] - geojson / kml / gpx
  * @param {String} [options.name = "export"] - export name file
  * @param {String} [options.description = "export"] - export description put into file
  * @param {String} [options.title = "Exporter"] - button name
  * @param {String} [options.kind = "secondary"] - button type : primary | secondary | tertiary
  * @param {Boolean} [options.menu = false] - displays the menu
  * @param {Object} [options.menuOptions] - options of the menu.
  * @param {Boolean} [options.menuOptions.outside = false] - displays all element outside of menu
  * @param {Boolean} [options.menuOptions.above = false] - displays menu above or not of the button
  * @param {Boolean} [options.menuOptions.labelName = true] - displays the label name
  * @param {Boolean} [options.menuOptions.labelDesc = true] - displays the label description
  * @param {Boolean} [options.menuOptions.selectFormat = true] - displays the select format
  * @param {String} [options.direction = "row"] - buttons and menus layout
  * @param {Object} [options.icons] - icons
  * @param {String} [options.icons.menu = "\u2630 "] - displays the menu icon, or otherwise left blank if you don't want it
  * @param {String} [options.icons.button = "export"] - displays the button icon : save or export icon, or otherwise left blank if you don't want it
  * @param {Function} [options.callback] - with a callback, the implementation is your responsibility
  * @param {HTMLElement} [options.target] - target where the button will plug in. By default, the target is 'container-buttons-plugin' into the wikdget
  * @param {Object} [options.control] - instance of control
  * @param {Object} [options.layer] - the layer instance is retrieved from the control, but you can defined it
  * @fires button:clicked 
  * @example
  * // pluggued widget Export into control Isocurve
  * var iso = new ol.control.Isocurve();
  * map.addControl(iso);
  *
  * // method : call render()
  * var export = new ButtonExport();
  * export.setDownload(true);
  * export.setControl(iso);
  * export.setTarget(<!-- HTMLElement -->);
  * export.setName("export");
  * export.setFormat("geojson");
  * export.setDescription("Export Isochrone");
  * export.setTitle("Exporter");
  * export.setMenu(true);
  * export.setMenuOptions({
  *   outside : false,
  *   labelName : true,
  *   labelDesc : true,
  *   selectFormat : true
  * });
  * export.render(); // <-- direct call to render function !
  * export.on("button:clicked", (data) => { console.log(data); });
  *
  * // method : call map.addControl()
  * var export = new ButtonExport();
  * export.setDownload(true);
  * export.setControl(iso);
  * export.setTarget(<!-- HTMLElement -->);
  * export.setName("export");
  * export.setFormat("geojson");
  * export.setDescription("Export Isochrone");
  * export.setTitle("Exporter");
  * export.setKind("secondary");
  * export.setMenu(false);
  * export.on("button:clicked", (data) => { console.log(data); });
  * map.addControl(export); // <-- using the OpenLayers mechanism, don't call to render function !
  *
  * // use control options instead of setters
  * var export = new ButtonExport({
  *   download : true,
  *   control : iso,
  *   target : <!-- HTMLElement -->,
  *   name : "export",
  *   description : "Export Isochrone",
  *   format : "geojson",
  *   title : "Exporter",
  *   menu : false,
  *   callback : (content, layer) => {
  *      console.log(content, layer);
  *   }
  * });
  * map.addControl(export);
  *
  * // method with passing option into the control Isocurve
  * var iso = new ol.control.Isocurve({ export : true });
  * // with control options :
  * var iso = new ol.control.Isocurve({ export : {
  *   download : false,
  *   name : "save-iso",
  *   format : "geojson",
  *   title : "Sauvegarde",
  *   menu : true
  * }});
   */
  constructor(options) {
    options = options || {
      layer: null,
      control: null,
      target: null,
      format: "geojson",
      name: "export",
      description: "export",
      title: "Exporter",
      kind: "secondary",
      menu: false,
      icons: {
        menu: "â˜° ",
        button: ""
      },
      callback: null
    };
    logger20.trace("[constructor] Export", options);
    super({
      element: document.createElement("div"),
      render: options.render,
      target: null
    });
    if (!(this instanceof _ButtonExport)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Export";
    this.EXPORT_ROUTE = {};
    this.EXPORT_ISOCHRON = {};
    this.EXPORT_PROFILE = {};
    this.uid = options.id || SelectorID_default.generate();
    this.extension = null;
    this.mimeType = null;
    this.container = null;
    this.button = null;
    this.buttonOptions = null;
    this.inputName = null;
    this.inputDesc = null;
    this.menu = null;
    this.menuClassHidden = "GPelementHidden gpf-hidden";
    this.initOptions(options);
    this.initContainer();
    this.BUTTON_EXPORT_CLICKED_EVENT = "button:clicked";
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Render DOM
   *
   * @public
   */
  render() {
    if (!this.options.target) {
      if (this.options.control) {
        var containerMain = this.options.control.getContainer();
        var containerPlug = containerMain.querySelector(".container-buttons-plugin");
        this.options.target = containerPlug || containerMain.lastChild;
      }
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
  }
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize options
   * (called by constructor)
   *
   * @param {Object} options - options
   * @private
   */
  initOptions(options) {
    this.options = {
      layer: null,
      control: null,
      target: null,
      download: true,
      format: "geojson",
      name: "export",
      description: "export",
      title: "Exporter",
      kind: "secondary",
      direction: "row",
      menu: false,
      menuOptions: {
        above: false,
        // au dessus ou en dessous du bouton !
        outside: false,
        labelName: true,
        labelDesc: true,
        selectFormat: true
      },
      icons: {
        menu: "â˜° ",
        // FIXME Ã  supprimer !
        button: "export"
      },
      callback: null
    };
    var icons = Helper_default2.assign(this.options.icons, options.icons);
    var menuOptions = Helper_default2.assign(this.options.menuOptions, options.menuOptions);
    Helper_default2.assign(this.options, options);
    Helper_default2.assign(this.options.icons, icons);
    Helper_default2.assign(this.options.menuOptions, menuOptions);
    logger20.debug(this.options);
    if (this.options.layer) {
    }
    if (this.options.control) {
    }
    if (this.options.target) {
    }
    var format = this.options.format;
    format ? this.setFormat(format) : this.setFormat("");
    if (!this.options.name) {
      this.setName("export");
    }
    if (!this.options.description) {
      this.setDescription("export");
    }
    if (!this.options.title) {
      this.setTitle("Exporter");
    }
    if (!this.options.kind) {
      this.setKind("secondary");
    }
    if (this.options.menu === void 0) {
      this.setMenu(false);
    }
  }
  /**
   * Initialize container
   * (called by constructor)
   *
   * @private
   * @todo menu des options
   */
  initContainer() {
    var title3 = this.options.title;
    if (this.options.menu) {
      title3 = this.options.icons.menu + this.options.title;
    }
    var div = document.createElement("div");
    div.id = this._addUID("GPexportContainer");
    div.className = "GPexportMenuContainer gpf-export-menu-container gpf-export-menu-container-row-reverse";
    if (this.options.direction === "column") {
      div.classList.replace("gpf-export-menu-container-row-reverse", "gpf-export-menu-container-column-reverse");
    }
    var menu = this.stringToHTML(`
            <div class="GPexportMenuHidden gpf-accordion fr-accordion ${this.menuClassHidden}">
                <h3 class="gpf-accordion__title fr-accordion__title">
                    <button type="button" 
                        id="GPexportBtnMenuContent-${this.uid}"
                        class="gpf-accordion__btn fr-accordion__btn" 
                        aria-expanded="false" aria-controls="GPexportMenuContent-${this.uid}">options</button>
                </h3>
                <div id="GPexportMenuContent-${this.uid}"
                    class="GPexportMenuContent fr-collapse fr-mx-2w">
                    <div id="GPexportMenuName-${this.uid}" 
                        class="GPexportMenuName">
                        <label class="GPlabel gpf-label fr-label" for="GPexportMenuInputName-${this.uid}" title="Nom">Nom</label>
                        <input type="text" id="GPexportMenuInputName-${this.uid}" class="GPinput gpf-input fr-input">
                    </div>
                    <div id="GPexportMenuDesc-${this.uid}"
                        class="GPexportMenuDesc">
                        <label class="GPlabel gpf-label fr-label" for="GPexportMenuInputDesc-${this.uid}" title="Description">Description</label>
                        <input type="text" id="GPexportMenuInputDesc-${this.uid}" class="GPinput gpf-input fr-input">
                    </div>
                    <div id="GPexportMenuFormat-${this.uid}">
                        <label class="GPlabel gpf-label fr-label" title="Formats">Formats</label>
                        <div class="GPexportMenuFormat fr-radio-group fr-m-1w">
                            <input type="radio" 
                                id="GPmenuFormatGeojson-${this.uid}"
                                name="format" 
                                value="geojson">
                            <label class="fr-label container" for="GPmenuFormatGeojson-${this.uid}">GeoJSON
                                <span class="checkmark"></span>
                            </label>
                        </div>
                        <div class="GPexportMenuFormat fr-radio-group fr-m-1w">
                            <input type="radio" 
                                id="GPmenuFormatKml-${this.uid}"
                                name="format" 
                                value="kml">
                            <label class="fr-label container" for="GPmenuFormatKml-${this.uid}">KML
                                <span class="checkmark"></span>
                            </label>
                        </div>
                        <div class="GPexportMenuFormat fr-radio-group fr-m-1w">
                            <input type="radio" 
                                id="GPmenuFormatGpx-${this.uid}"
                                name="format" 
                                value="gpx">
                            <label class="fr-label container" for="GPmenuFormatGpx-${this.uid}">GPX
                                <span class="checkmark"></span>
                            </label>
                        </div>
                    </div>
                    <div id="GPexportMenuButtons-${this.uid}" 
                        class="GPexportMenuButtons">
                        <button 
                            type="button"
                            id="GPexportMenuButtonValidate-${this.uid}" 
                            class="GPexportMenuButtonValidate GPsubmit gpf-btn gpf-btn-icon-export-validate fr-btn fr-btn--secondary fr-m-1w">
                            Valider
                        </button>
                        <button 
                            type="button"
                            id="GPexportMenuButtonCancel-${this.uid}" 
                            class="GPexportMenuButtonIconCancel GPsubmit gpf-btn gpf-btn-icon-export-cancel fr-btn fr-btn--secondary fr-m-1w">
                            Annuler
                        </button>
                    </div>
                </div>
            </div>
        `);
    this.menu = menu.firstChild;
    if (this.menu) {
      if (this.options.menu) {
        var className = this.menu.className;
        this.menu.className = className.replace(this.menuClassHidden, "");
      }
      var format = this.options.format.toUpperCase();
      var radios = this.menu.querySelectorAll(`input[type=radio][name="format"]`);
      for (let i = 0; i < radios.length; i++) {
        var radio = radios[i];
        if (radio.id.toUpperCase().includes(format)) {
          radio.checked = true;
        }
        radio.addEventListener("change", (e) => this.onChangeRadioFormat(e));
      }
      this.buttonOptions = this.menu.querySelector("#GPexportBtnMenuContent-" + this.uid);
      if (this.buttonOptions) {
        this.buttonOptions.addEventListener("click", (e) => this.onClickButtonToggleOptions(e));
      }
      this.inputName = this.menu.querySelector("#GPexportMenuInputName-" + this.uid);
      this.inputDesc = this.menu.querySelector("#GPexportMenuInputDesc-" + this.uid);
      this.inputName.addEventListener("change", (e) => this.onChangeInputName(e));
      this.inputName.addEventListener("focusin", (e) => this.onFocusInputName(e));
      this.inputDesc.addEventListener("change", (e) => this.onChangeInputDesc(e));
      this.inputDesc.addEventListener("focusin", (e) => this.onFocusInputDesc(e));
      var btnValidate = this.menu.querySelector("#GPexportMenuButtonValidate-" + this.uid);
      btnValidate.addEventListener("click", (e) => this.onClickButtonValidate(e));
      var btnCancel = this.menu.querySelector("#GPexportMenuButtonCancel-" + this.uid);
      btnCancel.addEventListener("click", (e) => this.onClickButtonCancel(e));
      if (this.options.menuOptions) {
        if (this.options.menuOptions.outside) {
          this.menu.classList.remove("gpf-accordion", "fr-accordion");
          var divButton = this.menu.querySelector("#GPexportBtnMenuContent-" + this.uid);
          divButton.classList.add("gpf-hidden");
          var divContent = this.menu.querySelector("#GPexportMenuContent-" + this.uid);
          divContent.classList.remove("fr-collapse");
          var divButtons = this.menu.querySelector("#GPexportMenuButtons-" + this.uid);
          divButtons.classList.add("gpf-hidden");
        }
        if (this.options.menuOptions.above) {
          div.classList.replace("gpf-export-menu-container-row-reverse", "gpf-export-menu-container-row");
          div.classList.replace("gpf-export-menu-container-column-reverse", "gpf-export-menu-container-column");
        }
        if (!this.options.menuOptions.labelName) {
          var divName = this.menu.querySelector("#GPexportMenuName-" + this.uid);
          divName.classList.add("gpf-hidden");
        }
        if (!this.options.menuOptions.labelDesc) {
          var divDesc = this.menu.querySelector("#GPexportMenuDesc-" + this.uid);
          divDesc.classList.add("gpf-hidden");
        }
        if (!this.options.menuOptions.selectFormat) {
          var divFormat = this.menu.querySelector("#GPexportMenuFormat-" + this.uid);
          divFormat.classList.add("gpf-hidden");
        }
      }
    }
    div.appendChild(this.menu);
    var button = this.stringToHTML(`
            <button 
                type="button"
                id="${this._addUID("GPexportButton")}" 
                class="GPexportButtonExportIcon GPsubmit gpf-btn gpf-btn-icon-export-submit fr-btn fr-m-1w">
                ${title3}
            </button>
        `);
    this.button = button.firstChild;
    if (this.button) {
      this.button.addEventListener("click", (e) => this.onClickButtonExport(e));
    }
    switch (this.options.kind) {
      case "tertiary":
        this.button.classList.add("fr-btn--tertiary", "gpf-btn--tertiary");
        break;
      case "secondary":
        this.button.classList.add("fr-btn--secondary", "gpf-btn--secondary");
        break;
      case "primary":
      default:
        this.button.classList.add("fr-btn--primary", "gpf-btn--primary");
        break;
    }
    if (!this.options.icons.button) {
      this.button.classList.remove("GPexportButtonExportIcon", "gpf-btn-icon-export-submit");
    } else {
      switch (this.options.icons.button) {
        case "export":
          break;
        case "save":
          this.button.classList.replace("GPexportButtonExportIcon", "GPexportButtonSaveIcon");
          this.button.classList.replace("gpf-btn-icon-export-submit", "gpf-btn-icon-save-submit");
          break;
        default:
          this.button.classList.remove("GPexportButtonExportIcon", "gpf-btn-icon-export-submit");
          break;
      }
    }
    div.appendChild(this.button);
    this.container = div;
  }
  /**
   * ...
   *
   * @param {String} str - ...
   * @returns {HTMLElement} - ...
   * @private
   */
  stringToHTML(str) {
    var support = function() {
      if (!window.DOMParser) {
        return false;
      }
      var parser2 = new DOMParser();
      try {
        parser2.parseFromString("x", "text/html");
      } catch (err) {
        return false;
      }
      return true;
    };
    if (support()) {
      var parser = new DOMParser();
      var doc = parser.parseFromString(str, "text/html");
      return doc.body;
    }
    var dom = document.createElement("div");
    dom.innerHTML = str;
    return dom;
  }
  /**
   * ...
   * @returns {Boolean} - ...
   * @private
   */
  isPluggableControl() {
    if (this.options.control && typeof this.options.control.getContainer === "function" && typeof this.options.control.getLayer === "function") {
      return true;
    }
    return false;
  }
  /**
   * ...
   * @param {Layer} layer - ...
   * @param {Object} [data] - ...
   * @param {Object} [style] - ...
   * @returns {String} - ...
   * @private
   */
  exportFeatures(layer, data, style) {
    var result = null;
    if (!layer) {
      logger20.warn("Impossible to export : no layer is hosting features.");
      return result;
    }
    if (!layer.getSource() || !layer.getSource().getFeatures() || !layer.getSource().getFeatures().length) {
      logger20.warn("Impossible to export : no features found.");
      return result;
    }
    layer.getSource().getFeatures().forEach((feature) => {
      var style2 = feature.getStyle();
      if (!style2 && this.options.control && typeof this.options.control.getStyle === "function") {
        feature.setStyle(this.options.control.getStyle());
      }
    });
    var options = {
      defaultStyle: style,
      extensions: {}
    };
    if (data) {
      options.extensions = {
        "geoportail:compute": data
      };
    }
    if (this.options.description) {
      options.extensions.description = this.inputDesc && this.inputDesc.value ? this.inputDesc.value : this.options.description;
    }
    var ClassName = null;
    switch (this.options.format.toUpperCase()) {
      case "KML":
        options.writeStyles = true;
        options.showPointNames = true;
        ClassName = new KML_default2(options);
        break;
      case "GPX":
        ClassName = new GPX_default2(options);
        break;
      case "GEOJSON":
        ClassName = new GeoJSON_default2(options);
        break;
      default:
        break;
    }
    if (!ClassName) {
      logger20.warn("Impossible to export : format unknown !?");
      return result;
    }
    var featProj = layer.getSource().getProjection();
    var map = this.getMap();
    if (map) {
      featProj = featProj || map.getView().getProjection();
    }
    var features = layer.getSource().getFeatures();
    result = ClassName.writeFeatures(features, {
      dataProjection: "EPSG:4326",
      featureProjection: featProj || "EPSG:3857"
    });
    return result;
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {Event} e - Click
   * @private
   */
  onClickButtonExport(e) {
    if (!this.isPluggableControl()) {
      logger20.warn("Componant not pluggable with the control !");
    }
    var layer = this.options.control && this.options.control.getLayer !== void 0 ? this.options.control.getLayer() : this.options.layer;
    var data = this.options.control && this.options.control.getData !== void 0 ? this.options.control.getData() : {};
    var style = this.options.control && this.options.control.getStyle !== void 0 ? this.options.control.getStyle() : {};
    var content = this.exportFeatures(layer, data, style);
    if (!content || content === "null") {
      return;
    }
    this.dispatchEvent({
      type: this.BUTTON_EXPORT_CLICKED_EVENT,
      content,
      name: this.options.name,
      description: this.options.description,
      format: this.options.format,
      layer
    });
    if (this.options.download) {
      var link = document.createElement("a");
      var charset = "utf-8";
      link.setAttribute("href", "data:" + this.mimeType + ";charset=" + charset + "," + encodeURIComponent(content));
      link.setAttribute("download", this.options.name + this.extension);
      if (document.createEvent) {
        var event = document.createEvent("MouseEvents");
        event.initEvent("click", true, true);
        link.dispatchEvent(event);
      } else {
        link.click();
      }
    }
    if (this.options.callback && typeof this.options.callback === "function") {
      this.options.callback(content, layer);
    }
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onChangeRadioFormat(e) {
    this.setFormat(e.target.value);
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onChangeInputName(e) {
    this.setName(e.target.value);
  }
  /**
   * 
   * @param {Event} e - Focus
   * @private
   */
  onFocusInputName(e) {
    var map = this.getMap();
    if (!map) {
      return;
    }
    if (this.options.control && typeof this.options.control.disable === "function") {
      this.options.control.disable();
    }
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onChangeInputDesc(e) {
    this.setDescription(e.target.value);
  }
  /**
   * 
   * @param {Event} e - Focus
   * @private
   */
  onFocusInputDesc(e) {
    var map = this.getMap();
    if (!map) {
      return;
    }
    if (this.options.control && typeof this.options.control.disable === "function") {
      this.options.control.disable();
    }
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onClickButtonToggleOptions(e) {
    e.target.ariaExpanded = !(e.target.ariaExpanded === "true");
    var collapse = this.menu.querySelector("#" + e.target.getAttribute("aria-controls"));
    if (!collapse) {
      return;
    }
    if (e.target.ariaExpanded === "true") {
      collapse.classList.add("fr-collapse--expanded");
      this.menu.classList.add("gpf-full-container");
      this.menu.classList.add("gpf-accordion--opened");
      collapse.classList.remove("GPelementHidden");
    } else {
      collapse.classList.remove("fr-collapse--expanded");
      this.menu.classList.remove("gpf-full-container");
      this.menu.classList.remove("gpf-accordion--opened");
      collapse.classList.add("GPelementHidden");
    }
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onClickButtonValidate(e) {
    this.setName(this.inputName.value);
    this.setDescription(this.inputDesc.value);
    this.buttonOptions.click();
  }
  /**
   * 
   * @param {Event} e - Click
   * @private
   */
  onClickButtonCancel(e) {
    this.inputName.value = "";
    this.inputDesc.value = "";
    this.buttonOptions.click();
  }
  // ################################################################### //
  // ################# public getters/setters ########################## //
  // ################################################################### //
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  /**
   * ...
   * @param {Object} control - ...
   * @public
   */
  setControl(control) {
    this.options.control = control;
  }
  /**
   * ...
   * @param {HTMLElement} target - ...
   * @public
   */
  setTarget(target2) {
    this.options.target = target2;
  }
  /**
   * ...
   * @param {String} format - ...
   * @public
   */
  setFormat(format) {
    this.options.format = format.toUpperCase();
    switch (this.options.format) {
      case "KML":
        this.extension = ".kml";
        this.mimeType = "application/vnd.google-earth.kml+xml";
        break;
      case "GPX":
        this.extension = ".gpx";
        this.mimeType = "application/gpx+xml";
        break;
      case "GEOJSON":
        this.extension = ".geojson";
        this.mimeType = "application/geo+json";
        break;
      default:
        this.options.format = "GEOJSON";
        this.extension = ".geojson";
        this.mimeType = "application/geo+json";
        break;
    }
  }
  /**
   * ...
   * @param {String} name - ...
   * @public
   */
  setName(name) {
    this.options.name = name;
  }
  /**
   * ...
   * @param {String} desc - ...
   * @public
   */
  setDescription(desc) {
    this.options.description = desc;
  }
  /**
   * ...
   * @param {String} title - ...
   * @public
   */
  setTitle(title3) {
    this.options.title = title3;
    if (this.button) {
      this.button.textContent = this.options.menu ? this.options.icons.menu + title3 : title3;
    }
  }
  /**
   * ...
   * @param {String} type - ...
   * @public
   */
  setKind(type) {
    this.options.kind = type;
    if (this.button) {
      this.button.classList.remove("fr-btn--tertiary", "gpf-btn--tertiary");
      this.button.classList.remove("fr-btn--secondary", "gpf-btn--secondary");
      switch (this.options.kind) {
        case "tertiary":
          this.button.classList.add("fr-btn--tertiary", "gpf-btn--tertiary");
          break;
        case "secondary":
          this.button.classList.add("fr-btn--secondary", "gpf-btn--secondary");
          break;
        case "primary":
        default:
          this.button.classList.add("fr-btn--primary", "gpf-btn--primary");
          break;
      }
    }
  }
  /**
   * ...
   * @param {Boolean} active - ...
   * @public
   */
  setMenu(active) {
    this.options.menu = active;
    if (this.button) {
      this.button.textContent = this.options.menu ? this.options.icons.menu + this.options.title : this.options.title;
    }
    if (this.menu && this.options.menu) {
      var className = this.menu.className;
      this.menu.className = className.replace(this.menuClassHidden, "");
      var format = this.options.format.toUpperCase();
      var radios = this.menu.querySelectorAll(`input[type=radio][name="format"]`);
      for (let i = 0; i < radios.length; i++) {
        var radio = radios[i];
        if (radio.id.toUpperCase().includes(format)) {
          radio.checked = true;
        }
      }
    }
  }
  /**
   * ...
   * @param {Object} opts - ...
   * @todo ...
   */
  setMenuOptions(opts) {
  }
  /**
   * ...
   * @param {*} layer  - ...
   * @public
   */
  setLayer(layer) {
    this.options.layer = layer;
  }
  /**
   * ...
   * @param {Boolean} value - ...
   * @public
   */
  setDownload(value2) {
    this.options.download = value2;
  }
};
Object.assign(ButtonExport.prototype, ExportDOM_default);
Object.assign(ButtonExport.prototype, Widget_default);
var Export_default = ButtonExport;
if (window.ol && window.ol.control) {
  window.ol.control.Export = ButtonExport;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Route/RouteDOM.js
var logger21 = LoggerByDefault_default2.getLogger("RouteDOM");
var RouteDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GProute");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //
  /**
   * Show route control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowRoutePictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowRoutePicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowRoutePicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-route");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Ouvrir le calcul d'itinÃ©raire");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRoutePanelClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRoutePanelClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createRoutePanelHeaderElement
   * don't call this._createRoutePanelFormElement
   * don't call this._createRoutePanelResultsElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GProutePanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createRoutePanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  _createDrawingButtonsPluginDiv: function() {
    var div = document.createElement("div");
    div.className = "container-buttons-plugin fr-mx-2w";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.innerHTML = "Calcul d'itinÃ©raire";
    container.appendChild(div);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GProutePanelClose");
    divClose.className = "GPpanelClose GProutePanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Masquer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowRoutePicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowRoutePicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Create Footer Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFooterElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelFooter gpf-panel__footer fr-modal__footer";
    return container;
  },
  /**
   * Create Point label
   *
   * @param {String} innerHTML text to display
   * @param {Boolean} display should the label be dsiplayed?
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormPointLabel: function(innerHTML, display = true) {
    var p2 = document.createElement("p");
    p2.innerHTML = innerHTML;
    var classesToAdd = !display ? " GPelementHidden gpf-hidden" : "";
    p2.className = "GProutePointLabelP gpf-label fr-label" + classesToAdd;
    return p2;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormElement: function() {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GProuteForm");
    form.className = "gpf-panel__content fr-modal__content";
    form.setAttribute("onkeypress", "return event.keyCode != 13;");
    form.addEventListener("submit", function(e) {
      logger21.log(e);
      e.preventDefault();
      var points = document.getElementsByClassName(self2._addUID("GPlocationPoint"));
      var start2 = points[0].childNodes[0].id;
      var end = points[points.length - 1].childNodes[0].id;
      var startID = SelectorID_default.index(start2);
      var endID = SelectorID_default.index(end);
      if (document.getElementById(self2._addUID("GPlocationOrigin_" + startID)).value === "" && document.getElementById(self2._addUID("GPlocationOriginCoords_" + startID)).value === "" || document.getElementById(self2._addUID("GPlocationOrigin_" + endID)).value === "" && document.getElementById(self2._addUID("GPlocationOriginCoords_" + endID)).value === "") {
        return false;
      }
      self2._addRouteResultsStagesValuesElement(points);
      var modeComputation = null;
      if (document.getElementById(self2._addUID("GProuteComputationChoice"))) {
        if (document.getElementById(self2._addUID("GProuteComputationFastest"))) {
          if (document.getElementById(self2._addUID("GProuteComputationFastest")).checked) {
            modeComputation = document.getElementById(self2._addUID("GProuteComputationFastest")).value;
          }
        }
        if (document.getElementById(self2._addUID("GProuteComputationShortest"))) {
          if (document.getElementById(self2._addUID("GProuteComputationShortest")).checked) {
            modeComputation = document.getElementById(self2._addUID("GProuteComputationShortest")).value;
          }
        }
      }
      var modeTransport = null;
      if (document.getElementById(self2._addUID("GProuteTransportCar"))) {
        if (document.getElementById(self2._addUID("GProuteTransportCar")).checked) {
          modeTransport = document.getElementById(self2._addUID("GProuteTransportCar")).value;
        }
      }
      if (document.getElementById(self2._addUID("GProuteTransportPedestrian"))) {
        if (document.getElementById(self2._addUID("GProuteTransportPedestrian")).checked) {
          modeTransport = document.getElementById(self2._addUID("GProuteTransportPedestrian")).value;
        }
      }
      var exclusions = [];
      var exclusionsElement = document.getElementsByClassName("GProuteExclusionsOption");
      for (var j2 = 0; j2 < exclusionsElement.length; j2++) {
        var id = exclusionsElement[j2].htmlFor;
        var el = document.getElementById(id);
        if (!el.checked) {
          exclusions.push(el.value);
        }
      }
      self2.onRouteComputationSubmit({
        computation: modeComputation,
        transport: modeTransport,
        exclusions
      });
      return false;
    });
    return form;
  },
  /**
   * Create Results Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelResultsElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResultsPanel");
    container.className = "GPelementHidden gpf-hidden";
    container.appendChild(this._createRouteResultsStagesElement());
    container.appendChild(this._createRouteResultsElement());
    container.appendChild(this._createRouteShowResultsDetailsElement());
    container.appendChild(this._createRouteResultsDetailsElement());
    return container;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the window results ##################### //
  // ################################################################### //
  /**
   * Create Results Stages
   * (results dynamically generate !)
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteResultsStagesElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsStages");
    return div;
  },
  /**
   * Add Stages Results
   *
   * @param {HTMLElement} points - list of points
   */
  _addRouteResultsStagesValuesElement: function(points) {
    document.getElementById(this._addUID("GProuteResultsStages")).innerHTML = "";
    for (var i = 0; i < points.length; i++) {
      var tag = points[i].childNodes[0].id;
      var id = SelectorID_default.index(tag);
      if (document.getElementById(this._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPlocationStageFlexInput gpf-flex") {
        var resultStage = document.createElement("div");
        resultStage.className = "GProuteResultsStages fr-my-1w";
        var resultStageLabel = document.createElement("span");
        resultStageLabel.className = "GProuteResultStageLabel";
        resultStageLabel.innerHTML = document.getElementById(this._addUID("GPlocationOriginLabel_" + id)).innerHTML + " : ";
        resultStage.appendChild(resultStageLabel);
        var resultStageValue = document.createElement("span");
        resultStageValue.className = "GProuteResultStageValue";
        var elementCoords = document.getElementById(this._addUID("GPlocationOriginCoords_" + id));
        var stageCoords = elementCoords.value;
        if (stageCoords !== null && stageCoords !== "") {
          resultStageValue.innerHTML = stageCoords;
        } else {
          resultStageValue.innerHTML = document.getElementById(this._addUID("GPlocationOrigin_" + id)).value;
        }
        resultStage.appendChild(resultStageValue);
        if (resultStageValue.innerHTML !== "") {
          document.getElementById(this._addUID("GProuteResultsStages")).appendChild(resultStage);
        }
      }
    }
  },
  /**
   * Create Show Results
   * see event!
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteResultsElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResults");
    var divValue = document.createElement("div");
    divValue.id = this._addUID("GProuteResultsValues");
    container.appendChild(divValue);
    var divMode = document.createElement("div");
    divMode.id = this._addUID("GProuteResultsMode");
    var select = document.createElement("select");
    select.id = this._addUID("GProuteResultsComputationSelect");
    select.className = "GPselect gpf-select fr-select";
    select.addEventListener("change", function(e) {
      self2.onRouteModeComputationChangeAndRun(e);
    });
    var computes = [{
      code: "fastest",
      label: "Plus rapide"
    }, {
      code: "shortest",
      label: "Plus court"
    }];
    for (var i = 0; i < computes.length; i++) {
      var option2 = document.createElement("option");
      option2.value = computes[i].code;
      option2.text = computes[i].label;
      select.appendChild(option2);
    }
    divMode.appendChild(select);
    container.appendChild(divMode);
    var divNew = document.createElement("div");
    divNew.id = this._addUID("GProuteResultsNew");
    divNew.className = "GPresetPicto gpf-btn gpf-btn-icon-reset fr-btn fr-btn--secondary gpf-btn--secondary";
    divNew.title = "Modifier le calcul";
    divNew.addEventListener("click", function(e) {
      document.getElementById(self2._addUID("GProuteResultsPanel")).className = "GPelementHidden gpf-hidden";
      document.getElementById(self2._addUID("GProuteForm")).className = "gpf-panel__content fr-modal__content";
      self2.onShowRouteResultsNewClick(e);
    });
    container.appendChild(divNew);
    return container;
  },
  /**
   * Add Results Duration and Distance
   * (results dynamically generate !)
   * see event!
   * @param {Number} distance - distance
   * @param {Number} duration - duration
   * @param {Function} fconvert - fconvert
   *
   * @returns {HTMLElement} DOM element
   */
  _addRouteResultsValuesElement: function(distance, duration, fconvert) {
    var div = document.getElementById(this._addUID("GProuteResultsValues"));
    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }
    var containerDistance = document.createElement("div");
    containerDistance.className = "GProuteResultsValue";
    var labelDistance = document.createElement("label");
    labelDistance.className = "GProuteResultsValueLabel";
    labelDistance.innerHTML = "Distance :";
    containerDistance.appendChild(labelDistance);
    var distanceLabel = 0;
    var isKm = parseInt(distance / 1e3, 10);
    if (!isKm) {
      distanceLabel = Math.round(distance) + " m";
    } else {
      var distanceArrondi = Math.round(distance);
      distanceArrondi = distanceArrondi / 1e3;
      distanceLabel = distanceArrondi + " km";
    }
    var divDistance = document.createElement("div");
    divDistance.id = this._addUID("GProuteResultsValueDist");
    divDistance.innerHTML = distanceLabel;
    containerDistance.appendChild(divDistance);
    div.appendChild(containerDistance);
    var containerDuration = document.createElement("div");
    containerDuration.className = "GProuteResultsValue";
    var labelDuration = document.createElement("label");
    labelDuration.className = "GProuteResultsValueLabel";
    labelDuration.innerHTML = "DurÃ©e :";
    containerDuration.appendChild(labelDuration);
    var divDuration = document.createElement("div");
    divDuration.id = this._addUID("GProuteResultsValueDist");
    divDuration.innerHTML = fconvert(duration);
    containerDuration.appendChild(divDuration);
    div.appendChild(containerDuration);
    return div;
  },
  /**
   * Create Show Results Details
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteShowResultsDetailsElement: function() {
    var div = document.createElement("div");
    div.className = "GProuteResultsShowDetailsDiv gpf-flex fr-checkbox-group fr-m-1w";
    if (!CheckDsfr_default()) {
      var divBorderUp = document.createElement("div");
      divBorderUp.className = "GPfakeBorder GPfakeBorderLeft";
      div.appendChild(divBorderUp);
    }
    var input = document.createElement("input");
    input.id = this._addUID("GProuteResultsShowDetails");
    input.type = "checkbox";
    div.appendChild(input);
    var labelShow = document.createElement("label");
    labelShow.className = "gpf-label fr-label";
    labelShow.htmlFor = this._addUID("GProuteResultsShowDetails");
    labelShow.innerHTML = "Afficher le dÃ©tail";
    div.appendChild(labelShow);
    if (!CheckDsfr_default()) {
      var labelHide = document.createElement("label");
      labelHide.htmlFor = this._addUID("GProuteResultsShowDetails");
      labelHide.innerHTML = "Masquer le dÃ©tail";
      div.appendChild(labelHide);
      var divBorderDown = document.createElement("div");
      divBorderDown.className = "GPfakeBorder";
      div.appendChild(divBorderDown);
    }
    return div;
  },
  /**
   *  Create Results Details
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteResultsDetailsElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsDetails");
    return div;
  },
  /**
   *  Add Results Details
   * (results dynamically generate !)
   * @param {Object[]} instructions - instructions
   * @param {Function} fconvert - fconvert
   *
   * @returns {HTMLElement} DOM element
   */
  _addRouteResultsDetailsElement: function(instructions, fconvert) {
    var context = this;
    var div = document.getElementById(this._addUID("GProuteResultsDetails"));
    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }
    var distanceCumul = 0;
    var durationCumul = 0;
    for (var i = 0; i < instructions.length; i++) {
      var id = i + 1;
      var o = instructions[i];
      var divNum = document.createElement("div");
      divNum.className = "GProuteResultsDetailsNumber";
      divNum.innerHTML = id + ".";
      div.appendChild(divNum);
      durationCumul += parseFloat(o.duration);
      distanceCumul += parseFloat(o.distance);
      var distance = 0;
      var isCumulKm = parseInt(distanceCumul / 1e3, 10);
      if (!isCumulKm) {
        distance = Math.round(distanceCumul) + " m";
      } else {
        var distanceArrondi = Math.round(distanceCumul);
        distanceArrondi = distanceArrondi / 1e3;
        distance = distanceArrondi + " km";
      }
      var divIns = document.createElement("div");
      divIns.className = "GProuteResultsDetailsInstruction";
      divIns.id = this._addUID("GProuteResultsDetailsInstruction_" + id);
      divIns.title = "distance : " + distance + " / temps : " + fconvert(durationCumul);
      divIns.innerHTML = o.instruction;
      divIns.addEventListener("mouseover", function(e) {
        context.onRouteResultsDetailsMouseOver(e);
      });
      divIns.addEventListener("mouseout", function(e) {
        context.onRouteResultsDetailsMouseOut(e);
      });
      divIns.addEventListener("click", function(e) {
        if (typeof context.onRouteResultsDetailsClick === "function") {
          context.onRouteResultsDetailsClick(e);
        }
      });
      div.appendChild(divIns);
    }
    return div;
  },
  // ################################################################### //
  // ################### Methods to the form points #################### //
  // ################# OVERWRITTEN BY LOCATIONSELECTOR ! ################# //
  /**
   * Create Point
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   * @param {String} text - text
   * @param {Boolean} visibility - visibility
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormPointElement: function(n, text, visibility) {
    var context = this;
    var div = document.createElement("div");
    div.id = "GProutePoint" + n;
    div.className = visibility ? "GPflexInput GProuteStageFlexInput" : "GPflexInput GProuteStageFlexInputHidden";
    var labelOrigin = document.createElement("label");
    labelOrigin.id = "GProuteOriginLabel" + n;
    labelOrigin.htmlFor = "GProuteOrigin" + n;
    labelOrigin.innerHTML = text;
    labelOrigin.addEventListener("click", function() {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteOriginCoords" + i).value = "";
      for (var j2 = 1; j2 < 8; j2++) {
        document.getElementById("GProutePoint" + j2).style.display = "flex";
      }
      document.getElementById("GProuteForm").className = "gpf-panel__content fr-modal__content";
      document.getElementById("GProuteOriginPointer" + i).checked = false;
      document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
      document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
    });
    div.appendChild(labelOrigin);
    var inputOrigin = document.createElement("input");
    inputOrigin.id = "GProuteOrigin" + n;
    inputOrigin.className = "GPelementVisible gpf-visible";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse, un lieu...";
    inputOrigin.addEventListener("keyup", function(e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13 || charCode === 10) {
        return;
      }
      var i = this.id.charAt(this.id.length - 1);
      if (document.getElementById("GProuteOrigin" + i).value.length > 2) {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "block";
      } else {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
      }
      context.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("blur", function() {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
    });
    div.appendChild(inputOrigin);
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = "GProuteOriginCoords" + n;
    inputOriginCoord.className = "GPelementHidden gpf-hidden";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = true;
    div.appendChild(inputOriginCoord);
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = "GProuteOriginPointer" + n;
    inputOriginPointer.type = "checkbox";
    div.appendChild(inputOriginPointer);
    var labelOriginPointer = document.createElement("label");
    labelOriginPointer.id = "GProuteOriginPointerImg" + n;
    labelOriginPointer.htmlFor = "GProuteOriginPointer" + n;
    labelOriginPointer.className = "GProuteOriginPointerImg";
    labelOriginPointer.title = "Pointer un lieu sur la carte";
    labelOriginPointer.addEventListener("click", function(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var i = this.id.charAt(this.id.length - 1);
      var j2;
      for (j2 = 1; j2 < 8; j2++) {
        if (i !== j2) {
          document.getElementById("GProuteOriginPointer" + j2).checked = false;
          if (document.getElementById("GProuteOriginCoords" + j2).value === "Pointer un lieu sur la carte") {
            document.getElementById("GProuteOriginCoords" + j2).value = "";
            document.getElementById("GProuteOrigin" + j2).className = "GPelementVisible gpf-visible";
            document.getElementById("GProuteOriginCoords" + j2).className = "GPelementHidden gpf-hidden";
          }
        }
      }
      if (document.getElementById("GProuteOriginPointer" + i).checked) {
        document.getElementById("GProuteOriginCoords" + i).value = "";
        for (j2 = 1; j2 < 8; j2++) {
          document.getElementById("GProutePoint" + j2).style.display = "flex";
        }
        document.getElementById("GProuteForm").className = "gpf-panel__content fr-modal__content";
        document.getElementById("GProuteOriginPointer" + i).checked = false;
        document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
      } else {
        document.getElementById("GProuteOriginCoords" + i).value = "Pointer un lieu sur la carte";
        for (j2 = 1; j2 < 8; j2++) {
          if (i === j2) {
            document.getElementById("GProutePoint" + j2).style.display = "flex";
          } else {
            document.getElementById("GProutePoint" + j2).style.display = "none";
          }
        }
        document.getElementById("GProuteForm").className = "GProuteFormMini gpf-panel__content fr-modal__content";
        document.getElementById("GProuteOriginPointer" + i).checked = true;
        document.getElementById("GProuteOrigin" + i).className = "GPelementHidden gpf-hidden";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementVisible gpf-visible";
      }
      context.onRouteMapPointClick(evt);
    });
    div.appendChild(labelOriginPointer);
    return div;
  },
  /**
   * Create Remove Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormRemoveStageElement: function(n) {
    var context = this;
    var divRm = document.createElement("div");
    divRm.id = "GProuteStageRemove" + n;
    divRm.className = "GProuteStageRemove";
    divRm.title = "Supprimer l'Ã©tape";
    if (n !== 1 && n !== 7) {
      divRm.addEventListener("click", function(e) {
        var i = this.id.charAt(this.id.length - 1);
        document.getElementById("GProutePoint" + i).className = "GPflexInput GProuteStageFlexInputHidden";
        document.getElementById("GProuteOrigin" + i).value = "";
        document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
        document.getElementById("GProuteOriginCoords" + i).value = "";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
        document.getElementById("GProuteStageAdd").style.display = "";
        context.onRouteRemovePointClick(e);
      });
    }
    return divRm;
  },
  /**
   * Create Add Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormAddStageElement: function() {
    var context = this;
    var divAdd = document.createElement("div");
    divAdd.id = "GProuteStageAdd";
    divAdd.title = "Ajouter une Ã©tape";
    divAdd.addEventListener("click", function(e) {
      var lastStage = 1;
      var nbStages = 0;
      for (var i = 2; i < 7; i++) {
        if (document.getElementById("GProutePoint" + i).className === "GPflexInput GProuteStageFlexInputHidden") {
          if (lastStage === 1) {
            lastStage = i;
          }
        } else {
          nbStages++;
        }
      }
      if (lastStage < 7) {
        document.getElementById("GProutePoint" + lastStage).className = "GPflexInput GProuteStageFlexInput";
      }
      if (nbStages === 4) {
        document.getElementById("GProuteStageAdd").style.display = "none";
      }
      context.onRouteAddPointClick(e);
    });
    return divAdd;
  },
  /**
   * Create Results autocompletion to the point
   * see event!
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormAutoCompleteListElement: function(n) {
    var context = this;
    var div = document.createElement("div");
    div.id = "GProuteAutoCompleteList" + n;
    div.className = "GPadvancedAutoCompleteList";
    if (div.addEventListener) {
      div.addEventListener("click", function(e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function(e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      });
    }
    return div;
  },
  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   *
   * @param {Object} location - suggested location results
   * @param {Number} n  - number of the point
   * @param {Number} id - ID
   */
  _createRouteAutoCompletedLocationElement: function(location, n, id) {
    var container = document.getElementById("GProuteAutoCompleteList" + n);
    var div = document.createElement("div");
    div.id = "AutoCompletedLocation" + id;
    div.className = "GPautoCompleteProposal";
    div.innerHTML = GeocodeUtils_default.getSuggestedLocationFreeform(location);
    container.appendChild(div);
  },
  // ################################################################### //
  // ############## Methods to the choice mode into form ############### //
  // ################################################################### //
  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {String[]} transports - transports
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormModeChoiceTransportElement: function(transports) {
    var context = this;
    var divContainer = document.createElement("div");
    divContainer.id = this._addUID("GProuteTransportChoice");
    var label = document.createElement("label");
    label.className = "GProuteModeLabel gpf-label fr-label";
    label.innerHTML = "Choisir un mode de dÃ©placement";
    divContainer.appendChild(label);
    var divRadio = document.createElement("div");
    divRadio.className = "gpf-radio-btn-group";
    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];
      var div = document.createElement("div");
      div.className = "GProuteTransportChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GProuteTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GProuteTransport";
        inputCar.value = "Voiture";
        if (i === 0) {
          inputCar.checked = true;
        }
        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function(e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function(e) {
            context.onRouteModeTransportChange(e);
          });
        }
        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GProuteTransportImg gpf-label fr-label";
        labelCar.htmlFor = this._addUID("GProuteTransportCar");
        labelCar.title = "Voiture";
        labelCar.innerHTML = "Voiture";
        div.appendChild(labelCar);
      }
      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GProuteTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GProuteTransport";
        inputPedestrian.value = "Pieton";
        if (i === 0) {
          inputPedestrian.checked = true;
        }
        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function(e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function(e) {
            context.onRouteModeTransportChange(e);
          });
        }
        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GProuteTransportImg gpf-label fr-label";
        labelPedestrian.htmlFor = this._addUID("GProuteTransportPedestrian");
        labelPedestrian.title = "PiÃ©ton";
        labelPedestrian.innerHTML = "PiÃ©ton";
        div.appendChild(labelPedestrian);
      }
      divRadio.appendChild(div);
    }
    divContainer.appendChild(divRadio);
    return divContainer;
  },
  /**
   * Create Mode choice computation
   * see event!
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormModeChoiceComputeElement: function() {
    var context = this;
    var divContainer = document.createElement("div");
    divContainer.id = this._addUID("GProuteComputationChoice");
    divContainer.className = "fr-mt-2w";
    var label = document.createElement("label");
    label.className = "GProuteComputationLabel gpf-label fr-label";
    label.innerHTML = "Mode de calcul";
    divContainer.appendChild(label);
    var divRadio = document.createElement("div");
    divRadio.className = "gpf-radio-btn-group";
    var div = document.createElement("div");
    div.className = "GProuteComputationChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
    var inputFastest = document.createElement("input");
    inputFastest.id = this._addUID("GProuteComputationFastest");
    inputFastest.type = "radio";
    inputFastest.name = "GProuteComputation";
    inputFastest.value = "fastest";
    inputFastest.checked = true;
    if (inputFastest.addEventListener) {
      inputFastest.addEventListener("change", function(e) {
        context.onRouteModeComputationChange(e);
      });
    } else if (inputFastest.attachEvent) {
      inputFastest.attachEvent("onchange", function(e) {
        context.onRouteModeComputationChange(e);
      });
    }
    div.appendChild(inputFastest);
    var labelFastest = document.createElement("label");
    labelFastest.className = "gpf-label fr-label";
    labelFastest.htmlFor = this._addUID("GProuteComputationFastest");
    labelFastest.title = "Plus rapide";
    labelFastest.innerHTML = "Plus rapide";
    div.appendChild(labelFastest);
    divRadio.appendChild(div);
    var div2 = document.createElement("div");
    div2.className = "GProuteComputationChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
    var inputShortest = document.createElement("input");
    inputShortest.id = this._addUID("GProuteComputationShortest");
    inputShortest.type = "radio";
    inputShortest.name = "GProuteComputation";
    inputShortest.value = "shortest";
    if (inputShortest.addEventListener) {
      inputShortest.addEventListener("change", function(e) {
        context.onRouteModeComputationChange(e);
      });
    } else if (inputShortest.attachEvent) {
      inputShortest.attachEvent("onchange", function(e) {
        context.onRouteModeComputationChange(e);
      });
    }
    div2.appendChild(inputShortest);
    var labelShortest = document.createElement("label");
    labelShortest.className = "gpf-label fr-label";
    labelShortest.htmlFor = this._addUID("GProuteComputationShortest");
    labelShortest.title = "Plus court";
    labelShortest.innerHTML = "Plus court";
    div2.appendChild(labelShortest);
    divRadio.appendChild(div2);
    divContainer.appendChild(divRadio);
    return divContainer;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //
  /**
   * Label to Exclusions Options
   * see event !
   * FIXME event not useful
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowRouteExclusionsPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowRouteExclusionsPicto");
    var hidden = "";
    if (CheckDsfr_default()) {
      hidden = "GPelementHidden gpf-hidden";
    }
    button.className = `GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowRouteExclusionsPicto ${hidden} gpf-btn fr-btn--sm fr-btn--tertiary gpf-btn--tertiary fr-icon-arrow-down-fill`;
    button.title = "Exclusions";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", true);
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        e.preventDefault();
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRouteExclusionsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        e.preventDefault();
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRouteExclusionsClick(e);
      });
    }
    return button;
  },
  /**
   * Create Container to Exclusions
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormExclusionsElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteExclusions");
    div.className = "fr-mt-2w";
    var label = document.createElement("label");
    label.className = "GProuteExclusionsLabel fr-label";
    label.innerHTML = "Passages autorisÃ©s";
    div.appendChild(label);
    return div;
  },
  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Object[]} exclusions - exclusions
   *
   * @returns {HTMLElement} DOM element
   */
  _createRoutePanelFormExclusionOptionsElement: function(exclusions) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GProuteExclusionsOptions gpf-flex fr-checkbox-group fr-m-1w";
    for (var value2 in exclusions) {
      if (exclusions.hasOwnProperty(value2)) {
        var status = exclusions[value2];
        switch (value2) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GProuteExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.value = "Toll";
            inputToll.name = "Peage";
            inputToll.checked = !status;
            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function(e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function(e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GProuteExclusionsOption";
            labelToll.htmlFor = this._addUID("GProuteExclusionsToll");
            labelToll.innerHTML = "PÃ©ages";
            div.appendChild(labelToll);
            break;
          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GProuteExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.value = "Tunnel";
            inputTunnel.name = "Tunnel";
            inputTunnel.checked = !status;
            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function(e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function(e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GProuteExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GProuteExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;
          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GProuteExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.value = "Bridge";
            inputBridge.name = "Ponts";
            inputBridge.checked = !status;
            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function(e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function(e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GProuteExclusionsOption";
            labelBridge.htmlFor = this._addUID("GProuteExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }
    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //
  /**
   * Create Submit Form Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteSubmitFormElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GProuteSubmit");
    input.className = "GPsubmit gpf-btn gpf-btn-icon-submit fr-btn";
    input.type = "submit";
    input.value = "Calculer l'itinÃ©raire";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //
  /**
   * Create Reset Picto Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createRouteFormResetElement: function() {
    var self2 = this;
    var buttonReset = document.createElement("button");
    buttonReset.id = this._addUID("GProuteReset");
    buttonReset.title = "RÃ©initialiser les paramÃ¨tres";
    buttonReset.className = "GPresetPicto gpf-btn gpf-btn-icon-reset fr-btn fr-btn--secondary gpf-btn--secondary";
    buttonReset.title = "RÃ©initialiser les paramÃ¨tres";
    buttonReset.setAttribute("tabindex", "0");
    buttonReset.setAttribute("aria-pressed", false);
    buttonReset.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self2.onRouteResetClick(e);
    });
    return buttonReset;
  }
};
var RouteDOM_default = RouteDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Route/Route.js
var logger22 = LoggerByDefault_default2.getLogger("route");
var Route2 = class _Route extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - route control options
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {String}  [options.apiKey] - API key for services call (route and autocomplete services). The key "calcul" is used by default.
   * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
   * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
   * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
   * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link packages/Controls/Export/Export.default}
   * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
   * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of resources, by default : ["Voiture", "Pieton"]. The first element is selected.
   * @param {Object} [options.routeOptions = {}] - route service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~route Gp.Services.route()} to know all route options.
   * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
   * @param {Object} [options.markersOpts] - options to use your own markers. Object properties can be "departure", "stages" or "arrival". Corresponding value is an object with following properties :
   * @param {String} [options.markersOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
   * @param {Array} [options.markersOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
   * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
   * @param {String} [options.layerDescription.title = "ItinÃ©raire"] - Layer title to be displayed in LayerSwitcher
   * @param {String} [options.layerDescription.description = "ItinÃ©raire basÃ© sur un graphe"] - Layer description to be displayed in LayerSwitcher
   * @fires route:drawstart
   * @fires route:drawend
   * @fires route:compute
   * @fires route:compute
   * @fires route:newresults
   * @example
   *  var route = ol.control.Route({
   *      "collapsed" : true
   *      "draggable" : true,
   *      "export"    : false,
   *      "exclusions" : {
   *         "toll" : true,
   *         "bridge" : false,
   *         "tunnel" : true
   *      },
   *      "graphs" : ['Pieton', 'Voiture'],
   *      "markersOpts" : {
   *          "departure" : {
   *              "url" : "...",
   *              "offset" : [0,0]
   *          },
   *          "stages" : {
   *              "url" : "...",
   *              "offset" : [0,0]
   *          },
   *          "arrival" : {
   *              "url" : "...",
   *              "offset" : [0,0]
   *          }
   *      }
   *      "autocompleteOptions" : {},
   *      "routeOptions" : {}
   *  });
   *
   *  // if you want to pluggued the control Export with options :
   *  var route = new ol.control.Route({
   *    export : {
   *      name : "export",
   *      format : "geojson",
   *      title : "Exporter",
   *      menu : false
   *    }
   *  });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Route)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Route";
    this.initialize(options);
    this._container = this._createMainContainerElement();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._container = this._initContainer(map);
      this.element = this._container;
      if (this.options.export) {
        var opts = Helper_default2.assign({ control: this }, this.options.export);
        this.export = new Export_default(opts);
        this.export.render();
        var self2 = this;
        this.export.on("button:clicked", (e) => {
          self2.dispatchEvent({
            type: "export:compute",
            content: e.content
          });
        });
      }
      if (this.draggable) {
        Draggable_default.dragElement(
          this._panelRouteContainer,
          this._panelHeaderRouteContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this._showRouteButton.setAttribute("aria-pressed", true);
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger22.log("[ERROR] Route:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      document.getElementById("GProutePanelClose-" + this._uid).click();
    } else {
      this._showRouteButton.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Get vector layer where geoJson route is drawn
   *
   * @returns {VectorLayer} layer - ol.layer.Vector route layer
   */
  getLayer() {
    return this._geojsonSections;
  }
  /**
   * Set vector layer where route geometry is drawn
   *
   * @param {VectorLayer} layer - ol.layer.Vector route layer
   */
  setLayer(layer) {
    if (!layer) {
      this._geojsonSections = null;
      return;
    }
    if (!(layer instanceof Vector_default2)) {
      logger22.log("no valid layer given for hosting drawn features.");
      return;
    }
    layer.setStyle(this._defaultFeatureStyle);
    this._geojsonSections = layer;
  }
  /**
   * Get vector layer
   *
   * @returns {String} geojson - GeoJSON format layer
   */
  getGeoJSON() {
    return JSON.stringify(this._geojsonObject);
  }
  /**
   * Set vector layer
   *
   * @param {String} geojson - GeoJSON format layer
   */
  setGeoJSON(geojson) {
    try {
      this._geojsonObject = JSON.parse(geojson);
    } catch (e) {
      logger22.log("no valid geojson given :" + e.message);
    }
  }
  /**
   * Get route informations
   *
   * @returns {Object} data - route informations
   */
  getData() {
    var points = [];
    for (let index2 = 0; index2 < this._currentPoints.length; index2++) {
      const p2 = this._currentPoints[index2];
      points.push(p2.getCoordinate());
    }
    var data = {
      type: "route",
      points,
      transport: this._currentTransport,
      exclusions: this._currentExclusions,
      computation: this._currentComputation,
      results: {}
    };
    Helper_default2.assign(data.results, this._currentRouteInformations);
    return data;
  }
  /**
   * Set route data
   *
   * @param {Object} data - control informations
   * @param {String} data.transport - transport type
   * @param {String} data.computation - computation type
   * @param {Array} data.exclusions - list of exclusions
   * @param {Array} data.points - list of points : [[lon, lat]]
   * @param {Object} data.results - service response
   */
  setData(data) {
    this._currentTransport = data.transport;
    this._currentComputation = data.computation;
    this._currentExclusions = data.exclusions;
    for (var j2 = 0; j2 < data.points.length; j2++) {
      const c = data.points[j2];
      if (c) {
        this._currentPoints[j2].setCoordinate(c, "EPSG:4326");
      }
    }
    for (var i = 0; i < this._currentPoints.length; i++) {
      var point = this._currentPoints[i];
      if (point.getCoordinate()) {
        var id = i + 1 + "-" + this._uid;
        var coordinate = point.getCoordinate()[1].toFixed(4) + " / " + point.getCoordinate()[0].toFixed(4);
        document.getElementById("GPlocationOriginCoords_" + id).value = coordinate;
        document.getElementById("GPlocationOrigin_" + id).value = coordinate;
        if (i > 0 && i < 6) {
          document.getElementById("GPlocationPoint_" + id).className = "GPflexInput GPelementHidden gpf-flex gpf-hidden ";
        }
      }
    }
    this._currentRouteInformations = data.results;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  /**
   * Get default style
   *
   * @returns {Style} style
   */
  getStyle() {
    return this._defaultFeatureStyle;
  }
  /**
   * This method is public.
   * It allows to init the control.
   */
  init() {
    for (let index2 = 0; index2 < this._currentPoints.length; index2++) {
      const point = this._currentPoints[index2];
      var id = index2 + 1;
      var coordinate = point.getCoordinate();
      if (coordinate) {
        var input = document.getElementById("GPlocationOrigin_" + id + "-" + this._uid);
        input.value = coordinate[1].toFixed(4) + " / " + coordinate[0].toFixed(4);
        if (index2 > 0 && index2 < 6) {
          document.getElementById("GPlocationPoint_" + id + "-" + this._uid).className = "GPflexInput GPlocationStageFlexInput gpf-flex";
        }
      }
    }
    var points = document.getElementsByClassName("GPlocationPoint-" + this._uid);
    this._addRouteResultsStagesValuesElement(points);
    var transportdiv;
    if (this._currentTransport === "Pieton") {
      transportdiv = document.getElementById("GProuteTransportPedestrian-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } else {
      transportdiv = document.getElementById("GProuteTransportCar-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    }
    var computationdiv = document.getElementById("GProuteComputationSelect-" + this._uid);
    if (computationdiv) {
      computationdiv.value = this._currentComputation;
    }
    var tollInput = document.getElementById("GProuteExclusionsToll-" + this._uid);
    if (tollInput) {
      if (this._currentExclusions.indexOf("toll") !== -1) {
        tollInput.checked = false;
      } else {
        tollInput.checked = true;
      }
    }
    var tunnelInput = document.getElementById("GProuteExclusionsTunnel-" + this._uid);
    if (tunnelInput) {
      if (this._currentExclusions.indexOf("tunnel") !== -1) {
        tunnelInput.checked = false;
      } else {
        tunnelInput.checked = true;
      }
    }
    var bridgeInput = document.getElementById("GProuteExclusionsBridge-" + this._uid);
    if (bridgeInput) {
      if (this._currentExclusions.indexOf("bridge") !== -1) {
        bridgeInput.checked = false;
      } else {
        bridgeInput.checked = true;
      }
    }
    var distance = this._currentRouteInformations.totalDistance;
    var duration = this._currentRouteInformations.totalTime;
    var instructions = this._simplifiedInstructions(this._currentRouteInformations.routeInstructions);
    if (instructions) {
      this._fillRouteResultsDetailsContainer(distance, duration, instructions);
    }
    this._formRouteContainer.className = "GPelementHidden gpf-hidden gpf-panel__content fr-modal__content";
    this._hideWaitingContainer();
    this._resultsRouteContainer.className = "";
  }
  /**
   * Clean UI : reinit control
   */
  clean() {
    this._currentTransport = null;
    this._currentExclusions = [];
    this._currentComputation = null;
    for (var i = 0; i < this._currentPoints.length; i++) {
      this._currentPoints[i].clear();
    }
    this._removeRouteStepLocations();
    this._clearRouteInputOptions();
    this._clearRouteResultsDetails();
    this.setLayer();
    this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
    this._resultsRouteContainer.className = "GPelementHidden gpf-hidden";
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize route control (called by Route constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this._checkInputOptions(options);
    this.options = {
      collapsed: true,
      draggable: false,
      export: false,
      graphs: ["Pieton", "Voiture"],
      exclusions: {
        toll: false,
        tunnel: false,
        bridge: false
      },
      routeOptions: {},
      autocompleteOptions: {},
      layerDescription: {
        title: "ItinÃ©raire",
        description: "ItinÃ©raire basÃ© sur un graphe"
      }
    };
    Helper_default2.assign(this.options, options);
    var defaultMarkersOpts = {
      departure: {
        url: Markers_default["red"],
        offset: Markers_default.defaultOffset
      },
      stages: {
        url: Markers_default["lightOrange"],
        offset: Markers_default.defaultOffset
      },
      arrival: {
        url: Markers_default["darkOrange"],
        offset: Markers_default.defaultOffset
      }
    };
    this.options.markersOpts = Helper_default2.assign(defaultMarkersOpts, options.markersOpts);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this._uid = this.options.id || SelectorID_default.generate();
    this._showRouteButton = null;
    this._panelRouteContainer = null;
    this._panelHeaderRouteContainer = null;
    this._waitingContainer = null;
    this._formRouteContainer = null;
    this._resultsRouteContainer = null;
    this._showRouteExclusionsElement = null;
    this._currentPoints = [];
    this._currentTransport = null;
    this._initTransport();
    this._currentComputation = null;
    this._initComputation();
    this._currentExclusions = [];
    this._initExclusions();
    this._waiting = false;
    this._timer = null;
    this._geojsonRoute = null;
    this._geojsonSections = null;
    this._geojsonObject = null;
    this.export = null;
    this._popupContent = null;
    this._popupDiv = this._initPopupDiv();
    this._popupOverlay = null;
    this._resultsSelectInteraction = null;
    this._resultsHoverInteraction = null;
    this._defaultFeatureStyle = new Style_default({
      stroke: new Stroke_default({
        color: "rgba(0,183,152,0.9)",
        width: 12
      })
    });
    this._selectedFeatureStyle = new Style_default({
      stroke: new Stroke_default({
        color: "rgba(255,102,0,0.9)",
        width: 12
      })
    });
    this._currentRouteInformations = null;
    this._resources = {};
    this.listenerKey = null;
  }
  /**
   * this method is called by this.initialize()
   *
   * @param {Object} options - options
   *
   * @private
   */
  _checkInputOptions(options) {
    if (options.graphs) {
      if (Array.isArray(options.graphs) && options.graphs.length) {
        for (var i = 0; i < options.graphs.length; i++) {
          if (typeof options.graphs[i] === "string") {
            if (options.graphs[i].toLowerCase() === "pieton") {
              options.graphs[i] = "Pieton";
            }
            if (options.graphs[i].toLowerCase() === "voiture") {
              options.graphs[i] = "Voiture";
            }
          } else {
            logger22.log("[ol.control.Route] ERROR : parameter 'graphs' elements should be of type 'string'");
            options.graphs[i] = null;
          }
        }
      } else {
        logger22.warn("'graphs' parameter should be an array");
        options.graphs = null;
      }
    }
    if (options.collapsed === "true") {
      options.collapsed = true;
    }
    if (options.collapsed === "false") {
      options.collapsed = false;
    }
  }
  /**
   * initialize component container (DOM)
   *
   * @param {Object} map - the map
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer(map) {
    var container = this._container;
    if (container.childElementCount > 0) {
      return container;
    }
    var picto = this._showRouteButton = this._createShowRoutePictoElement();
    container.appendChild(picto);
    var routePanel = this._panelRouteContainer = this._createRoutePanelElement();
    var routePanelDiv = this._createRoutePanelDivElement();
    routePanel.appendChild(routePanelDiv);
    var routeHeader = this._panelHeaderRouteContainer = this._createRoutePanelHeaderElement();
    routePanelDiv.appendChild(routeHeader);
    var routeForm = this._formRouteContainer = this._createRoutePanelFormElement();
    routeForm.appendChild(this._createRoutePanelFormModeChoiceTransportElement(this.options.graphs));
    var points = this._createRoutePanelFormPointsElement(map);
    for (var i = 0; i < points.length; i++) {
      routeForm.appendChild(points[i]);
    }
    routeForm.appendChild(this._createRoutePanelFormModeChoiceComputeElement());
    this._showRouteExclusionsElement = this._createShowRouteExclusionsPictoElement();
    routeForm.appendChild(this._showRouteExclusionsElement);
    var exclusion = this._createRoutePanelFormExclusionsElement();
    exclusion.appendChild(this._createRoutePanelFormExclusionOptionsElement(this.options.exclusions));
    routeForm.appendChild(exclusion);
    var panelFooter = this._createRoutePanelFooterElement();
    routeForm.appendChild(panelFooter);
    if (!CheckDsfr_default()) {
      var buttonReset = this._createRouteFormResetElement();
      panelFooter.appendChild(buttonReset);
    }
    var buttonSubmit = this._createRouteSubmitFormElement();
    panelFooter.appendChild(buttonSubmit);
    routePanelDiv.appendChild(routeForm);
    var routeResults = this._resultsRouteContainer = this._createRoutePanelResultsElement();
    routePanelDiv.appendChild(routeResults);
    var plugin = this._createDrawingButtonsPluginDiv();
    routePanelDiv.appendChild(plugin);
    var waiting = this._waitingContainer = this._createRouteWaitingElement();
    routePanelDiv.appendChild(waiting);
    container.appendChild(routePanel);
    if (container.addEventListener) {
      container.addEventListener("click", (e) => this._hideRouteSuggestedLocations(e));
    }
    return container;
  }
  // ################################################################### //
  // ####################### init application ########################## //
  // ################################################################### //
  /**
   * this method is called by the constructor and initialize transport mode
   * ("Voiture" ou "Pieton")
   *
   * @private
   */
  _initTransport() {
    this._currentTransport = "Pieton";
    var transport = this.options.graphs;
    if (!transport || transport.length === 0) {
      this.options.graphs = ["Pieton", "Voiture"];
    }
    if (Array.isArray(transport) && transport.length) {
      if (transport[0] === "Voiture" || transport[0] === "Pieton") {
        this._currentTransport = transport[0];
      }
    }
    var serviceOptions = this.options.routeOptions;
    if (serviceOptions.graph) {
      this._currentTransport = serviceOptions.graph;
    }
  }
  /**
   * this method is called by the constructor and initialize computation mode
   * (fastest or shortest)
   *
   * @private
   */
  _initComputation() {
    this._currentComputation = "fastest";
    var serviceOptions = this.options.routeOptions;
    if (serviceOptions.routePreference) {
      this._currentComputation = serviceOptions.routePreference;
    }
  }
  /**
   * this method is called by the constructor and initialize exclusions
   *
   * @private
   */
  _initExclusions() {
    this._currentExclusions = [];
    var exclusion = this.options.exclusions;
    if (!exclusion || typeof exclusion === "object" && Object.keys(exclusion).length === 0) {
      this.options.exclusions = {
        toll: false,
        tunnel: false,
        bridge: false
      };
    }
    if (exclusion && typeof exclusion === "object" && Object.keys(exclusion).length) {
      for (var k3 in exclusion) {
        if (exclusion.hasOwnProperty(k3)) {
          if (exclusion[k3]) {
            this._currentExclusions.push(k3);
          }
        }
      }
    }
    var serviceOptions = this.options.routeOptions;
    if (Array.isArray(serviceOptions.exclusions)) {
      this._currentExclusions = serviceOptions.exclusions;
    }
  }
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on route result click)
   *
   * @returns {Object} element - DOM element for popup
   * @private
   */
  _initPopupDiv() {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("button");
    closer.className = "gp-styling-button closer";
    closer.onclick = function() {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(void 0);
      }
      return false;
    };
    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    element.appendChild(this._popupContent);
    element.appendChild(closer);
    return element;
  }
  // ################################################################### //
  // ############################## DOM ################################ //
  // ################################################################### //
  /**
   * Create List Points
   * Overwrite RouteDOM method !
   *
   * @param {Map} map - the map
   *
   * @returns {Array} List DOM element
   * @private
   */
  _createRoutePanelFormPointsElement(map) {
    var points = [];
    var count = 1;
    var start2 = new LocationSelector_default({
      apiKey: this.options.apiKey || null,
      tag: {
        id: count,
        label: "DÃ©part",
        groupId: this._uid,
        markerOpts: this.options.markersOpts["departure"],
        display: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });
    start2.setMap(map);
    this._addFormPointsEventListeners(start2);
    points.push(this._createRoutePanelFormPointLabel("DÃ©part"));
    points.push(start2._container);
    this._currentPoints.push(start2);
    for (count = 2; count < 7; count++) {
      var step = new LocationSelector_default({
        apiKey: this.options.apiKey || null,
        tag: {
          id: count,
          label: "Etape " + (count - 1),
          groupId: this._uid,
          markerOpts: this.options.markersOpts["stages"],
          display: false,
          removeOption: true
        },
        autocompleteOptions: this.options.autocompleteOptions || null
      });
      step.setMap(map);
      this._addFormPointsEventListeners(step);
      points.push(this._createRoutePanelFormPointLabel("Ã‰tape", false));
      points.push(step._container);
      this._currentPoints.push(step);
    }
    var end = new LocationSelector_default({
      apiKey: this.options.apiKey || null,
      tag: {
        id: count,
        label: "ArrivÃ©e",
        groupId: this._uid,
        markerOpts: this.options.markersOpts["arrival"],
        display: true,
        addOption: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });
    end.setMap(map);
    this._addFormPointsEventListeners(end);
    points.push(this._createRoutePanelFormPointLabel("ArrivÃ©e"));
    points.push(end._container);
    this._currentPoints.push(end);
    return points;
  }
  /**
   * Attach events listeners to route form points (locationSelector)
   *
   * @param {Object} formPoint - route form point (locationSelector)
   * @private
   */
  _addFormPointsEventListeners(formPoint) {
    if (!formPoint) {
      return;
    }
    if (formPoint._buttonLabel.addEventListener) {
      formPoint._buttonLabel.addEventListener(
        "click",
        (e) => this.onRouteOriginLabelClick(e)
      );
      formPoint._inputShowPointer.addEventListener(
        "click",
        (e) => this.onRouteOriginPointerClick(e, formPoint)
      );
      if (formPoint._removePointElement) {
        formPoint._removePointElement.addEventListener(
          "click",
          (e) => {
            logger22.trace("click on _removePointElement", e);
          }
        );
      }
      if (formPoint._addPointElement) {
        formPoint._addPointElement.addEventListener(
          "click",
          (e) => {
            logger22.trace("click on _addPointElement", e);
          }
        );
      }
    } else if (formPoint._buttonLabel.attachEvent) {
      formPoint._buttonLabel.attachEvent(
        "onclick",
        (e) => this.onRouteOriginLabelClick(e)
      );
      formPoint._inputShowPointer.attachEvent(
        "onclick",
        (e) => this.onRouteOriginPointerClick(e, formPoint)
      );
      if (formPoint._removePointElement) {
        formPoint._removePointElement.attachEvent(
          "onclick",
          (e) => {
          }
        );
      }
      if (formPoint._addPointElement) {
        formPoint._addPointElement.attachEvent(
          "onclick",
          (e) => {
          }
        );
      }
    }
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'submit' on 'GProuteForm' tag form
   * (cf. this._createRoutePanelFormElement), and it displays the results.
   *
   * @param {Object} options - options
   * @private
   */
  onRouteComputationSubmit(options) {
    logger22.log("onRouteComputationSubmit", options);
    var points = this._currentPoints;
    var start2;
    if (points[0] && points[0].getCoordinate) {
      var startCoordinate = points[0].getCoordinate();
      start2 = {
        x: startCoordinate[0].toFixed(5),
        y: startCoordinate[1].toFixed(5)
      };
      logger22.log("start", start2);
    }
    var end;
    var endPoint = points[points.length - 1];
    if (endPoint && endPoint.getCoordinate) {
      var endCoordinate = endPoint.getCoordinate();
      end = {
        x: endCoordinate[0].toFixed(5),
        y: endCoordinate[1].toFixed(5)
      };
      logger22.log("end", end);
    }
    var step = [];
    for (var i = 1; i < points.length - 1; i++) {
      if (points[i] && points[i].getCoordinate) {
        var iCoordinate = points[i].getCoordinate();
        if (iCoordinate) {
          var coordinate = {
            x: iCoordinate[0].toFixed(5),
            y: iCoordinate[1].toFixed(5)
          };
          logger22.log("step", coordinate);
          step.push(coordinate);
        }
      }
    }
    this._currentTransport = options.transport;
    this._currentComputation = options.computation;
    this._currentExclusions = options.exclusions;
    var routeOptions = this.options.routeOptions;
    var routeResource;
    if (!routeOptions.resource) {
      if (this._currentComputation === "fastest" && this._currentTransport === "Pieton") {
        routeResource = "bdtopo-valhalla";
      }
    } else {
      routeResource = routeOptions.resource;
    }
    var _protocol = routeOptions.protocol || "XHR";
    var _timeout = routeOptions.timeOut || 0;
    if (_protocol === "JSONP" && _timeout === 0) {
      _timeout = 15e3;
    }
    var bOnFailure = !!(routeOptions.onFailure !== null && typeof routeOptions.onFailure === "function");
    var bOnSuccess = !!(routeOptions.onSuccess !== null && typeof routeOptions.onSuccess === "function");
    var context = this;
    this._requestRouting({
      startPoint: start2,
      endPoint: end,
      viaPoints: step,
      graph: routeOptions.graph || this._currentTransport,
      routePreference: routeOptions.routePreference || this._currentComputation,
      exclusions: routeOptions.exclusions || this._currentExclusions,
      geometryInInstructions: true,
      distanceUnit: "m",
      timeOut: _timeout,
      protocol: _protocol,
      resource: routeResource,
      // callback onSuccess
      onSuccess: function(results) {
        logger22.log(results);
        if (results) {
          context._fillRouteResultsDetails(results);
        }
        if (bOnSuccess) {
          routeOptions.onSuccess.call(context, results);
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._hideWaitingContainer();
        context._clearRouteResultsDetails();
        logger22.log(error.message);
        if (bOnFailure) {
          routeOptions.onFailure.call(context, error);
        }
      }
    });
  }
  /**
   * this method is called by event 'click' on 'GPlocationOriginLabel' label
   * and set 'GProuteForm' CSS class to "" (normal)
   *
   * @param {Object} routeControl - context : route Control (this)
   * @private
   */
  onRouteOriginLabelClick() {
    this._formRouteContainer.className = "gpf-panel__content gpf-mobile-form fr-modal__content";
    unByKey(this.listenerKey);
    this.dispatchEvent("route:drawend");
  }
  /**
   * this method is called by event 'click' on 'GPlocationOriginPointerImg' label
   * and display or minimize 'GProuteForm', using CSS class ("GProuteFormMini" or "")
   *
   * @param {Object} e - context : route Control (equivalent to this)
   * @param {Object} locationSelector - context : locationSelector input (one of this._currentPoints)
   * @private
   */
  onRouteOriginPointerClick(e, locationSelector) {
    var map = this.getMap();
    if (locationSelector._inputShowPointerContainer.checked) {
      this._formRouteContainer.className = "GProuteFormMini gpf-panel__content fr-modal__content";
      e.target.parentElement.parentElement.classList.add("selected");
      this.listenerKey = map.on(
        "click",
        () => {
          e.target.parentElement.parentElement.classList.remove("selected");
          if (this._formRouteContainer.className === "GProuteFormMini gpf-panel__content fr-modal__content") {
            this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
          }
          unByKey(this.listenerKey);
          this.dispatchEvent("route:drawend");
        }
      );
      this.dispatchEvent("route:drawstart");
    } else {
      this._formRouteContainer.className = "";
      unByKey(this.listenerKey);
      this.dispatchEvent("route:drawend");
    }
  }
  /**
   * this method is called by event 'click' on 'GPshowRoutePicto'
   * tag label (cf. this._createShowRoutePictoElement),
   * and it cleans all value of input.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onShowRoutePanelClick(e) {
    var opened = this._showRouteButton.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    if (!this._geojsonSections && !this._waiting) {
      this._clear();
    }
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
  /**
   * this method is called by event 'change' on 'GProuteComputationSelect' tag select
   * (cf. this._createRoutePanelFormModeChoiceComputeElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onRouteModeComputationChange(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    logger22.log(value2);
    this._currentComputation = value2;
  }
  /**
   * this method is called by event 'change' on 'GProuteResultsComputationSelect' tag select
   * (cf. this._createRouteResultsElement).
   * this value is saved as a parameter for the service route,
   * and this launches the route request !
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onRouteModeComputationChangeAndRun(e) {
    this.onRouteModeComputationChange(e);
    this._clearRouteResultsDetails();
    this._clearRouteResultsGeometry();
    this._clearRouteResultsFeatureGeometry();
    this.onRouteComputationSubmit({
      computation: this._currentComputation,
      transport: this._currentTransport,
      exclusions: this._currentExclusions
    });
  }
  /**
   * this method is called by event 'change' on 'GProuteTransportCar' or 'GProuteTransportPedestrian' tag input
   * (cf. this._createRoutePanelFormModeChoiceTransportElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {ObjecEventt} e - HTMLElement
   * @private
   */
  onRouteModeTransportChange(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    this._currentTransport = value2;
  }
  /**
   * TODO this method is called by event 'click' on 'GPshowRouteExclusionsPicto' tag input
   * (cf. this._createShowRouteExclusionsPictoElement), and it displays the panel options of exclusions.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onShowRouteExclusionsClick(e) {
    logger22.log("onShowRouteExclusionsClick", e);
  }
  /**
   * this method is called by event 'change' on 'GProuteExclusionsToll'
   * or 'GProuteExclusionsTunnel' or 'GProuteExclusionsBridge' tag input
   * (cf. this._createRoutePanelFormExclusionOptionsElement).
   * this value is saved as a parameter for the service route.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onRouteExclusionsChange(e) {
    var value2 = e.target.value;
    var checked = e.target.checked;
    if (!value2 || typeof value2 !== "string") {
      return;
    }
    value2 = value2.toLowerCase();
    var bFound = false;
    var iFound = null;
    for (var i = 0; i < this._currentExclusions.length; i++) {
      if (this._currentExclusions[i] === value2) {
        iFound = i;
        bFound = true;
      }
    }
    if (!bFound && !checked) {
      this._currentExclusions.push(value2);
    }
    if (bFound && checked) {
      this._currentExclusions.splice(iFound, 1);
    }
  }
  /**
   * this method is called by event 'click' on 'GProuteReset'
   * tag label (cf. this._createRouteFormResetElement),
   * and it cleans all route input options and results.
   *
   * @private
   */
  onRouteResetClick() {
    var currentPoints = this._currentPoints;
    for (var i = 0; i < currentPoints.length; i++) {
      currentPoints[i].clear();
    }
    this._clear();
    this._clearRouteInputOptions();
  }
  /**
   * this method is called by event 'click' on 'GProuteSubmit'
   * tag label (cf. this._createRouteSubmitFormElement),
   * and it cleans the route geometry.
   *
   * @private
   */
  onShowRouteResultsNewClick() {
    this._clearRouteResultsDetails();
    this._clearRouteResultsGeometry();
    this._clearRouteResultsFeatureGeometry();
    this.dispatchEvent("route:newresults");
  }
  /**
   * this method is called by event 'mouseover' on 'GProuteResultsDetailsInstruction_'
   * tag label (cf. this._addRouteResultsDetailsElement),
   * and it makes a style on feature route.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onRouteResultsDetailsMouseOver(e) {
    var tagid = e.target.id;
    var idx = tagid.substring(tagid.indexOf("_") + 1);
    if (e.target.classList) {
      e.target.classList.add("GProuteResultsDetailsInstructionHighlight");
    }
    if (!this._geojsonSections) {
      return;
    }
    var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
    f.setStyle(this._selectedFeatureStyle);
  }
  /**
   * this method is called by event 'mouseout' on 'GProuteResultsDetailsInstruction_'
   * tag label (cf. this._addRouteResultsDetailsElement),
   * and it deletes a style on feature route.
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  onRouteResultsDetailsMouseOut(e) {
    var tagid = e.target.id;
    var idx = tagid.substring(tagid.indexOf("_") + 1);
    if (e.target.classList) {
      e.target.classList.remove("GProuteResultsDetailsInstructionHighlight");
    }
    if (!this._geojsonSections) {
      return;
    }
    var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
    f.setStyle(null);
  }
  // ################################################################### //
  // ########################### Routing ############################### //
  // ############## (methods to request and results) ################### //
  /**
   * this method is called by this.onRouteComputationSubmit()
   * and executes a request to the service.
   *
   * @param {Object} options - route service request options
   * @param {Function} options.onSuccess - callback
   * @param {Function} options.onFailure - callback
   * @private
   */
  _requestRouting(options) {
    if (!options || typeof options === "object" && Object.keys(options).length === 0) {
      return;
    }
    if (!options.startPoint) {
      return;
    }
    if (!options.endPoint) {
      return;
    }
    options.apiKey = this.options.routeOptions.apiKey || this.options.apiKey;
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    logger22.log(options);
    this._displayWaitingContainer();
    Gp_default.Services.route(options);
  }
  /**
   * this method is called by this.onRouteComputationSubmit() (in case of route computation success)
   * and fills the container of the route instructions list, distance and time
   * information, also, constructs the geometry route.
   *
   * @param {Object} results - results of the route calculation
   *
   * @private
   */
  _fillRouteResultsDetails(results) {
    var distance = results.totalDistance;
    var duration = results.totalTime;
    var instructions = this._simplifiedInstructions(results.routeInstructions);
    if (instructions) {
      this._fillRouteResultsDetailsContainer(distance, duration, instructions);
    }
    var geometry = results.routeGeometry;
    if (geometry) {
      this._fillRouteResultsDetailsGeometry(geometry, this._defaultFeatureStyle);
    }
    if (instructions && instructions[0].geometry) {
      this._fillRouteResultsDetailsFeatureGeometry(instructions, this._defaultFeatureStyle);
    }
    var bbox = results.bbox;
    if (bbox) {
      var map = this.getMap();
      var bounds = [bbox.left, bbox.bottom, bbox.right, bbox.top];
      var mapProj = map.getView().getProjection().getCode();
      if (mapProj !== "EPSG:4326") {
        bounds = transformExtent(bounds, "EPSG:4326", mapProj);
      }
      map.getView().fit(bounds, map.getSize());
    }
    this._currentRouteInformations = results;
    this.dispatchEvent({
      type: "route:compute"
    });
    this._formRouteContainer.className = "GPelementHidden gpf-hidden gpf-panel__content fr-modal__content";
    this._hideWaitingContainer();
    this._resultsRouteContainer.className = "";
  }
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and fills the container of the route instructions list, distance and time
   * information.
   *
   * @param {Number} distance - distance
   * @param {Number} duration - duration
   * @param {Object[]} instructions - list of instructions
   *
   * @private
   */
  _fillRouteResultsDetailsContainer(distance, duration, instructions) {
    this._resultsRouteValuesContainer = this._addRouteResultsValuesElement(distance, duration, MathUtils_default.convertSecondsToTime);
    this._resultsRouteDetailsContainer = this._addRouteResultsDetailsElement(instructions, MathUtils_default.convertSecondsToTime);
  }
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and constructs the geometry route.
   *
   * @param {Object} geometry - geoJSON object for route geometry
   * @param {Object} style - route ol.style.Style object
   * @private
   */
  _fillRouteResultsDetailsGeometry(geometry, style) {
    this._clearRouteResultsGeometry();
    var map = this.getMap();
    if (!geometry) {
      return;
    }
    var geojsonObject = {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          crs: {
            type: "name",
            properties: {
              name: "EPSG:4326"
            }
          },
          geometry
        }
      ]
    };
    var geojsonformat = new GeoJSON_default2({
      defaultDataProjection: "EPSG:4326",
      defaultStyle: style
    });
    var features = geojsonformat.readFeatures(
      geojsonObject,
      {
        dataProjection: "EPSG:4326",
        featureProjection: "EPSG:3857"
      }
    );
    this._geojsonRoute = new Vector_default2({
      source: new Vector_default({
        features
      }),
      style,
      title: "Mon ItinÃ©raire"
    });
    map.addLayer(this._geojsonRoute);
  }
  /**
   * this method is called by this._fillRouteResultsDetails()
   * and constructs the geometries street with informations.
   *
   * @param {Array} instructions - route instructions list (containing geoJSON geometry)
   * @param {Object} style - route ol.style.Style object
   * @private
   */
  _fillRouteResultsDetailsFeatureGeometry(instructions, style) {
    this._clearRouteResultsFeatureGeometry();
    var map = this.getMap();
    this._geojsonObject = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:4326"
        }
      },
      features: []
    };
    for (var i = 0; i < instructions.length; i++) {
      var o = instructions[i];
      var id = i + 1;
      var coords = o.geometry.coordinates;
      for (var j2 = 0; j2 < coords.length; j2++) {
        if (typeof coords[j2][0] === "string") {
          coords[j2][0] = parseFloat(coords[j2][0]);
          coords[j2][1] = parseFloat(coords[j2][1]);
        }
      }
      this._geojsonObject.features.push({
        type: "Feature",
        geometry: o.geometry,
        properties: {
          popupContent: "(" + id + ") distance : " + MathUtils_default.convertDistance(o.distance) + " / temps : " + MathUtils_default.convertSecondsToTime(o.duration)
        },
        id
      });
    }
    this._geojsonObject.features.push({
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: this._currentPoints[0].getCoordinate()
      },
      properties: {
        description: "Point de dÃ©part",
        "marker-symbol": this.options.markersOpts.departure.url
      }
    });
    for (var k3 = 1; k3 < this._currentPoints.length - 1; k3++) {
      if (this._currentPoints[k3] && this._currentPoints[k3].getCoordinate) {
        var coordinates = this._currentPoints[k3].getCoordinate();
        if (coordinates) {
          this._geojsonObject.features.push({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates
            },
            properties: {
              description: "Point d'Ã©tape",
              "marker-symbol": this.options.markersOpts.stages.url
            }
          });
        }
      }
    }
    this._geojsonObject.features.push({
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: this._currentPoints[this._currentPoints.length - 1].getCoordinate()
      },
      properties: {
        description: "Point d'arrivÃ©e",
        "marker-symbol": this.options.markersOpts.arrival.url
      }
    });
    var geojsonformat = new GeoJSON_default2({
      defaultDataProjection: "EPSG:4326",
      defaultStyle: style
    });
    var mapProj = this.getMap().getView().getProjection().getCode();
    var features = geojsonformat.readFeatures(
      this._geojsonObject,
      {
        dataProjection: "EPSG:4326",
        featureProjection: mapProj
      }
    );
    this._geojsonSections = new Vector_default2({
      source: new Vector_default({
        features
      }),
      style,
      opacity: 0.9,
      title: "Mon ItinÃ©raire"
    });
    var graph;
    if (this._currentTransport === "Pieton") {
      graph = "piÃ©ton";
      this._geojsonSections.gpResultLayerId = "compute:Pieton$OGC:OPENLS;Itineraire";
    } else {
      graph = "voiture";
      this._geojsonSections.gpResultLayerId = "compute:Voiture$OGC:OPENLS;Itineraire";
    }
    map.addLayer(this._geojsonSections);
    map.getControls().forEach(
      (control) => {
        if (control instanceof LayerSwitcher_default) {
          var layerId = this._geojsonSections.gpLayerId;
          if (control._layers[layerId].title === layerId) {
            control.addLayer(
              this._geojsonSections,
              {
                title: this.options.layerDescription.title + " (" + graph + ")",
                description: this.options.layerDescription.description
              }
            );
          }
        }
      },
      this
    );
    this._resultsHoverInteraction = new Select_default({
      condition: pointerMove,
      layers: [this._geojsonSections],
      style: this._selectedFeatureStyle
    });
    this._resultsHoverInteraction.on(
      "select",
      (e) => this._onResultsFeatureMouseOver(e)
    );
    map.addInteraction(this._resultsHoverInteraction);
    this._resultsSelectInteraction = new Select_default({
      layers: [this._geojsonSections],
      style: this._selectedFeatureStyle
    });
    this._resultsSelectInteraction.on(
      "select",
      (e) => this._onResultsFeatureSelect(e)
    );
    map.addInteraction(this._resultsSelectInteraction);
  }
  /**
   * this method is called on route features hover
   * and highlight instruction label
   *
   * @param {Event} e - event
   *
   * @private
   */
  _onResultsFeatureMouseOver(e) {
    if (e.selected.length !== 0) {
      var f = e.selected[0];
      var selectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + f.getId() + "-" + this._uid);
      if (selectedInstruction && selectedInstruction.classList) {
        selectedInstruction.classList.add("GProuteResultsDetailsInstructionHighlight");
      }
    }
    if (e.deselected.length !== 0) {
      var deselectedFeature = e.deselected[0];
      var deSelectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + deselectedFeature.getId() + "-" + this._uid);
      if (deSelectedInstruction && deSelectedInstruction.classList) {
        deSelectedInstruction.classList.remove("GProuteResultsDetailsInstructionHighlight");
      }
    }
  }
  /**
   * this method is called on route features select
   * and set a popup with feature information
   *
   * @param {Event} e - on select event
   * @private
   */
  _onResultsFeatureSelect(e) {
    var map = this.getMap();
    if (e.selected.length !== 0) {
      var f = e.selected[0];
      this._popupContent.innerHTML = f.getProperties().popupContent;
      if (!this._popupOverlay) {
        this._popupOverlay = new Overlay_default({
          element: this._popupDiv,
          positioning: "bottom-center",
          position: e.mapBrowserEvent.coordinate
        });
        map.addOverlay(this._popupOverlay);
      } else {
        this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
      }
    } else {
      if (this._popupOverlay != null) {
        this._popupOverlay.setPosition(void 0);
      }
    }
  }
  // ################################################################### //
  // ############################# Clean ############################### //
  // ################################################################### //
  /**
   * this method is called by this.onShowRoutePanelClick()
   * and it clears all elements (reinit).
   *
   * @private
   */
  _clear() {
    this._currentTransport = null;
    this._currentExclusions = [];
    this._currentComputation = null;
    this._clearRouteResultsDetails();
    this._clearRouteResultsGeometry();
    this._clearRouteResultsFeatureGeometry();
    for (var i = 0; i < this._currentPoints.length; i++) {
      this._currentPoints[i].clear();
    }
    this._removeRouteStepLocations();
  }
  /**
   * this method is called by this.onRouteResetClick()
   * and it clears all options inputs (reinit).
   *
   * @private
   */
  _clearRouteInputOptions() {
    this._initTransport();
    this._initComputation();
    this._initExclusions();
    var transportdiv;
    if (this._currentTransport === "Pieton") {
      transportdiv = document.getElementById("GProuteTransportPedestrian-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } else {
      transportdiv = document.getElementById("GProuteTransportCar-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    }
    var computationdiv = document.getElementById("GProuteComputationSelect-" + this._uid);
    if (computationdiv) {
      computationdiv.value = this._currentComputation;
    }
    var tollInput = document.getElementById("GProuteExclusionsToll-" + this._uid);
    if (tollInput) {
      if (this._currentExclusions.indexOf("toll") !== -1) {
        tollInput.checked = false;
      } else {
        tollInput.checked = true;
      }
    }
    var tunnelInput = document.getElementById("GProuteExclusionsTunnel-" + this._uid);
    if (tunnelInput) {
      if (this._currentExclusions.indexOf("tunnel") !== -1) {
        tunnelInput.checked = false;
      } else {
        tunnelInput.checked = true;
      }
    }
    var bridgeInput = document.getElementById("GProuteExclusionsBridge-" + this._uid);
    if (bridgeInput) {
      if (this._currentExclusions.indexOf("bridge") !== -1) {
        bridgeInput.checked = false;
      } else {
        bridgeInput.checked = true;
      }
    }
  }
  /**
   * this method is called by this._clear()
   * and it removes step location inputs (excepted departure and arrival)
   *
   * @private
   */
  _removeRouteStepLocations() {
    var points = document.querySelectorAll('div[id^="GPlocationPoint"]');
    if (points.length !== 0) {
      var goodPoints = [];
      for (var k3 = 0; k3 < points.length; k3++) {
        if (points[k3].id.indexOf(this._uid) !== -1) {
          goodPoints.push(points[k3]);
        }
      }
      for (var i = 1; i < goodPoints.length - 1; i++) {
        var classList = goodPoints[i].classList;
        if (classList.length !== 0) {
          for (var j2 = 0; j2 < classList.length; j2++) {
            if (classList[j2] === "GPlocationStageFlexInput") {
              document.getElementById(this._addUID("GPlocationStageRemove_" + (i + 1))).click();
            }
          }
        }
      }
    }
  }
  /**
   * this method is called by this.onRouteComputationSubmit() (in case of failure)
   * and it clears all route instructions.
   *
   * @private
   */
  _clearRouteResultsDetails() {
    this._currentRouteInformations = null;
    if (this._resultsRouteDetailsContainer) {
      var detailsDiv = this._resultsRouteDetailsContainer;
      if (detailsDiv.childElementCount) {
        while (detailsDiv.firstChild) {
          detailsDiv.removeChild(detailsDiv.firstChild);
        }
      }
    }
    if (this._resultsRouteValuesContainer) {
      var valuesDiv = this._resultsRouteValuesContainer;
      if (valuesDiv.childElementCount) {
        while (valuesDiv.firstChild) {
          valuesDiv.removeChild(valuesDiv.firstChild);
        }
      }
    }
  }
  /**
   * this method is called by this.onRouteComputationSubmit()
   * and it clears all route geometries.
   *
   * @private
   */
  _clearRouteResultsGeometry() {
    var map = this.getMap();
    if (this._geojsonRoute != null) {
      map.removeLayer(this._geojsonRoute);
      this._geojsonRoute = null;
    }
  }
  /**
   * this method is called by this.onRouteComputationSubmit()
   * and it clears all route geometries.
   *
   * @private
   */
  _clearRouteResultsFeatureGeometry() {
    var map = this.getMap();
    if (this._geojsonSections != null) {
      map.removeLayer(this._geojsonSections);
      this._geojsonSections = null;
      this._geojsonObject = null;
    }
    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    }
    if (this._resultsSelectInteraction != null) {
      map.removeInteraction(this._resultsSelectInteraction);
      this._resultsSelectInteraction = null;
    }
    if (this._resultsHoverInteraction != null) {
      map.removeInteraction(this._resultsHoverInteraction);
      this._resultsHoverInteraction = null;
    }
  }
  /**
   * this method is called by event 'click' on control main container
   * and hide suggested Locations (unless target is an autocomplete input)
   *
   * @param {Object} e - event
   *
   * @private
   */
  _hideRouteSuggestedLocations(e) {
    if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {
      var pointId = parseInt(e.target.id.split("_")[1][0], 10) - 1;
      for (var j2 = 0; j2 < this._currentPoints.length; j2++) {
        if (j2 !== parseInt(pointId, 10)) {
          this._currentPoints[j2]._hideSuggestedLocation();
        }
      }
    } else {
      for (var i = 0; i < this._currentPoints.length; i++) {
        this._currentPoints[i]._hideSuggestedLocation();
      }
    }
  }
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */
  _displayWaitingContainer() {
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
    this._waiting = true;
    var opts = this.options.routeOptions;
    if (opts && opts.timeOut) {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      var context = this;
      this._timer = setTimeout(function() {
        if (context._waiting === true) {
          context._hideWaitingContainer();
        } else {
          if (context._timer) {
            clearTimeout(context._timer);
          }
        }
      }, 16e3);
    }
  }
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */
  _hideWaitingContainer() {
    if (this._waiting) {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
      this._waiting = false;
      var opts = this.options.routeOptions;
      if (opts && opts.timeOut) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  }
  // ################################################################### //
  // ########################## Geometry ############################### //
  // ################################################################### //
  /**
   * simplified instructions
   *
   * @param {Object[]} instructions - list of instructions
   *
   * @returns {Object[]} simplified instructions
   *
   * @private
   */
  _simplifiedInstructions(instructions) {
    var newInstructions = [];
    var current = instructions[0];
    if (instructions.length === 1) {
      newInstructions.push(current);
    }
    for (var i = 1; i < instructions.length; i++) {
      var o = instructions[i];
      if (o.instruction === current.instruction) {
        current.distance = (parseFloat(o.distance) + parseFloat(current.distance)).toString();
        current.duration = (parseFloat(o.duration) + parseFloat(current.duration)).toString();
        for (var j2 = 1; j2 < o.geometry.coordinates.length; j2++) {
          current.geometry.coordinates.push(o.geometry.coordinates[j2]);
        }
      } else {
        newInstructions.push(current);
        current = o;
        if (i === instructions.length - 1) {
          newInstructions.push(o);
          current = null;
        }
      }
    }
    logger22.log(newInstructions);
    return newInstructions;
  }
};
Object.assign(Route2.prototype, RouteDOM_default);
Object.assign(Route2.prototype, Widget_default);
var Route_default2 = Route2;
if (window.ol && window.ol.control) {
  window.ol.control.Route = Route2;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Isocurve/Isocurve.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Isochron/GPFisochron.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Isocurve/IsocurveDOM.js
var IsoDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPisochron");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //
  /**
   * Show iso control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowIsoPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowIsochronPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowIsochronPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-isocurve");
    button.classList.add("icon--ri", "icon--ri--map-pin-time-line");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Calculer une isochrone");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowIsoPanelClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowIsoPanelClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createIsoPanelHeaderElement
   * don't call this._createIsoPanelFormElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPisochronPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createIsoPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  _createDrawingButtonsPluginDiv: function() {
    var div = document.createElement("div");
    div.className = "container-buttons-plugin fr-mx-2w";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.innerHTML = "Calcul d'isochrone";
    container.appendChild(div);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPisochronPanelClose");
    divClose.className = "GPpanelClose GPisochronPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowIsochronPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowIsochronPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormElement: function() {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPisochronForm");
    form.className = "GPform gpf-panel__content gpf-mobile-form fr-modal__content";
    form.addEventListener("submit", function(e) {
      e.preventDefault();
      self2.onIsoComputationSubmit(e);
      return false;
    });
    return form;
  },
  /**
   * Create Results Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelResultsElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.id = this._addUID("GPisoResultsPanel");
    container.className = "GPelementHidden gpf-hidden";
    var divNew = document.createElement("div");
    divNew.id = this._addUID("GPisoResultsNew");
    divNew.className = "GPresetPicto gpf-btn gpf-btn-icon-reset fr-btn fr-btn--secondary gpf-btn--secondary fr-m-2w";
    divNew.title = "Modifier le calcul";
    divNew.addEventListener("click", function(e) {
      document.getElementById(self2._addUID("GPisoResultsPanel")).className = "GPelementHidden gpf-hidden";
      document.getElementById(self2._addUID("GPisochronForm")).className = "gpf-panel__content fr-modal__content";
      self2.onShowIsoResultsNewClick(e);
    });
    container.appendChild(divNew);
    return container;
  },
  /**
   * Add Results Duration and Distance
   * (results dynamically generate !)
   * see event!
   * @param {Object} results - resultats renvoyÃ© par le service d'isochrone
   * @param {Object} computeOptions - options donnÃ©es au service d'isochrone
   * @param {Function} fconvert - fconvert
   *
   * @returns {HTMLElement} DOM element
   */
  _addIsoResultsValuesElement: function(results, computeOptions, fconvert) {
    var distance = results.distance;
    var duration = results.time;
    var origin = results.location;
    var mode2 = computeOptions.graph;
    var type = computeOptions.method;
    var exclusions = computeOptions.exclusions;
    var div = document.getElementById(this._addUID("GPisoResultsPanel"));
    if (div.childElementCount && div.firstChild.id === this._addUID("GPisoResultsValueDiv")) {
      div.removeChild(div.firstChild);
    }
    var isoResultsValueDiv = document.createElement("div");
    isoResultsValueDiv.id = this._addUID("GPisoResultsValueDiv");
    isoResultsValueDiv.className = "fr-m-2w";
    var containerType = document.createElement("div");
    containerType.className = "GPisoResultsValue";
    var labelType = document.createElement("label");
    labelType.className = "GPisoResultsValueLabel";
    labelType.innerHTML = "Type :";
    containerType.appendChild(labelType);
    var divType = document.createElement("div");
    divType.id = this._addUID("GPisoResultsValueType");
    if (type === "time") {
      divType.innerHTML = "temps";
    } else {
      divType.innerHTML = "distance";
    }
    containerType.appendChild(divType);
    isoResultsValueDiv.appendChild(containerType);
    var containerMode = document.createElement("div");
    containerMode.className = "GPisoResultsValue";
    var labelMode = document.createElement("label");
    labelMode.className = "GPisoResultsValueLabel";
    labelMode.innerHTML = "Mode :";
    containerMode.appendChild(labelMode);
    var divMode = document.createElement("div");
    divMode.id = this._addUID("GPisoResultsValueMode");
    divMode.innerHTML = mode2;
    containerMode.appendChild(divMode);
    isoResultsValueDiv.appendChild(containerMode);
    var containerOrigin = document.createElement("div");
    containerOrigin.className = "GPisoResultsValue";
    var labelOrigin = document.createElement("label");
    labelOrigin.className = "GPisoResultsValueLabel";
    labelOrigin.innerHTML = "Centre :";
    containerOrigin.appendChild(labelOrigin);
    var divOrigin = document.createElement("div");
    divOrigin.id = this._addUID("GPisoResultsValueOrigin");
    divOrigin.innerHTML = parseFloat(origin.y).toFixed(4) + ", " + parseFloat(origin.x).toFixed(4);
    containerOrigin.appendChild(divOrigin);
    isoResultsValueDiv.appendChild(containerOrigin);
    if (distance && distance.length !== 0) {
      var containerDistance = document.createElement("div");
      containerDistance.className = "GPisoResultsValue";
      var labelDistance = document.createElement("label");
      labelDistance.className = "GPisoResultsValueLabel";
      labelDistance.innerHTML = "Distance :";
      containerDistance.appendChild(labelDistance);
      var distanceLabel = 0;
      var isKm = parseInt(distance / 1e3, 10);
      if (!isKm) {
        distanceLabel = Math.round(distance) + " m";
      } else {
        var distanceArrondi = Math.round(distance);
        distanceArrondi = distanceArrondi / 1e3;
        distanceLabel = distanceArrondi + " km";
      }
      var divDistance = document.createElement("div");
      divDistance.id = this._addUID("GPisoResultsValueDist");
      divDistance.innerHTML = distanceLabel;
      containerDistance.appendChild(divDistance);
      isoResultsValueDiv.appendChild(containerDistance);
    }
    if (duration && duration.length !== 0) {
      var containerDuration = document.createElement("div");
      containerDuration.className = "GPisoResultsValue";
      var labelDuration = document.createElement("label");
      labelDuration.className = "GPisoResultsValueLabel";
      labelDuration.innerHTML = "DurÃ©e :";
      containerDuration.appendChild(labelDuration);
      var divDuration = document.createElement("div");
      divDuration.id = this._addUID("GPisoResultsValueTime");
      divDuration.innerHTML = fconvert(duration);
      containerDuration.appendChild(divDuration);
      isoResultsValueDiv.appendChild(containerDuration);
    }
    if (exclusions.length > 0) {
      var containerExclusions = document.createElement("div");
      containerExclusions.className = "GPisoResultsValue";
      var labelExclusions = document.createElement("label");
      labelExclusions.className = "GPisoResultsValueLabel";
      labelExclusions.innerHTML = "Exclusions :";
      containerExclusions.appendChild(labelExclusions);
      var divExclusions = document.createElement("div");
      divExclusions.id = this._addUID("GPisoResultsValueExclusions");
      divExclusions.innerHTML = exclusions.join(", ");
      containerExclusions.appendChild(divExclusions);
      isoResultsValueDiv.appendChild(containerExclusions);
    }
    div.prepend(isoResultsValueDiv);
    return div;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  /**
   * Create Footer Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFooterElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelFooter gpf-panel__footer fr-modal__footer";
    return container;
  },
  /**
   * Create Point label
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormPointLabel: function() {
    var p2 = document.createElement("p");
    p2.id = this._addUID("GPisochronPointLabelP");
    p2.className = "gpf-label fr-label";
    p2.innerHTML = "DÃ©part";
    return p2;
  },
  // ################################################################### //
  // ############# Methods to the type choice into form ################ //
  // ################################################################### //
  /**
   * Create Container to type choice
   *
   * FIXME
   * don't call this._createIsoPanelFormTypeChoiceChronElement
   * don't call this._createIsoPanelFormTypeChoiceDistElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormTypeChoiceElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronChoice");
    div.className = "fr-mt-2w";
    return div;
  },
  /**
   * Create Type choice Chron
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormTypeChoiceChronElement: function(checked) {
    var self2 = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt gpf-flex gpf-flex-isocurve gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltChron");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;
    if (input.addEventListener) {
      input.addEventListener("change", function(e) {
        document.getElementById(self2._addUID("GPisochronValueChron")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self2._addUID("GPisochronValueDist")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronValueChronLabelP")).className = "gpf-label fr-label";
        document.getElementById(self2._addUID("GPisochronValueDistLabelP")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronSubmit")).value = "Calculer l'isochrone";
        self2.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function() {
        document.getElementById(self2._addUID("GPisochronValueChron")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self2._addUID("GPisochronValueDist")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronValueChronLabelP")).className = "gpf-label fr-label";
        document.getElementById(self2._addUID("GPisochronValueDistLabelP")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronSubmit")).value = "Calculer l'isochrone";
        self2.onIsoTypeChoiceChange();
      });
    }
    input.value = "isochron";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg gpf-label fr-label";
    label.htmlFor = this._addUID("GPisochronChoiceAltChron");
    label.innerHTML = "DurÃ©e";
    label.title = "DurÃ©e";
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltChronTxt");
    span.className = "gpf-hidden";
    span.innerHTML = "DurÃ©e";
    if (span.addEventListener) {
      span.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPisochronChoiceAltChron")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPisochronChoiceAltChron")).click();
      });
    }
    div.appendChild(span);
    return div;
  },
  /**
   * Create Type choice Dist
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormTypeChoiceDistElement: function(checked) {
    var self2 = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt gpf-flex gpf-flex-isocurve gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltDist");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;
    if (input.addEventListener) {
      input.addEventListener("change", function(e) {
        document.getElementById(self2._addUID("GPisochronValueDist")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self2._addUID("GPisochronValueChron")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronValueDistLabelP")).className = "gpf-label fr-label";
        document.getElementById(self2._addUID("GPisochronValueChronLabelP")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronSubmit")).value = "Calculer l'isodistance";
        self2.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function() {
        document.getElementById(self2._addUID("GPisochronValueDist")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self2._addUID("GPisochronValueChron")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronValueDistLabelP")).className = "gpf-label fr-label";
        document.getElementById(self2._addUID("GPisochronValueChronLabelP")).className = "GPelementHidden gpf-hidden";
        document.getElementById(self2._addUID("GPisochronSubmit")).value = "Calculer l'isodistance";
        self2.onIsoTypeChoiceChange();
      });
    }
    input.value = "isodistance";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg gpf-label fr-label";
    label.htmlFor = this._addUID("GPisochronChoiceAltDist");
    label.innerHTML = "Distance";
    label.title = "Distance";
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltDistTxt");
    span.className = "gpf-hidden";
    span.innerHTML = "Distance";
    if (span.addEventListener) {
      span.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPisochronChoiceAltDist")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPisochronChoiceAltDist")).click();
      });
    }
    div.appendChild(span);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the value iso into form ################ //
  // ################################################################### //
  /**
   * Create isochron inputs label
   * see event !
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormLabelIsochronElement: function(checked) {
    var context = this;
    var p2 = document.createElement("p");
    p2.id = this._addUID("GPisochronValueChronLabelP");
    p2.className = checked ? "gpf-label fr-label" : "GPelementHidden gpf-hidden";
    p2.innerHTML = "DÃ©finir un temps de trajet";
    return p2;
  },
  /**
   * Create isochron inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormValueIsochronElement: function(checked) {
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueChron");
    div.className = checked ? "GPflexInput gpf-flex fr-mt-1w" : "GPelementHidden gpf-hidden";
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueChronInput1");
    input1.className = "gpf-input fr-input";
    input1.min = "0";
    input1.step = "1";
    input1.value = "0";
    input1.type = "number";
    input1.title = "Temps";
    if (input1.addEventListener) {
      input1.addEventListener("change", function(e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function(e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    }
    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "h";
    label1.className = "gpf-label fr-label";
    div.appendChild(label1);
    var input2 = document.createElement("input");
    input2.id = this._addUID("GPisochronValueChronInput2");
    input2.className = "gpf-input fr-input";
    input2.min = "0";
    input2.max = "59";
    input2.step = "1";
    input2.value = "0";
    input2.type = "number";
    input2.title = "Heures";
    if (input2.addEventListener) {
      input2.addEventListener("change", function(e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    } else if (input2.attachEvent) {
      input2.attachEvent("onchange", function(e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    }
    div.appendChild(input2);
    var label2 = document.createElement("label");
    label2.innerHTML = "min";
    label2.className = "gpf-label fr-label";
    div.appendChild(label2);
    return div;
  },
  /**
   * Create isodistance inputs label
   * see event !
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormLabelIsodistanceElement: function(checked) {
    var context = this;
    var p2 = document.createElement("p");
    p2.id = this._addUID("GPisochronValueDistLabelP");
    p2.className = checked ? "gpf-label fr-label" : "GPelementHidden gpf-hidden";
    p2.innerHTML = "DÃ©finir une distance";
    return p2;
  },
  /**
   * Create isodistance inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormValueIsodistanceElement: function(checked) {
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueDist");
    div.className = checked ? "GPflexInput gpf-flex fr-mt-1w" : "GPelementHidden gpf-hidden";
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueDistInput");
    input1.className = "gpf-input fr-input fr-ml-1w";
    input1.min = "0";
    input1.step = "any";
    input1.value = "0";
    input1.type = "number";
    input1.title = "Distance";
    if (input1.addEventListener) {
      input1.addEventListener("change", function(e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function(e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    }
    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "km";
    label1.className = "gpf-label fr-label";
    div.appendChild(label1);
    return div;
  },
  // ################################################################### //
  // ############ Methods to the mode choice into form ################# //
  // ################################################################### //
  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {Array} transports - transports in a list
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormModeChoiceTransportElement: function(transports) {
    var context = this;
    var divContainer = document.createElement("div");
    divContainer.id = this._addUID("GPisochronTransportChoice");
    var label = document.createElement("label");
    label.className = "GPisochronModeLabel gpf-label fr-label";
    label.innerHTML = "Choisir un mode de dÃ©placement";
    divContainer.appendChild(label);
    var radioContainer = document.createElement("div");
    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];
      var div = document.createElement("div");
      div.className = "GPisochronTransportChoice gpf-flex gpf-radio-group fr-radio-group";
      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GPisochronTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GPisochronTransport";
        if (i === 0) {
          inputCar.checked = true;
        }
        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function(e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function(e) {
            context.onIsoModeTransportChange(e);
          });
        }
        inputCar.value = "Voiture";
        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GPisochronTransportImg gpf-label fr-label";
        labelCar.htmlFor = this._addUID("GPisochronTransportCar");
        labelCar.title = "Voiture";
        labelCar.innerHTML = "Voiture";
        div.appendChild(labelCar);
      }
      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GPisochronTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GPisochronTransport";
        if (i === 0) {
          inputPedestrian.checked = true;
        }
        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function(e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function(e) {
            context.onIsoModeTransportChange(e);
          });
        }
        inputPedestrian.value = "Pieton";
        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GPisochronTransportImg gpf-label fr-label";
        labelPedestrian.htmlFor = this._addUID("GPisochronTransportPedestrian");
        labelPedestrian.title = "PiÃ©ton";
        labelPedestrian.innerHTML = "PiÃ©ton";
        div.appendChild(labelPedestrian);
      }
      radioContainer.appendChild(div);
    }
    divContainer.appendChild(radioContainer);
    return divContainer;
  },
  /**
   * Create Mode choice direction
   * see event!
   *
   * @param {Array} directions - directions to display in list ("Departure", "Arrival"). First element will be selected by default
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormModeChoiceDirectionElement: function(directions) {
    var self2 = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronDirectionChoice");
    div.className = "fr-my-2w";
    var label = document.createElement("label");
    label.innerHTML = "DÃ©finir un sens de parcours";
    label.className = "fr-label";
    div.appendChild(label);
    var select = document.createElement("select");
    select.id = this._addUID("GPisochronDirectionSelect");
    select.className = "GPselect gpf-select fr-select";
    select.title = "Sens de parcours";
    select.addEventListener("change", function(e) {
      self2.onIsoModeDirectionChange(e);
    });
    for (var i = 0; i < directions.length; i++) {
      var direction = directions[i];
      if (direction.toLowerCase() === "departure") {
        var departureOption = document.createElement("option");
        if (i === 0) {
          departureOption.selected = "selected";
        }
        departureOption.value = "departure";
        departureOption.text = "DÃ©part";
        select.appendChild(departureOption);
      }
      if (direction.toLowerCase() === "arrival") {
        var arrivalOption = document.createElement("option");
        if (i === 0) {
          arrivalOption.selected = "selected";
        }
        arrivalOption.value = "arrival";
        arrivalOption.text = "ArrivÃ©e";
        select.appendChild(arrivalOption);
      }
    }
    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //
  /**
   * Label to Exclusions Options
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowIsoExclusionsPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowIsoExclusionsPicto");
    var hidden = "";
    if (CheckDsfr_default()) {
      hidden = "GPelementHidden gpf-hidden";
    }
    button.className = `GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowIsoExclusionsPicto ${hidden} gpf-btn fr-btn--sm fr-btn--tertiary gpf-btn--tertiary fr-icon-arrow-down-fill`;
    button.title = "Exclusions";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", true);
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        e.preventDefault();
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowIsoSettingsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        e.preventDefault();
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowIsoSettingsClick(e);
      });
    }
    return button;
  },
  /**
   * Create Container to Exclusions
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormExclusionsElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisoExclusions");
    var label = document.createElement("label");
    label.className = "GPisoExclusionsLabel gpf-label fr-label";
    label.innerHTML = "Passages autorisÃ©s";
    div.appendChild(label);
    return div;
  },
  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Array} exclusions - exclusions to display in list
   * @returns {HTMLElement} DOM element
   */
  _createIsoPanelFormExclusionOptionsElement: function(exclusions) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPisoExclusionsOptions gpf-flex fr-checkbox-group fr-m-1w";
    for (var value2 in exclusions) {
      if (exclusions.hasOwnProperty(value2)) {
        var status = exclusions[value2];
        switch (value2) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GPisoExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.name = "PÃ©ages";
            inputToll.checked = !status;
            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function(e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function(e) {
                context.onIsoExclusionsChange(e);
              });
            }
            inputToll.value = "Toll";
            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GPisoExclusionsOption";
            labelToll.htmlFor = this._addUID("GPisoExclusionsToll");
            labelToll.innerHTML = "PÃ©ages";
            div.appendChild(labelToll);
            break;
          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GPisoExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.name = "Tunnel";
            inputTunnel.checked = !status;
            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function(e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function(e) {
                context.onIsoExclusionsChange(e);
              });
            }
            inputTunnel.value = "Tunnel";
            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GPisoExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GPisoExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;
          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GPisoExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.name = "Ponts";
            inputBridge.checked = !status;
            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function(e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function(e) {
                context.onIsoExclusionsChange(e);
              });
            }
            inputBridge.value = "Bridge";
            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GPisoExclusionsOption";
            labelBridge.htmlFor = this._addUID("GPisoExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }
    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //
  /**
   * Create Submit Form Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoSubmitFormElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronSubmit");
    input.className = "GPsubmit gpf-btn fr-btn";
    input.type = "submit";
    input.value = "Calculer l'isochrone";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //
  /**
   * Create Reset Picto Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createIsoFormResetElement: function() {
    var self2 = this;
    var buttonReset = document.createElement("button");
    buttonReset.id = this._addUID("GPisochronReset");
    buttonReset.className = "GPresetPicto GPisochronReset gpf-btn gpf-btn-icon-reset gpf-btn-icon-isocurve-reset fr-btn fr-btn--secondary gpf-btn--secondary";
    buttonReset.title = "RÃ©initialiser les paramÃ¨tres";
    buttonReset.setAttribute("tabindex", "0");
    buttonReset.setAttribute("aria-pressed", false);
    buttonReset.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self2.onIsoResetClick(e);
    });
    return buttonReset;
  }
};
var IsocurveDOM_default = IsoDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Isocurve/Isocurve.js
var logger23 = LoggerByDefault_default2.getLogger("isocurve");
var Isocurve = class _Isocurve extends Control_default2 {
  /**
   * @constructor
  * @param {Object} options - Isocurve control options
  * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {String} [options.apiKey] - API key for services call (isocurve and autocomplete services). The key "calcul" is used by default.
  * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
  * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
  * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
  * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link packages/Controls/Export/Export.default}
  * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
  * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of graph resources to be used for isocurve calculation, by default : ["Voiture", "Pieton"]. Possible values are "Voiture" and "Pieton". The first element is selected.
  * @param {Array}   [options.methods = ["time", "distance"]] - list of methods, by default : ["time", "distance"]. Possible values are "time" and "distance". The first element is selected by default.
  * @param {Array}   [options.directions = ["departure", "arrival"]] - list of directions to be displayed, by default : ["departure", "arrival"]. The first element is selected by default. Possible values are "departure" and "arrival".
  *      Directions enable to specify if input location point will be used as a departure point ("departure") or as an arrival point ("arrival")
  * @param {Object} [options.isocurveOptions = {}] - isocurve service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~isoCurve Gp.Services.isoCurve()} to know all isocurve options.
  * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
  * @param {Object} [options.markerOpts] - options to use your own marker. Default is a lightOrange marker.
  * @param {String} [options.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
  * @param {Array} [options.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
  * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
  * @param {String} [options.layerDescription.title = "Isochrone/Isodistance"] - Layer title to be displayed in LayerSwitcher
  * @param {String} [options.layerDescription.description = "isochrone/isodistance basÃ© sur un graphe"] - Layer description to be displayed in LayerSwitcher
  * @fires isocurve:drawstart
  * @fires isocurve:drawend
  * @fires isocurve:compute
  * @fires export:compute
  * @example
  *  var iso = ol.control.Isocurve({
  *      "collapsed" : false,
  *      "draggable" : true,
  *      "export"    : false,
  *      "methods" : ["time", "distance"],
  *      "exclusions" : {
  *         "toll" : true,
  *         "bridge" : false,
  *         "tunnel" : true
  *      },
  *      "graphs" : ["Pieton", "Voiture"],
  *      "markerOpts" : {
  *          "url" : "...",
  *          "offset" : [0,0]
  *      }
  *      "isocurveOptions" : {},
  *      "autocompleteOptions" : {}
  *  });
  *
  *  // if you want to pluggued the control Export with options :
  *  var iso = new ol.control.Isocurve({
  *    export : {
  *      name : "export",
  *      format : "geojson",
  *      title : "Exporter",
  *      menu : false
  *    }
  *  });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Isocurve)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Isocurve";
    this.initialize(options);
    this._container = this._createMainContainerElement();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._container = this._initContainer(map);
      if (this.options.export) {
        var opts = Helper_default2.assign({ control: this }, this.options.export);
        this.export = new Export_default(opts);
        this.export.render();
        var self2 = this;
        this.export.on("button:clicked", (e) => {
          self2.dispatchEvent({
            type: "export:compute",
            content: e.content
          });
        });
      }
      if (this.draggable) {
        Draggable_default.dragElement(
          this._IsoPanelContainer,
          this._IsoPanelHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this._pictoIsoButton.setAttribute("aria-pressed", true);
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger23.log("[ERROR] Isocurve:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      document.getElementById("GPisochronPanelClose-" + this._uid).click();
    } else {
      this._pictoIsoButton.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Get vector layer where Isocurve geometry is drawn
   *
   * @returns {Object} layer - ol.layer.Vector isocurve layer
   */
  getLayer() {
    return this._geojsonLayer;
  }
  /**
   * Set vector layer where Isocurve geometry is drawn
   *
   * @param {Layer} layer - ol.layer.Vector isocurve layer
   */
  setLayer(layer) {
    if (!layer) {
      this._geojsonLayer = null;
      return;
    }
    if (!(layer instanceof Vector_default2)) {
      logger23.log("no valid layer given for hosting drawn features.");
      return;
    }
    layer.setStyle(this._defaultFeatureStyle);
    this._geojsonLayer = layer;
  }
  /**
   * Get vector layer
   *
   * @returns {String} geojson - GeoJSON format layer
   */
  getGeoJSON() {
    return JSON.stringify(this._geojsonObject);
  }
  /**
   * Set vector layer
   *
   * @param {String} geojson - GeoJSON format layer
   */
  setGeoJSON(geojson) {
    try {
      this._geojsonObject = JSON.parse(geojson);
    } catch (e) {
      logger23.log("no valid geojson given :" + e.message);
    }
  }
  /**
   * Get isocurve data
   *
   * @returns {Object} data - process results
   */
  getData() {
    var data = {
      type: "isocurve",
      transport: this._currentTransport,
      computation: this._currentComputation,
      exclusions: this._currentExclusions,
      direction: this._currentDirection,
      point: this._originPoint.getCoordinate(),
      // lon/lat wgs84
      results: {}
    };
    Helper_default2.assign(data.results, this._currentIsoResults);
    return data;
  }
  /**
   * Set isocurve data
   *
   * @param {Object} data - control informations
   * @param {String} data.transport - transport type
   * @param {String} data.computation - computation type
   * @param {Array} data.exclusions - list of exclusions
   * @param {String} data.direction - direction type
   * @param {Array} data.point - [lon, lat]
   * @param {Object} data.results - service response
   */
  setData(data) {
    this._currentTransport = data.transport;
    this._currentComputation = data.computation;
    this._currentExclusions = data.exclusions;
    this._currentDirection = data.direction;
    var inputPointer = document.getElementById("GPlocationOriginPointer_1-" + this._uid);
    inputPointer.checked = true;
    var inputCoordsDOM = document.getElementById("GPlocationOrigin_1-" + this._uid);
    var inputCoords = document.getElementById("GPlocationOriginCoords_1-" + this._uid);
    inputCoords.value = data.point;
    inputCoordsDOM.value = data.point[1].toFixed(4) + " / " + data.point[0].toFixed(4);
    this._originPoint.setCoordinate(data.point, "EPSG:4326");
    this._currentIsoResults = data.results;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  /**
   * Get default style
   *
   * @returns {ol.style} style
   */
  getStyle() {
    return this._defaultFeatureStyle;
  }
  /**
   * This method is public.
   * It allows to control the execution of a traitment.
   *
   * @param {Array} position - position in the projection map [ x, y ]
   * @param {Object} value - distance in km or hours-minutes
   * @param {Object} options - options = {...}
   */
  compute(position, value2, options) {
    this._clear();
    var opened = this._pictoIsoButton.ariaPressed;
    if (!(opened === "true")) {
      this._pictoIsoButton.click();
    }
    var map = this.getMap();
    if (!map) {
      return;
    }
    var settings = {
      direction: "departure",
      method: "time",
      transport: "Voiture",
      exclusions: []
    };
    Helper_default2.assign(settings, options);
    this._originPoint.setCoordinate(position);
    var coordinate = this._originPoint.getCoordinate();
    var input = document.getElementById("GPlocationOrigin_1-" + this._uid);
    input.value = coordinate[0].toFixed(4) + " / " + coordinate[1].toFixed(4);
    this._currentTransport = settings.transport;
    if (settings.transport === "Voiture") {
      document.getElementById("GPisochronTransportCar-" + this._uid).checked = true;
    } else {
      document.getElementById("GPisochronTransportPedestrian-" + this._uid).checked = true;
    }
    this._currentExclusions = settings.exclusions;
    this._currentComputation = settings.method;
    if (settings.method === "time") {
      var time = value2.split(".");
      this._currentTimeHour = time[0] || 0;
      document.getElementById("GPisochronValueChronInput1-" + this._uid).value = this._currentTimeHour;
      this._currentTimeMinute = time[1] || 0;
      document.getElementById("GPisochronValueChronInput2-" + this._uid).value = this._currentTimeMinute;
      document.getElementById("GPisochronChoiceAltChron-" + this._uid).click();
    } else {
      this._currentDistance = value2;
      document.getElementById("GPisochronValueDistInput-" + this._uid).value = this._currentDistance;
      document.getElementById("GPisochronChoiceAltDist-" + this._uid).click();
    }
    this._currentDirection = settings.direction;
    settings.direction === "departure" ? document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 0 : document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 1;
    this.onIsoComputationSubmit();
  }
  /**
   * This method is public.
   * It allows to init the control.
   */
  init() {
    var coordinate = this._originPoint.getCoordinate();
    var input = document.getElementById("GPlocationOrigin_1-" + this._uid);
    input.value = coordinate[1].toFixed(4) + " / " + coordinate[0].toFixed(4);
    if (this._currentTransport === "Voiture") {
      document.getElementById("GPisochronTransportCar-" + this._uid).checked = true;
    } else {
      document.getElementById("GPisochronTransportPedestrian-" + this._uid).checked = true;
    }
    if (this._currentComputation === "time") {
      var minutes = this._currentIsoResults.time / 60;
      this._currentTimeHour = Math.floor(minutes / 60);
      document.getElementById("GPisochronValueChronInput1-" + this._uid).value = this._currentTimeHour;
      this._currentTimeMinute = Math.round((minutes / 60 - this._currentTimeHour) * 60);
      document.getElementById("GPisochronValueChronInput2-" + this._uid).value = this._currentTimeMinute;
      document.getElementById("GPisochronChoiceAltChron-" + this._uid).click();
    } else {
      this._currentDistance = this._currentIsoResults.distance / 1e3;
      document.getElementById("GPisochronValueDistInput-" + this._uid).value = this._currentDistance;
      document.getElementById("GPisochronChoiceAltDist-" + this._uid).click();
    }
    this._currentDirection === "departure" ? document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 0 : document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 1;
    this._fillIsoResultsDetails(this._currentIsoResults, {
      graph: this._currentTransport,
      exclusions: this._currentExclusions,
      method: this._currentComputation
    });
  }
  /**
   * Clean UI : reinit control
   */
  clean() {
    this._clearIsoInputs();
    this._originPoint.clearResults();
    document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
    document.getElementById("GPlocationOriginCoords_1-" + this._uid).value = "";
    document.getElementById("GPlocationOrigin_1-" + this._uid).value = "";
    document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
    document.getElementById("GPlocationOriginPointer_1-" + this._uid).checked = false;
    document.getElementById("GPlocationOrigin_1-" + this._uid).className = "GPlocationOriginVisible gpf-visible";
    document.getElementById("GPlocationOriginCoords_1-" + this._uid).className = "GPlocationOriginHidden gpf-hidden";
    this._currentIsoResults = null;
    this.setLayer();
    this._resultsIsoContainer.className = "GPelementHidden gpf-hidden";
    this._formContainer.className = "gpf-panel__content fr-modal__content";
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize Isocurve control (called by Isocurve constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this._checkInputOptions(options);
    this.options = {
      collapsed: true,
      draggable: false,
      export: false,
      methods: ["time", "distance"],
      graphs: ["Pieton", "Voiture"],
      exclusions: {
        toll: false,
        tunnel: false,
        bridge: false
      },
      directions: ["departure", "arrival"],
      markerOpts: {
        url: Markers_default["lightOrange"],
        offset: Markers_default.defaultOffset
      },
      isocurveOptions: {},
      autocompleteOptions: {},
      layerDescription: {
        title: "Isochrone/Isodistance",
        description: "isochrone/isodistance basÃ© sur un graphe"
      }
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this._uid = this.options.id || SelectorID_default.generate();
    this._currentTransport = null;
    this._initTransport();
    this._currentComputation = null;
    this._initComputation();
    this._currentExclusions = [];
    this._initExclusions();
    this._currentDirection = null;
    this._initDirection();
    this._originPoint = null;
    this._pictoIsoButton = null;
    this._waitingContainer = null;
    this._formContainer = null;
    this._resultsIsoContainer = null;
    this._IsoPanelContainer = null;
    this._IsoPanelHeaderContainer = null;
    this._currentIsoResults = null;
    this._geojsonLayer = null;
    this._geojsonObject = null;
    this.export = null;
    this._waiting = false;
    this._timer = null;
    this._defaultFeatureStyle = new Style_default({
      fill: new Fill_default({
        color: "rgba(0, 183, 152, 0.7)"
      }),
      stroke: new Stroke_default({
        color: "rgba(0, 183, 152, 0)",
        width: 1
      })
    });
    this._resources = {};
    this.listenerKey = null;
    this.COMPUTE_ISOCURVE_EVENT = "isocurve:comput";
    this.RESULTS_ISOCURVE_EVENT = "isocurve:newresults";
    this.DRAW_START_ISOCURVE_EVENT = "isocurve:drawstart";
    this.DRAW_END_ISOCURVE_EVENT = "isocurve:drawend";
  }
  /**
   * this method is called by this.initialize()
   *
   * @param {Object} options - options
   *
   * @private
   */
  _checkInputOptions(options) {
    var i;
    if (options.methods) {
      if (Array.isArray(options.methods)) {
        if (options.methods.length === 0) {
          options.methods = null;
        } else {
          for (i = 0; i < options.methods.length; i++) {
            if (typeof options.methods[i] !== "string") {
              logger23.log("[ol.control.Isocurve] ERROR : parameter 'methods' elements should be of type 'string'");
            }
          }
        }
      } else {
        logger23.warn("'methods' parameter should be an array");
        options.methods = null;
      }
    }
    if (options.graphs) {
      if (Array.isArray(options.graphs)) {
        if (options.graphs.length === 0) {
          options.graphs = null;
        } else {
          for (i = 0; i < options.graphs.length; i++) {
            if (typeof options.graphs[i] !== "string") {
              logger23.log("[ol.control.Isocurve] ERROR : parameter 'graphs' elements should be of type 'string'");
            } else {
              if (options.graphs[i].toLowerCase() === "pieton") {
                options.graphs[i] = "Pieton";
              }
              if (options.graphs[i].toLowerCase() === "voiture") {
                options.graphs[i] = "Voiture";
              }
            }
          }
        }
      } else {
        logger23.warn("'graphs' parameter should be an array");
        options.graphs = null;
      }
    }
    if (options.directions) {
      if (Array.isArray(options.directions)) {
        if (options.directions.length === 0) {
          options.directions = null;
        } else {
          for (i = 0; i < options.directions.length; i++) {
            if (typeof options.directions[i] !== "string") {
              logger23.log("[ol.control.Isocurve] ERROR : parameter 'directions' elements should be of type 'string'");
            }
          }
        }
      } else {
        logger23.warn("'directions' parameter should be an array");
        options.directions = null;
      }
    }
    if (options.collapsed === "true") {
      options.collapsed = true;
    }
    if (options.collapsed === "false") {
      options.collapsed = false;
    }
  }
  /**
   * this method is called by this.initialize() and initialize transport mode
   * ("Voiture" ou "Pieton")
   *
   * @private
   */
  _initTransport() {
    this._currentTransport = "PiÃ©ton";
    var transports = this.options.graphs;
    if (!transports || transports.length === 0) {
      this.options.graphs = ["Pieton", "Voiture"];
    }
    if (Array.isArray(transports) && transports.length) {
      if (transports[0] === "Voiture" || transports[0] === "Pieton") {
        this._currentTransport = transports[0];
      }
    }
    var serviceOptions = this.options.isocurveOptions;
    if (serviceOptions.graph) {
      this._currentTransport = serviceOptions.graph;
    }
  }
  /**
   * this method is called by this.initialize() and initialize computation mode
   * (time or distance)
   *
   * @private
   */
  _initComputation() {
    this._currentComputation = "time";
    var methods = this.options.methods;
    if (!methods || methods.length === 0) {
      this.options.methods = ["time", "distance"];
    }
    if (Array.isArray(methods) && methods.length) {
      if (methods[0] === "time" || methods[0] === "distance") {
        this._currentComputation = methods[0];
      }
    }
    var serviceOptions = this.options.isocurveOptions;
    if (serviceOptions.method) {
      this._currentComputation = serviceOptions.method;
    }
    if (serviceOptions.time) {
      this._currentComputation = "time";
    }
    if (serviceOptions.distance) {
      this._currentComputation = "distance";
    }
  }
  /**
   * this method is called by this.initialize() and initialize direction mode
   * (departure or arrival)
   *
   * @private
   */
  _initDirection() {
    this._currentDirection = "departure";
    var directions = this.options.directions;
    if (!directions || directions.length === 0) {
      this.options.directions = ["departure", "arrival"];
    }
    if (Array.isArray(directions) && directions.length) {
      if (directions[0] === "departure" || directions[0] === "arrival") {
        this._currentDirection = directions[0];
      }
    }
    var serviceOptions = this.options.isocurveOptions;
    if (!serviceOptions.reverse) {
      this._currentDirection = "departure";
    }
    if (serviceOptions.reverse === true) {
      this._currentDirection = "arrival";
      this.options.directions = ["arrival", "departure"];
    }
  }
  /**
   * this method is called by this.initialize() and initialize exclusions
   *
   * @private
   */
  _initExclusions() {
    this._currentExclusions = [];
    var exclusion = this.options.exclusions;
    if (!exclusion || typeof exclusion === "object" && Object.keys(exclusion).length === 0) {
      this.options.exclusions = {
        toll: false,
        tunnel: false,
        bridge: false
      };
    }
    if (exclusion && typeof exclusion === "object" && Object.keys(exclusion).length) {
      for (var k3 in exclusion) {
        if (exclusion.hasOwnProperty(k3)) {
          if (exclusion.k) {
            this._currentExclusions.push(k3);
          }
        }
      }
    }
    var serviceOptions = this.options.isocurveOptions;
    if (Array.isArray(serviceOptions.exclusions)) {
      this._currentExclusions = serviceOptions.exclusions;
    }
  }
  // ################################################################### //
  // ######################## DOM initialize ########################### //
  // ################################################################### //
  /**
   * initialize component container (DOM)
   *
   * @param {Object} map - the map
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer(map) {
    var container = this._container;
    if (container.childElementCount > 0) {
      return container;
    }
    var picto = this._pictoIsoButton = this._createShowIsoPictoElement();
    container.appendChild(picto);
    var panel = this._IsoPanelContainer = this._createIsoPanelElement();
    var panelDiv = this._createIsoPanelDivElement();
    panel.appendChild(panelDiv);
    var header = this._IsoPanelHeaderContainer = this._createIsoPanelHeaderElement();
    panelDiv.appendChild(header);
    var form = this._formContainer = this._createIsoPanelFormElement();
    form.appendChild(this._createIsoPanelFormModeChoiceTransportElement(this.options.graphs));
    form.appendChild(this._createIsoPanelFormPointLabel());
    var point = this._createIsoPanelFormPointElement(map);
    form.appendChild(point);
    var isoChronChecked = false;
    var isoDistChecked = false;
    var typeChoice = this._createIsoPanelFormTypeChoiceElement();
    for (var i = 0; i < this.options.methods.length; i++) {
      if (this.options.methods[i] === "time") {
        isoChronChecked = i === 0;
        typeChoice.appendChild(this._createIsoPanelFormTypeChoiceChronElement(isoChronChecked));
      }
      if (this.options.methods[i] === "distance") {
        isoDistChecked = i === 0;
        typeChoice.appendChild(this._createIsoPanelFormTypeChoiceDistElement(isoDistChecked));
      }
    }
    form.appendChild(typeChoice);
    form.appendChild(this._createIsoPanelFormLabelIsochronElement(isoChronChecked));
    form.appendChild(this._createIsoPanelFormValueIsochronElement(isoChronChecked));
    form.appendChild(this._createIsoPanelFormLabelIsodistanceElement(isoDistChecked));
    form.appendChild(this._createIsoPanelFormValueIsodistanceElement(isoDistChecked));
    form.appendChild(this._createIsoPanelFormModeChoiceDirectionElement(this.options.directions));
    if (this.options.exclusions && typeof this.options.exclusions === "object" && Object.keys(this.options.exclusions).length !== 0) {
      form.appendChild(this._createShowIsoExclusionsPictoElement());
      var exclusion = this._createIsoPanelFormExclusionsElement();
      exclusion.appendChild(this._createIsoPanelFormExclusionOptionsElement(this.options.exclusions));
      form.appendChild(exclusion);
    }
    var footer = this._createIsoPanelFooterElement();
    form.appendChild(footer);
    if (!CheckDsfr_default()) {
      var buttonReset = this._createIsoFormResetElement();
      footer.appendChild(buttonReset);
    }
    var buttonSubmit = this._submitContainer = this._createIsoSubmitFormElement();
    footer.appendChild(buttonSubmit);
    panelDiv.appendChild(form);
    var isoResults = this._resultsIsoContainer = this._createIsoPanelResultsElement();
    panelDiv.appendChild(isoResults);
    var plugin = this._createDrawingButtonsPluginDiv();
    panelDiv.appendChild(plugin);
    var waiting = this._waitingContainer = this._createIsoWaitingElement();
    panel.appendChild(waiting);
    container.appendChild(panel);
    if (container.addEventListener) {
      container.addEventListener("click", (e) => this._hideIsoSuggestedLocations(e));
    }
    return container;
  }
  /**
   * Create start point
   *
   * @param {Object} map - the map
   *
   * @returns {Object} DOM element
   * @private
   */
  _createIsoPanelFormPointElement(map) {
    this._originPoint = new LocationSelector_default({
      apiKey: this.options.apiKey || null,
      tag: {
        id: 1,
        groupId: this._uid,
        markerOpts: this.options.markerOpts,
        display: true
      },
      autocompleteOptions: this.options.autocompleteOptions || null
    });
    this._originPoint.setMap(map);
    var self2 = this;
    document.getElementById("GPlocationOriginPointerImg_1-" + this._uid).onclick = function() {
      self2._clearGeojsonLayer();
      var map2 = self2.getMap();
      if (self2._originPoint._inputShowPointerContainer.checked) {
        self2._formContainer.className = "GPisochronFormMini gpf-panel__content fr-modal__content";
        this.listenerKey = map2.on(
          "click",
          () => {
            self2._formContainer.className = "gpf-panel__content fr-modal__content";
            self2.dispatchEvent(self2.DRAW_END_ISOCURVE_EVENT);
          }
        );
      } else {
        self2._formContainer.className = "gpf-panel__content fr-modal__content";
        unByKey(this.listenerKey);
      }
      self2.dispatchEvent(self2.DRAW_START_ISOCURVE_EVENT);
    };
    document.getElementById("GPlocationOriginLabel_1-" + this._uid).onclick = function() {
      self2._clearGeojsonLayer();
      self2._formContainer.className = "gpf-panel__content fr-modal__content";
      map.un(
        "click",
        () => {
          self2._formContainer.className = "gpf-panel__content fr-modal__content";
        }
      );
      self2.dispatchEvent(self2.DRAW_END_ISOCURVE_EVENT);
    };
    document.getElementById("GPlocationOrigin_1-" + this._uid).onclick = function() {
      self2._clearGeojsonLayer();
      self2.dispatchEvent(self2.DRAW_END_ISOCURVE_EVENT);
    };
    return this._originPoint._container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'submit' on 'GPisochronForm' tag form
   * (cf. this._createIsoPanelFormElement),
   * and call isocurve service to display results
   *
   * @private
   */
  onIsoComputationSubmit() {
    if (!this._originPoint || !this._originPoint.getCoordinate || !this._originPoint.getCoordinate()) {
      logger23.log("[Isocurve] Missing position parameter to submit isocurve request");
      return;
    }
    var positionCoordinates = this._originPoint.getCoordinate();
    var position = {
      x: positionCoordinates[0].toFixed(5),
      y: positionCoordinates[1].toFixed(5)
    };
    logger23.log("origin : ", position);
    var time;
    var distance;
    if (this._currentComputation.toLowerCase() === "time") {
      var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);
      var hours = parseInt(timeHourInput.value, 10);
      if (isNaN && isNaN(hours)) {
        hours = 0;
      }
      var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);
      var minutes = parseInt(timeMinutesInput.value, 10);
      if (isNaN && isNaN(minutes)) {
        minutes = 0;
      }
      time = hours * 3600 + minutes * 60;
      logger23.log("time : " + time);
    }
    if (this._currentComputation.toLowerCase() === "distance") {
      var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid);
      distance = parseFloat(distInput.value) * 1e3;
      logger23.log("distance : " + distance);
    }
    if (!time && !distance) {
      logger23.log("[Isocurve] Missing time or distance parameter to submit isocurve request");
      return;
    }
    var options = this.options.isocurveOptions || {};
    var _protocol = options.protocol || "XHR";
    var _timeout = options.timeOut || 0;
    if (_protocol === "JSONP" && _timeout === 0) {
      _timeout = 15e3;
    }
    var bOnFailure = !!(options.onFailure !== null && typeof options.onFailure === "function");
    var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");
    var context = this;
    var isoRequestOptions = {
      position,
      graph: options.graph || this._currentTransport,
      exclusions: options.exclusions || this._currentExclusions,
      method: options.method || this._currentComputation,
      smoothing: options.smoothing || true,
      timeOut: _timeout,
      protocol: _protocol,
      resource: options.resource,
      // callback onSuccess
      onSuccess: function(results) {
        logger23.log(results);
        if (results) {
          context._fillIsoResultsDetails(results, isoRequestOptions);
          context._drawIsoResults(results);
        }
        if (bOnSuccess) {
          options.onSuccess.call(context, results);
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._hideWaitingContainer();
        logger23.log(error.message);
        if (bOnFailure) {
          options.onFailure.call(context, error);
        }
      }
    };
    if (this._currentDirection.toLowerCase() === "arrival" || options.reverse) {
      isoRequestOptions.reverse = true;
    }
    if (time) {
      isoRequestOptions.time = time;
    }
    if (distance) {
      isoRequestOptions.distance = distance;
    }
    this._requestIsoCurve(isoRequestOptions);
  }
  /**
   * this method is called by event 'click' on 'GPshowIsochronPicto' picto
   * (cf. this._createShowIsoPictoElement),
   * and clear inputs and previous isocurve drawings
   *
   * @param { event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowIsoPanelClick(e) {
    var opened = this._pictoIsoButton.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
  /**
   * this method is called by event 'change' on 'GPisochronChoiceAltDist' or 'GPisochronChoiceAltChron'
   * input (cf. this._createIsoPanelFormTypeChoiceElement),
   * and updates current computation mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onIsoTypeChoiceChange(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    if (value2 === "isodistance") {
      this._currentComputation = "distance";
    }
    if (value2 === "isochron") {
      this._currentComputation = "time";
    }
  }
  /**
   * this method is called by event 'click' on 'GPisochronTransportPedestrian' or 'GPisochronTransportCar'
   * input (cf. this._createIsoPanelFormModeChoiceTransportElement),
   * and updates current transport mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onIsoModeTransportChange(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    this._currentTransport = value2;
  }
  /**
   * this method is called by event 'change' on 'GPisochronDirectionSelect' select
   * (cf. this._createIsoPanelFormModeChoiceDirectionElement),
   * and updates current direction mode
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onIsoModeDirectionChange(e) {
    var value2 = e.target.value;
    if (!value2) {
      return;
    }
    if (value2.toLowerCase() === "arrival") {
      document.getElementById("GPisochronPointLabelP-" + this._uid).innerHTML = "ArrivÃ©e";
    } else {
      document.getElementById("GPisochronPointLabelP-" + this._uid).innerHTML = "DÃ©part";
    }
    this._currentDirection = value2;
  }
  /**
   * this method is called by event 'change' on 'GPIsoExclusionsToll'
   * or 'GPIsoeExclusionsTunnel' or 'GPIsoExclusionsBridge' tag input
   * (cf. this._createIsoPanelFormExclusionOptionsElement).
   * this value is saved as a parameter for the service isocurve.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onIsoExclusionsChange(e) {
    var value2 = e.target.value;
    var checked = e.target.checked;
    if (!value2) {
      return;
    }
    var bFound = false;
    var iFound = null;
    for (var i = 0; i < this._currentExclusions.length; i++) {
      if (deepEqual(this._currentExclusions[i], value2.toLowerCase())) {
        iFound = i;
        bFound = true;
      }
    }
    if (!bFound && !checked) {
      this._currentExclusions.push(value2.toLowerCase());
    }
    if (bFound && checked) {
      this._currentExclusions[iFound] = null;
    }
  }
  /**
   * this method is called by event 'click' on 'GPisoReset'
   * tag label (cf. this._createIsoFormResetElement),
   * and it cleans all isochron input options and results.
   *
   * @private
   */
  onIsoResetClick() {
    this._clear();
  }
  /**
   * this method is called by event 'click' on 'GPIsoSubmit'
   * tag label (cf. this._createIsoSubmitFormElement),
   * and it cleans the isochrone geometry.
   *
   * @private
   */
  onShowIsoResultsNewClick() {
    this._clearGeojsonLayer();
    this.dispatchEvent(this.RESULTS_ISOCURVE_EVENT);
  }
  /**
   * ...
   * @private
   */
  onShowIsoSettingsClick() {
  }
  // ################################################################### //
  // ######################## isocurve calculation ##################### //
  // ################################################################### //
  /**
   * this method is called by this.onIsoComputationSubmit
   * and executes a request to the service.
   *
   * @param {Object} options - isocurve service request options
   * @private
   */
  _requestIsoCurve(options) {
    if (!options || typeof options === "object" && Object.keys(options).length === 0) {
      return;
    }
    if (!options.position) {
      return;
    }
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    logger23.log(options);
    this._clearGeojsonLayer();
    this._displayWaitingContainer();
    Gp_default.Services.isoCurve(options);
  }
  /**
   * this method is called by this.onIsoComputationSubmit() (in case of route computation success)
   * and fills the container of the iso compute results with its metadata
   * information, also, constructs the geometry isochrone.
   *
   * @param {Object} results - results of the iso calculation
   * @param {Object} computeOptions - options of the iso calculation
   *
   * @private
   */
  _fillIsoResultsDetails(results, computeOptions) {
    this._fillIsoResultsDetailsContainer(results, computeOptions);
    this._currentIsoInformations = results;
    this.dispatchEvent({
      type: this.COMPUTE_ISOCURVE_EVENT
    });
    this._formContainer.className = "GPelementHidden gpf-hidden gpf-panel__content fr-modal__content";
    this._hideWaitingContainer();
    this._resultsIsoContainer.className = "gpf-flex GPflex";
  }
  /**
   * this method is called by this._fillIsoResultsDetails()
   * and fills the container of the iso compute results with its metadata
   * information.
   *
   * @param {Object} results - Resultats renvoyÃ©s par le service d'isochrone
   * @param {Object} computeOptions - options of the iso calculation
   * 
   * @private
   */
  _fillIsoResultsDetailsContainer(results, computeOptions) {
    this._resultsIsoValuesContainer = this._addIsoResultsValuesElement(results, computeOptions, MathUtils_default.convertSecondsToTime);
  }
  /**
   * this method is called by this.onIsoComputationSubmit (in case of success)
   * and draw isocurve results geometry on map
   *
   * @param {Object} results - isocurve response results
   * @private
   */
  _drawIsoResults(results) {
    this._currentIsoResults = results;
    this._hideWaitingContainer();
    if (!results.geometry) {
      return;
    }
    var map = this.getMap();
    this._geojsonObject = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:4326"
        }
      },
      features: [
        {
          type: "Feature",
          crs: {
            type: "name",
            properties: {
              name: "EPSG:4326"
            }
          },
          geometry: results.geometry
        }
      ]
    };
    this._geojsonObject.features.push({
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: this._originPoint.getCoordinate()
      },
      properties: {
        description: "Point d'origine",
        "marker-symbol": this.options.markerOpts.url
      }
    });
    var geojsonformat = new GeoJSON_default2({
      defaultDataProjection: "EPSG:4326",
      defaultStyle: this._defaultFeatureStyle
    });
    var mapProj = map.getView().getProjection().getCode();
    var features = geojsonformat.readFeatures(
      this._geojsonObject,
      {
        dataProjection: "EPSG:4326",
        featureProjection: mapProj
      }
    );
    var method = this._currentComputation === "time" ? "Isochrone" : "Isodistance";
    this._geojsonLayer = new Vector_default2({
      source: new Vector_default({
        features
      }),
      style: this._defaultFeatureStyle,
      opacity: 0.9,
      title: "Mon " + method
    });
    var graph;
    if (this._currentTransport === "Pieton") {
      graph = "piÃ©ton";
      this._geojsonLayer.gpResultLayerId = "compute:Pieton$GEOPORTAIL:GPP:Isocurve";
    } else {
      graph = "voiture";
      this._geojsonLayer.gpResultLayerId = "compute:Voiture$GEOPORTAIL:GPP:Isocurve";
    }
    map.addLayer(this._geojsonLayer);
    this.dispatchEvent({
      type: this.COMPUTE_ISOCURVE_EVENT
    });
    if (features[0] && features[0].getGeometry() && features[0].getGeometry().getExtent()) {
      var extent = features[0].getGeometry().getExtent();
      map.getView().fit(extent, map.getSize());
    }
    var method = this._currentComputation === "time" ? "Isochrone" : "Isodistance";
    map.getControls().forEach(
      (control) => {
        if (control instanceof LayerSwitcher_default) {
          var layerId = this._geojsonLayer.gpLayerId;
          if (control._layers[layerId].title === layerId) {
            control.addLayer(
              this._geojsonLayer,
              {
                title: this.options.layerDescription.title + " (" + method + "/" + graph + ")",
                description: this.options.layerDescription.description
              }
            );
          }
        }
      }
    );
  }
  // ################################################################### //
  // ############################# Clean ############################### //
  // ################################################################### //
  /**
   * this method is called by this.onShowIsoPanelClick()
   * and it clears all elements (reinit).
   *
   * @private
   */
  _clear() {
    this._clearIsoInputs();
    this._originPoint.clear();
    this._clearGeojsonLayer();
    this._currentIsoResults = null;
  }
  /**
   * this method is called by this._clear()
   * and it clears all input elements (dist and time)
   *
   * @private
   */
  _clearIsoInputs() {
    var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);
    if (timeHourInput) {
      timeHourInput.value = "0";
    }
    var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);
    if (timeMinutesInput) {
      timeMinutesInput.value = "0";
    }
    var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid);
    if (distInput) {
      distInput.value = "0";
    }
    this._initTransport();
    this._initComputation();
    this._initDirection();
    this._initExclusions();
    var transportdiv;
    if (this._currentTransport === "Pieton") {
      transportdiv = document.getElementById("GPisochronTransportPedestrian-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    } else {
      transportdiv = document.getElementById("GPisochronTransportCar-" + this._uid);
      if (transportdiv) {
        transportdiv.checked = "true";
      }
    }
    var computationdiv;
    if (this._currentComputation.toLowerCase() === "distance") {
      computationdiv = document.getElementById("GPisochronChoiceAltDist-" + this._uid);
      if (computationdiv) {
        computationdiv.checked = "true";
      }
      if (document.getElementById("GPisochronValueDist-" + this._uid)) {
        document.getElementById("GPisochronValueDist-" + this._uid).className = "GPflexInput gpf-flex";
      }
      if (document.getElementById("GPisochronValueChron-" + this._uid)) {
        document.getElementById("GPisochronValueChron-" + this._uid).className = "GPelementHidden gpf-hidden";
      }
    } else {
      computationdiv = document.getElementById("GPisochronChoiceAltChron-" + this._uid);
      if (computationdiv) {
        computationdiv.checked = "true";
      }
      if (document.getElementById("GPisochronValueChron-" + this._uid)) {
        document.getElementById("GPisochronValueChron-" + this._uid).className = "GPflexInput gpf-flex";
      }
      if (document.getElementById("GPisochronValueDist-" + this._uid)) {
        document.getElementById("GPisochronValueDist-" + this._uid).className = "GPelementHidden gpf-hidden";
      }
    }
    var directionSelect = document.getElementById("GPisochronDirectionSelect-" + this._uid);
    if (directionSelect) {
      directionSelect.value = this._currentDirection;
    }
    if (directionSelect.value.toLowerCase() === "arrival") {
      document.getElementById("GPisochronPointLabelP-" + this._uid).innerHTML = "ArrivÃ©e";
    } else {
      document.getElementById("GPisochronPointLabelP-" + this._uid).innerHTML = "DÃ©part";
    }
    var tollInput = document.getElementById("GPisoExclusionsToll-" + this._uid);
    if (tollInput) {
      if (this._currentExclusions.indexOf("toll") !== -1) {
        tollInput.checked = false;
      } else {
        tollInput.checked = true;
      }
    }
    var tunnelInput = document.getElementById("GPisoExclusionsTunnel-" + this._uid);
    if (tunnelInput) {
      if (this._currentExclusions.indexOf("tunnel") !== -1) {
        tunnelInput.checked = false;
      } else {
        tunnelInput.checked = true;
      }
    }
    var bridgeInput = document.getElementById("GPisoExclusionsBridge-" + this._uid);
    if (bridgeInput) {
      if (this._currentExclusions.indexOf("bridge") !== -1) {
        bridgeInput.checked = false;
      } else {
        bridgeInput.checked = true;
      }
    }
  }
  /**
   * this method is called by this.onIsoComputationSubmit (in case of failure)
   * and it clears all geometries
   *
   * @private
   */
  _clearGeojsonLayer() {
    var map = this.getMap();
    if (this._geojsonLayer) {
      map.removeLayer(this._geojsonLayer);
      this._geojsonLayer = null;
    }
    this._geojsonObject = null;
  }
  /**
   * this method is called by event 'click' on control main container
   * and hide suggested Locations (unless target is an autocomplete input)
   *
   * @param {Object} e - event
   *
   * @private
   */
  _hideIsoSuggestedLocations(e) {
    if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {
    } else {
      this._originPoint._hideSuggestedLocation();
    }
  }
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */
  _displayWaitingContainer() {
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
    this._waiting = true;
    var opts = this.options.isocurveOptions;
    if (opts && opts.timeOut) {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      var context = this;
      this._timer = setTimeout(function() {
        if (context._waiting === true) {
          context._hideWaitingContainer();
        } else {
          if (context._timer) {
            clearTimeout(context._timer);
          }
        }
      }, 16e3);
    }
  }
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */
  _hideWaitingContainer() {
    if (this._waiting) {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
      this._waiting = false;
      var opts = this.options.isocurveOptions;
      if (opts && opts.timeOut) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    }
  }
};
Object.assign(Isocurve.prototype, IsocurveDOM_default);
Object.assign(Isocurve.prototype, Widget_default);
var Isocurve_default = Isocurve;
if (window.ol && window.ol.control) {
  window.ol.control.Isocurve = Isocurve;
}
var deepEqual = function(x3, y3) {
  if (x3 === y3) {
    return true;
  } else if (typeof x3 === "object" && x3 != null && (typeof y3 === "object" && y3 != null)) {
    if (Object.keys(x3).length !== Object.keys(y3).length) {
      return false;
    }
    for (var prop in x3) {
      if (y3.hasOwnProperty(prop)) {
        if (!deepEqual(x3[prop], y3[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
};

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ReverseGeocode/ReverseGeocode.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/ReverseGeocoding/GPFreverseGeocoding.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ReverseGeocode/ReverseGeocodeDOM.js
var ReverseGeocodeDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPreverseGeocoding");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show ReverseGeocoding
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowReverseGeocodingPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowReverseGeocodingPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowReverseGeocodingPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-reverse");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Ouvrir la recherche d'adresses");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowReverseGeocodingClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowReverseGeocodingClick(e);
      });
    }
    return button;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPreverseGeocodingCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  /**
   * Reverse geocoding results panel element.
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingResultsPanelElement: function() {
    var resultsPanelDiv = document.createElement("div");
    resultsPanelDiv.id = this._addUID("GPreverseGeocodingResultsPanel");
    resultsPanelDiv.className = "GPpanel GPelementHidden gpf-panel gpf-panel-reverse gpf-panel--hidden";
    return resultsPanelDiv;
  },
  /**
   * Reverse geocoding results list.
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingResultsListElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPreverseGeocodingResultsList");
    container.className = "gpf-panel__list";
    container.setAttribute("tabindex", "0");
    return container;
  },
  /**
   *  Add Result
   * (results dynamically generate !)
   *
   * @param {String} locationDescription - reverse geocoded location results
   * @param {Number} id - ID
   */
  _createReverseGeocodingResultElement: function(locationDescription, id) {
    var context = this;
    var container = document.getElementById(this._addUID("GPreverseGeocodingResultsList"));
    var resultDiv = document.createElement("div");
    if (!locationDescription) {
      resultDiv.id = this._addUID("GPreverseGeocodedLocationNoResultDiv");
      var div = document.createElement("div");
      div.id = this._addUID("GPreverseGeocodedNoResult");
      div.setAttribute("tabindex", "0");
      div.className = "GPautoCompleteProposal gpf-panel__items";
      div.innerHTML = "Aucun rÃ©sultat trouvÃ©";
      div.title = "Aucun rÃ©sultat trouvÃ©";
      resultDiv.appendChild(div);
    } else {
      resultDiv.id = this._addUID("GPreverseGeocodedLocationResultDiv_" + id);
      var div = document.createElement("div");
      div.id = this._addUID("GPreverseGeocodedLocation_" + id);
      div.setAttribute("tabindex", "0");
      div.className = "GPautoCompleteProposal gpf-panel__items";
      div.innerHTML = locationDescription;
      div.title = locationDescription;
      if (div.addEventListener) {
        div.addEventListener("mouseover", function(e) {
          context.onReverseGeocodingResultMouseOver(e);
        });
        div.addEventListener("focus", function(e) {
          context.onReverseGeocodingResultMouseOver(e);
        });
        div.addEventListener("mouseout", function(e) {
          context.onReverseGeocodingResultMouseOut(e);
        });
        div.addEventListener("blur", function(e) {
          context.onReverseGeocodingResultMouseOut(e);
        });
        div.addEventListener("click", function(e) {
          if (typeof context.onReverseGeocodingResultClick === "function") {
            context.onReverseGeocodingResultClick(e);
          }
        });
      } else if (div.attachEvent) {
        div.attachEvent("onmouseover", function(e) {
          context.onReverseGeocodingResultMouseOver(e);
        });
        div.attachEvent("onmouseout", function(e) {
          context.onReverseGeocodingResultMouseOut(e);
        });
        div.attachEvent("onclick", function(e) {
          if (typeof context.onReverseGeocodingResultClick === "function") {
            context.onReverseGeocodingResultClick(e);
          }
        });
      }
      var copyResultButton = document.createElement("button");
      copyResultButton.type = "button";
      copyResultButton.id = this._addUID("GPreverseGeocodedLocationResultCopy_" + id);
      copyResultButton.setAttribute("data-text-geolocate", div.innerHTML);
      copyResultButton.setAttribute("title", "Copier le rÃ©sultat");
      copyResultButton.classList.add("gpf-btn-icon-copy-result", "fr-btn", "fr-btn--tertiary", "gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon");
      if (copyResultButton.addEventListener) {
        copyResultButton.addEventListener("click", function(e) {
          if (typeof context.onReverseGeocodingResultCopyButtonClick === "function") {
            context.onReverseGeocodingResultCopyButtonClick(e);
            copyResultButton.classList.add("GPcopiedLocation");
            setTimeout(() => {
              copyResultButton.classList.remove("GPcopiedLocation");
            }, 1e3);
          }
        });
      } else if (copyResultButton.attachEvent) {
        copyResultButton.attachEvent("onclick", function(e) {
          if (typeof context.onReverseGeocodingResultCopyButtonClick === "function") {
            context.onReverseGeocodingResultCopyButtonClick(e);
          }
        });
      }
      resultDiv.appendChild(div);
      resultDiv.appendChild(copyResultButton);
    }
    container.appendChild(resultDiv);
  },
  // ################################################################### //
  // ######################### Inputs panel ############################ //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPreverseGeocodingPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createReverseGeocodingPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    return container;
  },
  /**
   * Create return picto in panel header
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelReturnPictoElement: function() {
    var self2 = this;
    var buttonNew = document.createElement("button");
    buttonNew.id = this._addUID("GPreverseGeocodingReturnPicto");
    buttonNew.title = "Nouvelle recherche";
    buttonNew.className = "GPreturnPicto GPimportPanelReturnPicto gpf-btn gpf-btn-icon-return fr-btn fr-btn--close fr-btn--tertiary-no-outline fr-m-1w";
    buttonNew.classList.add("GPelementHidden");
    buttonNew.classList.add("gpf-hidden");
    if (CheckDsfr_default()) {
      var returnSpan = document.createElement("span");
      returnSpan.className = "GPelementHidden gpf-visible";
      returnSpan.innerHTML = "Retour";
      buttonNew.appendChild(returnSpan);
    }
    if (buttonNew.addEventListener) {
      buttonNew.addEventListener("click", function(e) {
        document.getElementById(self2._addUID("GPreverseGeocodingResultsPanel")).className = "GPelementHidden gpf-panel--hidden";
        document.getElementById(self2._addUID("GPreverseGeocodingForm")).className = "GPform gpf-panel__content fr-modal__content";
        document.getElementById(self2._addUID("GPreverseGeocodingHeaderTitle")).innerHTML = "Trouver une adresse";
        document.getElementById(self2._addUID("GPreverseGeocodingReturnPicto")).classList.add("GPelementHidden");
        document.getElementById(self2._addUID("GPreverseGeocodingReturnPicto")).classList.add("gpf-hidden");
        self2.onGPreverseGeocodingReturnPictoClick(e);
      });
    } else if (buttonNew.attachEvent) {
      buttonNew.attachEvent("onclick", function(e) {
        document.getElementById(self2._addUID("GPreverseGeocodingResultsPanel")).className = "GPelementHidden gpf-panel--hidden";
        document.getElementById(self2._addUID("GPreverseGeocodingForm")).className = "GPform gpf-panel__content fr-modal__content";
        document.getElementById(self2._addUID("GPreverseGeocodingHeaderTitle")).innerHTML = "Trouver une adresse";
        document.getElementById(self2._addUID("GPreverseGeocodingReturnPicto")).classList.add("GPelementHidden");
        document.getElementById(self2._addUID("GPreverseGeocodingReturnPicto")).classList.add("gpf-hidden");
        self2.onGPreverseGeocodingReturnPictoClick(e);
      });
    }
    return buttonNew;
  },
  /**
   * Create Header Title Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.id = this._addUID("GPreverseGeocodingHeaderTitle");
    div.innerHTML = "Trouver une adresse";
    return div;
  },
  /**
   * Create Header close div
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelCloseElement: function() {
    var self2 = this;
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPreverseGeocodingPanelClose");
    divClose.className = "GPpanelClose GPreverseGeocodingPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowReverseGeocodingPicto")).click();
      }, false);
      divClose.addEventListener("keydown", function(event) {
        if (event.keyCode === 13) {
          document.getElementById(self2._addUID("GPshowReverseGeocodingPicto")).click();
        }
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowReverseGeocodingPicto")).click();
      });
      divClose.attachEvent("onkeydown", function(event) {
        if (event.keyCode === 13) {
          document.getElementById(self2._addUID("GPshowReverseGeocodingPicto")).click();
        }
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    return divClose;
  },
  /**
   * Create Form
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingPanelFormElement: function() {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPreverseGeocodingForm");
    form.className = "GPform gpf-panel__content fr-modal__content";
    if (form.addEventListener) {
      form.addEventListener("submit", function(e) {
        e.preventDefault();
        self2.onReverseGeocodingSubmit();
      });
    } else if (form.attachEvent) {
      form.attachEvent("onsubmit", function(e) {
        e.preventDefault();
        self2.onReverseGeocodingSubmit();
      });
    }
    return form;
  },
  // ################################################################### //
  // ####################### Choice mode into form ##################### //
  // ################################################################### //
  /**
   * Create Container to Mode choice geocoding type
   *
   * @param {Array} resources - geocoding resources to be displayed (and used)
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingFormModeChoiceGeocodingTypeElement: function(resources) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPflexInput gpf-flex gpf-flex-reverse fr-mb-1w";
    var label = document.createElement("label");
    label.id = "label-recherche-par";
    label.className = "GPlabel gpf-label fr-label";
    label.innerHTML = "Recherche par";
    label.title = "Recherche par";
    div.appendChild(label);
    var select = document.createElement("select");
    select.setAttribute("aria-labelledby", "label-recherche-par");
    select.className = "GPselect gpf-select fr-select";
    if (select.addEventListener) {
      select.addEventListener("change", function(e) {
        context.onReverseGeocodingTypeChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function(e) {
        context.onReverseGeocodingTypeChange(e);
      });
    }
    if (!resources || !Array.isArray(resources)) {
      resources = ["StreetAddress", "PositionOfInterest", "CadastralParcel"];
    }
    for (var i = 0; i < resources.length; i++) {
      switch (resources[i]) {
        case "PositionOfInterest":
          var POIOption = document.createElement("option");
          POIOption.value = "PositionOfInterest";
          POIOption.text = "Lieux/toponymes";
          select.appendChild(POIOption);
          break;
        case "StreetAddress":
          var SAOption = document.createElement("option");
          SAOption.value = "StreetAddress";
          SAOption.text = "Adresses";
          select.appendChild(SAOption);
          break;
        case "CadastralParcel":
          var CPOption = document.createElement("option");
          CPOption.value = "CadastralParcel";
          CPOption.text = "Parcelles cadastrales";
          select.appendChild(CPOption);
          break;
        default:
          break;
      }
    }
    div.appendChild(select);
    return div;
  },
  /**
   * Create Container to Mode choice geocoding delimitation
   *
   * @param {Array} delimitations - geocoding delimitations to be displayed (and used)
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingFormModeChoiceGeocodingDelimitationElement: function(delimitations) {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPflexInput gpf-flex gpf-flex-reverse fr-mb-2w";
    var label = document.createElement("label");
    label.id = "label-delimitation";
    label.className = "GPlabel gpf-label fr-label";
    label.innerHTML = "DÃ©limitation";
    label.title = "DÃ©limitation";
    div.appendChild(label);
    var select = document.createElement("select");
    select.setAttribute("aria-labelledby", "label-delimitation");
    select.className = "GPselect gpf-select fr-select";
    if (select.addEventListener) {
      select.addEventListener("change", function(e) {
        context.onReverseGeocodingDelimitationChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function(e) {
        context.onReverseGeocodingDelimitationChange(e);
      });
    }
    if (!delimitations || !Array.isArray(delimitations)) {
      delimitations = ["Point", "Circle", "Extent"];
    }
    for (var i = 0; i < delimitations.length; i++) {
      switch (delimitations[i].toLowerCase()) {
        case "point":
          var pointOption = document.createElement("option");
          pointOption.value = "point";
          pointOption.text = "Pointer un lieu";
          select.appendChild(pointOption);
          break;
        case "circle":
          var circleOption = document.createElement("option");
          circleOption.value = "circle";
          circleOption.text = "Dessiner un cercle";
          select.appendChild(circleOption);
          break;
        case "extent":
          var extentOption = document.createElement("option");
          extentOption.value = "extent";
          extentOption.text = "Dessiner une emprise";
          select.appendChild(extentOption);
          break;
        default:
          break;
      }
    }
    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ########################### Submit Form ########################### //
  // ################################################################### //
  /**
   * Create Submit Form Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createReverseGeocodingSubmitFormElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GPreverseGeocodingSubmit");
    input.className = "GPsubmit gpf-btn fr-btn";
    input.type = "submit";
    input.value = "Rechercher";
    return input;
  }
};
var ReverseGeocodeDOM_default = ReverseGeocodeDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ReverseGeocode/ReverseGeocode.js
var logger24 = LoggerByDefault_default2.getLogger("reversegeocoding");
var ReverseGeocode2 = class _ReverseGeocode extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - ReverseGeocode control options
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {String}  [options.apiKey] - API key for services call (reverse geocode service). The key "calcul" is used by default.
   * @param {String}  [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
   * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
   * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
   * @param {Object}  [options.resources =  ["StreetAddress", "PositionOfInterest", "CadastralParcel"]] - resources for geocoding, by default : ["StreetAddress", "PositionOfInterest", "CadastralParcel"]. Possible values are : "StreetAddress", "PositionOfInterest", "CadastralParcel". Resources will be displayed in the same order in widget list.
   * @param {Object}  [options.delimitations = ["Point", "Circle", "Extent"]] - delimitations for reverse geocoding, by default : ["Point", "Circle", "Extent"]. Possible values are : "Point", "Circle", "Extent". Delimitations will be displayed in the same order in widget list.
   * @param {Object}  [options.reverseGeocodeOptions = {}] - reverse geocode service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~reverseGeocode Gp.Services.reverseGeocode()} to know all reverse geocode options.
   * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
   * @param {String} [options.layerDescription.title = "Saisie (recherche inverse)"] - Layer title to be displayed in LayerSwitcher
   * @param {String} [options.layerDescription.description = "Couche de saisie d'une zone de recherche pour la recherche inverse"] - Layer description to be displayed in LayerSwitcher
   * @fires reversegeocode:compute
   * @fires reversegeocode:onclickresult
   * @example
   *  var iso = ol.control.ReverseGeocode({
   *      "collapsed" : false,
   *      "draggable" : true,
   *      "resources" : ["StreetAddress", "PositionOfInterest"],
   *      "delimitations" : ["Point", "Circle"],
   *      "reverseGeocodeOptions" : {}
   *  });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _ReverseGeocode)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "ReverseGeocode";
    this.initialize(options);
    this.container = this._initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger24.log("[ERROR] ReverseGeocode:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      this._panelCloseButton.click();
    } else {
      this._showReverseGeocodingButton.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._activateMapInteraction(map);
      if (this.draggable) {
        Draggable_default.dragElement(
          this._panelContainer,
          this._panelHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this._showReverseGeocodingButton.setAttribute("aria-pressed", true);
      }
    } else {
      var _map = this.getMap();
      this._clearResults();
      this._clearInputFeatures();
      this._removeMapInteraction(_map);
      if (this._inputFeaturesLayer != null) {
        _map.removeLayer(this._inputFeaturesLayer);
        this._inputFeaturesLayer = null;
        this._inputFeaturesSources = null;
        this._inputFeatures = null;
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Get locations data
   *
   * @returns {Object} data - locations
   */
  getData() {
    return this._reverseGeocodingLocations;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize ReverseGeocode control (called by ReverseGeocode constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this._checkInputOptions(options);
    this.options = {
      collapsed: true,
      draggable: false,
      resources: ["StreetAddress", "PositionOfInterest", "CadastralParcel"],
      delimitations: ["Point", "Circle", "Extent"],
      reverseGeocodeOptions: {},
      layerDescription: {
        title: "Saisie (recherche inverse)",
        description: "Couche de saisie d'une zone de recherche pour la recherche inverse"
      }
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this._uid = this.options.id || SelectorID_default.generate();
    this._currentGeocodingType = null;
    this._initGeocodingType();
    this._currentGeocodingDelimitation = null;
    this._initGeocodingDelimitation();
    this._showReverseGeocodingButton = null;
    this._panelContainer = null;
    this._panelHeaderContainer = null;
    this._panelTitleContainer = null;
    this._returnPictoContainer = null;
    this._panelCloseButton = null;
    this._formContainer = null;
    this._resultsContainer = null;
    this._resultsListContainer = null;
    this._waitingContainer = null;
    this._inputFeatures = null;
    this._inputFeaturesSource = null;
    this._inputFeaturesLayer = null;
    this._mapInteraction = null;
    this._requestOptions = null;
    this._requestGeom = null;
    this._requestPosition = null;
    this._waiting = false;
    this._timer = null;
    this._reverseGeocodingLocations = [];
    this._reverseGeocodingLocationsMarkers = [];
    this._resultsDefaultStyle = new Style_default({
      image: new Icon_default({
        src: Markers_default["lightOrange"],
        anchor: [0.5, 1]
      })
    });
    this._resultsSelectedStyle = new Style_default({
      image: new Icon_default({
        src: Markers_default["red"],
        anchor: [0.5, 1]
      })
    });
    this._resultsHoverInteraction = null;
    this._resultsSelectInteraction = null;
    this._popupContent = null;
    this._popupDiv = this._initPopupDiv();
    this._popupOverlay = null;
  }
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - options
   *
   * @private
   */
  _checkInputOptions(options) {
    var i;
    var j2;
    if (options.resources) {
      var resources = options.resources;
      if (Array.isArray(resources)) {
        var resourcesList = ["StreetAddress", "PositionOfInterest", "CadastralParcel"];
        var wrongResourcesIndexes = [];
        for (i = 0; i < resources.length; i++) {
          if (resourcesList.indexOf(resources[i]) === -1) {
            wrongResourcesIndexes.push(i);
            logger24.log("[ReverseGeocode] options.resources : " + resources[i] + " is not a resource for reverse geocode");
          }
        }
        if (wrongResourcesIndexes.length !== 0) {
          for (j2 = 0; j2 < wrongResourcesIndexes.length; j2++) {
            resources.splice(wrongResourcesIndexes[j2], 1);
          }
        }
      } else {
        logger24.log("[ReverseGeocode] 'options.resources' parameter should be an array");
        resources = null;
      }
    }
    if (options.delimitations) {
      var delimitations = options.delimitations;
      if (Array.isArray(delimitations)) {
        var delimitationsList = ["Circle", "Point", "Extent"];
        var wrongDelimitationsIndexes = [];
        for (i = 0; i < delimitations.length; i++) {
          if (delimitationsList.indexOf(delimitations[i]) === -1) {
            wrongDelimitationsIndexes.push(i);
            logger24.log("[ReverseGeocode] options.delimitations : " + delimitations[i] + " is not a delimitation for reverse geocode");
          }
        }
        if (wrongDelimitationsIndexes.length !== 0) {
          for (j2 = 0; j2 < wrongDelimitationsIndexes.length; j2++) {
            delimitations.splice(wrongDelimitationsIndexes[j2], 1);
          }
        }
      } else {
        logger24.log("[ReverseGeocode] 'options.delimitations' parameter should be an array");
        delimitations = null;
      }
    }
  }
  /**
   * this method is called by this.initialize() and initialize geocoding type (=resource)
   * ("StreetAddress", "PositionOfInterest", "CadastralParcel")
   *
   * @private
   */
  _initGeocodingType() {
    this._currentGeocodingType = "StreetAddress";
    var resources = this.options.resources;
    if (!resources || resources.length === 0) {
      this.options.resources = ["StreetAddress", "PositionOfInterest", "CadastralParcel"];
    }
    if (Array.isArray(resources) && resources.length) {
      if (resources[0] === "StreetAddress" || resources[0] === "PositionOfInterest" || resources[0] === "CadastralParcel") {
        this._currentGeocodingType = resources[0];
      }
    }
    var serviceOptions = this.options.reverseGeocodeOptions;
    if (serviceOptions.filterOptions && Array.isArray(serviceOptions.filterOptions.type) && serviceOptions.filterOptions.type.length !== 0) {
      this._currentGeocodingType = serviceOptions.filterOptions.type[0];
    }
  }
  /**
   * this method is called by this.initialize() and initialize geocoding delimitation
   * ("Point", "Circle", "Extent")
   *
   * @private
   */
  _initGeocodingDelimitation() {
    this._currentGeocodingDelimitation = "Point";
    var delimitations = this.options.delimitations;
    if (!delimitations || delimitations.length === 0) {
      this.options.delimitations = ["Point", "Circle", "Extent"];
    }
    if (Array.isArray(delimitations) && delimitations.length) {
      var d4 = delimitations[0].toLowerCase();
      if (d4 === "point" || d4 === "circle" || d4 === "extent") {
        this._currentGeocodingDelimitation = delimitations[0];
      }
    }
  }
  /**
   * this method is called by this.initialize() and initialize popup div
   * (to display results information on marker click)
   *
   * @returns {Object} element - DOM element for popup
   * @private
   */
  _initPopupDiv() {
    var context = this;
    var element = document.createElement("div");
    element.className = "gp-feature-info-div";
    var closer = document.createElement("button");
    closer.className = "gp-styling-button closer";
    closer.onclick = function() {
      if (context._popupOverlay != null) {
        context._popupOverlay.setPosition(void 0);
      }
      return false;
    };
    this._popupContent = document.createElement("div");
    this._popupContent.className = "gp-features-content-div";
    element.appendChild(this._popupContent);
    element.appendChild(closer);
    return element;
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var picto = this._showReverseGeocodingButton = this._createShowReverseGeocodingPictoElement();
    container.appendChild(picto);
    var reverseGeocodingPanel = this._panelContainer = this._createReverseGeocodingPanelElement();
    var reverseGeocodingPanelDiv = this._createReverseGeocodingPanelDivElement();
    reverseGeocodingPanel.appendChild(reverseGeocodingPanelDiv);
    var panelHeader = this._panelHeaderContainer = this._createReverseGeocodingPanelHeaderElement();
    var returnPicto = this._returnPictoContainer = this._createReverseGeocodingPanelReturnPictoElement();
    panelHeader.appendChild(returnPicto);
    var panelTitle = this._panelTitleContainer = this._createReverseGeocodingPanelTitleElement();
    panelHeader.appendChild(panelTitle);
    var closeDiv = this._panelCloseButton = this._createReverseGeocodingPanelCloseElement();
    panelHeader.appendChild(closeDiv);
    reverseGeocodingPanelDiv.appendChild(panelHeader);
    var reverseGeocodingForm = this._formContainer = this._createReverseGeocodingPanelFormElement();
    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingTypeElement(this.options.resources));
    reverseGeocodingForm.appendChild(this._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement(this.options.delimitations));
    var submit = this._createReverseGeocodingSubmitFormElement();
    reverseGeocodingForm.appendChild(submit);
    reverseGeocodingPanelDiv.appendChild(reverseGeocodingForm);
    var waiting = this._waitingContainer = this._createReverseGeocodingWaitingElement();
    reverseGeocodingPanelDiv.appendChild(waiting);
    var resultsPanel = this._resultsContainer = this._createReverseGeocodingResultsPanelElement();
    var reverseGeocodingResultsList = this._resultsListContainer = this._createReverseGeocodingResultsListElement();
    resultsPanel.appendChild(reverseGeocodingResultsList);
    reverseGeocodingPanelDiv.appendChild(resultsPanel);
    container.appendChild(reverseGeocodingPanel);
    logger24.log(container);
    return container;
  }
  // ################################################################### //
  // ################### Map interactions management ################### //
  // ################################################################### //
  /**
   * this method is called by this.setMap,
   * or by this.onShowReverseGeocodingClick,
   * and calls method corresponding to current delimitation, if widget is not collapsed.
   *
   * @param {Map} map - control map.
   * @private
   */
  _activateMapInteraction(map) {
    if (!this.collapsed) {
      if (this._inputFeaturesLayer == null) {
        this._inputFeatures = new Collection_default();
        this._inputFeaturesSource = new Vector_default({
          features: this._inputFeatures
        });
        this._inputFeaturesLayer = new Vector_default2({
          source: this._inputFeaturesSource,
          style: new Style_default({
            fill: new Fill_default({
              color: "rgba(0, 183, 152, 0.3)"
            }),
            stroke: new Stroke_default({
              color: "rgba(0, 183, 152, 0.8)",
              width: 3
            }),
            image: new Icon_default({
              src: Markers_default["turquoiseBlue"],
              anchor: [0.5, 1]
            })
          })
        });
        this._inputFeaturesLayer.gpResultLayerId = "reverseGeocoding";
        map.addLayer(this._inputFeaturesLayer);
      }
      var delimitation = this._currentGeocodingDelimitation.toLowerCase();
      switch (delimitation) {
        case "point":
          this._activatePointInteraction(map);
          break;
        case "circle":
          this._activateCircleInteraction(map);
          break;
        case "extent":
          this._activateBoxInteraction(map);
          break;
        default:
          break;
      }
      map.getControls().forEach(
        (control) => {
          if (control instanceof LayerSwitcher_default) {
            var layerId = this._inputFeaturesLayer.gpLayerId;
            if (control._layers[layerId].title === layerId) {
              control.addLayer(
                this._inputFeaturesLayer,
                {
                  title: this.options.layerDescription.title,
                  description: this.options.layerDescription.description
                }
              );
              control.setRemovable(this._inputFeaturesLayer, false);
            }
          }
        }
      );
    }
  }
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map point drawing interaction.
   *
   * @param {Map} map - control map.
   * @private
   */
  _activatePointInteraction(map) {
    this._mapInteraction = new Draw_default({
      style: new Style_default({
        image: new Circle_default2({
          radius: 0,
          fill: new Fill_default({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "Point",
      source: this._inputFeaturesSource
    });
    this._mapInteraction.on(
      "drawstart",
      (e) => {
        logger24.log("on drawstart ", e);
        this._inputFeatures.clear();
        this._onDrawStart(e, "point");
      }
    );
    this._mapInteraction.on(
      "drawend",
      (e) => {
        logger24.log("on drawend", e);
        if (e.feature && e.feature.getGeometry) {
          this._requestGeom = {
            type: "Point",
            coordinates: [
              this._requestPosition.lon,
              this._requestPosition.lat
            ]
          };
        }
      }
    );
    map.addInteraction(this._mapInteraction);
    this._setCursor("crosshair", map);
  }
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map circle drawing interaction.
   *
   * @param {Map} map - control map.
   * @private
   */
  _activateCircleInteraction(map) {
    this._mapInteraction = new Draw_default({
      style: new Style_default({
        fill: new Fill_default({
          color: "rgba(0, 183, 152, 0.3)"
        }),
        stroke: new Stroke_default({
          color: "rgba(0, 183, 152, 0.8)",
          width: 3
        }),
        image: new Circle_default2({
          radius: 4,
          fill: new Fill_default({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "Circle",
      source: this._inputFeaturesSource,
      geometryFunction: function(coordinates, geometry) {
        const center = coordinates[0];
        const last = coordinates[coordinates.length - 1];
        const dx = center[0] - last[0];
        const dy = center[1] - last[1];
        const maxRadius = 500;
        const radius = Math.min(Math.sqrt(dx * dx + dy * dy), maxRadius);
        if (!geometry) {
          geometry = new Circle_default(center, radius);
        } else {
          geometry.setCenterAndRadius(center, radius);
        }
        return geometry;
      }
    });
    this._mapInteraction.on(
      "drawstart",
      (e) => {
        logger24.log("on drawstart ", e);
        this._inputFeatures.clear();
        this._onDrawStart(e, "circle");
      }
    );
    this._mapInteraction.on(
      "drawend",
      (e) => {
        logger24.log("on drawend", e);
        if (e.feature && e.feature.getGeometry) {
          var radius = e.feature.getGeometry().getRadius();
          this._requestGeom = {};
          this._requestGeom.type = "Circle";
          this._requestGeom.radius = radius;
          if (this._requestPosition) {
            this._requestGeom.coordinates = [
              this._requestPosition.lon,
              this._requestPosition.lat
            ];
          }
          logger24.log("circle radius : ", radius);
        }
      }
    );
    map.addInteraction(this._mapInteraction);
  }
  /**
   * this method is called by this._activateMapInteraction,
   * and creates map box drawing interaction.
   *
   * @param {Map} map - control map.
   * @private
   */
  _activateBoxInteraction(map) {
    var geometryFunction = function(coordinates, geometry) {
      if (!geometry) {
        geometry = new Polygon_default([]);
      }
      var start2 = coordinates[0];
      var end = coordinates[1];
      const dx = start2[0] - end[0];
      const dy = start2[1] - end[1];
      const maxLength = 1e3;
      const lengthX = Math.max(-maxLength, Math.min(dx, maxLength));
      const lengthY = Math.max(-maxLength, Math.min(dy, maxLength));
      geometry.setCoordinates([
        [start2, [start2[0], start2[1] - lengthY], [start2[0] - lengthX, start2[1] - lengthY], [start2[0] - lengthX, start2[1]], start2]
      ]);
      return geometry;
    };
    this._mapInteraction = new Draw_default({
      style: new Style_default({
        fill: new Fill_default({
          color: "rgba(0, 183, 152, 0.3)"
        }),
        stroke: new Stroke_default({
          color: "rgba(0, 183, 152, 0.8)",
          width: 3
        }),
        image: new Circle_default2({
          radius: 4,
          fill: new Fill_default({
            color: "rgba(0, 183, 152, 0.8)"
          })
        })
      }),
      type: "LineString",
      source: this._inputFeaturesSource,
      maxPoints: 2,
      geometryFunction
    });
    this._mapInteraction.on(
      "drawstart",
      (e) => {
        logger24.log("on drawstart", e);
        this._inputFeatures.clear();
        this._onDrawStart(e, "polygon");
      }
    );
    this._mapInteraction.on(
      "drawend",
      (e) => {
        logger24.log("on drawend", e);
        this._onBoxDrawEnd(e);
      }
    );
    map.addInteraction(this._mapInteraction);
  }
  /**
   * remove draw interaction from map (if exists)
   *
   * @param {Map} map - control map.
   * @private
   */
  _removeMapInteraction(map) {
    if (this._mapInteraction != null) {
      map.removeInteraction(this._mapInteraction);
      this._mapInteraction = null;
    }
    this._setCursor();
  }
  /**
   * this method is called by event 'drawstart' on map point or circle drawing interaction
   * (cf. this._activatePointInteraction), and it gets map click coordinates.
   * this point is saved as a parameter for reverse Geocode service.
   *
   * @param {Object} e - HTMLElement
   * @param {String} type - geometry type : "point" or "circle"
   * @private
   */
  _onDrawStart(e, type) {
    var coordinate;
    if (e.feature && e.feature.getGeometry) {
      var geometry = e.feature.getGeometry();
      if (type === "point") {
        coordinate = geometry.getCoordinates();
      }
      if (type === "circle") {
        coordinate = geometry.getCenter();
      }
      if (type === "polygon") {
        coordinate = geometry.getFirstCoordinate();
      }
    }
    if (!coordinate) {
      return;
    }
    var crs;
    if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
      crs = this.options.reverseGeocodeOptions.srs;
    } else {
      var map = this.getMap();
      if (!map || !map.getView()) {
        return;
      }
      crs = map.getView().getProjection();
    }
    var geoCoordinate = transform(coordinate, crs, "EPSG:4326");
    this._requestPosition = {
      lon: geoCoordinate[0],
      lat: geoCoordinate[1]
    };
    logger24.log("position coordinates : ", this._requestPosition);
  }
  /**
   * this method is called by event 'drawend' on map box drawing interaction
   * (cf. this._activateBoxInteraction), and it gets geometry coordinates,
   * to be saved as a filter parameter for reverse Geocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  _onBoxDrawEnd(e) {
    if (e.feature && e.feature.getGeometry) {
      var coordinates = e.feature.getGeometry().getCoordinates()[0];
      var start2 = coordinates[0];
      var end = coordinates[2];
      var crs;
      if (this.options.reverseGeocodeOptions && this.options.reverseGeocodeOptions.srs) {
        crs = this.options.reverseGeocodeOptions.srs;
      } else {
        var map = this.getMap();
        if (!map || !map.getView()) {
          return;
        }
        crs = map.getView().getProjection();
      }
      var startGeoCoordinate = transform(start2, crs, "EPSG:4326");
      var endGeoCoordinate = transform(end, crs, "EPSG:4326");
      var bbox = {};
      if (startGeoCoordinate[0] < endGeoCoordinate[0]) {
        bbox.left = startGeoCoordinate[0];
        bbox.right = endGeoCoordinate[0];
      } else {
        bbox.left = endGeoCoordinate[0];
        bbox.right = startGeoCoordinate[0];
      }
      if (startGeoCoordinate[1] < endGeoCoordinate[1]) {
        bbox.bottom = startGeoCoordinate[1];
        bbox.top = endGeoCoordinate[1];
      } else {
        bbox.bottom = endGeoCoordinate[1];
        bbox.top = startGeoCoordinate[1];
      }
      this._requestGeom = {
        type: "Polygon",
        coordinates: [[
          [bbox.left, bbox.top],
          [bbox.left, bbox.bottom],
          [bbox.right, bbox.bottom],
          [bbox.right, bbox.top],
          [bbox.left, bbox.top]
        ]]
      };
      logger24.log("searchGeometry filter : ", this._requestGeom);
    }
  }
  /**
   * this change the cursor of the map when entering a point.
   *
   * @param {String} cursor - cursor style
   * @param {ol.Map} map - control map (optional)
   * @private
   */
  _setCursor(cursor, map) {
    map = map || this.getMap();
    if (!map) {
      return;
    }
    var div = map.getTargetElement();
    if (cursor) {
      div.style.cursor = cursor;
    } else {
      div.style.cursor = null;
    }
  }
  // ################################################################### //
  // ##################### Reverse Geocoding request ################### //
  // ################################################################### //
  /**
   * this methode is called by this.onReverseGeocodingSubmit method,
   * it generates and sends reverse geocode request, then displays results
   *
   * @private
   */
  _reverseGeocodingRequest() {
    var map = this.getMap();
    this._requestOptions = this._getReverseGeocodingRequestOptions();
    this._removeMapInteraction(map);
    this._displayWaitingContainer();
    Gp_default.Services.reverseGeocode(this._requestOptions);
  }
  /**
   * this methode is called by this._reverseGeocodingRequest method,
   * and returns options object for Gp.Services.reverseGeocode request
   *
   * @returns {Object} requestOptions - reverse geocode options
   * @private
   */
  _getReverseGeocodingRequestOptions() {
    var map = this.getMap();
    var reverseGeocodeOptions = this.options.reverseGeocodeOptions;
    var context = this;
    if (typeof this.options.ssl !== "boolean") {
      this.options.ssl = true;
    }
    var bOnFailure = !!(reverseGeocodeOptions.onFailure !== null && typeof reverseGeocodeOptions.onFailure === "function");
    var bOnSuccess = !!(reverseGeocodeOptions.onSuccess !== null && typeof reverseGeocodeOptions.onSuccess === "function");
    var requestOptions = {
      apiKey: reverseGeocodeOptions.apiKey || this.options.apiKey,
      ssl: this.options.ssl,
      position: this._requestPosition,
      filterOptions: {
        type: [this._currentGeocodingType]
      },
      srs: "CRS:84",
      returnFreeForm: false,
      maximumResponses: reverseGeocodeOptions.maximumResponses || 18,
      timeOut: reverseGeocodeOptions.timeOut || 3e4,
      // protocol : reverseGeocodeOptions.protocol || "XHR",
      // callback onSuccess
      onSuccess: function(response) {
        if (response.locations) {
          logger24.log("reverseGeocode results : ", response.locations);
          context._displayGeocodedLocations(response.locations);
        }
        if (bOnSuccess) {
          reverseGeocodeOptions.onSuccess.call(context, response.locations);
        }
      },
      // callback onFailure
      onFailure: function(error) {
        context._hideWaitingContainer();
        context._clearResults();
        context._clearInputFeatures();
        context._activateMapInteraction(map);
        logger24.log(error.message);
        if (bOnFailure) {
          reverseGeocodeOptions.onFailure.call(context, error);
        }
      }
    };
    if (this._requestGeom.type.toLowerCase() === "circle") {
      if (this._requestGeom.radius > 500) {
        logger24.log("INFO : initial circle radius (" + this._requestGeom.radius + ") limited to 1000m.");
        this._requestGeom.radius = 500;
      }
      requestOptions.searchGeometry = this._requestGeom;
    } else if (this._requestGeom.type.toLowerCase() === "polygon") {
      requestOptions.searchGeometry = this._requestGeom;
    } else if (this._requestGeom.type.toLowerCase() === "point") {
      if (this._currentGeocodingType === "StreetAddress") {
        requestOptions.searchGeometry = {
          type: "Circle",
          radius: 50,
          coordinates: this._requestGeom.coordinates
        };
        requestOptions.maximumResponses = 1;
      } else {
        requestOptions.searchGeometry = this._requestGeom;
      }
    }
    logger24.log("reverseGeocode request options : ", requestOptions);
    return requestOptions;
  }
  /**
   * this method is called by this._reverseGeocodingRequest() (in case of reverse geocode success)
   * and display results : in both container list and map
   *
   * @param {Array} locations - array of geocoded locations (reverse geocode results)
   * @private
   */
  _displayGeocodedLocations(locations) {
    this._clearResults();
    this._reverseGeocodingLocations = locations;
    this.dispatchEvent({
      type: "reversegeocode:compute"
    });
    this._formContainer.className = "GPelementHidden gpf-hidden";
    this._hideWaitingContainer();
    this._panelTitleContainer.innerHTML = "RÃ©sultats de la recherche";
    this._returnPictoContainer.classList.remove("GPelementHidden");
    this._returnPictoContainer.classList.remove("gpf-hidden");
    this._resultsContainer.className = "GPform gpf-panel__content fr-modal__content";
    this._fillGeocodedLocationListContainer(locations);
    this._displayGeocodedLocationsOnMap(locations);
  }
  // ################################################################### //
  // ############################# results list ######################## //
  // ################################################################### //
  /**
   * this method is called by this._displayGeocodedLocations()
   * and fills the container with results list
   *
   * @param {Array} locations - array of geocoded locations (reverse geocode results)
   * @private
   */
  _fillGeocodedLocationListContainer(locations) {
    if (locations.length === 0) {
      this._createReverseGeocodingResultElement();
    }
    for (var i = 0; i < locations.length; i++) {
      var location = locations[i];
      logger24.log(location);
      var locationDescription = this._fillGeocodedLocationDescription(location);
      if (locationDescription && locationDescription.length !== 0) {
        this._createReverseGeocodingResultElement(locationDescription, i);
      }
    }
  }
  /**
   * this method is called by this._fillGeocodedLocationListContainer()
   * and fills location description (String), depending on matchType
   *
   * @param {Object} location - geocoded location (from reverse geocode results)
   * @returns {String} locationDescription - geocoded location description to be displayed
   * @private
   */
  _fillGeocodedLocationDescription(location) {
    if (!location || !location.placeAttributes) {
      return;
    }
    var attr = location.placeAttributes;
    var locationDescription = "";
    switch (location.type) {
      case "StreetAddress":
        if (attr.street) {
          locationDescription += attr.housenumber ? attr.housenumber + " " : "";
          locationDescription += attr.street + ", ";
        }
        locationDescription += attr.postcode + " " + attr.city;
        break;
      case "PositionOfInterest":
        locationDescription += attr.toponym;
        if (attr.postcode && attr.postcode.length === 1) {
          locationDescription += ", " + attr.postcode[0];
        }
        locationDescription += " (" + attr.category.join(",") + ")";
        break;
      case "CadastralParcel":
        locationDescription += attr.id;
        locationDescription += attr.city ? " (" + attr.city + ")" : "";
        break;
      default:
        locationDescription += attr.city ? attr.city : "";
        break;
    }
    ;
    return locationDescription;
  }
  // ################################################################### //
  // ######################## map results (markers) #################### //
  // ################################################################### //
  /**
   * this method is called by this._displayGeocodedLocations()
   * and display locations in map (markers)
   *
   * @param {Object} locations - geocoded locations (reverse geocode result)
   * @private
   */
  _displayGeocodedLocationsOnMap(locations) {
    if (this._reverseGeocodingLocations.length !== 0) {
      var map = this.getMap();
      this._createResultsLayer();
      for (var i = 0; i < locations.length; i++) {
        this._addResultFeature(locations[i], i);
      }
      if (this._resultsFeatures.getLength() > 1) {
        if (this._resultsFeaturesSource && this._resultsFeaturesSource.getExtent) {
          var extent = this._resultsFeaturesSource.getExtent();
          map.getView().fit(extent, map.getSize());
        }
      } else {
        var feature = this._resultsFeatures.item(0);
        var coords = feature.getGeometry().getCoordinates();
        map.getView().setCenter(coords);
        map.getView().setZoom(17);
      }
      this._resultsHoverInteraction = new Select_default({
        condition: pointerMove,
        layers: [this._resultsFeaturesLayer]
      });
      this._resultsHoverInteraction.on(
        "select",
        (e) => this._onResultsFeatureMouseOver(e)
      );
      map.addInteraction(this._resultsHoverInteraction);
      this._resultsSelectInteraction = new Select_default({
        layers: [this._resultsFeaturesLayer]
      });
      this._resultsSelectInteraction.on(
        "select",
        (e) => this._onResultsFeatureSelect(e)
      );
      map.addInteraction(this._resultsSelectInteraction);
      var geocodeType = "";
      switch (this._currentGeocodingType) {
        case "StreetAddress":
          geocodeType = "adresses";
          break;
        case "PositionOfInterest":
          geocodeType = "toponymes";
          break;
        case "CadastralParcel":
          geocodeType = "parcelles cadastrales";
          break;
        default:
          break;
      }
      map.getControls().forEach(
        (control) => {
          if (control instanceof LayerSwitcher_default) {
            var layerId = this._resultsFeaturesLayer.gpLayerId;
            if (control._layers[layerId].title === layerId) {
              control.addLayer(
                this._resultsFeaturesLayer,
                {
                  title: "RÃ©sultats de la recherche inverse",
                  description: "RÃ©sultats de la recherche inverse sur les " + geocodeType
                }
              );
              control.setRemovable(this._resultsFeaturesLayer, false);
            }
          }
        }
      );
    }
  }
  /**
   * this method is called by this._displayGeocodedLocations()
   * and creates result layer (where geocoded locations will be displayed)
   *
   * @private
   */
  _createResultsLayer() {
    var map = this.getMap();
    this._resultsFeatures = new Collection_default();
    this._resultsFeaturesSource = new Vector_default({
      features: this._resultsFeatures
    });
    this._resultsFeaturesLayer = new Vector_default2({
      source: this._resultsFeaturesSource
    });
    this._resultsFeaturesLayer.gpResultLayerId = "reverseGeocodingResults";
    map.addLayer(this._resultsFeaturesLayer);
  }
  /**
   * this method is called by this._displayGeocodedLocations()
   * and displays locations in map (markers) : add new feature to results layer
   *
   * @param {Object} location - geocoded location (reverse geocode result)
   * @param {Number} i - geocoded location index in response list
   * @private
   */
  _addResultFeature(location, i) {
    var map = this.getMap();
    var position = [location.position.lon, location.position.lat];
    if (position.length === 0) {
      return;
    }
    var view = map.getView();
    var mapProj = view.getProjection().getCode();
    if (mapProj !== "EPSG:4326") {
      position = transform(position, "EPSG:4326", mapProj);
    }
    var feature = new Feature_default({
      geometry: new Point_default(position)
    });
    feature.setStyle(this._resultsDefaultStyle);
    feature.setId(i);
    feature.setProperties({
      location,
      popupContent: this._fillPopupContent(location)
    });
    this._resultsFeatures.push(feature);
  }
  /**
   * this method is called by this._addResultFeature()
   * and fills popup content (to be displayed on marker click) for a given geocoded location
   *
   * @param {Object} location - geocoded location (reverse geocode result)
   * @returns {String} popupContent - text to be displayed in popup
   * @private
   */
  _fillPopupContent(location) {
    var popupContent = "<ul>";
    var attributes = location.placeAttributes;
    for (var attr in attributes) {
      if (attributes.hasOwnProperty(attr)) {
        if (attr !== "trueGeometry" && attr !== "extraFields" && attr !== "houseNumberInfos" && attr !== "_count") {
          popupContent += "<li>";
          popupContent += '<span class="gp-attname-others-span">' + attr.toUpperCase() + " : </span>";
          popupContent += attributes[attr];
          popupContent += " </li>";
        }
      }
    }
    popupContent += " </ul>";
    return popupContent;
  }
  /**
   * this method is called on 'pointerMove' on this._resultsFeaturesLayer (ol.interaction.Select)
   * (cf. this._displayGeocodedLocationsOnMap() )
   * and highlights result in list container
   *
   * @param {Object} e - on select event
   * @private
   */
  _onResultsFeatureMouseOver(e) {
    var f;
    if (e.selected.length !== 0) {
      f = e.selected[0];
      f.setStyle(this._resultsSelectedStyle);
      if (f.getId() != null) {
        var selectedResultDiv = document.getElementById("GPreverseGeocodedLocation_" + f.getId() + "-" + this._uid);
        if (selectedResultDiv && selectedResultDiv.classList) {
          selectedResultDiv.classList.add("GPlocationHighlight");
        }
      }
      document.getElementById("GPreverseGeocodedLocation_" + f.getId() + "-" + this._uid);
    }
    if (e.deselected.length !== 0) {
      f = e.deselected[0];
      f.setStyle(this._resultsDefaultStyle);
      var deSelectedResultDiv = document.getElementById("GPreverseGeocodedLocation_" + f.getId() + "-" + this._uid);
      if (deSelectedResultDiv && deSelectedResultDiv.classList) {
        deSelectedResultDiv.classList.remove("GPlocationHighlight");
      }
    }
  }
  /**
   * this method is called on 'click' on this._resultsFeaturesLayer (ol.interaction.Select)
   * (cf. this._displayGeocodedLocationsOnMap() )
   * and sets a popup with feature information
   *
   * @param {Object} e - on select event
   * @private
   */
  _onResultsFeatureSelect(e) {
    var map = this.getMap();
    if (e.selected.length !== 0) {
      var f = e.selected[0];
      this._popupContent.innerHTML = f.getProperties().popupContent;
      if (!this._popupOverlay) {
        this._popupOverlay = new Overlay_default({
          element: this._popupDiv,
          positioning: "bottom-center",
          position: e.mapBrowserEvent.coordinate
        });
        map.addOverlay(this._popupOverlay);
      } else {
        this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
      }
      this.dispatchEvent({
        type: "reversegeocode:onclickresult",
        location: f.getProperties().location
      });
    } else {
      if (this._popupOverlay != null) {
        this._popupOverlay.setPosition(void 0);
      }
    }
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPshowReverseGeocodingPicto' tag label
   * (cf. ReverseGeocodeDOM._createShowReverseGeocodingPictoElement), and it cleans the component
   * when it's closed.
   *
   * @param { event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowReverseGeocodingClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    if (!map) {
      return;
    }
    Interactions_default.unset(map);
    var opened = this._showReverseGeocodingButton.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
    if (!this._waiting && !this._reverseGeocodingLocations.length) {
      if (this.collapsed) {
        this._clearResults();
        this._clearInputFeatures();
        this._removeMapInteraction(map);
        if (this._inputFeaturesLayer != null) {
          map.removeLayer(this._inputFeaturesLayer);
          this._inputFeaturesLayer = null;
          this._inputFeaturesSources = null;
          this._inputFeatures = null;
        }
      } else {
        this._activateMapInteraction(map);
      }
    }
  }
  /**
   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select
   * (cf. ReverseGeocodeDOM._createReverseGeocodingFormModeChoiceGeocodingTypeElement).
   * this value is saved as a parameter for reverseGeocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingTypeChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    if (!value2) {
      return;
    }
    logger24.log(value2);
    this._currentGeocodingType = value2;
  }
  /**
   * this method is called by event 'change' on 'GPreverseGeocodingCode' tag select
   * (cf. ReverseGeocodeDOM._createReverseGeocodingFormModeChoiceGeocodingDelimitationElement).
   * this value is saved as a parameter for reverseGeocode service.
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingDelimitationChange(e) {
    var idx = e.target.selectedIndex;
    var value2 = e.target.options[idx].value;
    if (!value2) {
      return;
    }
    logger24.log(value2);
    this._currentGeocodingDelimitation = value2;
    var map = this.getMap();
    this._clearInputFeatures();
    this._removeMapInteraction(map);
    this._activateMapInteraction(map);
  }
  /**
   * this method is called by event 'click' on 'GPreverseGeocodingReturnPicto' div
   * (cf. ReverseGeocodeDOM._createReverseGeocodingPanelReturnPictoElement),
   * and clear geocoded location (from both list container and map)
   *
   * @private
   */
  onGPreverseGeocodingReturnPictoClick() {
    this._clearResults();
    this._clearInputFeatures();
    this._activateMapInteraction(this.getMap());
  }
  /**
   * this methode is called by event 'submit' on reverseGeocoding form ('GPreverseGeocodingForm')
   * (cf. ReverseGeocodeDOM._createReverseGeocodingPanelFormElement),
   * it checks reverse geocode mandatory parameters,
   * then call this._reverseGeocodingRequest() to generate and send request
   *
   * @private
   */
  onReverseGeocodingSubmit() {
    if (!this._requestPosition) {
      logger24.log("missing position");
      return;
    }
    this._reverseGeocodingRequest();
  }
  /**
   * this method is called by event 'click' on 'GPreverseGeocodedLocation_' div
   * (cf. ReverseGeocodeDOM._createReverseGeocodingResultElement),
   * and zoom to location ?
   * TODO
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingResultClick(e) {
    var tagid = e.target.id;
    var idx = tagid.substring(tagid.indexOf("_") + 1);
    var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10));
    this.dispatchEvent({
      type: "reversegeocode:onclickresult",
      location: f.getProperties().location
    });
  }
  /**
   * this method is called by event 'mouseover' on 'GPreverseGeocodedLocation_' div
   * (cf. ReverseGeocodeDOM._createReverseGeocodingResultElement),
   * and changes style of matching marker on map (selected)
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingResultMouseOver(e) {
    var tagid = e.target.id;
    var idx = tagid.substring(tagid.indexOf("_") + 1);
    if (e.target.classList) {
      e.target.classList.add("GPlocationHighlight");
    }
    if (!this._resultsFeaturesSource) {
      return;
    }
    var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10));
    f.setStyle(this._resultsSelectedStyle);
  }
  /**
   * this method is called by event 'mouseout' on 'GPreverseGeocodedLocation_' div
   * (cf. ReverseGeocodeDOM._createReverseGeocodingResultElement),
   * and changes style of matching marker on map (default)
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingResultMouseOut(e) {
    var tagid = e.target.id;
    var idx = tagid.substring(tagid.indexOf("_") + 1);
    if (e.target.classList) {
      e.target.classList.remove("GPlocationHighlight");
    }
    if (!this._resultsFeaturesSource) {
      return;
    }
    var f = this._resultsFeaturesSource.getFeatureById(parseInt(idx, 10));
    f.setStyle(this._resultsDefaultStyle);
  }
  /**
   * this method is called by event 'click' on 'GPreverseGeocodedLocationResultCopy_' button
   * (cf. ReverseGeocodeDOM._createReverseGeocodingResultElement),
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onReverseGeocodingResultCopyButtonClick(e) {
    navigator.clipboard.writeText(e.target.getAttribute("data-text-geolocate")).then(() => console.log("Texte copiÃ© !")).catch((err) => console.error("Erreur de copie :", err));
  }
  // ################################################################### //
  // ################################ clean ############################ //
  // ################################################################### //
  /**
   * this method clears previous location results
   *
   * @private
   */
  _clearResults() {
    var map = this.getMap();
    this._reverseGeocodingLocations = [];
    if (this._resultsListContainer) {
      while (this._resultsListContainer.firstChild) {
        this._resultsListContainer.removeChild(this._resultsListContainer.firstChild);
      }
    }
    if (this._resultsFeaturesLayer) {
      map.removeLayer(this._resultsFeaturesLayer);
      this._resultsFeaturesLayer = null;
    }
    if (this._popupOverlay != null) {
      map.removeOverlay(this._popupOverlay);
      this._popupOverlay = null;
    }
    if (this._resultsSelectInteraction != null) {
      map.removeInteraction(this._resultsSelectInteraction);
      this._resultsSelectInteraction = null;
    }
    if (this._resultsHoverInteraction != null) {
      map.removeInteraction(this._resultsHoverInteraction);
      this._resultsHoverInteraction = null;
    }
  }
  /**
   * this method clears previous input features (features, layer, position and filters)
   *
   * @private
   */
  _clearInputFeatures() {
    if (this._inputFeatures) {
      this._inputFeatures.clear();
    }
    this._requestGeom = null;
    this._requestPosition = null;
  }
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */
  _displayWaitingContainer() {
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
    this._waiting = true;
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
    var context = this;
    this._timer = setTimeout(function() {
      if (context._waiting === true) {
        context._hideWaitingContainer();
      } else {
        if (context._timer) {
          clearTimeout(context._timer);
        }
      }
    }, 16e3);
  }
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */
  _hideWaitingContainer() {
    if (this._waiting) {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
      this._waiting = false;
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
};
Object.assign(ReverseGeocode2.prototype, ReverseGeocodeDOM_default);
Object.assign(ReverseGeocode2.prototype, Widget_default);
var ReverseGeocode_default2 = ReverseGeocode2;
if (window.ol && window.ol.control) {
  window.ol.control.ReverseGeocode = ReverseGeocode2;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerImport/LayerImport.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/LayerImport/GPFlayerImport.css";

// node_modules/ol/format/XML.js
var XML2 = class {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object|null} An object representing the source.
   * @api
   */
  read(source) {
    if (!source) {
      return null;
    }
    if (typeof source === "string") {
      const doc = parse(source);
      return this.readFromDocument(doc);
    }
    if (isDocument(source)) {
      return this.readFromDocument(
        /** @type {Document} */
        source
      );
    }
    return this.readFromNode(
      /** @type {Element} */
      source
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {Object|null} Object
   */
  readFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(
          /** @type {Element} */
          n
        );
      }
    }
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(node) {
    abstract();
  }
};
var XML_default2 = XML2;

// node_modules/ol/format/xlink.js
var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
function readHref(node) {
  return node.getAttributeNS(NAMESPACE_URI, "href");
}

// node_modules/ol/format/WMSCapabilities.js
var NAMESPACE_URIS = [
  null,
  "http://www.opengis.net/wms",
  "http://www.opengis.net/sld"
];
function isV13(objectStack) {
  return compareVersions(objectStack[0].version, "1.3") >= 0;
}
var PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Service": makeObjectPropertySetter(readService),
  "Capability": makeObjectPropertySetter(readCapability)
});
var CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Request": makeObjectPropertySetter(readRequest),
  "Exception": makeObjectPropertySetter(readException),
  "Layer": makeObjectPropertySetter(readCapabilityLayer),
  "UserDefinedSymbolization": makeObjectPropertySetter(
    readUserDefinedSymbolization
  )
});
var WMSCapabilities = class extends XML_default2 {
  constructor() {
    super();
    this.version = void 0;
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(node) {
    this.version = node.getAttribute("version").trim();
    const wmsCapabilityObject = pushParseAndPop(
      {
        "version": this.version
      },
      PARSERS,
      node,
      []
    );
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  }
};
var COMMON_SERVICE_PARSERS = {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "ContactInformation": makeObjectPropertySetter(readContactInformation),
  "Fees": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString)
};
var SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS, COMMON_SERVICE_PARSERS);
var SERVICE_PARSERS_V13 = makeStructureNS(NAMESPACE_URIS, {
  ...COMMON_SERVICE_PARSERS,
  "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
  "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
  "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
});
var CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
  "ContactPosition": makeObjectPropertySetter(readString),
  "ContactAddress": makeObjectPropertySetter(readContactAddress),
  "ContactVoiceTelephone": makeObjectPropertySetter(readString),
  "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
  "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
});
var CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ContactPerson": makeObjectPropertySetter(readString),
  "ContactOrganization": makeObjectPropertySetter(readString)
});
var CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "AddressType": makeObjectPropertySetter(readString),
  "Address": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "StateOrProvince": makeObjectPropertySetter(readString),
  "PostCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString)
});
var EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Format": makeArrayPusher(readString)
});
var COMMON_LAYER_PARSERS = {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "BoundingBox": makeObjectPropertyPusher(readBoundingBox),
  "Dimension": makeObjectPropertyPusher(readDimension),
  "Attribution": makeObjectPropertySetter(readAttribution),
  "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
  "Identifier": makeObjectPropertyPusher(readString),
  "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
  "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "Style": makeObjectPropertyPusher(readStyle),
  "Layer": makeObjectPropertyPusher(readLayer)
};
var LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  ...COMMON_LAYER_PARSERS,
  "SRS": makeObjectPropertyPusher(readString),
  "Extent": makeObjectPropertySetter(readExtent),
  "ScaleHint": makeObjectPropertyPusher(readScaleHint),
  "LatLonBoundingBox": makeObjectPropertySetter(
    (node, objectStack) => readBoundingBox(node, objectStack, false)
  ),
  "Layer": makeObjectPropertyPusher(readLayer)
});
var LAYER_PARSERS_V13 = makeStructureNS(NAMESPACE_URIS, {
  ...COMMON_LAYER_PARSERS,
  "CRS": makeObjectPropertyPusher(readString),
  "EX_GeographicBoundingBox": makeObjectPropertySetter(
    readEXGeographicBoundingBox
  ),
  "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
  "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
  "Layer": makeObjectPropertyPusher(readLayer)
});
var ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
});
var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "westBoundLongitude": makeObjectPropertySetter(readDecimal),
  "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
  "southBoundLatitude": makeObjectPropertySetter(readDecimal),
  "northBoundLatitude": makeObjectPropertySetter(readDecimal)
});
var REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "GetCapabilities": makeObjectPropertySetter(readOperationType),
  "GetMap": makeObjectPropertySetter(readOperationType),
  "GetFeatureInfo": makeObjectPropertySetter(readOperationType),
  "DescribeLayer": makeObjectPropertySetter(readOperationType),
  "GetLegendGraphic": makeObjectPropertySetter(readOperationType)
});
var OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Format": makeObjectPropertyPusher(readString),
  "DCPType": makeObjectPropertyPusher(readDCPType)
});
var DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "HTTP": makeObjectPropertySetter(readHTTP)
});
var HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Get": makeObjectPropertySetter(readFormatOnlineresource),
  "Post": makeObjectPropertySetter(readFormatOnlineresource)
});
var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
  "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
  "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
});
var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Format": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref)
});
var KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "Keyword": makeArrayPusher(readString)
});
function readAttribution(node, objectStack) {
  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node, objectStack);
}
function readUserDefinedSymbolization(node, objectStack) {
  return {
    "SupportSLD": !!readBooleanString(node.getAttribute("SupportSLD")),
    "UserLayer": !!readBooleanString(node.getAttribute("UserLayer")),
    "UserStyle": !!readBooleanString(node.getAttribute("UserStyle")),
    "RemoteWFS": !!readBooleanString(node.getAttribute("RemoteWFS")),
    "InlineFeatureData": !!readBooleanString(
      node.getAttribute("InlineFeatureData")
    ),
    "RemoteWCS": !!readBooleanString(node.getAttribute("RemoteWCS"))
  };
}
function readBoundingBox(node, objectStack, withCrs = true) {
  const extent = [
    readDecimalString(node.getAttribute("minx")),
    readDecimalString(node.getAttribute("miny")),
    readDecimalString(node.getAttribute("maxx")),
    readDecimalString(node.getAttribute("maxy"))
  ];
  const resolutions = [
    readDecimalString(node.getAttribute("resx")),
    readDecimalString(node.getAttribute("resy"))
  ];
  const result = {
    extent,
    res: resolutions
  };
  if (!withCrs) {
    return result;
  }
  if (isV13(objectStack)) {
    result.crs = node.getAttribute("CRS");
  } else {
    result.srs = node.getAttribute("SRS");
  }
  return result;
}
function readEXGeographicBoundingBox(node, objectStack) {
  const geographicBoundingBox = pushParseAndPop(
    {},
    EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS,
    node,
    objectStack
  );
  if (!geographicBoundingBox) {
    return void 0;
  }
  const westBoundLongitude = (
    /** @type {number|undefined} */
    geographicBoundingBox["westBoundLongitude"]
  );
  const southBoundLatitude = (
    /** @type {number|undefined} */
    geographicBoundingBox["southBoundLatitude"]
  );
  const eastBoundLongitude = (
    /** @type {number|undefined} */
    geographicBoundingBox["eastBoundLongitude"]
  );
  const northBoundLatitude = (
    /** @type {number|undefined} */
    geographicBoundingBox["northBoundLatitude"]
  );
  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
    return void 0;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude
  ];
}
function readCapability(node, objectStack) {
  return pushParseAndPop({}, CAPABILITY_PARSERS, node, objectStack);
}
function readService(node, objectStack) {
  return pushParseAndPop(
    {},
    isV13(objectStack) ? SERVICE_PARSERS_V13 : SERVICE_PARSERS,
    node,
    objectStack
  );
}
function readContactInformation(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
}
function readContactPersonPrimary(node, objectStack) {
  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node, objectStack);
}
function readContactAddress(node, objectStack) {
  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
}
function readException(node, objectStack) {
  return pushParseAndPop([], EXCEPTION_PARSERS, node, objectStack);
}
function readCapabilityLayer(node, objectStack) {
  const layerObject = pushParseAndPop(
    {},
    isV13(objectStack) ? LAYER_PARSERS_V13 : LAYER_PARSERS,
    node,
    objectStack
  );
  if (layerObject["Layer"] === void 0) {
    return Object.assign(layerObject, readLayer(node, objectStack));
  }
  return layerObject;
}
function readLayer(node, objectStack) {
  const v13 = isV13(objectStack);
  const parentLayerObject = (
    /**  @type {!Object<string,*>} */
    objectStack[objectStack.length - 1]
  );
  const layerObject = pushParseAndPop(
    {},
    v13 ? LAYER_PARSERS_V13 : LAYER_PARSERS,
    node,
    objectStack
  );
  if (!layerObject) {
    return void 0;
  }
  let queryable = readBooleanString(node.getAttribute("queryable"));
  if (queryable === void 0) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== void 0 ? queryable : false;
  let cascaded = readNonNegativeIntegerString(node.getAttribute("cascaded"));
  if (cascaded === void 0) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  let opaque = readBooleanString(node.getAttribute("opaque"));
  if (opaque === void 0) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== void 0 ? opaque : false;
  let noSubsets = readBooleanString(node.getAttribute("noSubsets"));
  if (noSubsets === void 0) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
  let fixedWidth = readDecimalString(node.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  let fixedHeight = readDecimalString(node.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  const addKeys = ["Style", "AuthorityURL"];
  if (v13) {
    addKeys.push("CRS");
  } else {
    addKeys.push("SRS", "Dimension");
  }
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      const childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  const replaceKeys = ["BoundingBox", "Attribution"];
  if (v13) {
    replaceKeys.push(
      "Dimension",
      "EX_GeographicBoundingBox",
      "MinScaleDenominator",
      "MaxScaleDenominator"
    );
  } else {
    replaceKeys.push("LatLonBoundingBox", "ScaleHint", "Extent");
  }
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      const parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
function readDimension(node, objectStack) {
  const dimensionObject = {
    "name": node.getAttribute("name"),
    "units": node.getAttribute("units"),
    "unitSymbol": node.getAttribute("unitSymbol")
  };
  if (isV13(objectStack)) {
    Object.assign(dimensionObject, {
      "default": node.getAttribute("default"),
      "multipleValues": readBooleanString(node.getAttribute("multipleValues")),
      "nearestValue": readBooleanString(node.getAttribute("nearestValue")),
      "current": readBooleanString(node.getAttribute("current")),
      "values": readString(node)
    });
  }
  return dimensionObject;
}
function readExtent(node, objectStack) {
  return {
    "name": node.getAttribute("name"),
    "default": node.getAttribute("default"),
    "nearestValue": readBooleanString(node.getAttribute("nearestValue"))
  };
}
function readScaleHint(node, objectStack) {
  return {
    "min": readDecimalString(node.getAttribute("min")),
    "max": readDecimalString(node.getAttribute("max"))
  };
}
function readFormatOnlineresource(node, objectStack) {
  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
}
function readRequest(node, objectStack) {
  return pushParseAndPop({}, REQUEST_PARSERS, node, objectStack);
}
function readDCPType(node, objectStack) {
  return pushParseAndPop({}, DCPTYPE_PARSERS, node, objectStack);
}
function readHTTP(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
}
function readOperationType(node, objectStack) {
  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node, objectStack);
}
function readSizedFormatOnlineresource(node, objectStack) {
  const formatOnlineresource = readFormatOnlineresource(node, objectStack);
  if (formatOnlineresource) {
    const size = [
      readNonNegativeIntegerString(node.getAttribute("width")),
      readNonNegativeIntegerString(node.getAttribute("height"))
    ];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return void 0;
}
function readAuthorityURL(node, objectStack) {
  const authorityObject = readFormatOnlineresource(node, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node.getAttribute("name");
    return authorityObject;
  }
  return void 0;
}
function readMetadataURL(node, objectStack) {
  const metadataObject = readFormatOnlineresource(node, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node.getAttribute("type");
    return metadataObject;
  }
  return void 0;
}
function readStyle(node, objectStack) {
  return pushParseAndPop({}, STYLE_PARSERS, node, objectStack);
}
function readKeywordList(node, objectStack) {
  return pushParseAndPop([], KEYWORDLIST_PARSERS, node, objectStack);
}
var WMSCapabilities_default = WMSCapabilities;

// node_modules/ol/format/OWS.js
var NAMESPACE_URIS2 = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS2 = makeStructureNS(NAMESPACE_URIS2, {
  "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
  "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
  "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
});
var OWS = class extends XML_default2 {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(node) {
    const owsObject = pushParseAndPop({}, PARSERS2, node, []);
    return owsObject ? owsObject : null;
  }
};
var ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "DeliveryPoint": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "AdministrativeArea": makeObjectPropertySetter(readString),
  "PostalCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString),
  "ElectronicMailAddress": makeObjectPropertySetter(readString)
});
var ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Value": makeObjectPropertyPusher(readValue)
});
var CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "AllowedValues": makeObjectPropertySetter(readAllowedValues)
});
var CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Phone": makeObjectPropertySetter(readPhone),
  "Address": makeObjectPropertySetter(readAddress)
});
var DCP_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "HTTP": makeObjectPropertySetter(readHttp)
});
var HTTP_PARSERS2 = makeStructureNS(NAMESPACE_URIS2, {
  "Get": makeObjectPropertyPusher(readGet),
  "Post": void 0
  // TODO
});
var OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "DCP": makeObjectPropertySetter(readDcp)
});
var OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Operation": readOperation
});
var PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Voice": makeObjectPropertySetter(readString),
  "Facsimile": makeObjectPropertySetter(readString)
});
var REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Constraint": makeObjectPropertyPusher(readConstraint)
});
var SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "IndividualName": makeObjectPropertySetter(readString),
  "PositionName": makeObjectPropertySetter(readString),
  "ContactInfo": makeObjectPropertySetter(readContactInfo)
});
var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Abstract": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "Fees": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "ServiceTypeVersion": makeObjectPropertySetter(readString),
  "ServiceType": makeObjectPropertySetter(readString)
});
var SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "ProviderName": makeObjectPropertySetter(readString),
  "ProviderSite": makeObjectPropertySetter(readHref),
  "ServiceContact": makeObjectPropertySetter(readServiceContact)
});
function readAddress(node, objectStack) {
  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
}
function readAllowedValues(node, objectStack) {
  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}
function readConstraint(node, objectStack) {
  const name = node.getAttribute("name");
  if (!name) {
    return void 0;
  }
  return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node, objectStack);
}
function readContactInfo(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
}
function readDcp(node, objectStack) {
  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
}
function readGet(node, objectStack) {
  const href = readHref(node);
  if (!href) {
    return void 0;
  }
  return pushParseAndPop(
    { "href": href },
    REQUEST_METHOD_PARSERS,
    node,
    objectStack
  );
}
function readHttp(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS2, node, objectStack);
}
function readOperation(node, objectStack) {
  const name = node.getAttribute("name");
  const value2 = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
  if (!value2) {
    return void 0;
  }
  const object = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  object[name] = value2;
}
function readOperationsMetadata(node, objectStack) {
  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}
function readPhone(node, objectStack) {
  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
}
function readServiceIdentification(node, objectStack) {
  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}
function readServiceContact(node, objectStack) {
  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}
function readServiceProvider(node, objectStack) {
  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}
function readValue(node, objectStack) {
  return readString(node);
}
var OWS_default = OWS;

// node_modules/ol/format/WMTSCapabilities.js
var NAMESPACE_URIS3 = [null, "http://www.opengis.net/wmts/1.0"];
var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS3 = makeStructureNS(NAMESPACE_URIS3, {
  "Contents": makeObjectPropertySetter(readContents)
});
var WMTSCapabilities = class extends XML_default2 {
  constructor() {
    super();
    this.owsParser_ = new OWS_default();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(node) {
    let version3 = node.getAttribute("version");
    if (version3) {
      version3 = version3.trim();
    }
    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject["version"] = version3;
    WMTSCapabilityObject = pushParseAndPop(
      WMTSCapabilityObject,
      PARSERS3,
      node,
      []
    );
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  }
};
var CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Layer": makeObjectPropertyPusher(readLayer2),
  "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
});
var LAYER_PARSERS2 = makeStructureNS(
  NAMESPACE_URIS3,
  {
    "Style": makeObjectPropertyPusher(readStyle2),
    "Format": makeObjectPropertyPusher(readString),
    "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
    "Dimension": makeObjectPropertyPusher(readDimensions),
    "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Title": makeObjectPropertySetter(readString),
    "Abstract": makeObjectPropertySetter(readString),
    "WGS84BoundingBox": makeObjectPropertySetter(readBoundingBox2),
    "BoundingBox": makeObjectPropertyPusher(readBoundingBoxWithCrs),
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var STYLE_PARSERS2 = makeStructureNS(
  NAMESPACE_URIS3,
  {
    "LegendURL": makeObjectPropertyPusher(readLegendUrl)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Title": makeObjectPropertySetter(readString),
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "TileMatrixSet": makeObjectPropertySetter(readString),
  "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
});
var TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
});
var TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "TileMatrix": makeObjectPropertySetter(readString),
  "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
});
var DIMENSION_PARSERS = makeStructureNS(
  NAMESPACE_URIS3,
  {
    "Default": makeObjectPropertySetter(readString),
    "Value": makeObjectPropertyPusher(readString)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
  "LowerCorner": makeArrayPusher(readCoordinates),
  "UpperCorner": makeArrayPusher(readCoordinates)
});
var TMS_PARSERS = makeStructureNS(
  NAMESPACE_URIS3,
  {
    "WellKnownScaleSet": makeObjectPropertySetter(readString),
    "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "SupportedCRS": makeObjectPropertySetter(readString),
    "Identifier": makeObjectPropertySetter(readString),
    "BoundingBox": makeObjectPropertySetter(readBoundingBox2)
  })
);
var TM_PARSERS = makeStructureNS(
  NAMESPACE_URIS3,
  {
    "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
    "ScaleDenominator": makeObjectPropertySetter(readDecimal),
    "TileWidth": makeObjectPropertySetter(readPositiveInteger),
    "TileHeight": makeObjectPropertySetter(readPositiveInteger),
    "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
    "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Identifier": makeObjectPropertySetter(readString)
  })
);
function readContents(node, objectStack) {
  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
}
function readLayer2(node, objectStack) {
  return pushParseAndPop({}, LAYER_PARSERS2, node, objectStack);
}
function readTileMatrixSet(node, objectStack) {
  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
}
function readStyle2(node, objectStack) {
  const style = pushParseAndPop({}, STYLE_PARSERS2, node, objectStack);
  if (!style) {
    return void 0;
  }
  const isDefault = node.getAttribute("isDefault") === "true";
  style["isDefault"] = isDefault;
  return style;
}
function readTileMatrixSetLink(node, objectStack) {
  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
}
function readDimensions(node, objectStack) {
  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
}
function readResourceUrl(node, objectStack) {
  const format = node.getAttribute("format");
  const template = node.getAttribute("template");
  const resourceType = node.getAttribute("resourceType");
  const resource = {};
  if (format) {
    resource["format"] = format;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
}
function readBoundingBox2(node, objectStack) {
  const coordinates = pushParseAndPop(
    [],
    WGS84_BBOX_READERS,
    node,
    objectStack
  );
  if (coordinates.length != 2) {
    return void 0;
  }
  return boundingExtent(coordinates);
}
function readBoundingBoxWithCrs(node, objectStack) {
  const crs = node.getAttribute("crs");
  const coordinates = pushParseAndPop(
    [],
    WGS84_BBOX_READERS,
    node,
    objectStack
  );
  if (coordinates.length != 2) {
    return void 0;
  }
  return { extent: boundingExtent(coordinates), crs };
}
function readLegendUrl(node, objectStack) {
  const legend = {};
  legend["format"] = node.getAttribute("format");
  legend["href"] = readHref(node);
  return legend;
}
function readCoordinates(node, objectStack) {
  const coordinates = readString(node).split(/\s+/);
  if (!coordinates || coordinates.length != 2) {
    return void 0;
  }
  const x3 = +coordinates[0];
  const y3 = +coordinates[1];
  if (isNaN(x3) || isNaN(y3)) {
    return void 0;
  }
  return [x3, y3];
}
function readTileMatrix(node, objectStack) {
  return pushParseAndPop({}, TM_PARSERS, node, objectStack);
}
function readTileMatrixLimitsList(node, objectStack) {
  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}
function readTileMatrixLimits(node, objectStack) {
  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
}
var WMTSCapabilities_default = WMTSCapabilities;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Editor.js
var import_eventbusjs8 = __toESM(require_eventbus_min());
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Editor/GPFeditor.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Style.js
var import_eventbusjs = __toESM(require_eventbus_min());

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Event.js
var EventEditor = {
  /** evenement sur la fin de chargement de l'editeur */
  onloaded: "editor:onloaded",
  layer: {
    /** evenement sur la visibilitÃ© : clic sur le bouton 'oeil' */
    onclickvisibility: "editor:layer:onclickvisibility",
    /** evenement sur la duplication : clic sur le bouton
    (not yet implemented !) */
    onclickclone: "editor:layer:onclickclone",
    /** evenement sur la suppression : clic sur le bouton
    (not yet implemented !) */
    onclickremove: "editor:layer:onclickremove"
  },
  legend: {
    /** evenement sur l'affichage du mode edition */
    onclickedition: "editor:legend:onclickedition",
    /** evenement sur la modification d'une valeur */
    onchangevalue: "editor:legend:onchangevalue"
  },
  group: {
    /**  evenement pour deplier/plier le groupe
    (not yet implemented !) */
    oncollapse: "editor:group:oncollapse"
  },
  style: {
    /** evenement sur l'Ã©dition du style
    (not yet implemented !) */
    oneditjson: "editor:style:oneditjson",
    /** evenement sur la modification de l'echelle d'affichage */
    scale: {
      onchangemin: "editor:style:scale:onchangemin",
      onchangemax: "editor:style:scale:onchangemax"
    }
  },
  filter: {
    /** evenement sur l'Ã©dition du filtre
    (not yet implemented !) */
    oneditjson: "editor:filter:oneditjson"
  },
  themes: {
    /** evenement sur le clic de l'image */
    onclickimage: "editor:themes:onclickimage",
    /** evenement sur le clic du titre */
    onclicktitle: "editor:themes:onclicktitle"
  },
  search: {
    /** evenement sur la recherche */
    onsubmit: "editor:search:onsubmit",
    onautocomplete: "editor:search:onautocomplete"
  }
};
var Event_default = EventEditor;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Style.js
var logger25 = LoggerByDefault_default2.getLogger("editor-style");
var Style = class _Style {
  constructor(options) {
    logger25.trace("[constructor] Style", options);
    this.options = options || {
      // default...
      target: null,
      position: 0,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof _Style)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    if (!this.options.position) {
      this.options.position = 0;
    }
    var _toolsDefault = {
      scale: true,
      edition: false
    };
    if (!this.options.tools) {
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    if (!this.options.obj) {
      this.options.obj = {
        paint: {},
        layout: {}
      };
    }
    if (!this.options.title) {
      this.options.title = "JSON Styles :";
    }
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxStyleTarget",
      container: "GPEditorMapBoxStyleContainer",
      containerjson: "GPEditorMapBoxStyleJsonContainer",
      jsonlabel: "GPEditorMapBoxStyleJsonTitle",
      jsondisplay: "GPEditorMapBoxStyleJsonDisplay",
      containertoolsscale: "GPEditorMapBoxStyleToolsScaleContainer",
      scaletitle: "GPEditorMapBoxStyleScaleTitle",
      containertoolsminscale: "GPEditorMapBoxStyleToolsScaleMinContainer",
      scalelabelmin: "GPEditorMapBoxStyleScaleLabelMin",
      scaleinputmin: "GPEditorMapBoxStyleScaleInputMin",
      containertoolsmaxscale: "GPEditorMapBoxStyleToolsScaleMaxContainer",
      scalelabelmax: "GPEditorMapBoxStyleScaleLabelMax",
      scaleinputmax: "GPEditorMapBoxStyleScaleInputMax",
      containertoolsedit: "GPEditorMapBoxStyleToolsEditionContainer"
    };
  }
  /**
   * Graphical rendering of the component
   * ie. this.container
   * (called by constructor)
   *
   * @private
   * @example
   * <div class="GPEditorMapBoxStyleContainer">
   *   <div class ="GPEditorMapBoxStyleJsonContainer">
   *      <label class="GPEditorMapBoxStyleJsonTitle">JSON Styles :</label>
   *      <pre class="GPEditorMapBoxStyleJsonDisplay">...</pre>
   *   </div>
   *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
   *   <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
   * </div>
   */
  _initContainer() {
    var self2 = this;
    var _found = false;
    var _obj = JSON.parse(JSON.stringify(this.options.obj));
    var _style = {};
    if (_obj.paint) {
      _found = true;
      _style.paint = _obj.paint;
      if (Object.keys(_obj.paint).length === 0) {
        logger25.info("tag 'paint' is empty !");
      }
    }
    if (_obj.layout) {
      _found = true;
      _style.layout = _obj.layout;
      if (_obj.layout.visibility) {
        delete _style.visibility;
      }
      if (Object.keys(_obj.layout).length === 0) {
        logger25.info("tag 'layout' is empty !");
      }
    }
    var div = document.createElement("div");
    div.className = this.name.container;
    var json = null;
    if (_found) {
      var strJson = JSON.stringify(_style, null, 4);
      json = this._syntaxHighlight(strJson);
    }
    var divJson = document.createElement("div");
    divJson.className = this.name.containerjson;
    var label = document.createElement("label");
    label.className = this.name.jsonlabel;
    label.innerHTML = this.options.title;
    divJson.appendChild(label);
    var pre = document.createElement("pre");
    pre.className = this.name.jsondisplay;
    pre.innerHTML = json;
    if (pre.addEventListener) {
      pre.addEventListener("click", function(e) {
        if (self2.options.tools.edition) {
          self2.onEditJsonStyleMapBox(e);
        }
      });
    } else if (pre.attachEvent) {
      pre.attachEvent("onclick", function(e) {
        if (self2.options.tools.edition) {
          self2.onEditJsonStyleMapBox(e);
        }
      });
    }
    divJson.appendChild(pre);
    div.appendChild(divJson);
    if (this.options.tools.scale) {
      div.appendChild(this._createElementToolsScale({
        min: _style.layout ? _style.layout.minzoom : 0,
        max: _style.layout ? _style.layout.maxzoom : 21
      }));
    }
    if (this.options.tools.edition) {
      div.appendChild(this._createElementToolsEdition());
    }
    this.container = div;
  }
  /**
   * Graphical rendering of the scale tools
   *
   * @param {Object} scale - {min,max} or 0|21
   * @returns {HTMLElement} DOM element
   *
   * @private
   * @example
   *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
   */
  _createElementToolsScale(scale) {
    logger25.trace("_createElementToolsScale");
    var self2 = this;
    var obj = this.options.obj;
    var divToolsScale = document.createElement("div");
    divToolsScale.className = this.name.containertoolsscale;
    var divMin = document.createElement("div");
    divMin.className = this.name.containertoolsminscale;
    var labelMin = document.createElement("label");
    labelMin.className = this.name.scalelabelmin;
    labelMin.innerHTML = "min :";
    divMin.appendChild(labelMin);
    var inputMin = document.createElement("input");
    inputMin.className = this.name.scaleinputmin;
    inputMin.type = "range";
    inputMin.value = scale.min || 0;
    inputMin.title = scale.min || 0;
    inputMin.disabled = false;
    inputMin.min = 0;
    inputMin.max = 21;
    inputMin.data = obj;
    if (inputMin.addEventListener) {
      inputMin.addEventListener("change", function(e) {
        self2.onChangeStyleScaleMinMapBox(e);
      });
    } else if (inputMin.appendChild) {
      inputMin.appendChild("onchange", function(e) {
        self2.onChangeStyleScaleMinMapBox(e);
      });
    }
    divMin.appendChild(inputMin);
    divToolsScale.appendChild(divMin);
    var divMax = document.createElement("div");
    divMax.className = this.name.containertoolsmaxscale;
    var labelMax = document.createElement("label");
    labelMax.className = this.name.scalelabelmax;
    labelMax.innerHTML = "max :";
    divMax.appendChild(labelMax);
    var inputMax = document.createElement("input");
    inputMax.className = this.name.scaleinputmin;
    inputMax.type = "range";
    inputMax.value = scale.max || 21;
    inputMax.title = scale.max || 21;
    inputMax.disabled = false;
    inputMax.min = 0;
    inputMax.max = 21;
    inputMax.data = obj;
    if (inputMax.addEventListener) {
      inputMax.addEventListener("change", function(e) {
        self2.onChangeStyleScaleMaxMapBox(e);
      });
    } else if (inputMax.appendChild) {
      inputMax.appendChild("onchange", function(e) {
        self2.onChangeStyleScaleMaxMapBox(e);
      });
    }
    divMax.appendChild(inputMax);
    divToolsScale.appendChild(divMax);
    return divToolsScale;
  }
  /**
   * Graphical rendering of the edition tools
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   * @example
   *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
   */
  _createElementToolsEdition() {
    logger25.warn("_createElementToolsEdition, it's not yet implemented !");
    var divToolsEdit = document.createElement("div");
    divToolsEdit.className = this.name.containertoolsedit;
    return divToolsEdit;
  }
  // ################################################################### //
  // ##################### private methods ############################# //
  // ################################################################### //
  /**
   * Transform a JSON into a DOM with a syntax in color
   *
   * @private
   * @param {Object} json - json.
   * @returns {HTMLElement} dom element
   */
  _syntaxHighlight(json) {
    json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function(match2) {
      var cls = "gp-json-number";
      if (/^"/.test(match2)) {
        if (/:$/.test(match2)) {
          cls = "gp-json-key";
        } else {
          cls = "gp-json-string";
        }
      } else if (/true|false/.test(match2)) {
        cls = "gp-json-boolean";
      } else if (/null/.test(match2)) {
        cls = "gp-json-null";
      }
      return "<span class='" + cls + "'>" + match2 + "</span>";
    });
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   * @returns {Object} - Legend instance
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Set display container or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger25.trace("display()", display);
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "flex" : "none";
    }
    return this.container.style.display === "flex";
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Style#editor:style:oneditjson
   */
  onEditJsonStyleMapBox(e) {
    logger25.trace("onEditJsonStyleMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs.default.dispatch(Event_default.style.oneditjson, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Style#editor:style:scale:onchangemin
   */
  onChangeStyleScaleMinMapBox(e) {
    logger25.trace("onChangeStyleScaleMinMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs.default.dispatch(Event_default.style.scale.onchangemin, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Style#editor:style:scale:onchangemax
   */
  onChangeStyleScaleMaxMapBox(e) {
    logger25.trace("onChangeStyleScaleMaxMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs.default.dispatch(Event_default.style.scale.onchangemax, e);
  }
};
var Style_default2 = Style;
if (window.ol && window.ol.style) {
  if (!window.ol.style.editor) {
    window.ol.style.editor = {};
  }
  window.ol.style.editor.Style = Style;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Themes.js
var import_eventbusjs2 = __toESM(require_eventbus_min());
var logger26 = LoggerByDefault_default2.getLogger("editor-themes");
var Themes = class _Themes {
  constructor(options) {
    logger26.trace("[constructor] Themes", options);
    this.options = options || {
      // TODO default...
    };
    if (!(this instanceof _Themes)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    var _toolsDefault = {
      thumbnails: true,
      button: {
        visible: true,
        type: "radio"
      }
    };
    if (!this.options.tools || Object.keys(this.options.tools).length === 0) {
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    if (typeof this.options.obj === "undefined" || this.options.obj === null || !this.options.obj) {
      this.options.obj = {
        themesSummary: "",
        themes: []
      };
    }
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxThemeTarget",
      container: "GPEditorMapBoxThemesContainer",
      containertheme: "GPEditorMapBoxThemeContainer",
      containerthemeID: "GPEditorMapBoxThemeContainer_ID_",
      input: "GPEditorMapBoxThemeInput",
      inputID: "GPEditorMapBoxThemeInput_ID_",
      label: "GPEditorMapBoxThemeTitle",
      labelID: "GPEditorMapBoxThemeTitle_ID_",
      image: "GPEditorMapBoxThemeImage",
      imageID: "GPEditorMapBoxThemeImage_ID_",
      message: "GPEditorMapBoxThemeMessage"
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   *  <div class="GPEditorMapBoxThemesContainer">
   *      <div id="GPEditorMapBoxThemeContainer-1" class="GPEditorMapBoxThemeContainer">
   *          <input type="radio" id="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeInput" name="1552920176933">
   *          <img class="GPEditorMapBoxThemeImage" src="http://image1.png" alt="Description1"></img>
   *          <label for="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeTitle">Titre1</label>
   *      </div>
   *      <div id="GPEditorMapBoxThemeContainer-2" class="GPEditorMapBoxThemeContainer">
   *          <input type="radio" id="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeInput" name="1552920176934">
   *          <img class="GPEditorMapBoxThemeImage" src="http://image2.png" alt="Description2"></img>
   *          <label for="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeTitle">Titre2</label>
   *      </div>
   * </div>
   */
  _initContainer() {
    var self2 = this;
    var obj = this.options.obj;
    var id = this.id || SelectorID_default.generate();
    var div = document.createElement("div");
    div.className = this.name.container;
    div.title = obj.themesSummary || "";
    var _lstThemes = obj.themes;
    if (_lstThemes) {
      for (var i = 0; i < _lstThemes.length; i++) {
        var _theme = _lstThemes[i];
        var divTheme = document.createElement("div");
        divTheme.id = this.name.containerthemeID + i + "_" + id;
        divTheme.className = this.name.containertheme;
        divTheme.tabIndex = i;
        var _url = _theme.url;
        var _selected = _theme.selected || false;
        if (_url) {
          var button = this.options.tools.button;
          if (button.visible) {
            var _type = button.type === "checkbox" ? "checkbox" : "radio";
            var _button = document.createElement("input");
            _button.type = _type;
            _button.id = this.name.inputID + i + "_" + id;
            _button.className = this.name.input;
            _button.name = id;
            _button.checked = _selected;
            _button.data = _url;
            if (_button.addEventListener) {
              _button.addEventListener("click", function(e) {
                self2.onClickThemeTitleMapBox(e);
              });
            } else if (_button.attachEvent) {
              _button.attachEvent("onclick", function(e) {
                self2.onClickThemeTitleMapBox(e);
              });
            }
            divTheme.appendChild(_button);
          }
          if (this.options.tools.thumbnails) {
            if (_theme.thumbnail) {
              var _img = document.createElement("img");
              _img.id = this.name.imageID + i + "_" + id;
              _img.className = this.name.image;
              _img.src = _theme.thumbnail;
              _img.alt = _theme.thumbnail;
              _img.title = _theme.description || "";
              _img.data = _url;
              if (_img.addEventListener) {
                _img.addEventListener("click", function(e) {
                  self2.onClickThemeImageMapBox(e);
                  var nodes = e.target.parentElement.childNodes;
                  if (nodes) {
                    var node = nodes[0];
                    if (node.tagName.toLowerCase() === "input") {
                      node.checked = !node.checked;
                    }
                  }
                });
              } else if (_img.attachEvent) {
                _img.attachEvent("onclick", function(e) {
                  self2.onClickThemeImageMapBox(e);
                  var nodes = e.target.parentElement.childNodes;
                  if (nodes) {
                    var node = nodes[0];
                    if (node.tagName.toLowerCase() === "input") {
                      node.checked = !node.checked;
                    }
                  }
                });
              }
              divTheme.appendChild(_img);
            }
          }
          if (_theme.name) {
            var _label = document.createElement("label");
            _label.id = this.name.labelID + i + "_" + id;
            if (this.options.tools.button.visible) {
              _label.htmlFor = _button.id;
            }
            _label.className = this.name.label;
            _label.innerHTML = _theme.name;
            _label.title = _theme.description || "";
            _label.data = _url;
            if (!this.options.tools.button.visible) {
              if (_label.addEventListener) {
                _label.addEventListener("click", function(e) {
                  self2.onClickThemeTitleMapBox(e);
                });
              } else if (_label.attachEvent) {
                _label.attachEvent("onclick", function(e) {
                  self2.onClickThemeTitleMapBox(e);
                });
              }
            }
            divTheme.appendChild(_label);
          }
        } else {
          var _msg = document.createElement("label");
          _msg.className = this.name.message;
          _msg.innerHTML = "ThÃ¨me non disponible...";
          divTheme.appendChild(_msg);
        }
        div.appendChild(divTheme);
      }
    }
    this.container = div;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   * @returns {Object} - Legend instance
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Set display container or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger26.trace("display()", display);
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "flex" : "none";
    }
    return this.container.style.display === "flex";
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Themes#editor:themes:image
   */
  onClickThemeImageMapBox(e) {
    logger26.trace("onClickThemeImageMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    if (this.options.tools.button.type === "checkbox") {
      var targetIDX = e.target.previousSibling.id.substring(
        e.target.previousSibling.id.lastIndexOf("_") + 1
      );
      var _inputs = document.getElementsByClassName(this.name.input);
      for (var i = 0; i < _inputs.length; i++) {
        var el = _inputs[i];
        if (el.id === e.target.previousSibling.id) {
          continue;
        }
        var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);
        if (elIDX !== targetIDX) {
          continue;
        }
        el.checked = false;
      }
    }
    import_eventbusjs2.default.dispatch(Event_default.themes.onclickimage, e);
  }
  /**
   * this method is called by event '' on '' tag form
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Themes#editor:themes:title
   */
  onClickThemeTitleMapBox(e) {
    logger26.trace("onClickThemeTitleMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    if (this.options.tools.button.type === "checkbox") {
      var targetIDX = e.target.id.substring(e.target.id.lastIndexOf("_") + 1);
      var _inputs = document.getElementsByClassName(this.name.input);
      for (var i = 0; i < _inputs.length; i++) {
        var el = _inputs[i];
        if (el.id === e.target.id) {
          continue;
        }
        var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);
        if (elIDX !== targetIDX) {
          continue;
        }
        el.checked = false;
      }
    }
    import_eventbusjs2.default.dispatch(Event_default.themes.onclicktitle, e);
  }
};
var Themes_default = Themes;
if (window.ol && window.ol.style) {
  if (!window.ol.style.editor) {
    window.ol.style.editor = {};
  }
  window.ol.style.editor.Themes = Themes;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Filter.js
var import_eventbusjs3 = __toESM(require_eventbus_min());
var logger27 = LoggerByDefault_default2.getLogger("editor-filter");
var Filter = class _Filter {
  constructor(options) {
    logger27.trace("[constructor] Filter", options);
    this.options = options || {
      // default...
      target: null,
      position: 0,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof _Filter)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    if (!this.options.position) {
      this.options.position = 0;
    }
    var _toolsDefault = {
      edition: false
    };
    if (!this.options.tools) {
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    if (!this.options.obj) {
      this.options.obj = {
        filter: []
      };
    }
    if (!this.options.title) {
      this.options.title = "JSON Filtres :";
    }
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxFilterTarget",
      container: "GPEditorMapBoxFilterContainer",
      containerjson: "GPEditorMapBoxFilterJsonContainer",
      jsonlabel: "GPEditorMapBoxFilterTitleJson",
      jsondisplay: "GPEditorMapBoxFilterDisplayJson",
      containertoolsedit: "GPEditorMapBoxFilterToolsEditionContainer"
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   * <div class="GPEditorMapBoxFilterContainer">
   *  <div class ="GPEditorMapBoxFilterJsonontainer">
   *     <label class="GPEditorMapBoxFilterTitleJson">JSON Filtres :</label>
   *     <pre class="GPEditorMapBoxFilterDisplayJson">...</pre>
   *  </div>
   *  <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
   * </div>
   */
  _initContainer() {
    var self2 = this;
    var _found = false;
    var _filter = JSON.parse(JSON.stringify(this.options.obj));
    if (_filter.filter) {
      _found = true;
      if (_filter.filter.length === 0) {
        logger27.info("tag 'filter' is empty !");
      }
    }
    var div = document.createElement("div");
    div.className = this.name.container;
    var json = null;
    if (_found) {
      json = JSON.stringify(_filter.filter, null, 4);
    }
    var divJson = document.createElement("div");
    divJson.className = this.name.containerjson;
    var labelJson = document.createElement("label");
    labelJson.className = this.name.jsonlabel;
    labelJson.innerHTML = this.options.title;
    divJson.appendChild(labelJson);
    var preJson = document.createElement("pre");
    preJson.className = this.name.jsondisplay;
    preJson.innerHTML = json;
    if (preJson.addEventListener) {
      preJson.addEventListener("click", function(e) {
        if (self2.options.tools.edition) {
          self2.onEditJsonFilterMapBox(e);
        }
      });
    } else if (preJson.attachEvent) {
      preJson.attachEvent("onclick", function(e) {
        if (self2.options.tools.edition) {
          self2.onEditJsonFilterMapBox(e);
        }
      });
    }
    divJson.appendChild(preJson);
    div.appendChild(divJson);
    if (this.options.tools.edition) {
      var divEdit = document.createElement("div");
      divEdit.className = this.name.containertoolsedit;
      div.appendChild(divEdit);
    }
    this.container = div;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   * @returns {Object} - Legend instance
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Set display container or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger27.trace("display()", display);
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "flex" : "none";
    }
    return this.container.style.display === "flex";
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Filter#editor:style:oneditjson
   */
  onEditJsonFilterMapBox(e) {
    logger27.trace("onEditJsonFilterMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs3.default.dispatch(Event_default.filter.oneditjson, e);
  }
};
var Filter_default = Filter;
if (window.ol && window.ol.style) {
  if (!window.ol.style.editor) {
    window.ol.style.editor = {};
  }
  window.ol.style.editor.Filter = Filter;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Legend.js
var import_eventbusjs4 = __toESM(require_eventbus_min());
var logger28 = LoggerByDefault_default2.getLogger("editor-legend");
var Legend = class _Legend {
  constructor(options) {
    logger28.trace("[constructor] Legend", options);
    this.options = options || {
      // default...
      target: null,
      position: 0,
      sprites: null,
      obj: null
    };
    if (!(this instanceof _Legend)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  // ################################################################### //
  // ########################## init methods ########################### //
  // ################################################################### //
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    if (!this.options.position) {
      this.options.position = 0;
    }
    if (!this.options.obj) {
      this.options.obj = {
        title: "vide...",
        editable: true,
        paint: {
          "fill-color": "#FFFFFF"
        }
      };
    }
    var _editable = this.options.obj.editable;
    this.editable = typeof _editable !== "undefined" ? _editable : false;
    this.legendRender = {
      type: "fill",
      values: {
        width: 1,
        stroke: "#FFFFFF",
        color: "#000000",
        opacity: 1
      }
    };
    this.container = null;
    this.rendercontainer = null;
    this.toolscontainer = null;
    this.name = {
      target: "GPEditorMapBoxLegendTarget",
      container: "GPEditorMapBoxLegendContainer",
      containerlegendrender: "GPEditorMapBoxLegendRenderContainer",
      legendrender: "GPEditorMapBoxLegendRender",
      legendeditable: "GPEditorMapBoxLegendEditable",
      legendtitle: "GPEditorMapBoxLegendTitle",
      containerlegendtools: "GPEditorMapBoxLegendToolsContainer"
    };
    this.labels = {
      "line-color": "Couleur du trait",
      "line-width": "Epaisseur du trait",
      "line-opacity": "OpacitÃ© du trait",
      "fill-color": "Couleur de remplissage",
      "fill-opacity": "OpacitÃ© du remplissage"
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   * <div class="GPEditorMapBoxLegendContainer">
   *  <div class="GPEditorMapBoxLegendRenderContainer">
   *      <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-circle" style="..."></div>
   *      <span class="GPEditorMapBoxLegendTitle">test circle editable...</span>
   *  </div>
   *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
   * </div>
   */
  _initContainer() {
    var _obj = this.options.obj;
    var div = document.createElement("div");
    div.className = this.name.container;
    var style = Object.assign({}, _obj.paint, _obj.layout);
    var keys = Object.keys(style);
    if (keys.length === 0) {
      logger28.info("tag 'paint' or 'layout' is empty !");
      return;
    }
    var params2 = {};
    var bFound = false;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (/fill-/.test(key) || /line-/.test(key) || /circle-/.test(key) || /background-/.test(key) || /text-/.test(key) || /icon-/.test(key)) {
        bFound = true;
        var title3 = _obj.title || "";
        var type = key.split("-")[0];
        if (type === "text" || type === "icon") {
          type = "symbol";
        }
        this.legendRender = this._getProperties(type, style);
        params2 = {
          edit: this.editable,
          title: title3,
          type: this.legendRender.type,
          values: this.legendRender.values
        };
        div.appendChild(this._createElementIconLegend(params2));
        break;
      }
    }
    if (!bFound) {
      params2 = {
        edit: this.editable,
        title: "",
        type: this.legendRender.type,
        values: this.legendRender.values
      };
      div.appendChild(this._createElementIconLegend(params2));
      logger28.warn("legend type unknown, default legend used...");
    }
    this.toolscontainer = this._createElementEditionLegend(params2);
    div.appendChild(this.toolscontainer);
    this.container = div;
  }
  // ################################################################### //
  // ##################### private methods ############################# //
  // ################################################################### //
  /**
  * Get properties supported
  *
  * @param {Object} type - fill, line, circle, text, icon...
  * @param {Object} values - raw values from the JSON file
  * @returns {Object} - { type : (fill | line | circle | symbol), values : valuesSupported }
  *
  * @private
  * @example
  *
  * // TODO
  * // symbol with text (1) / symbol without text (2) / text (3)
  * // "layout":{
  * //      "icon-image":"{maki}-11",          <!--- IT'S A SYMBOL (1) (2)-->
  * //      "text-font":[
  * //           "Open Sans Semibold",
  * //           "Arial Unicode MS Bold"
  * //       ],
  * //       "text-field":"{name_en}",         <!--- IT'S A TEXT (1) (3)-->
  * //       "text-max-width":9,
  * //       "text-padding":2,
  * //       "text-offset":[
  * //            0,
  * //            0.6
  * //       ],
  * //       "text-anchor":"top",
  * //       "text-size":12
  * // },
  * // "paint":{
  * //     "text-color":"#666",
  * //     "text-halo-color":"#ffffff",
  * //     "text-halo-width":1,
  * //     "text-halo-blur":0.5
  * // },
  *
  */
  _getProperties(type, values) {
    if (type === "symbol") {
      var isTextValue = values["text-field"];
      var isIconValue = values["icon-image"];
      type = isTextValue && isIconValue ? "icon" : isTextValue ? "text" : isIconValue ? "icon" : "unknow";
      if (type === "unknow") {
        logger28.warn("type unknow !?");
        return;
      }
    }
    var valuesSupported = {};
    for (const key in values) {
      if (Object.hasOwnProperty.call(values, key)) {
        const val = values[key];
        if (_Legend.PROPERTIES[type].includes(key)) {
          var prop = key.replace(type, "").slice(1);
          var value2 = this._getValue(val);
          if (value2) {
            if (prop === "pattern" || prop === "image") {
              if (!this.options.sprites || !this.options.sprites.json || !this.options.sprites.json[value2]) {
                var k3 = type + ":" + prop;
                logger28.warn("sprites mandatory for key ", k3);
                break;
              }
            }
            valuesSupported[prop] = value2;
          }
        } else {
          logger28.warn("property not supported : ", key);
        }
      }
    }
    return {
      type,
      values: valuesSupported
    };
  }
  /**
  * Render thumbnail (SVG)
  *
  * @param {Object} type - fill, line, circle, text, ...
  * @param {Object} values - {"color":..., "width":..., "stroke":...., "opacity":...}
  * @returns {Boolean} true/false
  *
  * @private
  * @example
  * (...)
  */
  _renderThumbnail(type, values) {
    var div = this.rendercontainer;
    if (!div) {
      return false;
    }
    var svg = null;
    var factor = 3;
    if (!values.color) {
      values.color = "#FFFFFF";
    }
    switch (type) {
      case "text":
        var styleText = "font-size: 5em;font-weight: bold;";
        svg = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><text x='50' y='50' fill='%color%' fill-opacity='%opacity%'  text-anchor='middle' dominant-baseline='central' style='%style%'> T </text></svg>")`;
        div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : ColorUtils_default.hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%style%", styleText);
        break;
      case "icon":
        if (values.image) {
          svg = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' width='27px' height='27px' x='0' y='0' viewBox='%x% %y% %w% %h%'><image width='%W%px' height='%H%px' href='%URL%'/></svg>".replace("%x%", this.options.sprites.json[values.image].x).replace("%y%", this.options.sprites.json[values.image].y).replace(/%w%/g, this.options.sprites.json[values.image].width).replace(/%h%/g, this.options.sprites.json[values.image].height).replace("%W%", this.options.sprites.size.w).replace("%H%", this.options.sprites.size.h).replace("%URL%", this.options.sprites.url);
          div.innerHTML = svg;
        } else {
          var styleTextIcon = "fill: transparent;stroke-width: 10;";
          svg = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><path d='M 50,20 80,82.5 20,82.5 z' stroke='%color%' style='%style%'/></svg>")`;
          div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : ColorUtils_default.hexToRgba(values.color, 1)).replace("%style%", styleTextIcon);
        }
        break;
      case "line":
        var lstrockedasharray = Array.isArray(values["dasharray"]) ? values["dasharray"].join(" ") : 0;
        svg = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><line x1='0' y1='100' x2='100' y2='0' stroke='%color%' stroke-width='%stroke-width%' stroke-opacity='%stroke-opacity%' stroke-dasharray='%stroke-dasharray%' /></svg>")`;
        div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : ColorUtils_default.hexToRgba(values.color, 1)).replace("%stroke-opacity%", values.opacity || 1).replace("%stroke-dasharray%", lstrockedasharray).replace("%stroke-width%", (values.width || 0) * factor);
        break;
      case "circle":
        var cstrockcolor = values["stroke-color"] || "#FFFFFF";
        svg = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' stroke='%stroke-color%' stroke-width='%stroke-width%' stroke-opacity='%strock-opacity%' fill='%color%' fill-opacity='%opacity%' /></svg>")`;
        div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : ColorUtils_default.hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%stroke-color%", cstrockcolor.indexOf("rgb") === 0 ? cstrockcolor : ColorUtils_default.hexToRgba(cstrockcolor, 1)).replace("%stroke-opacity%", values["stroke-opacity"] || 1).replace("%stroke-width%", (values["stroke-width"] || 0) * factor);
        break;
      case "background":
      case "fill":
        if (values.pattern) {
          svg = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' width='27px' height='27px' x='0' y='0' viewBox='%x% %y% %w% %h%'><image width='%W%px' height='%H%px' href='%URL%'/></svg>".replace("%x%", this.options.sprites.json[values.pattern].x).replace("%y%", this.options.sprites.json[values.pattern].y).replace(/%w%/g, this.options.sprites.json[values.pattern].width).replace(/%h%/g, this.options.sprites.json[values.pattern].height).replace("%W%", this.options.sprites.size.w).replace("%H%", this.options.sprites.size.h).replace("%URL%", this.options.sprites.url);
          div.innerHTML = svg;
        } else {
          var fstrokecolor = values["outline-color"] || "#FFFFFF";
          svg = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' stroke='%stroke-color%' stroke-width='3' fill='%color%' fill-opacity='%opacity%' /></svg>")`;
          div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : ColorUtils_default.hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%stroke-color%", fstrokecolor.indexOf("rgb") === 0 ? fstrokecolor : ColorUtils_default.hexToRgba(fstrokecolor, 1));
        }
        break;
      default:
        logger28.warn("type not found, no thumbnail...");
        return false;
    }
    return true;
  }
  /**
   * Get value
   *
   * @param {*} value - value of a property (ex. "#2BB3E1")
   * @returns {*} return a verified value (ex. color": "#2BB3E1")
   *
   * @private
   * @example
   * // type simple for fill, line or circle type with string :
   * // "paint": {
   * //     "fill-color": "#2BB3E1"
   * // }
   *
   * // type simple for fill, line or circle type with array :
   * // "paint": {
   * //     "line-dasharray": [2,10]
   * // }
   *
   * // TODO type complexe : not yet implemented !
   * // "paint": {
   * //     "fill-color": [
   * //          "match",
   * //          ["get","symbo"],
   * //          "ZONE_BOISEE","#A7DA81",
   * //          "ZONE_MANGROVE","#7E8AB5",
   * //          "#A7DA81"
   * //      ]
   * // }
   *
   * // other type complexe :
   * // "paint": {
   * //     "fill-color": {
   * //        "base": 1,
   * //        "stops": [
   * //        [
   * //          15.5,
   * //         "#f2eae2"
   * //        ],
   * //        [
   * //          16,
   * //          "#dfdbd7"
   * //        ]
   * //        ]
   * //     }
   * // }
   */
  _getValue(value2) {
    var result = null;
    if (typeof value2 === "string") {
      result = value2;
    } else if (typeof value2 === "number") {
      result = value2;
    } else if (Array.isArray(value2)) {
      var isNumber = true;
      value2.forEach((v2) => {
        if (typeof v2 !== "number") {
          isNumber = false;
        }
      });
      if (isNumber) {
        result = value2;
      }
    } else if (typeof value2 === "object") {
      result = null;
      if ("stops" in value2) {
        value2.stops.sort((a2, b3) => {
          var numA = a2[0];
          var numB = b3[0];
          if (numA > numB) {
            return -1;
          }
          if (numA < numB) {
            return 1;
          }
          return 0;
        });
        var lastStopsValue = value2.stops.slice(-1);
        result = lastStopsValue[0][1];
      }
    } else {
      logger28.warn("value not supported !");
    }
    return result;
  }
  // ################################################################### //
  // ######################### DOM methods ############################# //
  // ################################################################### //
  /**
  * Create a Graphical Legend Icon
  *
  * @param {Object} params - param
  * @param {String} params.title - title
  * @param {String} params.type - fill, line, circle, text, icon, ...
  * @param {String} params.values - {"color": "#2BB3E1", "width": 10, "opacity": 0.5, "stroke": "#2BB3E1"}
  * @param {Boolean} params.edit - editable with a colorPicker for only line, fill and circle legend !
  * @returns {HTMLElement} DOM element
  *
  * @private
  * @example
  *   <div class="GPEditorMapBoxLegendRenderContainer">
  *       <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-fill"
  *           style="background: url(&quot;data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' fill='rgba(255, 255, 255, 1)' fill-opacity='1' /></svg>&quot;);">
  *       </div>
  *       <span class="GPEditorMapBoxLegendTitle">vide...</span>
  * </div>
  */
  _createElementIconLegend(params2) {
    var self2 = this;
    var container = document.createElement("div");
    container.className = this.name.containerlegendrender;
    var div = this.rendercontainer = document.createElement("div");
    div.className = this.name.legendrender;
    if (params2.edit) {
      div.className += " ";
      div.className += this.name.legendeditable;
      if (div.addEventListener) {
        div.addEventListener("click", function(e) {
          self2.onEditionLegendMapBox(e);
        });
      } else if (div.attachEvent) {
        div.attachEvent("onclick", function(e) {
          self2.onEditionLegendMapBox(e);
        });
      }
    }
    var type = params2.type;
    if (this._renderThumbnail(type, params2.values)) {
      div.className += params2.edit ? " legend-" + type : " legend-" + type + "-not-editable";
    } else {
      div.className += " legend-unknow";
    }
    container.appendChild(div);
    var span = document.createElement("span");
    span.className = this.name.legendtitle;
    span.innerHTML = params2.title || "";
    container.appendChild(span);
    return container;
  }
  /**
  * Create a Graphical Legend Edition
  *
  * @param {Object} params - param
  * @param {String} params.type - fill, line, (TODO : circle, icon or text)
  * @param {String} params.values - {"fill-color": "#2BB3E1"}
  * @param {Boolean} params.edit - editable with a colorPicker for only line and fill legend !
  * @returns {HTMLElement} DOM element
  *
  * @private
  * @example
  *   <div class="GPEditorMapBoxLegendToolsContainer">
  *       <div class="legend-styling-div">
  *           <label for="stroke-color">Couleur du trait</label>
  *           <input class="legend-styling" id="stroke-color" title="" type="color">
  *       </div>
  *       <div class="legend-styling-div">
  *           <label for="stroke-width">Epaisseur du trait</label>
  *           <input class="legend-styling" id="stroke-width" title="" type="range" min="0" max="10" step="1" value="1">
  *       </div>
  *       <div class="legend-styling-div">
  *           <label for="stroke-opacity">OpacitÃ© du trait</label>
  *           <input class="legend-styling" id="stroke-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
  *       </div>
  *       <div class="legend-styling-div">
  *           <label for="fill-color">Couleur de remplissage</label>
  *        <input class="legend-styling" id="fill-color" title="" type="color">
  *       </div>
  *       <div class="legend-styling-div">
  *           <label for="fill-opacity">OpacitÃ© du remplissage</label>
  *           <input class="legend-styling" id="fill-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
  *       </div>
  *   </div>
  */
  _createElementEditionLegend(params2) {
    var self2 = this;
    var container = document.createElement("div");
    container.className = this.name.containerlegendtools;
    if (!params2.edit) {
      return container;
    }
    switch (params2.type) {
      case "line":
        createLineColor.call(self2);
        createLineWidth.call(self2);
        createLineOpacity.call(self2);
        break;
      case "background":
      case "fill":
        createFillColor.call(self2);
        createFillOpacity.call(self2);
        break;
      default:
        break;
    }
    function createLineColor() {
      var linecolor = document.createElement("div");
      linecolor.className = "legend-styling-div";
      var lLineColor = document.createElement("label");
      lLineColor.className = "legend-line";
      lLineColor.htmlFor = this.id ? "line-color-" + this.id : "line-color";
      lLineColor.innerHTML = this.labels["line-color"];
      var inputLineColor = document.createElement("input");
      inputLineColor.className = "legend-styling";
      inputLineColor.id = this.id ? "line-color-" + this.id : "line-color";
      inputLineColor.title = "Selectionner une couleur de trait";
      inputLineColor.type = "color";
      inputLineColor.value = params2.values.color;
      inputLineColor.setAttribute("data-id", "line-color");
      if (inputLineColor.addEventListener) {
        inputLineColor.addEventListener("change", function(e) {
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            color: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      } else if (inputLineColor.attachEvent) {
        inputLineColor.attachEvent("onchange", function(e) {
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            color: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      }
      linecolor.appendChild(lLineColor);
      linecolor.appendChild(inputLineColor);
      container.appendChild(linecolor);
    }
    function createLineWidth() {
      var linewidth = document.createElement("div");
      linewidth.className = "legend-styling-div";
      var lLineWidth = document.createElement("label");
      lLineWidth.className = "legend-line";
      lLineWidth.htmlFor = this.id ? "line-width-" + this.id : "line-width";
      lLineWidth.innerHTML = this.labels["line-width"];
      var inputLineWidth = document.createElement("input");
      inputLineWidth.className = "legend-styling";
      inputLineWidth.id = this.id ? "line-width-" + this.id : "line-width";
      inputLineWidth.title = params2.values.width;
      inputLineWidth.type = "range";
      inputLineWidth.min = "0";
      inputLineWidth.max = "10";
      inputLineWidth.step = "1";
      inputLineWidth.defaultValue = params2.values.width;
      inputLineWidth.setAttribute("data-id", "line-width");
      if (inputLineWidth.addEventListener) {
        inputLineWidth.addEventListener("change", function(e) {
          logger28.trace(e);
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            width: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      } else if (inputLineWidth.attachEvent) {
        inputLineWidth.attachEvent("onchange", function(e) {
          logger28.trace(e);
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            width: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      }
      linewidth.appendChild(lLineWidth);
      linewidth.appendChild(inputLineWidth);
      container.appendChild(linewidth);
    }
    function createLineOpacity() {
      var lineopacity = document.createElement("div");
      lineopacity.className = "legend-styling-div";
      var lLineOpacity = document.createElement("label");
      lLineOpacity.className = "legend-line";
      lLineOpacity.htmlFor = this.id ? "line-opacity-" + this.id : "line-opacity";
      lLineOpacity.innerHTML = this.labels["line-opacity"];
      var inputLineOpacity = document.createElement("input");
      inputLineOpacity.className = "legend-styling";
      inputLineOpacity.id = this.id ? "line-opacity-" + this.id : "line-opacity";
      inputLineOpacity.title = params2.values.opacity;
      inputLineOpacity.type = "range";
      inputLineOpacity.min = "0";
      inputLineOpacity.max = "1";
      inputLineOpacity.step = "0.1";
      inputLineOpacity.defaultValue = params2.values.opacity;
      inputLineOpacity.setAttribute("data-id", "line-opacity");
      if (inputLineOpacity.addEventListener) {
        inputLineOpacity.addEventListener("change", function(e) {
          logger28.trace(e);
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            opacity: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      } else if (inputLineOpacity.attachEvent) {
        inputLineOpacity.attachEvent("onchange", function(e) {
          logger28.trace(e);
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            opacity: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      }
      lineopacity.appendChild(lLineOpacity);
      lineopacity.appendChild(inputLineOpacity);
      container.appendChild(lineopacity);
    }
    function createFillColor() {
      var fillcolor = document.createElement("div");
      fillcolor.className = "legend-styling-div";
      var lFillColor = document.createElement("label");
      lFillColor.className = "legend-fill";
      lFillColor.htmlFor = this.id ? "fill-color-" + this.id : "fill-color";
      lFillColor.innerHTML = this.labels["fill-color"];
      var inputFillColor = document.createElement("input");
      inputFillColor.className = "legend-styling";
      inputFillColor.id = this.id ? "fill-color-" + this.id : "fill-color";
      inputFillColor.title = "Selectionner une couleur de remplissage";
      inputFillColor.type = "color";
      inputFillColor.value = params2.values.color;
      inputFillColor.setAttribute("data-id", "fill-color");
      if (inputFillColor.addEventListener) {
        inputFillColor.addEventListener("change", function(e) {
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            color: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      } else if (inputFillColor.attachEvent) {
        inputFillColor.attachEvent("onchange", function(e) {
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            color: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      }
      fillcolor.appendChild(lFillColor);
      fillcolor.appendChild(inputFillColor);
      container.appendChild(fillcolor);
    }
    function createFillOpacity() {
      var fillopacity = document.createElement("div");
      fillopacity.className = "legend-styling-div";
      var lFillOpacity = document.createElement("label");
      lFillOpacity.className = "legend-fill";
      lFillOpacity.htmlFor = this.id ? "fill-opacity-" + this.id : "fill-opacity";
      lFillOpacity.innerHTML = this.labels["fill-opacity"];
      var inputFillOpacity = document.createElement("input");
      inputFillOpacity.className = "legend-styling";
      inputFillOpacity.id = this.id ? "fill-opacity-" + this.id : "fill-opacity";
      inputFillOpacity.title = params2.values.opacity;
      inputFillOpacity.type = "range";
      inputFillOpacity.min = "0";
      inputFillOpacity.max = "1";
      inputFillOpacity.step = "0.1";
      inputFillOpacity.defaultValue = params2.values.opacity;
      inputFillOpacity.setAttribute("data-id", "fill-opacity");
      if (inputFillOpacity.addEventListener) {
        inputFillOpacity.addEventListener("change", function(e) {
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            opacity: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      } else if (inputFillOpacity.attachEvent) {
        inputFillOpacity.attachEvent("onchange", function(e) {
          e.target.title = e.target.value;
          self2._renderThumbnail(params2.type, Object.assign(params2.values, {
            opacity: e.target.value
          }));
          self2.onChangeValueLegendMapBox(e);
        });
      }
      fillopacity.appendChild(lFillOpacity);
      fillopacity.appendChild(inputFillOpacity);
      container.appendChild(fillopacity);
    }
    return container;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   *
   * @returns {Object} - Legend instance
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Set display container or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger28.trace("display()", display);
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "flex" : "none";
    }
    return this.container.style.display === "flex";
  }
  /**
   * Is editable
   *
   * @returns {Boolean} - true/false
   */
  isEditable() {
    return this.editable;
  }
  /**
   * Get container Legend Render (DOM)
   *
   * @returns {HTMLElement} DOM element
   * @see Layer.prototype.slotLegend()
   * @example
   *  <div class="GPEditorMapBoxLegendRender legend-(line|fill|background|text|icon|circle|unknow)" style="..."></div>
   */
  getRenderContainer() {
    return this.rendercontainer;
  }
  /**
   * Get container Legend Tools (DOM)
   *
   * @returns {HTMLElement} DOM element
   * @see Layer.prototype.slotLegend()
   * @example
   *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
   */
  getToolsContainer() {
    return this.toolscontainer;
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Legend#editor:legend:onclickedition
   */
  onEditionLegendMapBox(e) {
    logger28.trace("onEditionLegendMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs4.default.dispatch(Event_default.legend.onclickedition, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Legend#editor:legend:onchangevalue
   */
  onChangeValueLegendMapBox(e) {
    logger28.trace("onChangeValueLegendMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs4.default.dispatch(Event_default.legend.onchangevalue, e);
  }
};
Legend.PROPERTIES = {
  line: [
    "line-color",
    "line-dasharray",
    "line-opacity",
    "line-width"
  ],
  fill: [
    "fill-color",
    "fill-opacity",
    "fill-outline-color",
    "fill-pattern"
  ],
  background: [
    "background-color",
    "background-opacity",
    "background-pattern"
  ],
  circle: [
    "circle-color",
    "circle-opacity",
    "circle-stroke-color",
    "circle-stroke-opacity",
    "circle-stroke-width"
  ],
  icon: [
    "icon-color",
    "icon-image",
    "icon-opacity",
    "__icon-size"
  ],
  text: [
    "__text-anchor",
    "text-color",
    "text-field",
    "__text-font",
    "__text-opacity",
    "__text-size"
  ]
};
var Legend_default = Legend;
if (window.ol && window.ol.style) {
  if (!window.ol.style.editor) {
    window.ol.style.editor = {};
  }
  window.ol.style.editor.Legend = Legend;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Layer.js
var import_eventbusjs5 = __toESM(require_eventbus_min());
var logger29 = LoggerByDefault_default2.getLogger("editor-layer");
var Layer = class _Layer {
  constructor(options) {
    logger29.trace("[constructor] Layer", options);
    this.options = options || {};
    if (!(this instanceof _Layer)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  // ################################################################### //
  // ##################### private methods ############################# //
  // ################################################################### //
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    if (!this.options.position) {
      this.options.position = 0;
    }
    var _toolsDefault = {
      visibility: true,
      icon: {
        image: true,
        anchor: "end"
      },
      type: true,
      pin: true,
      remove: false,
      // TODO
      clone: false
      // TODO
    };
    if (!this.options.tools) {
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    var _objDefault = {
      id: "",
      type: "",
      // icone sur le type de geometrie
      source: "",
      "source-layer": ""
    };
    if (!this.options.obj) {
      this.options.obj = _objDefault;
    }
    Helper_default2.mergeParams(this.options.obj, _objDefault, false);
    this.bSlotLegend = false;
    this.oFilter = null;
    this.oStyle = null;
    this.oLegend = null;
    this.container = null;
    this.DomVisibility = null;
    this.DomToggle = null;
    this.name = {
      target: "GPEditorMapBoxLayerTarget",
      container: "GPEditorMapBoxLayerContainer",
      containerlegend: "GPEditorMapBoxLayerLegendContainer",
      containertitle: "GPEditorMapBoxLayerTitleContainer",
      imagelabelinput: "GPEditorMapBoxLayerImageInput",
      imagelabel: "GPEditorMapBoxLayerImageLabel",
      typeimg: "GPEditorMapBoxLayerTypeImage",
      titleinput: "GPEditorMapBoxLayerTitleInput",
      titlelabel: "GPEditorMapBoxLayerTitleLabel",
      containertools: "GPEditorMapBoxToolsContainer",
      visibilityinput: "GPEditorMapBoxToolsVisibilityInput",
      visibilitylabel: "GPEditorMapBoxToolsVisibilityLabel",
      visibilityinputdisable: "GPEditorMapBoxToolsVisibilityInputDisable",
      visibilitylabeldisable: "GPEditorMapBoxToolsVisibilityLabelDisable"
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   * // >> Titre 1          |OOO| <- menu tools : visibility, clone, remove
   * // >> Titre 2          |OXX| <- affichage configurable (cf. options.tools)
   * // Event : clic sur le titre -> ex. affiche le menu des styles / filtres
   * //       : clic visibility, clone, remove
   * // DOM :
   *      <div class="GPEditorMapBoxLayerContainer">
   *          <div id="GPEditorMapBoxLayerTitleContainer-45" class="GPEditorMapBoxLayerTitleContainer">
   *              <input id="GPEditorMapBoxLayerImageInput-45" class="GPEditorMapBoxLayerImageInput" type="checkbox">
   *              <label class="GPEditorMapBoxLayerImageLabel" for="GPEditorMapBoxLayerImageInput-45"></label>
   *              <input id="GPEditorMapBoxLayerTitleInput-45" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
   *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-45" title="...">...</label>
   *          </div>
   *          <div id="GPEditorMapBoxToolsContainer-45" class="GPEditorMapBoxToolsContainer">
   *              <input id="GPEditorMapBoxToolsVisibilityInput-45" type="checkbox" class="GPEditorMapBoxToolsVisibilityInput">
   *              <label for="GPEditorMapBoxToolsVisibilityInput-45" id="GPEditorMapBoxToolsVisibilityLabel-45" class="GPEditorMapBoxToolsVisibilityLabel" title="Afficher/masquer la couche"></label>
   *          </div>
   *      </div>
   */
  _initContainer() {
    var self2 = this;
    var obj = this.options.obj;
    var div = document.createElement("div");
    div.className = this.name.container;
    var divTitle = document.createElement("div");
    divTitle.id = this.name.containertitle + "-" + this.options.position;
    divTitle.className = this.name.containertitle;
    if (this.options.tools.pin) {
      var inputImage = document.createElement("input");
      inputImage.id = this.name.imagelabelinput + "-" + this.options.position;
      inputImage.className = this.name.imagelabelinput;
      inputImage.type = "checkbox";
      divTitle.appendChild(inputImage);
      var labelImage = document.createElement("label");
      labelImage.className = this.name.imagelabel;
      labelImage.htmlFor = inputImage.id;
      if (labelImage.addEventListener) {
        labelImage.addEventListener("click", function(e) {
          self2.onClickLayerMapBox(e);
        });
      } else if (labelImage.attachEvent) {
        labelImage.attachEvent("onclick", function(e) {
          self2.onClickLayerMapBox(e);
        });
      }
      divTitle.appendChild(labelImage);
    }
    var _addTools = function() {
      var divTools = document.createElement("div");
      divTools.id = this.name.containertools + "-" + this.options.position;
      divTools.className = this.name.containertools;
      if (this.options.tools.visibility) {
        var inputTools = document.createElement("input");
        inputTools.id = this.name.visibilityinput + "-" + this.options.position;
        inputTools.className = this.options.tools.icon.image ? this.name.visibilityinput : this.name.visibilityinputdisable;
        inputTools.type = "checkbox";
        inputTools.checked = "checked";
        if (inputTools.addEventListener) {
          inputTools.addEventListener("click", function(e) {
            self2.onVisibilityLayerMapBox(e);
          });
        } else if (inputTools.attachEvent) {
          inputTools.attachEvent("onclick", function(e) {
            self2.onVisibilityLayerMapBox(e);
          });
        }
        divTools.appendChild(inputTools);
        this.DomVisibility = inputTools;
        var labelTools = document.createElement("label");
        labelTools.htmlFor = this.name.visibilityinput + "-" + this.options.position;
        labelTools.id = this.name.visibilitylabel + "-" + this.options.position;
        labelTools.className = this.options.tools.icon.image ? this.name.visibilitylabel : this.name.visibilitylabeldisable;
        labelTools.title = "Afficher/masquer la couche";
        divTools.appendChild(labelTools);
        div.appendChild(divTools);
      }
      if (this.options.tools.clone) {
        logger29.warn("Dom for tools clone, it's not yet implemented !");
      }
      if (this.options.tools.remove) {
        logger29.warn("Dom for tools remove, it's not yet implemented !");
      }
    };
    if (this.options.tools.icon.anchor === "start") {
      _addTools.apply(this);
    }
    if (this.options.tools.type && obj.type) {
      var imgType = document.createElement("img");
      imgType.className = this.name.typeimg;
      switch (obj.type.toUpperCase()) {
        case "SYMBOL-ICON":
          imgType.style["background-position"] = "0px 0";
          break;
        case "SYMBOL-TEXT":
          imgType.style["background-position"] = "-194px 0";
          break;
        case "SYMBOL":
          imgType.style["background-position"] = "-84px 0";
          break;
        case "LINE":
          imgType.style["background-position"] = "-28px 0";
          break;
        case "FILL":
          imgType.style["background-position"] = "-56px 0";
          break;
        case "BACKGROUND":
          imgType.style["background-position"] = "-140px 0";
          break;
        case "CIRCLE":
          imgType.style["background-position"] = "-168px 0";
          break;
        default:
          imgType.style["background-position"] = "-112px 0";
      }
      divTitle.appendChild(imgType);
    }
    var divLegend = document.createElement("div");
    divLegend.id = this.name.containerlegend + "-" + this.options.position;
    divLegend.className = this.name.containerlegend;
    divTitle.appendChild(divLegend);
    var inputTitle = document.createElement("input");
    inputTitle.id = this.name.titleinput + "-" + this.options.position;
    inputTitle.className = this.name.titleinput;
    inputTitle.type = "checkbox";
    divTitle.appendChild(inputTitle);
    var labelTitle = document.createElement("label");
    labelTitle.className = this.name.titlelabel;
    labelTitle.htmlFor = inputTitle.id;
    labelTitle.innerHTML = obj["id"] || obj["source-layer"] || obj["source"];
    labelTitle.title = obj["source-layer"] || obj["source"] || obj["id"];
    if (labelTitle.addEventListener) {
      labelTitle.addEventListener("click", function(e) {
        self2.onClickLayerMapBox(e);
      });
    } else if (labelTitle.attachEvent) {
      labelTitle.attachEvent("onclick", function(e) {
        self2.onClickLayerMapBox(e);
      });
    }
    divTitle.appendChild(labelTitle);
    this.DomToggle = labelTitle;
    div.appendChild(divTitle);
    if (this.options.tools.icon.anchor === "end") {
      _addTools.apply(this);
    }
    this.container = div;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   * @returns {Object} - Layer instance
   */
  add() {
    logger29.trace("add()");
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Add style in the submenu
   *
   * @param {Object} style - style object
   */
  addStyle(style) {
    logger29.trace("addStyle()", style);
    if (style && typeof style === "object" && style instanceof Style_default2) {
      this.oStyle = style;
      this.oStyle.display(false);
    }
  }
  /**
   * Add filter in the submenu
   *
   * @param {Object} filter - filter object
   */
  addFilter(filter) {
    logger29.trace("addFilter()", filter);
    if (filter && typeof filter === "object" && filter instanceof Filter_default) {
      this.oFilter = filter;
      this.oFilter.display(false);
    }
  }
  /**
   * Add Legend in the submenu
   *
   * @param {Object} legend - legend object
   */
  addLegend(legend) {
    logger29.trace("addLegend()", legend);
    if (legend && typeof legend === "object" && legend instanceof Legend_default) {
      this.oLegend = legend;
      this.oLegend.display(false);
    }
  }
  /**
   * Integrate Legend to the layer container
   */
  slotLegend() {
    var legend = this.oLegend;
    if (legend) {
      var node = null;
      var nodesLvl1 = this.container.childNodes;
      if (nodesLvl1.length) {
        var idx = this.options.tools.icon.anchor === "start" ? 1 : 0;
        var nodesLvl2 = nodesLvl1[idx].childNodes;
        for (var i = 0; i < nodesLvl2.length; i++) {
          var curnode = nodesLvl2[i];
          if (curnode.id.indexOf(this.name.containerlegend) !== -1) {
            node = curnode;
          }
        }
      }
      if (node) {
        var render = legend.getRenderContainer();
        if (render) {
          node.appendChild(render);
          this.bSlotLegend = true;
        }
      }
    }
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Set visibility or get
   *
   * @param {Boolean} display - set visibility or undefined to get status
   * @returns {Boolean} - true/false
   */
  visibility(display) {
    logger29.trace("visibility()", display);
    if (!this.options.tools.visibility) {
      return;
    }
    if (typeof display !== "undefined") {
      this.DomVisibility.checked = display ? "checked" : "";
    }
    return this.DomVisibility.checked;
  }
  /**
  * Collapse a layer panel (event)
  */
  collapse() {
    logger29.trace("collapse()");
    this.DomToggle.click();
  }
  /**
  * Click on visibility icon (event)
  */
  visible() {
    logger29.trace("visible()");
    if (!this.options.tools.visibility) {
      return;
    }
    this.DomVisibility.click();
  }
  /**
   * Set collapse or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger29.trace("display()", display);
    var checked = document.getElementById(this.DomToggle.htmlFor).checked;
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "inline-flex" : "none";
      if (this.oStyle) {
        this.oStyle.display(display && checked);
      }
      if (this.oFilter) {
        this.oFilter.display(display && checked);
      }
      if (this.oLegend) {
        this.oLegend.display(display && checked);
      }
    }
    return checked;
  }
  /**
   * Set disabled/enabled status or get
   *
   * @param {Boolean} active - disable/enable layer interaction or get status
   * @returns {Boolean} - true/false
   */
  active(active) {
    logger29.trace("active()", active);
    if (typeof active !== "undefined") {
      this.container.className = active ? this.name.container : this.name.container + " disabled";
    }
    return this.container.className === this.name.container;
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onClickLayerMapBox(e) {
    logger29.trace("onClickLayerMapBox", e);
    var id = e.target.htmlFor.substring(e.target.htmlFor.indexOf("-"));
    var checked = document.getElementById(e.target.htmlFor).checked;
    if (e.target.htmlFor === this.name.imagelabelinput + id) {
      document.getElementById(this.name.titleinput + id).checked = !checked;
    }
    if (e.target.htmlFor === this.name.titleinput + id) {
      if (document.getElementById(this.name.imagelabelinput + id)) {
        document.getElementById(this.name.imagelabelinput + id).checked = !checked;
      }
    }
    if (this.oStyle) {
      this.oStyle.display(!checked);
    }
    if (this.oFilter) {
      this.oFilter.display(!checked);
    }
    if (this.oLegend && this.oLegend.isEditable()) {
      this.oLegend.display(!checked);
    }
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Layer#editor:layer:onclickvisibility
   */
  onVisibilityLayerMapBox(e) {
    logger29.trace("onVisibilityLayerMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs5.default.dispatch(Event_default.layer.onclickvisibility, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Layer#editor:layer:onclickclone
   */
  onCloneLayerMapBox(e) {
    logger29.trace("onCloneLayerMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs5.default.dispatch(Event_default.layer.onclickclone, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Layer#editor:layer:onclickremove
   */
  onRemoveLayerMapBox(e) {
    logger29.trace("onRemoveLayerMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs5.default.dispatch(Event_default.layer.onclickremove, e);
  }
};
var Layer_default2 = Layer;
if (window.ol && window.ol.style) {
  if (!window.ol.style.editor) {
    window.ol.style.editor = {};
  }
  window.ol.style.editor.Layer = Layer;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Group.js
var import_eventbusjs6 = __toESM(require_eventbus_min());
var logger30 = LoggerByDefault_default2.getLogger("editor-group");
var Group = class _Group {
  constructor(options) {
    logger30.trace("[constructor] Group", options);
    this.options = options || {
      // default...
    };
    if (!(this instanceof _Group)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    if (!this.options.title) {
      this.options.title = "DÃ©tails du groupe...";
    }
    if (typeof this.options.collapse === "undefined") {
      this.options.collapse = true;
    }
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxGroupTarget",
      container: "GPEditorMapBoxGroupContainer",
      details: "GPEditorMapBoxGroupDetails",
      summary: "GPEditorMapBoxGroupSummary"
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   * <div class="GPEditorMapBoxGroupContainer">...</div>
   */
  _initContainer() {
    var div = document.createElement("div");
    div.className = this.name.container;
    var details = document.createElement("details");
    details.className = this.name.details;
    details.open = !this.options.collapse;
    div.appendChild(details);
    var summary = document.createElement("summary");
    summary.className = this.name.summary;
    summary.innerHTML = this.options.title;
    details.appendChild(summary);
    this.container = div;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
  }
  /**
   * Set display container (DOM)
   *
   * @param {Boolean} display - show/hidden container
   */
  display(display) {
    this.container.style.display = display ? "flex" : "none";
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    var nodes = this.container.childNodes;
    if (nodes.length) {
      return nodes[0];
    }
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form
   *
   * NOT USED !
   * @param {Object} e - HTMLElement
   * @private
   * @fires Group#editor:group:oncollapse
   */
  onCollapseGroupMapBox(e) {
    logger30.trace("onCollapseGroupMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs6.default.dispatch(Event_default.group.oncollapse, e);
  }
};
var Group_default = Group;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Search.js
var import_eventbusjs7 = __toESM(require_eventbus_min());
var logger31 = LoggerByDefault_default2.getLogger("editor-search");
var Search = class _Search {
  constructor(options) {
    logger31.trace("[constructor] Search", options);
    this.options = options || {
      // default...
      target: null,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof _Search)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    this.id = this.options.id || null;
    if (!this.options.target) {
    }
    var _toolsDefault = {};
    if (!this.options.tools) {
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    if (!this.options.obj) {
      this.options.obj = {};
    }
    if (!this.options.title) {
      this.options.title = "Recherche de couches :";
    }
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxSearchTarget",
      container: "GPEditorMapBoxSearchContainer"
      // TODO ...
    };
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @private
   * @example
   * <div class="GPEditorMapBoxSearchContainer">
   *  // ...
   * </div>
   */
  _initContainer() {
    var _search = JSON.parse(JSON.stringify(this.options.obj));
    if (_search.layers) {
      if (_search.layers.length === 0) {
        logger31.info("tag 'layers' is empty !");
      }
    }
    var div = document.createElement("div");
    div.className = this.name.container;
    this.container = div;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add element into target DOM
   * @returns {Object} - Search instance
   */
  add() {
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var div = document.createElement("div");
        div.id = this.name.target;
        var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
        node.appendChild(div);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    return this;
  }
  /**
   * Set display container or get
   *
   * @param {Boolean} display - show/hidden container or get status
   * @returns {Boolean} - true/false
   */
  display(display) {
    logger31.trace("display()", display);
    if (typeof display !== "undefined") {
      this.container.style.display = display ? "flex" : "none";
    }
    return this.container.style.display === "flex";
  }
  /**
   * Get container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Search#editor:search:onsubmit
   */
  onSubmitSearchLayersMapBox(e) {
    logger31.trace("onSubmitSearchLayersMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs7.default.dispatch(Event_default.search.onsubmit, e);
  }
  /**
   * this method is called by event '' on '' tag form...
   *
   * 'e' contains the option object into 'e.target.data' !
   * 'e' contains the id editor into 'e.target.editorID' !
   *
   * @param {Object} e - HTMLElement
   * @private
   * @fires Search#editor:search:onautocomplete
   */
  onAutocompleteSearchLayersMapBox(e) {
    logger31.trace("onAutocompleteSearchLayersMapBox", e);
    e.editorID = this.id;
    e.data = this.options;
    import_eventbusjs7.default.dispatch(Event_default.search.onautocomplete, e);
  }
};
var Search_default2 = Search;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/EditorDOM.js
var EditorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  }
};
var EditorDOM_default = EditorDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Editor/Editor.js
var logger32 = LoggerByDefault_default2.getLogger("editor");
var Editor = class _Editor {
  /**
   * @constructor
  * @param {EditorOptions} options - options for function call.
  * @fires editor:layer:onclickvisibility
  * @fires editor:layer:onclickclone
  * @fires editor:layer:onclickremove
  * @fires editor:style:oneditjson
  * @fires editor:style:scale:onchangemin
  * @fires editor:style:scale:onchangemax
  * @fires editor:legend:onclickedition
  * @fires editor:legend:onchangevalue
  * @fires editor:filter:oneditjson
  * @fires editor:themes:onclickimage
  * @fires editor:themes:onclicktitle
  * @fires editor:group:oncollapse
  * @fires editor:onloaded
  * @example
  *   var editor = new Editor ({
  *      target : "",
  *      style : "data/styles/layer.json",
  *      themes: {
  *          themesSummary : "",
  *          themes : [{
  *             "thumbnail": "data/images/layer0.png",
  *             "name": "standard0",
  *             "url": "data/styles/layer0.json",
  *             "description": "",
  *             "selected" : true
  *          },{
  *             "thumbnail": "data/images/layer1.png",
  *             "name": "standard1",
  *             "url": "data/styles/layer1.json",
  *             "description": ""
  *          }]
  *      },
  *      scope : this,
  *      events : {
  *          "editor:layer:onclickvisibility" : ...,
  *          "editor:layer:onclickclone" : ...,
  *          "editor:layer:onclickremove" : ...,
  *          "editor:style:oneditjson" : ...,
  *          "editor:style:scale:onchangemin" : ...,
  *          "editor:style:scale:onchangemax" : ...,
  *          "editor:filter:oneditjson" : ...,
  *          "editor:themes:onclickimage" : this._onClickEventImageTheme(),
  *          "editor:themes:onclicktitle" : function(e) {...}
  *      },
  *      tools : {
  *          // afficher/cacher les themes (par defaut) ou utiliser les options
  *          themes : true | false | {
  *              target : "...",
  *              tools : {
  *                  "thumbnails": true,
  *                  "button": { visible : true, type : "checkbox" }
  *              },
  *          },
  *          layers : true | false,     // afficher les couches (layers)
  *          search : true | false,     // TODO : afficher l'outil de recheche de couches
  *          style : true | false,      // afficher les styles (sous menu layers)
  *          filter : true | false,     // afficher les filtres (sous menu layers)
  *          legend : true | false,     // afficher les legendes (layers)
  *          group : true | false,      // grouper les couches, l'option 'sort' doit Ãªtre activÃ©e (layers)
  *          groupAuto : true | false,  // definir la construction automatiques des groupes
  *          sort : true | false,       // trier les couches (layers)
  *          sortBy : "id|class|geom",  // definir le type de tri (layers)
  *          sortOrder : "asc, desc",   // definir l'ordre de tri (layers)
  *          title : true | false       // afficher les titres des rubriques,
  *          collapse : true | false | undefined // afficher et/ou plier les couches ou ne pas afficher l'option,
  *          type : true | false,       // afficher le type de geometrie (layers)
  *          pin : true | false,        // afficher la puce pour chaque couche (layers)
  *          visibility : true | false, // afficher l'icone de visibilitÃ© (layers),
  *          icon : {                   // afficher l'icone "oeil" ou "checkbox" (layers),
  *              "image" : true,
  *              "anchor" : "start" // afficher l'icone au debut ou Ã  la fin de la ligne
  *          },
  *          editable : true | false    // active l'edition de la legende (legendes)
  *      }
  *   });
  *   // options par defaut
  *   {
  *      themes : false,
  *      layers : true,
  *      search : false,
  *      style : false,
  *      filter : false,
  *      legend : false,
  *      group : false,
  *      groupAuto : false,
  *      sort : true,
  *      sortBy : "id",
  *      sortOrder : "asc",
  *      title : true,
  *      collapse : undefined,
  *      type : true,
  *      pin : true,
  *      visibility : true,
  *      icon : {
  *          image : true,
  *          anchor : "end"
  *      },
  *      editable : true
  *   }
  *   // Context
  *   editor.setContext("map", map);
  *   editor.setContext("layer", layer);
  *   // create DOM
  *   editor.createElement()
  *     .then(() => {
  *       console.warn(editor.getID());
  *       console.log(this.getContext("map"));
  *       console.log(this.getContext("layer"));
  *     })
  *     .catch(error => {});
  *   // possibility to add listeners with globale variable : eventbus
  *   eventbus.addEventListener("editor:style:scale:onchangemin", function (e) {...});
   */
  constructor(options) {
    logger32.trace("[constructor] Editor", options);
    this.options = options || {
      // TODO default...
    };
    if (!(this instanceof _Editor)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
  }
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  _initialize() {
    if (!this.options.target) {
      logger32.info("La 'target' n'est pas renseignÃ©e (options.target).");
    }
    if (!this.options.style) {
      logger32.error("Le 'style' MapBox n'est pas renseignÃ© (options.style) !");
      return;
    }
    if (this.options.events) {
      this._initEvents();
    } else {
      logger32.warn("Les 'handlers' ne sont pas renseignÃ©s (options.events) !");
    }
    if (!this.options.themes) {
      logger32.info("Les 'themes' MapBox ne sont pas renseignÃ©s (options.themes).");
    }
    var _toolsDefault = {
      themes: false,
      layers: true,
      search: false,
      style: false,
      filter: false,
      legend: false,
      group: false,
      groupAuto: false,
      sort: true,
      sortBy: "id",
      sortOrder: "asc",
      title: true,
      collapse: void 0,
      type: true,
      pin: true,
      visibility: true,
      icon: {
        image: true,
        anchor: "end"
      },
      editable: true
    };
    if (!this.options.tools) {
      logger32.trace("Utilisation des outils MapBox par dÃ©faut (options.tools).");
      this.options.tools = _toolsDefault;
    }
    Helper_default2.mergeParams(this.options.tools, _toolsDefault, false);
    this.id = this.options.id || SelectorID_default.generate();
    this.context = {};
    this.layers = [];
    this.container = null;
    this.name = {
      target: "GPEditorMapBoxTarget",
      container: "GPEditorMapBoxContainer",
      containerID: "GPEditorMapBoxContainer_ID_",
      containerLayers: "GPEditorMapBoxLayersContainer",
      titleLayers: "GPEditorMapBoxLayersTitle",
      titleLayersID: "GPEditorMapBoxLayersTitle_ID_",
      titleThemes: "GPEditorMapBoxThemesTitle",
      titleThemesID: "GPEditorMapBoxThemesTitle_ID_",
      sep: "GPEditorMapBoxSep"
    };
    this.mapbox = {};
    this.sprites = {};
  }
  /**
  * Initialize events with handlers
  * (called by constructor)
  *
  * List Events :
  *          "editor:layer:visibility"
  *          "editor:layer:clone"
  *          "editor:layer:remove"
  *          "editor:style:edit"
  *          "editor:style:minScale"
  *          "editor:style:maxScale"
  *          "editor:filter:edit"
  *          "editor:themes:image",
  *          "editor:themes:title"
  * @private
  */
  _initEvents() {
    var ctx = this.options.scope || this;
    var events2 = this.options.events;
    if (events2) {
      for (var event in events2) {
        if (events2.hasOwnProperty(event)) {
          var handler = events2[event];
          if (handler) {
            if (!import_eventbusjs8.default.hasEventListener(event, handler, ctx)) {
              import_eventbusjs8.default.addEventListener(event, handler, ctx);
            }
          }
        }
      }
    }
  }
  /**
   * Graphical rendering of the component
   * (called by constructor)
   *
   * @example
   *  <div class="GPEditorMapBoxContainer" id="GPEditorMapBoxContainer_ID_0">
   *    <div id="GPEditorMapBoxThemesTitle" class="GPEditorMapBoxThemesTitle">Liste des 'thÃ¨mes'</div>
   *    <div class="GPEditorMapBoxThemesContainer">
   *      ...
   *    </div>
   *    <div id="GPEditorMapBoxLayersTitle" class="GPEditorMapBoxLayersTitle">Liste des 'couches'</div>
   *    <div class="GPEditorMapBoxLayersContainer">
   *      <div class="GPEditorMapBoxLayerContainer">
   *          <div id="GPEditorMapBoxLayerTitleContainer-0_1" class="GPEditorMapBoxLayerTitleContainer">
   *              <label class="GPEditorMapBoxLayerImageLabel"></label>
   *              <input id="GPEditorMapBoxLayerTitleInput-0_1" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
   *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-0_1" title="states">population_lt_2m</label>
   *          </div>
   *      </div>
   *      <div class="GPEditorMapBoxLayerContainer">...</div>
   *      <div class="GPEditorMapBoxLayerContainer">...</div>
   *    </div>
   *  </div>
   * @private
   */
  _initContainer() {
    logger32.trace(this.mapbox);
    var div = document.createElement("div");
    div.id = this.name.containerID + this.id;
    div.className = this.name.container;
    var _toolsThemes = this.options.tools.themes;
    if (_toolsThemes && this.options.themes) {
      if (this.options.tools.title) {
        var titleThemes = document.createElement("div");
        titleThemes.id = this.name.titleThemesID + this.id;
        titleThemes.className = this.name.titleThemes;
        titleThemes.innerHTML = "Liste des 'thÃ¨mes'";
        div.appendChild(titleThemes);
      }
      var themes = new Themes_default({
        id: this.id,
        target: div,
        tools: typeof _toolsThemes === "object" ? _toolsThemes : {},
        obj: this.options.themes
      });
      themes.add();
    }
    if (this.options.tools.search) {
      var search = new Search_default2({
        id: this.id,
        target: div,
        tools: {},
        obj: this.mapbox.layers
        // liste des objets layers
      });
      search.add();
    }
    for (var source in this.mapbox.sources) {
      if (this.mapbox.sources.hasOwnProperty(source)) {
        if (this.options.tools.layers) {
          var multisources = Object.keys(this.mapbox.sources).length > 1 ? 1 : 0;
          if (multisources) {
            var hr = document.createElement("hr");
            hr.className = this.name.sep;
            div.appendChild(hr);
          }
          if (this.options.tools.title) {
            var titleLayers = document.createElement("div");
            titleLayers.id = this.name.titleLayersID + this.id;
            titleLayers.className = this.name.titleLayers;
            titleLayers.innerHTML = multisources ? "Liste des 'couches' (" + source + ")" : "Liste des 'couches'";
            div.appendChild(titleLayers);
          }
        }
        var _layers = this.mapbox.layers.slice();
        _layers.forEach(function(layer, order) {
          var _metadata = layer["metadata"];
          if (_metadata) {
            _metadata["geoportail:order"] = order;
          } else {
            layer["metadata"] = {
              "geoportail:order": order
            };
          }
        });
        if (this.options.tools.sort) {
          var sortBy = this.options.tools.sortBy;
          var sortOrder = this.options.tools.sortOrder;
          var sortFct = function(a2, b3) {
            var result = 0;
            if (a2["metadata"] && a2["metadata"]["geoportail:group"] && b3["metadata"] && b3["metadata"]["geoportail:group"]) {
              var cmpA = null;
              var cmpB = null;
              cmpA = a2["metadata"]["geoportail:group"];
              cmpB = b3["metadata"]["geoportail:group"];
              result = cmpA.localeCompare(cmpB);
            } else {
              switch (sortBy) {
                case "geom":
                  result = sortOrder === "asc" ? a2.type.localeCompare(b3.type) || a2.id.localeCompare(b3.id) : b3.type.localeCompare(a2.type) || b3.id.localeCompare(a2.id);
                  break;
                case "class":
                  result = sortOrder === "asc" ? a2["source-layer"].localeCompare(b3["source-layer"]) || a2.id.localeCompare(b3.id) : b3["source-layer"].localeCompare(a2["source-layer"]) || b3.id.localeCompare(a2.id);
                  break;
                case "id":
                default:
                  result = sortOrder === "asc" ? a2.id.localeCompare(b3.id) : b3.id.localeCompare(a2.id);
                  break;
              }
            }
            return result;
          };
          _layers.sort(sortFct);
        }
        logger32.trace("Layers : ", _layers);
        var groupBy = this.options.tools.sortBy;
        var groupAuto = this.options.tools.groupAuto;
        var _groups = {};
        _layers.forEach(function(layer) {
          var _metadata = layer["metadata"];
          if (_metadata && _metadata["geoportail:group"]) {
            var _groupName = _metadata["geoportail:group"];
            _groups[_groupName] = _groups[_groupName] ? _groups[_groupName] + 1 : 1;
          } else {
            var _field = null;
            switch (groupBy) {
              case "class":
                _field = layer["source-layer"];
                break;
              case "geom":
                _field = layer.type;
                break;
              case "id":
              default:
                _field = layer.id;
                break;
            }
            var _newGroupName = _field;
            if (groupAuto) {
              var _regex = /_|-|:|=/;
              var _idx = _field.search(_regex);
              _newGroupName = _idx !== -1 ? _field.substring(0, _idx).trim() : _field;
            }
            _groups[_newGroupName] = _groups[_newGroupName] ? _groups[_newGroupName] + 1 : 1;
            if (_metadata) {
              _metadata["geoportail:group"] = _newGroupName;
            } else {
              layer["metadata"] = {
                "geoportail:group": _newGroupName
              };
            }
          }
        });
        logger32.trace("Groups : ", _groups);
        var divLayers = document.createElement("div");
        divLayers.className = this.name.containerLayers;
        div.appendChild(divLayers);
        var details;
        if (this.options.tools.collapse !== void 0) {
          details = document.createElement("details");
          details.className = "";
          details.open = !this.options.tools.collapse;
          divLayers.appendChild(details);
          var summary = document.createElement("summary");
          summary.className = "";
          summary.innerHTML = "";
          details.appendChild(summary);
        }
        var target2 = this.options.tools.collapse !== void 0 ? details : divLayers;
        var index2 = -1;
        for (var ii = 0; ii < _layers.length; ii++) {
          var data = _layers[ii];
          index2++;
          if (data.source === source) {
            if (this.options.tools.group && this.options.tools.sort) {
              var mtd = data.metadata;
              if (mtd) {
                var grp = data.metadata["geoportail:group"];
                if (grp) {
                  if (_groups[grp] > 1) {
                    _groups[grp] = -1;
                    var oGroup = new Group_default({
                      id: this.id,
                      target: this.options.tools.collapse !== void 0 ? details : divLayers,
                      title: grp,
                      collapse: true
                    });
                    oGroup.add();
                    target2 = oGroup.getContainer();
                  } else if (_groups[grp] === 1) {
                    target2 = this.options.tools.collapse !== void 0 ? details : divLayers;
                  } else {
                  }
                } else {
                  target2 = this.options.tools.collapse !== void 0 ? details : divLayers;
                }
              } else {
                target2 = this.options.tools.collapse !== void 0 ? details : divLayers;
              }
            }
            if (this.options.tools.layers) {
              var oLayer = new Layer_default2({
                id: this.id,
                target: target2,
                position: index2 + "_" + this.id,
                // unique !
                tools: {
                  visibility: this.options.tools.visibility,
                  icon: this.options.tools.icon,
                  type: this.options.tools.type,
                  pin: this.options.tools.pin
                },
                obj: {
                  id: data.id,
                  type: data.type,
                  source: data.source,
                  "source-layer": data["source-layer"]
                }
              });
              oLayer.add();
              if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
                oLayer.visibility(false);
              }
              this.layers.push(oLayer);
            }
            if (this.options.tools.legend) {
              var isEditable = this.options.tools.editable;
              if (typeof isEditable === "undefined") {
                isEditable = data.editable;
              }
              var oLegend = new Legend_default({
                id: this.id,
                target: target2,
                sprites: this.sprites,
                obj: {
                  id: data.id,
                  source: data.source,
                  title: data.id,
                  editable: typeof isEditable !== "undefined" ? isEditable : false,
                  paint: data.paint,
                  layout: data.layout
                }
              });
              oLegend.add();
              oLegend.display(false);
              if (oLayer) {
                oLayer.addLegend(oLegend);
                oLayer.slotLegend();
              }
            }
            if (this.options.tools.style) {
              var oStyle = new Style_default2({
                id: this.id,
                target: target2,
                position: index2 + "_" + this.id,
                // unique !,
                obj: {
                  id: data.id,
                  source: data.source,
                  layout: data.layout,
                  paint: data.paint
                }
              });
              oStyle.add();
              oStyle.display(false);
              if (oLayer) {
                oLayer.addStyle(oStyle);
              }
              if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
                oLayer.visibility(false);
              }
            }
            if (this.options.tools.filter) {
              var oFilter = new Filter_default({
                id: this.id,
                target: target2,
                position: index2 + "_" + this.id,
                // unique !,
                obj: {
                  id: data.id,
                  source: data.source,
                  filter: data.Filter
                }
              });
              oFilter.add();
              oFilter.display(false);
              if (oLayer) {
                oLayer.addFilter(oFilter);
              }
            }
          } else {
            if (index2 >= 0) {
              index2--;
            }
          }
        }
      }
    }
    this.container = div;
    if (!this.options.target) {
      if (!document.getElementById(this.name.target)) {
        var _target = document.createElement("div");
        _target.id = this.name.target;
        var node = document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0] || document.documentElement;
        node.appendChild(_target);
      }
      this.options.target = document.getElementById(this.name.target);
    }
    if (this.container) {
      this.options.target.appendChild(this.container);
    }
    import_eventbusjs8.default.dispatch(Event_default.onloaded, this);
  }
  /**
   * Getting Sprites informations
   * (called by _initialize)
   *
   * @param {String} sprites - url des sprites
   * @returns {Promise} - promise
   * @private
   */
  _getSprites(sprites) {
    var self2 = this;
    if (sprites && sprites.startsWith("mapbox://")) {
      return new Promise((resolve, reject) => {
        logger32.error("Protocole mapbox:// non gÃ©rÃ© !");
        resolve(self2);
      });
    }
    if (!sprites) {
      return new Promise((resolve, reject) => {
        logger32.error("Auncun sprites disponibles !");
        resolve(self2);
      });
    }
    var fetchSpritesImage = function() {
      var spritesImage = sprites + ".png";
      return fetch(spritesImage, {
        credentials: "same-origin"
      }).then(function(response) {
        if (response.ok) {
          return response.blob().then(function(blob) {
            self2.sprites.url = spritesImage;
            var theImage = new Image();
            theImage.src = spritesImage;
            return theImage.decode().then(function() {
              self2.sprites.size = {};
              self2.sprites.size.h = theImage.height;
              self2.sprites.size.w = theImage.width;
            });
          }).catch((error) => {
            logger32.warn("fetch image sprites exception :", error);
          });
        } else {
          var err = new Error("HTTP status code: " + response.status);
          throw err;
        }
      }).catch((error) => {
        return new Promise((resolve, reject) => {
          logger32.error("fetch image sprites exception :", error);
          reject(error);
        });
      });
    };
    var fetchSpritesJson = function() {
      var spritesJson = sprites + ".json";
      return fetch(spritesJson, {
        credentials: "same-origin"
      }).then(function(response) {
        if (response.ok) {
          return response.json().then(function(json) {
            self2.sprites.json = json;
          }).catch((error) => {
            logger32.warn("fetch json sprites exception :", error);
          });
        } else {
          var err = new Error("HTTP status code: " + response.status);
          throw err;
        }
      }).catch((error) => {
        return new Promise((resolve, reject) => {
          logger32.error("fetch json sprites exception :", error);
          reject(error);
        });
      });
    };
    return Promise.all([
      fetchSpritesImage(),
      fetchSpritesJson()
    ]);
  }
  // ################################################################### //
  // ########################## INTERFACE ############################## //
  // ################################################################### //
  /**
   * Create Editor
   *
   * @returns {Promise} - promise
   */
  createElement() {
    var self2 = this;
    if (typeof this.options.style === "object") {
      this.mapbox = this.options.style;
      if (this.options.tools.legend) {
        return this._getSprites(this.mapbox.sprite).then(function() {
          self2._initContainer();
          return self2;
        }).catch((error) => {
          logger32.warn("fetch sprites exception :", error);
        });
      } else {
        return new Promise((resolve, reject) => {
          self2._initContainer();
          resolve(self2);
        });
      }
    }
    if (typeof this.options.style === "string") {
      return fetch(this.options.style, {
        credentials: "same-origin"
      }).then((response) => {
        return response.json().then((style) => {
          self2.mapbox = style;
        }).then(function() {
          if (self2.options.tools.legend) {
            return self2._getSprites(self2.mapbox.sprite).then(function() {
              self2._initContainer();
              return self2;
            }).catch((error) => {
              logger32.warn("fetch sprites exception :", error);
            });
          } else {
            return new Promise((resolve, reject) => {
              self2._initContainer();
              resolve(self2);
            });
          }
        }).catch((error) => {
          logger32.error("json exception :", error);
        });
      }).catch((error) => {
        logger32.error("fetch exception :", error);
      });
    }
  }
  /**
   * Set display container (DOM)
   *
   * @param {Boolean} display - show/hidden container
   */
  display(display) {
    this.container.style.display = display ? "block" : "none";
  }
  setContext(key, value2) {
    this.context[key] = value2;
  }
  getContext(key) {
    return this.context[key];
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Get id editor
   * @returns {Number} id
   */
  getID() {
    return this.id;
  }
  /**
   * Get container (DOM)
   * @returns {HTMLElement} DOM element
   */
  getContainer() {
    return this.container;
  }
  /**
   * Get Style (json)
   * @returns {Object} Style MapBox
   */
  getStyle() {
    return this.mapbox;
  }
  /**
   * Get layer style (json)
   * @param {Number} i - index
   * @returns {Object} Style MapBox of a layers
   */
  getStyleLayer(i) {
    var layer = null;
    var o = this.getLayer(i);
    var id = o.options.obj.id;
    for (var k3 = 0; k3 < this.mapbox.layers.length; k3++) {
      var l3 = this.mapbox.layers[k3];
      if (l3.id === id) {
        layer = l3;
        break;
      }
    }
    return layer;
  }
  /**
   * Get layer object from json style
   * @param {Number} i - index into style json
   * @returns {Object} Style MapBox of a layers
   */
  getLayerFromStyle(i) {
    var layer = null;
    var l3 = this.mapbox.layers[i];
    for (var k3 = 0; k3 < this.getLayers().length; k3++) {
      var o = this.getLayer(k3);
      if (l3.id === o.options.obj.id) {
        layer = o;
        break;
      }
    }
    return layer;
  }
  /**
   * Get a list of layer object sorted or not (see options.tools.sort)
   * @returns {Array} - List of layer object
   * @see {ol.style.editor.Layer}
   */
  getLayers() {
    return this.layers;
  }
  /**
   * Get the layer object from a list sorted or not (see options.tools.sort)
   * @param {Number} i - index
   * @returns {Object} - layer object
   * @see {ol.style.editor.Layer}
   */
  getLayer(i) {
    return this.layers[i];
  }
};
Helper_default2.assign(Editor.prototype, EditorDOM_default);
var Editor_default = Editor;
if (window.ol && window.ol.style) {
  window.ol.style.Editor = Editor;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerImport/LayerImportDOM.js
var LayerImportDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Map loading
   *
   * @returns {HTMLElement} container
   */
  _createLoadingElement: function() {
    var div = document.createElement("div");
    div.id = "GPmapLoading";
    div.className = "";
    return div;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPimport");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ######################### show widget ############################# //
  // ################################################################### //
  /**
   * Show Import
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowImportPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowImportPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowImportPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-import");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Ouvrir l'import de couches");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2._onShowImportClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2._onShowImportClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################################ Panel ############################ //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPimportPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createImportPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader GPelementVisible gpf-visible gpf-panel__header fr-modal__header";
    return container;
  },
  /**
   * Create Return PIcto into Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelReturnPictoElement: function() {
    var self2 = this;
    var returnDiv = document.createElement("button");
    returnDiv.id = this._addUID("GPimportPanelReturnPicto");
    returnDiv.title = "Masquer le panneau";
    returnDiv.className = "GPreturnPicto GPimportPanelReturnPicto GPelementHidden gpf-hidden gpf-btn gpf-btn-icon-return fr-btn fr-btn--close fr-btn--tertiary-no-outline";
    if (CheckDsfr_default()) {
      var returnSpan = document.createElement("span");
      returnSpan.className = "GPelementHidden";
      returnSpan.innerHTML = "Retour";
      returnDiv.appendChild(returnSpan);
    }
    if (returnDiv.addEventListener) {
      returnDiv.addEventListener("click", function(e) {
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
        self2._onReturnPictoClick(e);
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
      });
    } else if (returnDiv.attachEvent) {
      returnDiv.attachEvent("onclick", function(e) {
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
        self2._onReturnPictoClick(e);
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
      });
    }
    return returnDiv;
  },
  /**
   * Create Header Title Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelTitleElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportHeaderTitle");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.innerHTML = "Import de donnÃ©es";
    return div;
  },
  /**
   * Create Header close div
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelCloseElement: function() {
    var self2 = this;
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPimportPanelClose");
    divClose.className = "GPpanelClose GPimportPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline";
    divClose.title = "Fermer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowImportPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    return divClose;
  },
  // ################################################################### //
  // ########################### Form panel ############################ //
  // ################################################################### //
  /**
   * Create Form
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportPanelFormElement: function() {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPimportForm");
    form.className = "GPform GPelementVisible gpf-visible gpf-mobile-form gpf-panel__content fr-modal__content";
    if (form.addEventListener) {
      form.addEventListener("submit", function(e) {
        e.preventDefault();
        self2._onImportSubmit();
      });
    } else if (form.attachEvent) {
      form.attachEvent("onsubmit", function(e) {
        e.preventDefault();
        self2._onImportSubmit();
      });
    }
    return form;
  },
  /**
   * Create Container for import type choice
   *
   * @param {Array} importTypes - import types to be displayed (and used)
   * @returns {HTMLElement} DOM element
   */
  _createImportTypeLineElement: function(importTypes) {
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPimportTypeLine");
    div.className = "GPimportInputLine";
    var label = document.createElement("label");
    label.id = this._addUID("GPimportTypeLabel");
    label.className = "GPlabel gpf-label fr-label";
    label.innerHTML = "Type de donnÃ©e";
    label.title = "Type de donnÃ©e";
    div.appendChild(label);
    var select = document.createElement("select");
    select.setAttribute("aria-labelledby", this._addUID("GPimportTypeLabel"));
    select.className = "GPselect gpf-select fr-select";
    if (select.addEventListener) {
      select.addEventListener("change", function(e) {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementHidden gpf-hidden";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementHidden gpf-hidden";
        }
        context._onImportTypeChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function() {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementHidden gpf-hidden";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementHidden gpf-hidden";
        }
        context._onImportTypeChange();
      });
    }
    select.id = this._addUID("GPimportTypeSelect");
    if (!importTypes || !Array.isArray(importTypes)) {
      importTypes = [
        "KML",
        "GPX",
        "GeoJSON",
        "MAPBOX",
        "WMS",
        "WMTS",
        "WFS"
      ];
    }
    var option2;
    for (var i = 0; i < importTypes.length; i++) {
      option2 = document.createElement("option");
      option2.value = importTypes[i];
      option2.text = importTypes[i] === "MAPBOX" ? "Tuiles vectorielles" : importTypes[i];
      select.appendChild(option2);
    }
    div.appendChild(select);
    return div;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  // ################################################################### //
  // ##### Params for static import (KML / GPX / GeoJSON) ############## //
  // ################################################################### //
  /**
   * Create container for KML/GPX/GeoJSON parameters
   * @param {String} currentType - GeoJSON, GPX or KML value
   * @returns {HTMLElement} DOM element
   */
  _createImportStaticParamsContainer: function(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportStaticParams");
    if (currentType === "KML" || currentType === "GPX" || currentType === "GeoJSON" || currentType === "MAPBOX") {
      div.className = "GPelementVisible gpf-visible fr-my-4w";
    } else {
      div.className = "GPelementHidden gpf-hidden";
    }
    return div;
  },
  /**
   * Create name label for KML/GPX/GeoJSON parameters
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticNameLabel: function() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine fr-mb-1w";
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportName");
    label.innerHTML = "Nom";
    label.title = "Nom";
    div.appendChild(label);
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportName");
    input.className = "GPinput gpf-input fr-input";
    div.appendChild(input);
    return div;
  },
  /**
   * Create import choice for KML/GPX/GeoJSON parameters (local or url)
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticModeChoiceDiv: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportChoice");
    div.className = "fr-my-1w";
    return div;
  },
  /**
   * Create local import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticLocalChoiceDiv: function() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.type = "radio";
    if (input.addEventListener) {
      input.addEventListener("change", function(e) {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine fr-mb-1w";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function() {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine fr-mb-1w";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange();
      });
    }
    input.name = "GPimportChoiceMode";
    input.value = "local";
    input.checked = true;
    input.id = this._addUID("GPimportChoiceAltLocal");
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportChoiceAltLocal");
    label.innerHTML = "par fichier local";
    label.title = "par fichier local";
    div.appendChild(label);
    return div;
  },
  /**
   * Create url import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticUrlChoiceDiv: function() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.type = "radio";
    if (input.addEventListener) {
      input.addEventListener("change", function(e) {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function() {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange();
      });
    }
    input.id = this._addUID("GPimportChoiceAltUrl");
    input.name = "GPimportChoiceMode";
    input.value = "url";
    input.checked = false;
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportChoiceAltUrl");
    label.innerHTML = "par URL";
    label.title = "par URL";
    div.appendChild(label);
    return div;
  },
  /**
   * Create input div for KML/GPX/GeoJSON parameters local import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticLocalInputDiv: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueLocal");
    div.className = "GPimportInputLine";
    return div;
  },
  /**
   * Create input label for KML/GPX/GeoJSON parameters local import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticLocalInputLabel: function() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label fr-mb-1w";
    label.htmlFor = this._addUID("GPimportFile");
    label.innerHTML = "Fichier local";
    label.title = "Fichier local";
    return label;
  },
  /**
   * Create file input for KML/GPX/GeoJSON parameters local import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticLocalInput: function() {
    var input = document.createElement("input");
    input.type = "file";
    input.id = this._addUID("GPimportFile");
    input.className = "GPimportInputFile gpf-upload fr-upload";
    return input;
  },
  /**
   * Create input div for KML/GPX/GeoJSON parameters url import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticUrlInputDiv: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueUrl");
    div.className = "GPelementHidden gpf-hidden";
    return div;
  },
  /**
   * Create input label for KML/GPX/GeoJSON parameters url import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticUrlInputLabel: function() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportUrl");
    label.innerHTML = "URL";
    label.title = "URL";
    return label;
  },
  /**
   * Create url input for KML/GPX/GeoJSON parameters url import
   *
   * @returns {HTMLElement} DOM element
   */
  _createStaticUrlInput: function() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportUrl");
    input.className = "GPinput gpf-input fr-input";
    return input;
  },
  // ################################################################### //
  // ######## Params for service params import (WMS//WMTS/WFS) ######### //
  // ################################################################### //
  /**
   * Create container for WMS/WMTS/WFS parameters
   * @param {String} currentType - WMS, WMTS or WFS value
   * @returns {HTMLElement} DOM element
   */
  _createServiceParamsContainer: function(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportServiceParams");
    if (currentType === "WMS" || currentType === "WMTS" || currentType === "WFS") {
      div.className = "GPelementVisible gpf-visible";
    } else {
      div.className = "GPelementHidden gpf-hidden";
    }
    return div;
  },
  /**
   * Create div for WMS/WMTS/WFS url
   *
   * @returns {HTMLElement} DOM element
   */
  _createServiceUrlDiv: function() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine";
    return div;
  },
  /**
   * Create input label for WMS/WMTS/WFS url
   *
   * @returns {HTMLElement} DOM element
   */
  _createServiceUrlInputLabel: function() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportServiceUrl");
    label.innerHTML = "URL du service";
    label.title = "URL du service";
    return label;
  },
  /**
   * Create input for WMS/WMTS/WFS parameters url
   *
   * @returns {HTMLElement} DOM element
   */
  _createServiceUrlInput: function() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportServiceUrl");
    input.className = "GPinput gpf-input fr-input";
    return input;
  },
  // ################################################################### //
  // ########################### Submit Form ########################### //
  // ################################################################### //
  /**
   * Create Submit Form Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportSubmitFormElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GPimportSubmit");
    input.className = "GPsubmit gpf-btn fr-btn";
    input.type = "submit";
    input.value = "Importer";
    return input;
  },
  // ################################################################### //
  // ########################### GetCap Panel ########################## //
  // ################################################################### //
  /**
   * Create GetCap Panel Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportGetCapPanelElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportGetCapPanel");
    div.className = "GPpanel GPelementHidden gpf-panel fr-modal gpf-hidden";
    return div;
  },
  /**
   * Create GetCap Panel Header Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportGetCapPanelHeaderElement: function() {
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    panelTitle.innerHTML = "Couches accessibles";
    panelTitle.title = "Couches accessibles";
    container.appendChild(panelTitle);
    var closeDiv = document.createElement("button");
    closeDiv.className = "GPpanelClose GPimportGetCapPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportGetCapPanelClose");
    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function() {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportGetCapPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(context._addUID("GPimportGetCapPanel")).classList.replace("gpf-visible", "gpf-hidden");
        context._onGetCapPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function() {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportGetCapPanel")).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(context._addUID("GPimportGetCapPanel")).classList.replace("gpf-visible", "gpf-hidden");
        context._onGetCapPanelClose();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    closeDiv.appendChild(span);
    container.appendChild(closeDiv);
    return container;
  },
  /**
   * Create GetCap Results List Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportGetCapResultsContainer: function() {
    var container = document.createElement("div");
    container.className = "GPimportGetCapRoot gpf-panel__list";
    container.id = this._addUID("GPimportGetCapResults");
    return container;
  },
  _addImportGetCapResultListRubrique: function(title3, container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListRubrique";
    ul.title = title3;
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultRubrique: function(title3, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapRubrique gpf-panel__items_layerimport";
    var input = document.createElement("input");
    input.id = "GPimportGetCapRubrique-" + SelectorID_default.generate();
    input.className = "GPimportGetCapRubrique";
    input.type = "checkbox";
    li.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportGetCapRubriqueTitle gpf-label fr-btn fr-btn--secondary";
    label.htmlFor = input.id;
    label.innerHTML = title3;
    label.title = title3;
    li.appendChild(label);
    container.appendChild(li);
    return container;
  },
  _addImportGetCapResultListLayer: function(container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListLayer";
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultLayer: function(description, id, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapProposal gpf-panel__items_layerimport gpf-panel__items";
    li.innerHTML = description.content;
    li.title = description.title;
    li.id = "GPimportGetCapProposal_" + id;
    var context = this;
    if (li.addEventListener) {
      li.addEventListener("click", function(e) {
        context._onGetCapResponseLayerClick(e);
      });
    } else if (li.attachEvent) {
      li.attachEvent("onclick", function() {
        context._onGetCapResponseLayerClick();
      });
    }
    container.appendChild(li);
    return container;
  },
  // ################################################################### //
  // ########################### MapBox Panel ########################## //
  // ################################################################### //
  /**
   * Create MapBox Panel Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportMapBoxPanelElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportMapBoxPanel");
    div.className = "GPpanel GPelementHidden gpf-panel fr-modal gpf-hidden";
    return div;
  },
  /**
   * Create MapBox Panel Header Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportMapBoxPanelHeaderElement: function() {
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var returnDiv = document.createElement("button");
    returnDiv.id = this._addUID("GPimportMapBoxPanelReturnPicto");
    returnDiv.title = "Nouvel import";
    returnDiv.className = "GPreturnPicto GPimportMapBoxPanelReturnPicto gpf-btn gpf-btn-icon-return fr-btn fr-btn--secondary gpf-btn--secondary";
    if (returnDiv.addEventListener) {
      returnDiv.addEventListener("click", function(e) {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        context._onMapBoxReturnPictoClick(e);
      });
    } else if (returnDiv.attachEvent) {
      returnDiv.attachEvent("onclick", function(e) {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        context._onMapBoxReturnPictoClick(e);
      });
    }
    container.appendChild(returnDiv);
    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    panelTitle.innerHTML = "Edition des styles";
    panelTitle.title = "Edition des styles";
    container.appendChild(panelTitle);
    var closeDiv = document.createElement("button");
    closeDiv.className = "GPpanelClose GPimportMapBoxPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportMapBoxPanelClose");
    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function() {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        context._onMapBoxPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function() {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        context._onMapBoxPanelClose();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    closeDiv.appendChild(span);
    container.appendChild(closeDiv);
    return container;
  },
  /**
   * Create MapBox Results List Element
   *
   * @returns {HTMLElement} DOM element
   */
  _createImportMapBoxResultsContainer: function() {
    var container = document.createElement("div");
    container.className = "GPimportMapBoxpRoot";
    container.id = this._addUID("GPimportMapBoxResults");
    return container;
  }
  // _addImportMapBoxResultListSource : function (id, source, container) {
  //     var ul = document.createElement("ul");
  //     ul.className = "GPimportMapBoxListSource";
  //     ul.title = id;
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxListSourceTitle";
  //     label.innerHTML = "Listes des couches pour la source '" + id + "' :";
  //     label.title = source.attribution || id;
  //     ul.appendChild(label);
  //
  //     container.appendChild(ul);
  //     return container;
  // },
  //
  // _addImportMapBoxResultSource : function (layer, container) {
  //     var li = document.createElement("li");
  //     li.className = "GPimportMapBoxSource";
  //
  //     // input
  //     var input = document.createElement("input");
  //     input.id = "GPimportMapBoxSource-" + SelectorID.generate();
  //     input.className = "GPimportMapBoxSource";
  //     input.type = "checkbox";
  //     li.appendChild(input);
  //
  //     // label for
  //     var name = layer["source-layer"] || layer.id || layer.source;
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceTitle";
  //     label.htmlFor = input.id;
  //     label.innerHTML = name;
  //     label.title = JSON.stringify(layer.metadata) || name;
  //     li.appendChild(label);
  //
  //     container.appendChild(li);
  //     return container;
  // },
  //
  // _addImportMapBoxStyleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _style = false;
  //     var _obj = {};
  //     var _layer = JSON.parse(JSON.stringify(layer)); // on utilise une copie  !
  //     if (_layer.paint && Object.keys(_layer.paint).length) {
  //         _style = true;
  //         _obj.paint = _layer.paint;
  //     }
  //
  //     // pas de style dans paint, on teste dans layout !
  //     if (_layer.layout && Object.keys(_layer.layout).length) {
  //         _style = true;
  //         _obj.layout = _layer.layout;
  //         // on supprime visibility Ã  l'affichage uniquement
  //         // cf. _addImportMapBoxVisibilitySource !
  //         if (_layer.layout.visibility) {
  //             delete _obj.visibility;
  //         }
  //     }
  //
  //     function syntaxHighlight (json) {
  //         json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  //         return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function (match) {
  //             var cls = "gp-json-number";
  //             if (/^"/.test(match)) {
  //                 if (/:$/.test(match)) {
  //                     cls = "gp-json-key";
  //                 } else {
  //                     cls = "gp-json-string";
  //                 }
  //             } else if (/true|false/.test(match)) {
  //                 cls = "gp-json-boolean";
  //             } else if (/null/.test(match)) {
  //                 cls = "gp-json-null";
  //             }
  //             return "<span class='" + cls + "'>" + match + "</span>";
  //         });
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceStyle";
  //
  //     if (_style) {
  //         var strJson = JSON.stringify(_obj, null, 4);
  //
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Styles :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = syntaxHighlight(strJson);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxFilterSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _filter = false;
  //     // FIXME tag filter est obselete !
  //     // on doit utiliser les expressions dans "paint" ou "layout" !
  //     if (layer.filter && layer.filter.length) {
  //         _filter = true;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceFilter";
  //
  //     if (_filter) {
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Filtres :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = JSON.stringify(layer.filter, null, 4);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxScaleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _scaleMin = layer.minzoom || 0;
  //     var _scaleMax = layer.maxzoom || 21;
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceScale";
  //
  //     var labelMin = document.createElement("label");
  //     labelMin.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMin.innerHTML = "minZoom :";
  //     div.appendChild(labelMin);
  //
  //     var inputMin = document.createElement("input");
  //     inputMin.className = "GPimportMapBoxSourceScaleInput";
  //     inputMin.type = "range";
  //     inputMin.value = _scaleMin;
  //     inputMin.title = _scaleMin;
  //     inputMin.disabled = false;
  //     inputMin.min = 0;
  //     inputMin.max = 21;
  //     if (inputMin.addEventListener) {
  //         inputMin.addEventListener("change", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     } else if (inputMin.appendChild) {
  //         inputMin.appendChild("onchange", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMin);
  //
  //     div.appendChild(document.createElement("br"));
  //
  //     var labelMax = document.createElement("label");
  //     labelMax.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMax.innerHTML = "maxZoom :";
  //     div.appendChild(labelMax);
  //
  //     var inputMax = document.createElement("input");
  //     inputMax.className = "GPimportMapBoxSourceScaleInput";
  //     inputMax.type = "range";
  //     inputMax.value = _scaleMax;
  //     inputMax.title = _scaleMax;
  //     inputMax.disabled = false;
  //     inputMax.min = 0;
  //     inputMax.max = 21;
  //     if (inputMax.addEventListener) {
  //         inputMax.addEventListener("change", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     } else if (inputMax.appendChild) {
  //         inputMax.appendChild("onchange", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMax);
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxVisibilitySource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _visibility = true;
  //     if (layer.layout && layer.layout.visibility && layer.layout.visibility === "none") {
  //         _visibility = false;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceVisibility";
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceVisibilityLabel";
  //     label.innerHTML = "VisibilitÃ© :";
  //     div.appendChild(label);
  //
  //     var input = document.createElement("input");
  //     input.className = "GPimportMapBoxSourceVisibilityInput";
  //     input.type = "checkbox";
  //     input.checked = _visibility;
  //     input.disabled = false;
  //     if (input.addEventListener) {
  //         input.addEventListener("change", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     } else if (input.appendChild) {
  //         input.appendChild("onchange", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(input);
  //
  //     container.appendChild(div);
  //     return container;
  // }
};
var LayerImportDOM_default = LayerImportDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ElevationPath/ElevationPath.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/ElevationPath/GPFelevationPath.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ToolBoxMeasure/MeasureToolBox.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasure.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ToolBoxMeasure/MeasureToolBoxDOM.js
var MeasureToolBoxDOM = {
  _toolboxId: "GPtoolbox-measure-main",
  _buttonId: "GPtoolbox-measure-button",
  _widgetId: "GPtoolbox-measure-widget",
  /**
  * get toolBox ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getToolBoxID: function(uid) {
    return uid ? this._toolboxId + "-" + uid : this._toolboxId;
  },
  /**
  * get button ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getButtonID: function(uid) {
    return uid ? this._buttonId + "-" + uid : this._buttonId;
  },
  /**
  * get toolBox Container for widget
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getWidgetID: function(uid) {
    return uid ? this._widgetId + "-" + uid : this._widgetId;
  },
  /**
   * Main container (DOM)
   * @param {Number} uid - uid
   * @returns {HTMLElement} DOM element
   */
  _createToolBoxContainerElement: function(uid) {
    var container = document.createElement("div");
    container.id = this.getToolBoxID(uid);
    container.className = "GPshowAdvancedToolPicto";
    var button = document.createElement("button");
    button.id = this.getButtonID(uid);
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowToolBoxPicto gpf-btn gpf-btn-icon-toolbox fr-btn";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    var self2 = this;
    button.addEventListener("click", function(e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      this.blur();
      var widget2 = document.getElementById(self2.getWidgetID(uid));
      if (widget2.style.display === "block") {
        widget2.style.display = "none";
      } else {
        widget2.style.display = "block";
      }
    });
    container.appendChild(button);
    var widget = document.createElement("div");
    widget.id = this.getWidgetID(uid);
    widget.addEventListener("click", function() {
    }, false);
    container.appendChild(widget);
    return container;
  }
};
var MeasureToolBoxDOM_default = MeasureToolBoxDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ToolBoxMeasure/MeasureToolBox.js
var logger33 = LoggerByDefault_default2.getLogger("toolbox");
var MeasureToolBox = {
  /**
   * liste des uid/map (pour chaque toolbox)
   * { map : uid }
   * Ex. { "map1" : 465456456486845 }
   */
  _toolbox: {},
  /**
   * Ajout d'un controle dans la ToolBox.
   * Creation de la toolbox si besoin...
   *
   * @param {Map} map - map
   * @param {Control} ctrl - objet Ã  ajouter de type ol.control.Control
   */
  add: (
    /** @type {(map: Map, ctrl: Control) => void} */
    function(map, ctrl) {
      logger33.trace("ToolBox.add()", ctrl);
      if (!map) {
        logger33.trace("map doesn't exist !?");
        return;
      }
      var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
      if (context) {
        this._toolbox = context.gpShareMeasureToolBox || {};
      }
      var mapContainer = map.getTargetElement();
      var mapDocument = mapContainer.ownerDocument;
      var mapId = mapContainer.id;
      if (!this._toolbox || Object.keys(this._toolbox).length === 0) {
        this._toolbox = {};
        this._toolbox[mapId] = SelectorID_default.generate();
      } else {
        if (!this._toolbox[mapId]) {
          this._toolbox[mapId] = SelectorID_default.generate();
        }
      }
      var uid = this._toolbox[mapId];
      if (!mapDocument.getElementById(this.getToolBoxID(uid))) {
        logger33.trace("create toolbox !");
        var toolboxContainer = this._createToolBoxContainerElement(uid);
        toolboxContainer.style.pointerEvents = "auto";
        var overlaysContainer = mapContainer.getElementsByClassName("ol-overlaycontainer-stopevent");
        overlaysContainer[0].appendChild(toolboxContainer);
      }
      var widgetContainer = mapDocument.getElementById(this.getWidgetID(uid));
      ctrl.setTarget(widgetContainer);
      if (context) {
        context.gpShareMeasureToolBox = this._toolbox;
      }
      logger33.trace("add control to toolbox !");
    }
  )
};
Helper_default2.assign(MeasureToolBox, MeasureToolBoxDOM_default);
var MeasureToolBox_default = MeasureToolBox;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/Measures.js
var logger34 = LoggerByDefault_default2.getLogger("measures");
var Measures = {
  // ****************************************************************** //
  // > Default Styles
  // ****************************************************************** //
  /*
   * Pointer
   */
  DEFAULT_POINTER_STYLE: new Circle_default2({
    radius: 5,
    stroke: new Stroke_default({
      color: "#002A50",
      width: 2
    }),
    fill: new Fill_default({
      color: "rgba(255, 155, 0, 0.7)"
    })
  }),
  /*
   * Measures style line
   */
  DEFAULT_DRAW_START_STYLE: new Style_default({
    fill: new Fill_default({
      color: "rgba(0, 183, 152, 0.2)"
    }),
    stroke: new Stroke_default({
      color: "#002A50",
      lineDash: [10, 10],
      width: 2
    })
  }),
  /*
   * Measures final style line
   */
  DEFAULT_DRAW_FINISH_STYLE: new Style_default({
    fill: new Fill_default({
      color: "rgba(0, 183, 152, 0.3)"
    }),
    stroke: new Stroke_default({
      color: "#002A50",
      width: 3
    })
  }),
  // ****************************************************************** //
  // > ToolBox : these tools work together
  // ****************************************************************** //
  // sample :
  // tools[name_control][0].(active|instance|map)
  // tools : {
  //      MeasureLength : [
  //          { active : true, instance : [Object MeasureLength], map : "map1" },
  //          { active : true, instance : [Object MeasureLength], map : "map2" }
  //      ],
  //      MeasureArea : [],
  //      MeasureAzimuth : []
  // }
  tools: {
    MeasureLength: [],
    MeasureArea: [],
    MeasureAzimuth: []
  },
  // ****************************************************************** //
  // > Variables
  // ****************************************************************** //
  /**
   * Global measure draw interaction
   * @type {ol.interaction.Draw}
   */
  measureDraw: null,
  /**
   * Global vector source for measure
   * @type {ol.source.Vector}
   */
  measureSource: null,
  /**
   * Global vector layer for measure
   * @type {ol.layer.Vector}
   */
  measureVector: null,
  /**
   * Event on removing map layer
   * @type {ol.CollectionEventType}
   */
  eventLayerRemove: null,
  /**
   * Currently drawn feature.
   * @type {ol.Feature}
   */
  sketch: null,
  /**
   * The measure tooltip element.
   * @type {Element}
   */
  measureTooltipElement: null,
  /**
   * Overlay to show the measurement.
   * @type {ol.Overlay}
   */
  measureTooltip: null,
  /**
   * TODO The help tooltip element.
   * @type {Element}
   */
  helpTooltipElement: null,
  /**
   * TODO Overlay to show the help.
   * @type {ol.Overlay}
   */
  helpTooltip: null,
  // ****************************************************************** //
  // > Methods Public
  // ****************************************************************** //
  /** Desactived Tool Measure */
  clean: function() {
    var _class = this.CLASSNAME;
    logger34.trace("[" + _class + "] deactived tool !");
    this.clearMeasure();
    this.clearMeasureToolTip();
    this.removeMeasureEvents();
    this._pictoContainer.setAttribute("aria-pressed", false);
  },
  // ****************************************************************** //
  // > Methods Events
  // ****************************************************************** //
  /**
   * Handle pointer move.
   *
   * @param {ol.MapBrowserEvent} e - The event.
   */
  onPointerMoveHandler: function(e) {
    if (e.dragging) {
      return;
    }
    var tooltipCoord = e.coordinate;
    if (this.sketch) {
      var output;
      var geom = this.sketch.getGeometry();
      output = this.format(geom);
      if (geom.getType() === "LineString") {
        tooltipCoord = geom.getLastCoordinate();
      } else if (geom.getType() === "Polygon") {
        tooltipCoord = geom.getInteriorPoint().getCoordinates();
      } else {
        return;
      }
      this.measureTooltipElement.innerHTML = output;
      this.measureTooltip.setPosition(tooltipCoord);
    }
  },
  /**
   * Main program !
   * This method is called by event 'click' on control picto
   *
   * @param {Object} e - HTMLElement
   * @param {String} type - LineString or Polygon
   * @private
   */
  onShowMeasureClick: function(e, type) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    var currentMapId = map.getTargetElement().id;
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      this.tools = context.gpShareMeasures || {};
    }
    var mySelf = this.CLASSNAME;
    for (var className in this.tools) {
      if (this.tools.hasOwnProperty(className)) {
        var measures = this.tools[className];
        for (var i = 0; i < measures.length; i++) {
          var o = measures[i];
          if (o && o.active && className !== mySelf && o.map.id === currentMapId) {
            o.active = false;
            if (o.instance !== null) {
              o.instance.clean();
            }
          }
        }
      }
    }
    Interactions_default.unset(map, {
      current: "Measures"
    });
    var opened = this._pictoContainer.ariaPressed;
    if (opened === "true") {
      this.addMeasureEvents();
      this.initMeasureInteraction();
      this.addMeasureInteraction(type);
      for (var j2 = 0; j2 < this.tools[mySelf].length; j2++) {
        if (this.tools[mySelf][j2].map.id === currentMapId) {
          this.tools[mySelf][j2].active = true;
        }
      }
    } else {
      this.clearMeasure();
      this.clearMeasureToolTip();
      this.removeMeasureEvents();
      for (var k3 = 0; k3 < this.tools[mySelf].length; k3++) {
        if (this.tools[mySelf][k3].map.id === currentMapId) {
          this.tools[mySelf][k3].active = false;
        }
      }
    }
  },
  // ****************************************************************** //
  // > Methods not Public
  // ****************************************************************** //
  /**
   * Clear all dom tooltip of length, area or azimut object.
   */
  clearMeasureToolTip: function() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var mapContainer = map.getTargetElement();
    var overlays = mapContainer.getElementsByClassName("ol-overlaycontainer");
    for (var k3 = 0; k3 < overlays.length; k3++) {
      var nodes = overlays[k3];
      var len = nodes.children.length;
      var nodesToRemove = [];
      for (var i = 0; i < len; i++) {
        var node = nodes.children[i];
        if (node.children.length !== 0) {
          var child = node.children[0];
          if (child.className === "GPmeasureTooltip GPmeasureTooltip-static" || child.className === "GPmeasureTooltip GPmeasureTooltip-measure") {
            nodesToRemove.push(node);
          }
        }
      }
      for (var j2 = 0; j2 < nodesToRemove.length; j2++) {
        nodes.removeChild(nodesToRemove[j2]);
      }
    }
  },
  /**
   * Clear all length, area or azimut object.
   */
  clearMeasure: function() {
    var map = this.getMap();
    if (this.measureVector) {
      map.removeLayer(this.measureVector);
      this.measureVector = null;
    }
    if (this.measureDraw) {
      map.removeInteraction(this.measureDraw);
      this.measureDraw = null;
    }
  },
  /**
   * Creates a new measure tooltip
   * FIXME bug d'affichage de la tooltip de saisie en cours si on ne termine pas
   * la saisie  !?
   *
   * @param {ol.Map} map - The Map.
   */
  createMeasureTooltip: function(map) {
    if (this.measureTooltipElement) {
      this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
    }
    this.measureTooltipElement = document.createElement("div");
    this.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-measure";
    this.measureTooltip = new Overlay_default({
      element: this.measureTooltipElement,
      stopEvent: false,
      offset: [0, -15],
      positioning: "bottom-center"
    });
    map.addOverlay(this.measureTooltip);
  },
  /**
   * TODO evolution
   * Creates a new help tooltip
   *
   * @param {ol.Map} map - The Map.
   */
  createHelpTooltip: function(map) {
    if (this.helpTooltipElement) {
      this.helpTooltipElement.parentNode.removeChild(this.helpTooltipElement);
    }
    this.helpTooltipElement = document.createElement("div");
    this.helpTooltipElement.className = "tooltip hidden";
    this.helpTooltip = new Overlay_default({
      element: this.helpTooltipElement,
      stopEvent: false,
      offset: [15, 0],
      positioning: "center-left"
    });
    map.addOverlay(this.helpTooltip);
  },
  /**
   * Creates a style for drawing
   *
   * @param {Object} styles - styles.
   */
  createStylingMeasureInteraction: function(styles) {
    this.options.styles = styles || {};
    logger34.trace("style start", this.options.styles.start);
    var startStyleOpts = {
      image: Measures.DEFAULT_POINTER_STYLE,
      fill: Measures.DEFAULT_DRAW_START_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_START_STYLE.getStroke()
    };
    if (this.options.styles.hasOwnProperty("pointer") && this.options.styles.pointer instanceof Image) {
      startStyleOpts.image = this.options.styles.pointer;
    }
    if (this.options.styles.hasOwnProperty("start") && this.options.styles.start instanceof Style_default) {
      if (this.options.styles.start.getFill() != null) {
        startStyleOpts.fill = this.options.styles.start.getFill();
      }
      if (this.options.styles.start.getStroke() != null) {
        startStyleOpts.stroke = this.options.styles.start.getStroke();
      }
    }
    this.options.styles.start = new Style_default(startStyleOpts);
    logger34.trace("style finish", this.options.styles.finish);
    var finishStyleOpts = {
      fill: Measures.DEFAULT_DRAW_FINISH_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_FINISH_STYLE.getStroke()
    };
    if (this.options.styles.hasOwnProperty("finish") && this.options.styles.finish instanceof Style_default) {
      if (this.options.styles.finish.getFill() != null) {
        finishStyleOpts.fill = this.options.styles.finish.getFill();
      }
      if (this.options.styles.finish.getStroke() != null) {
        finishStyleOpts.stroke = this.options.styles.finish.getStroke();
      }
    }
    this.options.styles.finish = new Style_default(finishStyleOpts);
  },
  /**
   * Add the measure interaction
   *
   * @param {String} type - LineString or Polygon.
   */
  addMeasureInteraction: function(type) {
    var map = this.getMap();
    var self2 = this;
    this.measureDraw = new Draw_default({
      source: this.measureSource,
      // condition : permet de gerer la suppression des derniers points saisis
      condition: function(event) {
        if (event.originalEvent.ctrlKey) {
          if (self2.sketch) {
            this.removeLastPoint();
          }
          return false;
        }
        return true;
      },
      type,
      style: this.options.styles.start || Measures.DEFAULT_DRAW_START_STYLE
    });
    this.measureDraw.setProperties({
      name: "Measures",
      source: this
    });
    map.addInteraction(this.measureDraw);
    this.createMeasureTooltip(map);
    this.measureDraw.on("drawstart", (evt) => {
      self2.sketch = evt.feature;
    });
    this.measureDraw.on("drawend", () => {
      if (self2.sketch) {
        var output;
        var tooltipCoord;
        var geom = self2.sketch.getGeometry();
        output = self2.format(geom);
        if (geom.getType() === "LineString") {
          tooltipCoord = geom.getLastCoordinate();
        } else if (geom.getType() === "Polygon") {
          tooltipCoord = geom.getInteriorPoint().getCoordinates();
        } else {
          return;
        }
        self2.measureTooltipElement.innerHTML = output;
        self2.measureTooltip.setPosition(tooltipCoord);
      }
      self2.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-static";
      self2.measureTooltip.setOffset([0, -7]);
      self2.sketch = null;
      self2.measureTooltipElement = null;
      self2.createMeasureTooltip(map);
    });
  },
  /**
   * Init the measure interaction
   */
  initMeasureInteraction: function() {
    var map = this.getMap();
    this.measureSource = new Vector_default();
    this.measureVector = new Vector_default2({
      source: this.measureSource,
      style: this.options.styles.finish || Measures.DEFAULT_DRAW_FINISH_STYLE
    });
    this.measureVector.gpResultLayerId = "measure";
    map.addLayer(this.measureVector);
    map.getControls().forEach(
      (control) => {
        if (control.CLASSNAME === "LayerSwitcher") {
          var layerId = this.measureVector.gpLayerId;
          if (control._layers[layerId].title === layerId) {
            control.addLayer(
              this.measureVector,
              {
                title: this.options.layerDescription.title,
                description: this.options.layerDescription.description
              }
            );
          }
        }
      }
    );
  }
};
var Measures_default = Measures;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ElevationPath/ElevationPathDOM.js
var ElevationPathDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPelevationPath");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //
  /**
   * Show control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowElevationPathPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowElevationPathPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowElevationPathPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-elevation");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Calculer un profil altimÃ©trique");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowElevationPathClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowElevationPathClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ######################### Methods to Panel ######################## //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createElevationPathPanelHeaderElement
   * don't call this._createElevationPathPanelProfilElement
   *
   * @returns {HTMLElement} DOM element
   */
  _createElevationPathPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPelevationPathPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createElevationPathPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  _createDrawingButtonsPluginDiv: function() {
    var div = document.createElement("div");
    div.className = "container-buttons-plugin fr-mx-2w";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createElevationPathPanelHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    if (!CheckDsfr_default()) {
      var divInfo = document.createElement("button");
      divInfo.id = this._addUID("GPelevationPathPanelInfo");
      divInfo.className = "GPpanelInfo gpf-btn gpf-btn-icon-info fr-btn fr-btn--secondary gpf-btn--secondary fr-m-1w";
      divInfo.title = "Informations";
      if (divInfo.addEventListener) {
        divInfo.addEventListener(
          "click",
          function() {
            self2.onOpenElevationPathInfoClick();
          }
        );
      } else if (divInfo.attachEvent) {
        divInfo.attachEvent(
          "onclick",
          function() {
            self2.onOpenElevationPathInfoClick();
          }
        );
      }
      container.appendChild(divInfo);
    }
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    divTitle.innerHTML = "Profil AltimÃ©trique";
    container.appendChild(divTitle);
    var buttonReduce = document.createElement("button");
    buttonReduce.id = this._addUID("GPelevationPathPanelReduce");
    buttonReduce.className = "GPpanelReduce gpf-btn gpf-btn-icon-reduce fr-btn fr-btn--secondary gpf-btn--secondary";
    buttonReduce.title = "Masquer le panneau";
    if (buttonReduce.addEventListener) {
      buttonReduce.addEventListener("click", function(e) {
        if (typeof self2.onReduceElevationPathPanelClick === "function") {
          self2.onReduceElevationPathPanelClick();
        }
      }, false);
    } else if (buttonReduce.attachEvent) {
      buttonReduce.attachEvent("onclick", function(e) {
        if (typeof self2.onReduceElevationPathPanelClick === "function") {
          self2.onReduceElevationPathPanelClick();
        }
      });
    }
    container.appendChild(buttonReduce);
    var buttonClose = document.createElement("button");
    buttonClose.id = this._addUID("GPelevationPathPanelClose");
    buttonClose.className = "GPpanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    buttonClose.title = "Fermer le panneau";
    if (buttonClose.addEventListener) {
      buttonClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowElevationPathPicto")).click();
      }, false);
    } else if (buttonClose.attachEvent) {
      buttonClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowElevationPathPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    buttonClose.appendChild(span);
    container.appendChild(buttonClose);
    return container;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {HTMLElement} DOM element
   */
  _createElevationPathPanelProfilElement: function() {
    var wrapper = document.createElement("div");
    wrapper.className = "GPelevationPathProfilWrapper";
    var div = document.createElement("div");
    div.id = "GPelevationPathProfil";
    wrapper.appendChild(div);
    return wrapper;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createElevationPathWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  /**
   * Create information Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createElevationPathInformationsElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathInformationsContainer");
    if (!CheckDsfr_default()) {
      div.className = "GPelementHidden gpf-hidden";
    }
    var p2 = document.createElement("p");
    p2.className = "GPelevationPathInformations";
    p2.innerHTML = "Aucune information...";
    div.appendChild(p2);
    return div;
  },
  /**
   * Add a information into Panel
   *
   * @param {String} name - name of item
   * @param {String} value - value of item
   * @returns {HTMLElement} DOM element
   */
  _addElevationPathInformationsItem: function(name, value2) {
    var div = document.getElementById(this._addUID("GPelevationPathInformationsContainer"));
    if (div) {
      var p2 = document.createElement("p");
      p2.className = "GPelevationPathInformations";
      var nameEl = document.createElement("span");
      nameEl.innerText = name;
      var valueEl = document.createElement("span");
      valueEl.innerText = value2;
      p2.appendChild(nameEl);
      p2.appendChild(valueEl);
      div.appendChild(p2);
    }
    return div;
  }
};
var ElevationPathDOM_default = ElevationPathDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ElevationPath/ProfileElevationPathDOM.js
var ProfileElevationPathDOM = {
  /**
   * Gets a css property from an element
   *
   * @private
   * @param {HTMLElement} element The element to get the property from
   * @param {String} property The css property
   * @returns {String} The value of the property
   *
   * @see https://stackoverflow.com/questions/7444451/how-to-get-the-actual-rendered-font-when-its-not-defined-in-css
   */
  _getCssProperty: function(element, property) {
    return window.getComputedStyle(element, null).getPropertyValue(property);
  },
  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   *
   * @private
   * @param {String} text The text to be rendered.
   * @param {HTMLElement} container The container of the text
   * @param {String} font The font of the container if known, format: 'weight size familiy'
   * @returns {Number} The width of the text
   *
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  _getTextWidth: function(text, container, font = null) {
    var canvas = (
      /** ts-syntax */
      this.canvas || (this.canvas = document.createElement("canvas"))
    );
    var context = canvas.getContext("2d");
    if (font === null) {
      context.font = `${this._getCssProperty(container, "font-weight")} ${this._getCssProperty(container, "font-size")} ${this._getCssProperty(container, "font-family")}`;
    } else {
      context.font = font;
    }
    var metrics = context.measureText(text);
    return metrics.width;
  },
  /**
   * Converts a data point z to svg y coord
   *
   * @private
   * @param {Object} z The z to convert.
   * @param {Number} pathHeight The height of the path in the svg container in px
   * @param {Number} minGraphZ Min z of the graph
   * @param {Number} pxPerMZ Number of pixels per meter for the z (y) axis
   * @returns {Number} The y svg coordinate of the point
   *
   */
  _dataZToSvgY: function(z3, pathHeight, minGraphZ, pxPerMZ) {
    return pathHeight - (z3 - minGraphZ) * pxPerMZ - 0.5;
  },
  /**
   * Converts a data point dist value to svg x coord
   *
   * @private
   * @param {Number} dist The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The x svg coordinate of the point
   *
   */
  _dataDistToSvgX: function(dist, svgWidth, pathWidth, pxPerMX) {
    return svgWidth - pathWidth + dist * pxPerMX;
  },
  /**
   * Converts a svg x coord to dist value
   *
   * @private
   * @param {Number} svgX The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The dist value
   *
   */
  _svgXToDataDist: function(svgX, svgWidth, pathWidth, pxPerMX) {
    return (svgX + pathWidth - svgWidth) / pxPerMX;
  },
  /**
   * Returns the index of value if it were inserted in sorted (by dist) array of data points.
   *
   * @private
   * @param {Array} array Sorted array of data points (with dist property)
   * @param {Number} value Value to test the index of.
   * @returns {Number} The index the value would have.
   *
   */
  _arrayBisect: function(array, value2) {
    let idx;
    if (array.length === 0) {
      return 0;
    }
    for (idx = 0; idx < array.length; idx++) {
      if (value2 < array[idx].dist) {
        return idx;
      }
    }
    return idx - 1;
  },
  /**
   * Display Profile function used by default : no additonal framework needed.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {HTMLElement} profil container
   */
  displayProfileByDefault: function(data, container, context, className) {
    var self2 = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }
    const style = {
      fontFamily: "Arial",
      strokeColor: "#0B6BA7",
      fillColor: "#00B798",
      focusLineColor: "#F90"
    };
    if (CheckDsfr_default()) {
      style.fontFamily = "Marianne";
      style.strokeColor = "#2F4077";
      style.fillColor = "#2F4077";
      style.focusLineColor = "#639f6a";
    }
    ;
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    const margin = {
      top: 25,
      right: 15,
      bottom: 10,
      left: 10
    };
    var _displayProfileOptions = self2.options.displayProfileOptions;
    var _points = data.points;
    var sortedElev = JSON.parse(JSON.stringify(_points));
    sortedElev.sort(function(e1, e2) {
      return e1.z - e2.z;
    });
    var minZ = sortedElev[0].z;
    var maxZ = sortedElev[sortedElev.length - 1].z;
    var dist = data.distance;
    let distUnit = "m";
    const widgetDiv = document.createElement("div");
    widgetDiv.id = "profileElevationByDefault";
    container.appendChild(widgetDiv);
    var clientWidth = window.getComputedStyle(container).getPropertyValue("width").replace(/px/, "");
    var clientHeight = window.getComputedStyle(container).getPropertyValue("height").replace(/px/, "");
    const widgetHeigth = clientHeight - margin.top - margin.bottom;
    const widgetWidth = clientWidth - margin.left - margin.right;
    const zLabelWidth = 17;
    const zGradWidth = this._getTextWidth(Math.round(maxZ).toLocaleString() + ",88", container, `400 10 ${style.fontFamily}`);
    const xLabelHeight = 17;
    const xGradHeight = 15;
    const minZguideHeigth = 15;
    const minXguideWidth = this._getTextWidth(Math.round(dist).toLocaleString() + ",5", container);
    const minNumXGuides = 1;
    const pathHeight = widgetHeigth - xLabelHeight - xGradHeight;
    const pathWidth = widgetWidth - zLabelWidth - zGradWidth;
    const elevationSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    elevationSvg.id = "profileElevationByDefaultSvg";
    elevationSvg.setAttribute("style", "display: block; margin: auto; overflow: visible;");
    elevationSvg.setAttribute("viewBox", `0 0 ${clientWidth} ${clientHeight}`);
    elevationSvg.setAttribute("width", "100%");
    elevationSvg.setAttribute("height", "100%");
    const maxNumZguides = Math.floor(pathHeight / minZguideHeigth);
    let gradZ;
    if (maxZ === minZ) {
      gradZ = 0.1;
    } else {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10))) / 2;
    }
    let minGraphZ = Math.floor(minZ / gradZ) * gradZ;
    let maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ;
    if (maxGraphZ === maxZ) {
      maxGraphZ += gradZ;
    }
    minGraphZ = Math.round(minGraphZ * 100) / 100;
    maxGraphZ = Math.round(maxGraphZ * 100) / 100;
    let numZguides = Math.round((maxGraphZ - minGraphZ) / gradZ);
    if (numZguides + 1 > maxNumZguides) {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10)));
      minGraphZ = Math.floor(minZ / gradZ) * gradZ;
      maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ;
      if (maxGraphZ === maxZ) {
        maxGraphZ += gradZ;
      }
      minGraphZ = Math.round(minGraphZ * 100) / 100;
      maxGraphZ = Math.round(maxGraphZ * 100) / 100;
      numZguides = Math.floor((maxGraphZ - minGraphZ) / gradZ);
    }
    numZguides = Math.max(Math.round(numZguides), 1);
    const axisZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisZ.setAttribute("class", "profile-z-vertical");
    const guidesZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const gradZyOffsetPx = pathHeight / numZguides;
    let pxPerMZ;
    if (maxZ === minZ) {
      pxPerMZ = pathHeight / 0.2;
    } else {
      pxPerMZ = pathHeight / (maxGraphZ - minGraphZ);
    }
    let gradZtext;
    let yTextTranslation;
    let yStrokeTranslation;
    let gradZstroke;
    let gradZpath;
    let gradZgrad;
    for (let i = 0; i <= numZguides; i++) {
      gradZtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradZtext.setAttribute("class", "profile-z-graduation");
      gradZtext.setAttribute("font-family", style.fontFamily);
      gradZtext.setAttribute("font-size", "10px");
      gradZtext.setAttribute("fill", "#5E5E5E");
      gradZtext.textContent = (Math.round(100 * (minGraphZ + i * gradZ)) / 100).toLocaleString();
      yTextTranslation = pathHeight - i * gradZyOffsetPx;
      gradZtext.setAttribute("transform", `translate(${zLabelWidth + zGradWidth - 8}, ${yTextTranslation + 5})`);
      gradZtext.setAttribute("text-anchor", "end");
      axisZ.appendChild(gradZtext);
      yStrokeTranslation = Math.round(yTextTranslation) - 0.5;
      gradZstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradZpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZpath.setAttribute("cs", "100,100");
      gradZpath.setAttribute("stroke-width", "1");
      if (i !== 0) {
        gradZpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradZpath.setAttribute("stroke-opacity", "1");
      }
      gradZpath.setAttribute("stroke", "#000000");
      gradZpath.setAttribute("fill", "none");
      gradZpath.setAttribute("d", `M${zLabelWidth + zGradWidth},${yStrokeTranslation} L${pathWidth + zLabelWidth + zGradWidth},${yStrokeTranslation}`);
      gradZgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZgrad.setAttribute("cs", "100,100");
      gradZgrad.setAttribute("stroke-width", "1");
      gradZgrad.setAttribute("stroke-opacity", "1");
      gradZgrad.setAttribute("stroke", "#000000");
      gradZgrad.setAttribute("fill", "none");
      gradZgrad.setAttribute("d", `M${zLabelWidth + zGradWidth},${yStrokeTranslation} L${zLabelWidth + zGradWidth + 5},${yStrokeTranslation}`);
      gradZgrad.setAttribute("transform", "translate(-5, 0)");
      gradZstroke.appendChild(gradZgrad);
      gradZstroke.appendChild(gradZpath);
      guidesZ.appendChild(gradZstroke);
    }
    var axisZLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisZLegend.setAttribute("class", "profile-z-legend");
    axisZLegend.setAttribute("font-family", style.fontFamily);
    axisZLegend.setAttribute("font-size", "11px");
    axisZLegend.setAttribute("fill", "#5E5E5E");
    axisZLegend.textContent = "Altitude (m)";
    axisZLegend.setAttribute("transform", `translate(${zLabelWidth - 8}, ${Math.round(pathHeight / 2)}) rotate(-90)`);
    axisZLegend.setAttribute("text-anchor", "middle");
    axisZ.appendChild(axisZLegend);
    elevationSvg.appendChild(axisZ);
    elevationSvg.appendChild(guidesZ);
    if (dist > 2e3) {
      dist /= 1e3;
      distUnit = "km";
    }
    const maxNumXguides = Math.floor(pathWidth / minXguideWidth);
    let gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10))) / 2;
    const maxGraphX = dist;
    let numXguides = Math.floor(maxGraphX / gradX);
    if (numXguides > maxNumXguides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)));
      numXguides = Math.floor(maxGraphX / gradX);
    } else if (numXguides < minNumXGuides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)) - 1);
      numXguides = Math.floor(maxGraphX / gradX);
    }
    numXguides = Math.max(numXguides, 1);
    const lastGradX = gradX * numXguides;
    const axisX = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisX.setAttribute("class", "profile-x-vertical");
    const guidesX = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const pxPerMX = pathWidth / maxGraphX;
    const xOffset = (maxGraphX - lastGradX) * pxPerMX;
    const gradXxOffsetPx = Math.round((pathWidth - xOffset) / numXguides);
    let gradXtext;
    let xTextTranslation;
    let xStrokeTranslation;
    let gradXstroke;
    let gradXpath;
    let gradXgrad;
    for (let i = 0; i <= numXguides + 1; i++) {
      gradXtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradXtext.setAttribute("class", "profile-x-graduation");
      gradXtext.setAttribute("font-family", style.fontFamily);
      gradXtext.setAttribute("font-size", "10px");
      gradXtext.setAttribute("fill", "#5E5E5E");
      if (i !== numXguides + 1) {
        gradXtext.textContent = (Math.round(100 * i * gradX) / 100).toLocaleString();
      }
      xTextTranslation = zLabelWidth + zGradWidth + i * gradXxOffsetPx;
      if (i === numXguides + 1) {
        xTextTranslation = zLabelWidth + zGradWidth + pathWidth;
      }
      gradXtext.setAttribute("transform", `translate(${xTextTranslation}, ${pathHeight + xGradHeight + 5})`);
      gradXtext.setAttribute("text-anchor", "middle");
      axisX.appendChild(gradXtext);
      xStrokeTranslation = xTextTranslation - 0.5;
      gradXstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradXpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXpath.setAttribute("cs", "100,100");
      gradXpath.setAttribute("stroke-width", "1");
      if (i !== 0) {
        gradXpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradXpath.setAttribute("stroke-opacity", "1");
      }
      gradXpath.setAttribute("stroke", "#000000");
      gradXpath.setAttribute("fill", "none");
      gradXpath.setAttribute("d", `M${xStrokeTranslation},${pathHeight} L${xStrokeTranslation},0`);
      gradXgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXgrad.setAttribute("cs", "100,100");
      gradXgrad.setAttribute("stroke-width", "1");
      gradXgrad.setAttribute("stroke-opacity", "1");
      gradXgrad.setAttribute("stroke", "#000000");
      gradXgrad.setAttribute("fill", "none");
      gradXgrad.setAttribute("d", `M${xStrokeTranslation},${pathHeight} L${xStrokeTranslation},${pathHeight - 5}`);
      gradXgrad.setAttribute("transform", "translate(0, 5)");
      gradXstroke.appendChild(gradXgrad);
      gradXstroke.appendChild(gradXpath);
      guidesX.appendChild(gradXstroke);
    }
    var axisXLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisXLegend.setAttribute("class", "profile-x-legend");
    axisXLegend.setAttribute("font-family", style.fontFamily);
    axisXLegend.setAttribute("font-size", "11px");
    axisXLegend.setAttribute("fill", "#5E5E5E");
    axisXLegend.textContent = `Distance (${distUnit})`;
    axisXLegend.setAttribute("transform", `translate(${zLabelWidth + zGradWidth + pathWidth / 2}, ${pathHeight + xGradHeight + xLabelHeight + 3})`);
    axisXLegend.setAttribute("text-anchor", "middle");
    axisX.appendChild(axisXLegend);
    elevationSvg.appendChild(axisX);
    elevationSvg.appendChild(guidesX);
    const elevationPathG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    let factor = 1;
    if (distUnit === "km") {
      factor = 1e3;
    }
    let pointX = this._dataDistToSvgX(_points[0].dist / factor, widgetWidth, pathWidth, pxPerMX);
    let pointY = this._dataZToSvgY(_points[0].z, pathHeight, minGraphZ, pxPerMZ);
    let pathD = `M${pointX},${pointY}`;
    for (let i = 1; i < _points.length; i++) {
      pointX = this._dataDistToSvgX(_points[i].dist / factor, widgetWidth, pathWidth, pxPerMX);
      pointY = this._dataZToSvgY(_points[i].z, pathHeight, minGraphZ, pxPerMZ);
      pathD += ` L${pointX},${pointY}`;
    }
    const pathPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathPath.setAttribute("cs", "100,100");
    pathPath.setAttribute("stroke-width", "1");
    pathPath.setAttribute("stroke-opacity", "1");
    pathPath.setAttribute("stroke", style.strokeColor);
    pathPath.setAttribute("fill", "none");
    pathPath.setAttribute("d", pathD);
    pathD += ` L${pointX},${pathHeight}`;
    pathD += ` L${widgetWidth - pathWidth},${pathHeight}`;
    const pathFill = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathFill.setAttribute("cs", "100,100");
    pathFill.setAttribute("stroke-width", "1");
    pathFill.setAttribute("stroke-opacity", "0");
    pathFill.setAttribute("stroke", "#000000");
    pathFill.setAttribute("fill", style.fillColor);
    pathFill.setAttribute("fill-opacity", "0.2");
    pathFill.setAttribute("d", pathD);
    elevationPathG.appendChild(pathPath);
    elevationPathG.appendChild(pathFill);
    elevationSvg.appendChild(elevationPathG);
    const dynamicsG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const pathRectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    pathRectangle.setAttribute("width", pathWidth);
    pathRectangle.setAttribute("height", pathHeight);
    pathRectangle.setAttribute("transform", `translate(${widgetWidth - pathWidth},0)`);
    pathRectangle.setAttribute("visibility", "hidden");
    pathRectangle.setAttribute("pointer-events", "all");
    const sortedDist = JSON.parse(JSON.stringify(_points));
    sortedDist.sort(function(e1, e2) {
      return e1.dist - e2.dist;
    });
    const focusLineX = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineX.setAttribute("id", "focusLineX");
    focusLineX.setAttribute("class", "focusLine-default");
    focusLineX.setAttribute("fill", "none");
    focusLineX.setAttribute("stroke", style.focusLineColor);
    focusLineX.setAttribute("stroke-width", "0.5px");
    focusLineX.setAttribute("visibility", "hidden");
    const focusLineY = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineY.setAttribute("id", "focusLineY");
    focusLineY.setAttribute("class", "focusLine-default");
    focusLineY.setAttribute("fill", "none");
    focusLineY.setAttribute("stroke", style.focusLineColor);
    focusLineY.setAttribute("stroke-width", "0.5px");
    focusLineY.setAttribute("visibility", "hidden");
    const focusCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    focusCircle.setAttribute("id", "focusCircle");
    focusCircle.setAttribute("r", 4);
    focusCircle.setAttribute("class", "circle-default focusCircle-default");
    focusCircle.setAttribute("fill", style.focusLineColor);
    focusCircle.setAttribute("visibility", "hidden");
    dynamicsG.appendChild(focusCircle);
    dynamicsG.appendChild(focusLineX);
    dynamicsG.appendChild(focusLineY);
    const tooltipDiv = document.createElementNS("http://www.w3.org/2000/svg", "text");
    const altiSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    const slopeSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    const coordsSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tooltipDiv.setAttribute("style", `text-align:center; max-width:220px; font-size:10px; color:#000000; font-family:${style.fontFamily}; z-index:50;`);
    tooltipDiv.style.pointerEvents = "none";
    tooltipDiv.style.position = "fixed";
    tooltipDiv.setAttribute("class", "tooltipInit");
    tooltipDiv.setAttribute("text-anchor", "middle");
    widgetDiv.appendChild(tooltipDiv);
    altiSpan.setAttribute("class", "altiPathValue");
    altiSpan.setAttribute("x", "0");
    altiSpan.setAttribute("dy", "-.7em");
    slopeSpan.setAttribute("class", "altiPathValue");
    slopeSpan.setAttribute("x", "0");
    slopeSpan.setAttribute("dy", "1em");
    coordsSpan.setAttribute("class", "altiPathCoords");
    coordsSpan.setAttribute("x", "0");
    coordsSpan.setAttribute("dy", "1em");
    tooltipDiv.appendChild(altiSpan);
    if (_displayProfileOptions.currentSlope) {
      tooltipDiv.appendChild(slopeSpan);
    }
    tooltipDiv.appendChild(coordsSpan);
    const tooltipG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    dynamicsG.appendChild(tooltipG);
    const tooltipBubble = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubble.setAttribute("cs", "100,100");
    tooltipBubble.setAttribute("fill", "#FFFFFF");
    tooltipBubble.setAttribute("stroke", "#CCCCCC");
    tooltipBubble.setAttribute("fill-opacity", "0.8");
    tooltipBubble.setAttribute("stroke-width", "1");
    tooltipBubble.setAttribute("stroke-opacity", "1");
    const tooltipBubbleShadow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubbleShadow.setAttribute("cs", "100,100");
    tooltipBubbleShadow.setAttribute("fill", "#FFFFFF");
    tooltipBubbleShadow.setAttribute("stroke", "#000000");
    tooltipBubbleShadow.setAttribute("fill-opacity", "0");
    tooltipBubbleShadow.setAttribute("stroke-width", "1");
    tooltipBubbleShadow.setAttribute("stroke-opacity", "0.4");
    tooltipBubbleShadow.setAttribute("transform", "translate(1,1)");
    tooltipG.appendChild(tooltipBubbleShadow);
    tooltipG.appendChild(tooltipBubble);
    tooltipG.appendChild(tooltipDiv);
    tooltipG.setAttribute("class", "tooltipInit");
    tooltipG.style.pointerEvents = "none";
    function onMouseOver() {
      focusLineX.setAttribute("visibility", "visible");
      focusLineY.setAttribute("visibility", "visible");
      focusCircle.setAttribute("visibility", "visible");
      className.__createProfileMarker(self2, _points[0]);
      tooltipDiv.classList.remove("tooltipInit");
      tooltipG.classList.remove("tooltipInit");
      tooltipDiv.classList.remove("tooltipFadeOut");
      tooltipG.classList.remove("tooltipFadeOut");
      tooltipDiv.classList.add("tooltipFadeIn");
      tooltipG.classList.add("tooltipFadeIn");
    }
    function onMouseOut() {
      focusLineX.setAttribute("visibility", "hidden");
      focusLineY.setAttribute("visibility", "hidden");
      focusCircle.setAttribute("visibility", "hidden");
      className.__removeProfileMarker(self2);
      tooltipDiv.classList.remove("tooltipFadeIn");
      tooltipG.classList.remove("tooltipFadeIn");
      tooltipDiv.classList.add("tooltipFadeOut");
      tooltipG.classList.add("tooltipFadeOut");
    }
    function onMouseMove(e) {
      const mousePoint = elevationSvg.createSVGPoint();
      mousePoint.x = e.clientX;
      mousePoint.y = e.clientY;
      const svgMousePoint = mousePoint.matrixTransform(elevationSvg.getScreenCTM().inverse());
      const mouseDist = this._svgXToDataDist(svgMousePoint.x, widgetWidth, pathWidth, pxPerMX) * factor;
      const distIndex = Math.max(1, this._arrayBisect(sortedDist, mouseDist));
      const d0 = _points[distIndex - 1];
      const d1 = _points[distIndex];
      let d4 = d0;
      if (mouseDist - d0.dist > d1.dist - mouseDist) {
        d4 = d1;
      }
      const focusX = this._dataDistToSvgX(d4.dist / factor, widgetWidth, pathWidth, pxPerMX);
      const focusY = this._dataZToSvgY(d4.z, pathHeight, minGraphZ, pxPerMZ);
      focusCircle.setAttribute("cx", focusX);
      focusCircle.setAttribute("cy", focusY);
      focusLineX.setAttribute("x1", focusX);
      focusLineX.setAttribute("y1", pathHeight);
      focusLineX.setAttribute("x2", focusX);
      focusLineX.setAttribute("y2", 0);
      focusLineY.setAttribute("x1", zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y1", focusY);
      focusLineY.setAttribute("x2", pathWidth + zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y2", focusY);
      className.__updateProfileMarker(self2, d4);
      const altiSpanTxt = `Altitude : ${d4.z.toLocaleString()} m`;
      const slopeSpanTxt = `Pente : ${d4.slope} %`;
      const coordsSpanTxt = `(lat : ${d4.lat.toLocaleString()} / lon : ${d4.lon.toLocaleString()})`;
      altiSpan.innerHTML = altiSpanTxt;
      slopeSpan.innerHTML = slopeSpanTxt;
      coordsSpan.innerHTML = coordsSpanTxt;
      const tooltipTextWidth = Math.max(
        this._getTextWidth(coordsSpanTxt, coordsSpan),
        this._getTextWidth(altiSpanTxt, altiSpan)
      );
      let toolTipBubbleD;
      if (d4.dist > dist * factor / 2) {
        toolTipBubbleD = `M -0.5 -0.5 l -6 6 l 0 16 l -${tooltipTextWidth + 10} 0 l 0 -44 l ${tooltipTextWidth + 10} 0 l 0 16 l 6 6`;
        tooltipDiv.setAttribute("transform", `translate(${-(tooltipTextWidth / 2 + 12)},0)`);
      } else if (d4.dist <= dist * factor / 2) {
        toolTipBubbleD = `M -0.5 -0.5 l 6 6 l 0 16 l ${tooltipTextWidth + 10} 0 l 0 -44 l -${tooltipTextWidth + 10} 0 l 0 16 l -6 6`;
        tooltipDiv.setAttribute("transform", `translate(${tooltipTextWidth / 2 + 12},0)`);
      }
      tooltipBubble.setAttribute("d", toolTipBubbleD);
      tooltipBubbleShadow.setAttribute("d", toolTipBubbleD);
      tooltipG.setAttribute("transform", `translate(${focusX},${focusY})`);
      tooltipG.style.transform = `translate(${focusX}px,${focusY}px)`;
    }
    pathRectangle.addEventListener("pointerover", onMouseOver);
    pathRectangle.addEventListener("pointerout", onMouseOut);
    pathRectangle.addEventListener("pointermove", onMouseMove.bind(this));
    dynamicsG.appendChild(pathRectangle);
    elevationSvg.appendChild(dynamicsG);
    widgetDiv.appendChild(elevationSvg);
    return container;
  },
  /**
   * Display Profile without graphical rendering (raw service response)
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {HTMLElement} profil container
   */
  displayProfileRaw: function(data, container, context, className) {
    if (!container) {
      return;
    }
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var _points = data && data.points ? data.points : {};
    var div = document.createElement("textarea");
    div.id = "profilElevationResults";
    div.rows = 10;
    div.cols = 50;
    div.style.width = "100%";
    div.innerHTML = JSON.stringify(_points, void 0, 4);
    div.addEventListener("mouseover", function(e) {
      className.__customRawProfileMouseOverEvent(context, e);
    });
    container.appendChild(div);
    return container;
  },
  /**
   * Display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {HTMLElement} profil container
   */
  displayProfileLibD3: function(data, container, context, className) {
    var self2 = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var _points = data.points;
    if (data.distance > 2e3) {
      data.unit = "km";
      for (let i = 0; i < _points.length; i++) {
        _points[i].dist /= 1e3;
      }
    }
    var _displayProfileOptions = self2.options.displayProfileOptions;
    var margin = {
      top: 20,
      right: 20,
      bottom: 30,
      left: 40
    };
    var widgetWidth = window.getComputedStyle(container).getPropertyValue("width");
    var widgetHeigth = window.getComputedStyle(container).getPropertyValue("height");
    var width = widgetWidth.replace(/px/, "") - margin.left - margin.right;
    var height = widgetHeigth.replace(/px/, "") - margin.top - margin.bottom;
    var x3 = d3.scale.linear().range([0, width]);
    var y3 = d3.scale.linear().range([height, 0]);
    var xAxis = d3.svg.axis().scale(x3).orient("bottom").ticks(5);
    var yAxis = d3.svg.axis().scale(y3).orient("left").ticks(5);
    var line = d3.svg.line().interpolate("basis").x(function(d4) {
      return x3(d4.dist);
    }).y(function(d4) {
      return y3(d4.z);
    });
    var area = d3.svg.area().interpolate("basis").x(function(d4) {
      return x3(d4.dist);
    }).y0(height).y1(function(d4) {
      return y3(d4.z);
    });
    var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var xDomain = d3.extent(_points, function(d4) {
      return d4.dist;
    });
    x3.domain(xDomain);
    var yDomain = [
      0,
      d3.max(_points, function(d4) {
        return d4.z;
      })
    ];
    y3.domain(yDomain);
    svg.append("path").datum(_points).attr("class", "area-d3").attr("d", area);
    svg.append("g").attr("class", "x axis-d3").attr("transform", "translate(0," + height + ")").call(xAxis).append("text").attr("y", -15).attr("dy", ".71em").attr("x", width).text("Distance (" + data.unit + ")");
    svg.append("g").attr("class", "y axis-d3").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").text("Altitude (m)");
    svg.append("g").attr("class", "grid-d3 vertical").attr("transform", "translate(0," + height + ")").call(
      xAxis.orient("bottom").tickSize(-height, 0, 0).tickFormat("")
    );
    svg.append("g").attr("class", "grid-d3 horizontal").call(
      yAxis.orient("left").tickSize(-width, 0, 0).tickFormat("")
    );
    svg.append("path").datum(_points).attr("class", "line-d3").attr("d", line);
    svg.selectAll("circle").data(_points).enter().append("circle").attr("cx", function(d4) {
      return x3(d4.dist);
    }).attr("cy", function(d4) {
      return y3(d4.z);
    }).attr("r", 0).attr("class", "circle-d3");
    var focus = svg.append("g").style("display", "none");
    focus.append("line").attr("id", "focusLineX").attr("class", "focusLine-d3");
    focus.append("line").attr("id", "focusLineY").attr("class", "focusLine-d3");
    focus.append("circle").attr("id", "focusCircle").attr("r", 4).attr("class", "circle-d3 focusCircle-d3");
    var div = d3.select(container).append("div").attr("class", "tooltip-d3").style("opacity", 0);
    var bisectDist = d3.bisector(function(d4) {
      return d4.dist;
    }).left;
    svg.append("rect").attr("class", "overlay-d3").attr("width", width).attr("height", height).on("mouseover", function() {
      focus.style("display", null);
      className.__createProfileMarker(self2, _points[0]);
    }).on("mouseout", function() {
      focus.style("display", "none");
      className.__removeProfileMarker(self2);
      div.transition().duration(500).style("opacity", 0);
    }).on("mousemove", function() {
      var m2 = d3.mouse(this);
      var distance = x3.invert(m2[0]);
      var i = Math.max(1, bisectDist(_points, distance));
      var d0 = _points[i - 1];
      var d1 = _points[i];
      var d4 = distance - d0[0] > d1[0] - distance ? d1 : d0;
      var xc = x3(d4.dist);
      var yc = y3(d4.z);
      focus.select("#focusCircle").attr("cx", xc).attr("cy", yc);
      focus.select("#focusLineX").attr("x1", xc).attr("y1", y3(yDomain[0])).attr("x2", xc).attr("y2", y3(yDomain[1]));
      focus.select("#focusLineY").attr("x1", x3(xDomain[0])).attr("y1", yc).attr("x2", x3(xDomain[1])).attr("y2", yc);
      className.__updateProfileMarker(self2, d4);
      div.transition().duration(200).style("opacity", 0.9);
      var _message = "";
      _message += " Altitude : " + d4.z + " m";
      if (_displayProfileOptions.currentSlope) {
        _message += "<br/> Pente : " + d4.slope + " %";
      }
      _message += "<br/> (Lat : " + d4.lat + "/ Lon : " + d4.lon + ")";
      div.html(_message).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 28 + "px");
    });
    return svg;
  },
  /**
   * Display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {HTMLElement} profil container
   */
  displayProfileLibAmCharts: function(data, container, context, className) {
    var self2 = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }
    var _points = data.points;
    var ballonText = "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/>";
    var currentSlope = self2.options.displayProfileOptions.currentSlope;
    if (currentSlope) {
      ballonText += "<span class='altiPathValue'>Pente : [[slope]] %</span><br/>";
    }
    ballonText += "<span class='altiPathCoords'>(Lat: [[lat]] / Lon:[[lon]])</span>";
    AmCharts.addInitHandler(function() {
    });
    if (data.distance > 2e3) {
      data.unit = "km";
      for (let i = 0; i < _points.length; i++) {
        _points[i].dist /= 1e3;
      }
    }
    for (let i = 0; i < _points.length; i++) {
      var dist = _points[i].dist;
      var coeffArrond = 100;
      if (dist > 100) {
        coeffArrond = 1;
      } else if (dist > 10) {
        coeffArrond = 10;
      }
      dist = Math.round(dist * coeffArrond) / coeffArrond;
      _points[i].dist = dist;
    }
    var settings = {
      type: "serial",
      pathToImages: "http://cdn.amcharts.com/lib/3/images/",
      categoryField: "dist",
      autoMarginOffset: 0,
      marginRight: 10,
      marginTop: 10,
      startDuration: 0,
      color: "#5E5E5E",
      fontSize: 8,
      theme: "light",
      thousandsSeparator: "",
      numberFormatter: {
        precision: -1,
        decimalSeparator: ",",
        thousandsSeparator: " "
      },
      categoryAxis: {
        color: "#5E5E5E",
        gridPosition: "start",
        minHorizontalGap: 40,
        tickPosition: "start",
        title: "Distance (" + data.unit + ")",
        titleColor: "#5E5E5E",
        labelOffset: 0,
        startOnAxis: true
      },
      chartCursor: {
        animationDuration: 0,
        bulletsEnabled: true,
        bulletSize: 10,
        categoryBalloonEnabled: false,
        cursorColor: "#F90",
        graphBulletAlpha: 1,
        graphBulletSize: 1,
        zoomable: false
      },
      trendLines: [],
      graphs: [{
        balloonColor: "#CCCCCC",
        balloonText: ballonText,
        bullet: "round",
        bulletAlpha: 0,
        bulletBorderColor: "#FFF",
        bulletBorderThickness: 2,
        bulletColor: "#F90",
        bulletSize: 6,
        hidden: false,
        id: "AmGraph-1",
        fillAlphas: 0.4,
        fillColors: "#C77A04",
        lineAlpha: 1,
        lineColor: "#C77A04",
        lineThickness: 1,
        title: "Altitude",
        valueField: "z"
      }],
      guides: [],
      valueAxes: [{
        id: "ValueAxis-1",
        minVerticalGap: 20,
        title: "Altitude (m)"
      }],
      balloon: {
        borderColor: "#CCCCCC",
        borderThickness: 1,
        fillColor: "#FFFFFF",
        showBullet: true
      },
      titles: [],
      allLabels: [],
      dataProvider: _points
    };
    var _containerProfile = AmCharts.makeChart(container, settings);
    _containerProfile.addListener("changed", function(e) {
      var obj = e.chart.dataProvider[e.index];
      className.__updateProfileMarker(self2, obj);
    });
    return _containerProfile;
  }
};
var ProfileElevationPathDOM_default = ProfileElevationPathDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ElevationPath/ElevationPath.js
var logger35 = LoggerByDefault_default2.getLogger("elevationpath");
var _ElevationPath = class _ElevationPath extends Control_default2 {
  /**
   * @constructor
  * @param {Object} options - options for function call.
  * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {String} [options.apiKey] - API key for services call (isocurve and autocomplete services). The key "calcul" is used by default.
  * @param {Boolean} [options.active = false] - specify if control should be actived at startup. Default is false.
  * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
  * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link packages/Controls/Export/Export.default}
  * @param {Object} [options.elevationOptions = {}] - elevation path service options. See {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~getAltitude Gp.Services.getAltitude()} for available options
  * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
  * @param {String} [options.layerDescription.title = "Profil altimÃ©trique"] - Layer title to be displayed in LayerSwitcher
  * @param {String} [options.layerDescription.description = "Mon profil altimÃ©trique"] - Layer description to be displayed in LayerSwitcher
  * @param {Object} [options.stylesOptions] - styles management
  * @param {Object} [options.stylesOptions.marker = {}] - styles management of marker displayed on map when the user follows the elevation path. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object
  * @param {Object} [options.stylesOptions.draw = {}] - styles used when drawing. Specified with following properties.
  * @param {Object} [options.stylesOptions.draw.pointer = {}] - Style for mouse pointer when drawing the line. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
  * @param {Object} [options.stylesOptions.draw.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
  * @param {Object} [options.stylesOptions.draw.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
  * @param {Object} [options.displayProfileOptions = {}] - profile options.
  * @param {Boolean} [options.displayProfileOptions.totalDistance = true] - display the total distance of the path
  * @param {Boolean} [options.displayProfileOptions.greaterSlope = true] - display the greater slope into the graph
  * @param {Boolean} [options.displayProfileOptions.meanSlope = true] -  display the mean slope into the graph
  * @param {Boolean} [options.displayProfileOptions.ascendingElevation = true] -  display the ascending elevation into the graph
  * @param {Boolean} [options.displayProfileOptions.descendingElevation = true] -  display the descending elevation into the graph
  * @param {Boolean} [options.displayProfileOptions.currentSlope = true] -  display current slope value on profile mouseover
  * @param {Function} [options.displayProfileOptions.apply] - function to display profile if you want to cutomise it. By default, ([DISPLAY_PROFILE_BY_DEFAULT()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_BY_DEFAULT)) is used. Helper functions to use with D3 ([DISPLAY_PROFILE_LIB_D3()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_D3)) or AmCharts ([DISPLAY_PROFILE_LIB_AMCHARTS()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_AMCHARTS)) frameworks are also provided. You may also provide your own function.
  * @param {Object} [options.displayProfileOptions.target] - DOM container to use to display the profile.
  * @fires elevationpath:drawstart
  * @fires elevationpath:drawend
  * @fires elevationpath:compute
  * @fires export:compute
  * @example
  *
  * var measure = new ol.control.ElevationPath({
  *    export : false,
  *    stylesOptions : {
  *     draw : {
  *       finish : new ol.style.Stroke({
  *            color : "rgba(0, 0, 0, 0.5)",
  *            width : 2
  *       })
  *     },
  *    }
  *    displayProfileOptions : {
  *       apply : ol.control.ElevationPath.DISPLAY_PROFILE_RAW,
  *    }
  * });
  *
  * // if you want to pluggued the control Export with options :
  * var measure = new ol.control.ElevationPath({
  *    export : {
  *      name : "export",
  *      format : "geojson",
  *      title : "Exporter",
  *      menu : false
  *    }
  * });
  *
  * Exemples :
  * - displayProfileOptions.apply : null
  * - displayProfileOptions.apply : function (elevations, container, context) {  // do some stuff... }
  * - displayProfileOptions.apply : ol.control.ElevationPath.DISPLAY_PROFILE_{LIB_AMCHARTS | LIB_D3 | RAW}
  *
   */
  constructor(options) {
    logger35.trace("ElevationPath()");
    options = options || {};
    super(options);
    if (!(this instanceof _ElevationPath)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "ElevationPath";
    this._uid = options.id || SelectorID_default.generate();
    this._showContainer = null;
    this._pictoButton = null;
    this._panelContainer = null;
    this._profileContainer = null;
    this._waitingContainer = null;
    this._infoContainer = null;
    this._timerHdlr = null;
    this._drawStyleStart = null;
    this._drawStyleFinish = null;
    this._markerStyle = null;
    this._profile = null;
    this._data = {};
    this._measureSource = null;
    this._measureVector = null;
    this._measureDraw = null;
    this._lastSketch = null;
    this._currentSketch = null;
    this._marker = null;
    this._initialize(options);
    this._container = this._initializeContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * suppression du marker
   *
   * @param {Object} context - context
   *
   * @private
   */
  static __removeProfileMarker(context) {
    var self2 = context;
    if (self2._marker) {
      self2._measureSource.removeFeature(self2._marker);
      self2._marker = null;
    }
  }
  /**
   * suppression du marker
   *
   * @param {Object} context - context
   * @param {Object} d - d
   *
   * @private
   */
  static __createProfileMarker(context, d4) {
    var self2 = context;
    if (self2._marker) {
      self2._measureSource.removeFeature(self2._marker);
      self2._marker = null;
    }
    var map = self2.getMap();
    var proj = map.getView().getProjection();
    var _coordinate = transform([d4.lon, d4.lat], "EPSG:4326", proj);
    var _coordinateProj = self2._measureSource.getFeatures()[0].getGeometry().getClosestPoint(_coordinate);
    var _geometry = new Point_default(_coordinateProj);
    self2._marker = new Feature_default({
      geometry: _geometry
    });
    logger35.trace(_geometry);
    self2._marker.setStyle(self2._markerStyle);
    self2._measureSource.addFeature(self2._marker);
  }
  /**
   * mise Ã  jour du marker
   *
   * @param {Object} context - context
   * @param {Object} d - data
   *
   * @private
   */
  static __updateProfileMarker(context, d4) {
    var self2 = context;
    _ElevationPath.__removeProfileMarker(self2);
    _ElevationPath.__createProfileMarker(self2, d4);
  }
  /**
   * TODO : customisation possible d'une opÃ©ration sur le profil
   *
   * @param {Object} context - context
   * @param {Object} d - data
   *
   * @private
   */
  static __customRawProfileOperation(context, d4) {
    logger35.log("__customRawProfileOperation");
    var self2 = context;
    var _pts = d4.points;
    var _proj = self2.getMap().getView().getProjection();
    for (var i = 0; i < _pts.length; i++) {
      var obj = _pts[i];
      var _coordinate = transform([obj.lon, obj.lat], "EPSG:4326", _proj);
      var _geometry = new Point_default(_coordinate);
      self2._marker = new Feature_default({
        geometry: _geometry
      });
      logger35.trace(_geometry);
      var styles = _ElevationPath.DEFAULT_STYLES.RESULTS;
      var _image = new Circle_default2({
        radius: styles.imageRadius,
        stroke: new Stroke_default({
          color: styles.imageStrokeColor,
          width: styles.imageStrokeWidth
        }),
        fill: new Fill_default({
          color: styles.imageFillColor
        })
      });
      self2._marker.setStyle(new Style_default({
        image: _image
      }));
      self2._measureSource.addFeature(self2._marker);
    }
  }
  /**
   * TODO : customisation possible d'une opÃ©ration sur le profil
   * Ex. Methode appÃ©lÃ©e dans le DOM : ProfileElevationPathDOM
   *
   * @param {Object} context - context
   * @param {Object} e - event
   * @private
   */
  static __customRawProfileMouseOverEvent(context, e) {
    logger35.log("__customRawProfileMouseOverEvent", context, e);
  }
  /**
   * display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
   *
   * @param {Object} data - collection elevations
   * @param {HTMLElement} container - container
   * @param {Object} context - this control object
   */
  static DISPLAY_PROFILE_LIB_AMCHARTS(data, container, context) {
    logger35.trace("ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS");
    if (typeof AmCharts === "undefined") {
      logger35.log("Lib. AmCharts is not loaded !");
      return;
    }
    var profile = ProfileElevationPathDOM_default.displayProfileLibAmCharts(data, container, context, _ElevationPath);
    if (profile) {
      this._profile = profile;
    }
  }
  /**
   * display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */
  static DISPLAY_PROFILE_LIB_D3(data, container, context) {
    logger35.trace("ElevationPath.DISPLAY_PROFILE_LIB_D3");
    if (typeof d3 === "undefined") {
      logger35.log("Lib. D3 is not loaded !");
      return;
    }
    var profile = ProfileElevationPathDOM_default.displayProfileLibD3(data, container, context, _ElevationPath);
    if (profile) {
      this._profile = profile;
    }
  }
  /**
   * display Profile without graphical rendering (raw service response)
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */
  static DISPLAY_PROFILE_RAW(data, container, context) {
    logger35.trace("ElevationPath.DISPLAY_PROFILE_RAW");
    var profile = ProfileElevationPathDOM_default.displayProfileRaw(data, container, context, _ElevationPath);
    if (profile) {
      this._profile = profile;
    }
  }
  /**
   * Display Profile function used by default : no additonal framework needed.
   *
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   */
  static DISPLAY_PROFILE_BY_DEFAULT(data, container, context) {
    logger35.trace("ElevationPath.DISPLAY_PROFILE_BY_DEFAULT");
    var profile = ProfileElevationPathDOM_default.displayProfileByDefault(data, container, context, _ElevationPath);
    if (profile) {
      this._profile = profile;
    }
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Attach control to map. Overloaded ol.control.Control.setMap() method.
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    logger35.trace("ElevationPath::setMap");
    if (map) {
      if (this.options.active) {
        if (this._profile === null) {
          this._panelContainer.style.display = "none";
        }
        this._initMeasureInteraction(map);
        this._addMeasureInteraction(map);
      }
      if (!this.options.target && !this.options.position) {
        MeasureToolBox_default.add(map, this);
      }
      if (this.options.export) {
        var opts = Helper_default2.assign({ control: this }, this.options.export);
        this.export = new Export_default(opts);
        this.export.render();
        var self2 = this;
        this.export.on("button:clicked", (e) => {
          self2.dispatchEvent({
            type: "export:compute",
            content: e.content
          });
        });
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Returns true if widget is actived (drawing),
   * false otherwise
   *
   * @returns {Boolean} active - true or false
   */
  getActive() {
    logger35.trace("ElevationPath::getActive");
    return this.options.active;
  }
  /**
   * Actived widget drawing or not
   *
   * @param {Boolean} active - true / false
   */
  setActive(active) {
    logger35.trace("ElevationPath::setActive");
    this.options.active = active;
  }
  /**
   * Get elevation data
   *
   * @returns {Object} data - elevations
   * @example
   * {
   *        type // "elevationpath"
   *        greaterSlope // pente max
   *        meanSlope  // pente moyenne
   *        distancePlus // distance cumulÃ©e positive
   *        distanceMinus // distance cumulÃ©e nÃ©gative
   *        ascendingElevation // dÃ©nivelÃ© cumulÃ©e positive
   *        descendingElevation // dÃ©nivelÃ© cumulÃ©e nÃ©gative
   *        altMin // altitude min
   *        altMax // altitude max
   *        distance // distance totale
   *        unit // unitÃ© des mesures de distance
   *        points // elevations
   *   }
   */
  getData() {
    return Helper_default2.assign({
      type: "elevationpath"
    }, this._data);
  }
  /**
   * Set profile data
   *
   * @param {*} data - elevations
   * @example
   * {
   *        greaterSlope // pente max
   *        meanSlope  // pente moyenne
   *        distancePlus // distance cumulÃ©e positive
   *        distanceMinus // distance cumulÃ©e nÃ©gative
   *        ascendingElevation // dÃ©nivelÃ© cumulÃ©e positive
   *        descendingElevation // dÃ©nivelÃ© cumulÃ©e nÃ©gative
   *        altMin // altitude min
   *        altMax // altitude max
   *        distance // distance totale
   *        unit // unitÃ© des mesures de distance
   *        points // elevations
   * }
   */
  setData(data) {
    this._data = data;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  /**
   * Get layer
   *
   * @returns {VectorLayer} layer
   */
  getLayer() {
    return this._measureVector;
  }
  /**
   * Set layer
   *
   * @param {VectorLayer} layer - ol.layer.Vector profil layer
   */
  setLayer(layer) {
    if (!layer) {
      this._measureVector = null;
      return;
    }
    if (!(layer instanceof Vector_default2)) {
      logger35.log("no valid layer given for hosting drawn features.");
      return;
    }
    layer.setStyle(this._drawStyleFinish);
    this._measureVector = layer;
    this._measureSource = layer.getSource();
  }
  /**
   * Get vector layer
   *
   * @returns {String} geojson - GeoJSON format layer
   */
  getGeoJSON() {
    var features = this._measureVector.getSource().getFeatures();
    var Format = new GeoJSON_default2({
      defaultStyle: this._drawStyleFinish
    });
    var geojson = Format.writeFeatures(features, {
      dataProjection: "EPSG:4326",
      featureProjection: "EPSG:3857"
    });
    return geojson;
  }
  /**
   * Get default style
   *
   * @returns {Style} style
   */
  getStyle() {
    return this._drawStyleFinish;
  }
  /**
   * clean
   * @param {Boolean} remove - remove layer
   */
  clean(remove) {
    logger35.trace("ElevationPath::clean");
    var map = this.getMap();
    this._panelContainer.style.display = "none";
    this._pictoButton.setAttribute("aria-pressed", false);
    this._removeProfile();
    this._removeMeasureInteraction(map, typeof remove !== "undefined" ? remove : false);
    this.setLayer();
  }
  /**
   * This method is public.
   * It allows to init the control.
   * @fixme
   */
  init() {
    this._pictoButton.setAttribute("aria-pressed", true);
    this._panelContainer.style.display = "block";
    this._displayProfile(this._data);
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */
  _initialize(options) {
    logger35.trace("ElevationPath::_initialize : ", options);
    this.options = {
      target: null,
      render: null,
      active: false,
      apiKey: null,
      export: false,
      elevationOptions: {
        outputFormat: "json"
      },
      layerDescription: {
        title: "Profil altimÃ©trique",
        description: "Mon profil altimÃ©trique"
      },
      displayProfileOptions: {
        totalDistance: true,
        greaterSlope: true,
        meanSlope: true,
        ascendingElevation: true,
        descendingElevation: true,
        currentSlope: true,
        apply: null,
        target: null
      },
      stylesOptions: {
        profile: null,
        draw: null,
        marker: null
      }
    };
    Helper_default2.mergeParams(this.options, options);
    this.options.target = options.target || null;
    this.options.apiKey = options.apiKey;
    var _profile = options.displayProfileOptions || {};
    this.export = null;
    var displayFunction = _profile.apply;
    this.options.displayProfileOptions.apply = typeof displayFunction === "function" ? displayFunction : _ElevationPath.DISPLAY_PROFILE_BY_DEFAULT;
    var displayContainer = _profile.target;
    this.options.displayProfileOptions.target = typeof displayContainer !== "undefined" ? displayContainer : null;
    var _styles = options.stylesOptions || {};
    this.options.stylesOptions.draw = _styles.draw || {};
    this._createStylingDraw();
    this.options.stylesOptions.marker = _styles.marker || {};
    this._createStylingMarker();
    this.COMPUTE_ELEVATION_EVENT = "elevationpath:compute";
    this.DRAW_START_ELEVATION_EVENT = "elevationpath:drawstart";
    this.DRAW_END_ELEVATION_EVENT = "elevationpath:drawend";
  }
  /**
   * initialize component container (DOM)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initializeContainer() {
    logger35.trace("ElevationPath::_initializeContainer : ", this._uid);
    var container = this._createMainContainerElement();
    var picto = this._pictoButton = this._createShowElevationPathPictoElement();
    container.appendChild(picto);
    if (this.options.active) {
      this._pictoButton.click();
    }
    var panel = this._panelContainer = this._createElevationPathPanelElement();
    var panelDiv = this._createElevationPathPanelDivElement();
    panel.appendChild(panelDiv);
    var header = this._createElevationPathPanelHeaderElement();
    panelDiv.appendChild(header);
    var profile = this._createElevationPathPanelProfilElement();
    this._profileContainer = profile.firstChild;
    panelDiv.appendChild(profile);
    var waiting = this._waitingContainer = this._createElevationPathWaitingElement();
    panelDiv.appendChild(waiting);
    var info = this._infoContainer = this._createElevationPathInformationsElement();
    panelDiv.appendChild(info);
    var plugin = this._createDrawingButtonsPluginDiv();
    panelDiv.appendChild(plugin);
    if (this.options.displayProfileOptions.target === null) {
      container.appendChild(panel);
    }
    return container;
  }
  // ################################################################### //
  // ###################### init styles ################################ //
  // ################################################################### //
  /**
   * create style marker object : "ol.style"
   *
   * @private
   */
  _createStylingMarker() {
    logger35.trace("ElevationPath::_createStylingMarker ");
    var marker = _ElevationPath.DEFAULT_STYLES.MARKER;
    logger35.trace("style marker", marker);
    if (this.options.stylesOptions.marker instanceof Image_default2) {
      marker = this.options.stylesOptions.marker;
    }
    this._markerStyle = new Style_default({
      image: marker
    });
  }
  /**
   * create style draw object : "ol.style"
   *
   * @private
   */
  _createStylingDraw() {
    logger35.trace("ElevationPath::_createStylingDraw");
    var styles = this.options.stylesOptions.draw;
    logger35.trace("style start", styles.start);
    var startStyleOpts = {
      image: Measures_default.DEFAULT_POINTER_STYLE,
      stroke: Measures_default.DEFAULT_DRAW_START_STYLE.getStroke()
    };
    if (styles.hasOwnProperty("pointer") && styles.pointer instanceof Image_default2) {
      startStyleOpts.image = styles.pointer;
    }
    if (styles.hasOwnProperty("start") && styles.start instanceof Stroke_default) {
      startStyleOpts.stroke = styles.start;
    }
    this._drawStyleStart = new Style_default(startStyleOpts);
    logger35.trace("style finish", styles.finish);
    var finishStyleOpts = {
      stroke: Measures_default.DEFAULT_DRAW_FINISH_STYLE.getStroke()
    };
    if (styles.hasOwnProperty("finish") && styles.finish instanceof Stroke_default) {
      finishStyleOpts.stroke = styles.finish;
    }
    this._drawStyleFinish = new Style_default(finishStyleOpts);
  }
  /**
   * create style graph
   * FIXME : Ã  revoir car ne sert que pour AmCharts !?
   *
   * @private
   */
  _createStylingProfile() {
    logger35.trace("ElevationPath::_createStylingProfile");
    var userStyles = this.options.stylesOptions.profile;
    logger35.trace("style profile", userStyles);
    var defaultStyle = _ElevationPath.DEFAULT_STYLES.PROFILE;
    Object.keys(defaultStyle).forEach((key) => {
      if (!userStyles.hasOwnProperty(key)) {
        userStyles[key] = defaultStyle[key];
      } else {
        var _defaultStyle = defaultStyle[key];
        if (typeof _defaultStyle === "object") {
          Helper_default2.mergeParams(_defaultStyle, userStyles[key]);
          userStyles[key] = _defaultStyle;
        }
      }
    });
  }
  // ################################################################### //
  // ################### Map interactions management ################### //
  // ################################################################### //
  /**
   * this method is called by this.onShowElevationPathClick,
   * and initialize a vector layer, if widget is active.
   *
   * @param {Map} map - Map
   * @private
   */
  _initMeasureInteraction(map) {
    logger35.trace("ElevationPath::_initMeasureInteraction()");
    if (!map) {
      return;
    }
    this._measureSource = new Vector_default();
    this._measureVector = new Vector_default2({
      source: this._measureSource,
      style: this._drawStyleFinish
    });
    this._measureVector.gpResultLayerId = "measure:profil";
    map.addLayer(this._measureVector);
    map.getControls().forEach(
      (control) => {
        if (control instanceof LayerSwitcher_default) {
          var layerId = this._measureVector.gpLayerId;
          if (control._layers[layerId].title === layerId) {
            control.addLayer(
              this._measureVector,
              {
                title: this.options.layerDescription.title,
                description: this.options.layerDescription.description
              }
            );
          }
        }
      }
    );
  }
  /**
   * this method is called by this.onShowElevationPathClick,
   * and add draw interaction to map, if widget is not active.
   *
   * @param {Map} map - Map
   * @private
   */
  _addMeasureInteraction(map) {
    logger35.trace("ElevationPath::_addMeasureInteraction()");
    if (!map) {
      return;
    }
    this._measureDraw = new Draw_default({
      source: this._measureSource,
      type: "LineString",
      style: this._drawStyleStart,
      stopClick: true
    });
    this._measureDraw.setProperties({
      name: "ElevationPath",
      source: this
    });
    map.addInteraction(this._measureDraw);
    this._measureDraw.on("drawstart", (evt) => {
      logger35.trace("drawstart", evt);
      if (this._marker !== null) {
        this._measureSource.removeFeature(this._marker);
        this._marker = null;
      }
      if (this._lastSketch !== null) {
        this._measureSource.removeFeature(this._lastSketch);
        this._lastSketch = null;
      }
      this._currentSketch = evt.feature;
      var _features = this._measureSource.getFeatures();
      for (var i = 0; i < _features.length; i++) {
        this._measureSource.removeFeature(_features[i]);
      }
      this.dispatchEvent(this.DRAW_START_ELEVATION_EVENT);
    });
    this._measureDraw.on("drawend", (evt) => {
      logger35.trace("drawend", evt);
      this.dispatchEvent(this.DRAW_END_ELEVATION_EVENT);
      this._lastSketch = this._currentSketch;
      if (typeof this.options.elevationOptions.onSuccess === "undefined" && this.options.displayProfileOptions.target === null) {
        this._panelContainer.style.display = "block";
      }
      this._measureDraw.setActive(false);
      this._requestService();
    });
  }
  /**
   * this method is called by this.onShowElevationPathClick,
   * and removes draw interaction from map (if exists)
   * And removes layer too...
   *
   * @param {Map} map - Map
   * @param {Boolean} remove - Remove layer
   * @private
   */
  _removeMeasureInteraction(map, remove) {
    logger35.trace("ElevationPath::_removeMeasureInteraction()");
    if (!map) {
      return;
    }
    if (remove) {
      if (this._measureVector) {
        map.removeLayer(this._measureVector);
        this._measureVector = null;
      }
    }
    if (this._measureDraw) {
      map.removeInteraction(this._measureDraw);
      this._measureDraw = null;
    }
  }
  // ################################################################### //
  // ############################ Alti request ######################### //
  // ################################################################### //
  /**
   * transforme geometry feature to position coordinate (service)
   *
   * @returns {Object[]} geometry
   *
   * @private
   */
  _getGeometry() {
    if (this._currentSketch === null) {
      logger35.warn("Current Feature undefined !?");
      return;
    }
    var geometry = [];
    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";
    var coordinates = this._currentSketch.getGeometry().getCoordinates();
    for (var i = 0; i < coordinates.length; i++) {
      var xy = coordinates[i];
      var ll = xy;
      if (projSrc !== projDest) {
        ll = transform(xy, projSrc, projDest);
      }
      geometry.push({
        lon: Math.round(ll[0] * 1e8) / 1e8,
        lat: Math.round(ll[1] * 1e8) / 1e8
      });
    }
    return geometry;
  }
  /**
   * get geometry feature length
   *
   * @returns {Integer} length
   *
   * @private
   */
  _getLength() {
    if (this._currentSketch === null) {
      logger35.warn("Current Feature undefined !?");
      return;
    }
    var length = 0;
    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";
    var coordinates = this._currentSketch.getGeometry().getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var c1 = transform(coordinates[i], projSrc, projDest);
      var c2 = transform(coordinates[i + 1], projSrc, projDest);
      c1[0] = Math.round(c1[0] * 1e8) / 1e8;
      c1[1] = Math.round(c1[1] * 1e8) / 1e8;
      c2[0] = Math.round(c2[0] * 1e8) / 1e8;
      c2[1] = Math.round(c2[1] * 1e8) / 1e8;
      length += getDistance(c1, c2);
    }
    return length;
  }
  /**
   * get geometry feature point coords in EPSG:4326 [lon, lat]
   *
   * @returns {Array} point coords in EPSG:4326 [lon, lat]
   *
   * @private
   */
  _getSketchCoords() {
    if (this._currentSketch === null) {
      logger35.warn("Current Feature undefined !?");
      return;
    }
    var map = this.getMap();
    var projSrc = map.getView().getProjection();
    var projDest = "EPSG:4326";
    var pointCoords = [];
    var coordinates = this._currentSketch.getGeometry().getCoordinates();
    for (var i = 0; i < coordinates.length; i++) {
      var c1 = transform(coordinates[i], projSrc, projDest);
      c1[0] = Math.round(c1[0] * 1e8) / 1e8;
      c1[1] = Math.round(c1[1] * 1e8) / 1e8;
      pointCoords.push(c1);
    }
    return pointCoords;
  }
  /**
   * this method is called at the end of the path,
   * it generates and sends alti request, then displays results
   *
   * @private
   */
  _requestService() {
    logger35.trace("ElevationPath::_requestService");
    var geometry = this._getGeometry();
    logger35.trace("geometry", geometry);
    if (!geometry) {
      logger35.warn("missing geometry !?");
      return;
    }
    var options = {};
    Helper_default2.mergeParams(options, this.options.elevationOptions);
    Helper_default2.mergeParams(options, {
      apiKey: options.apiKey || this.options.apiKey
    });
    if (typeof options.ssl !== "boolean") {
      if (typeof this.options.ssl === "boolean") {
        options.ssl = this.options.ssl;
      } else {
        options.ssl = true;
      }
    }
    Helper_default2.mergeParams(options, {
      ssl: options.ssl
    });
    var self2 = this;
    var bOnFailure = !!(this.options.elevationOptions.onFailure !== null && typeof this.options.elevationOptions.onFailure === "function");
    var bOnSuccess = !!(this.options.elevationOptions.onSuccess !== null && typeof this.options.elevationOptions.onSuccess === "function");
    var _requestServiceOnSuccess = function(result) {
      logger35.trace(result);
      if (result) {
        self2._panelContainer.style.display = "block";
        if (self2._data) {
          self2._data = {};
        }
        self2._data = self2._computeElevationMeasure(result.elevations);
        self2._displayProfile(self2._data);
        self2._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
        self2._waiting = false;
        self2._measureDraw.setActive(true);
      }
      if (bOnSuccess) {
        self2.options.elevationOptions.onSuccess.call(self2, self2.getData());
      }
    };
    var _requestServiceOnFailure = function(error) {
      self2._panelContainer.style.display = "none";
      logger35.error(error.message);
      self2._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
      self2._waiting = false;
      self2._measureDraw.setActive(true);
      if (bOnFailure) {
        self2.options.elevationOptions.onFailure.call(self2, error);
      }
    };
    Helper_default2.mergeParams(options, {
      onSuccess: _requestServiceOnSuccess,
      onFailure: _requestServiceOnFailure
    });
    var sampling = options.sampling || 200;
    var p2 = Math.max(50, Math.floor(this._getLength()) / 5);
    if (p2 > 200) {
      sampling = 200;
    } else {
      sampling = Math.floor(p2);
    }
    if (sampling > 0) {
      Helper_default2.mergeParams(options, {
        sampling
      });
    }
    Helper_default2.mergeParams(options, {
      positions: geometry
    });
    logger35.trace("options du service", options);
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
    Gp_default.Services.getAltitude(options);
  }
  // ################################################################### //
  // ########################## Profil display ######################### //
  // ################################################################### //
  /**
   * this method computes results elevations (Z and distance)
   *
   * @param {Array} elevations - array of elevation
   * @returns {Array} elevations
   * @private
   */
  _computeElevationMeasure(elevations) {
    logger35.trace("ElevationPath::_computeElevationMeasure", elevations);
    var _data = elevations;
    var _unit = "m";
    var _sketchPoints = this._getSketchCoords();
    if (!_sketchPoints) {
      return;
    }
    _data[0].dist = 0;
    _data[0].slope = 0;
    _data[0].oldlat = _data[0].lat;
    _data[0].oldlon = _data[0].lon;
    _data[0].lat = Math.round(_data[0].lat * 1e5) / 1e5;
    _data[0].lon = Math.round(_data[0].lon * 1e5) / 1e5;
    var _distanceMinus = 0;
    var _distancePlus = 0;
    var _ascendingElevation = 0;
    var _descendingElevation = 0;
    var _distance = 0;
    var _slopes = 0;
    var distances = [];
    for (var i = 1; i < _data.length; i++) {
      var a2 = [_data[i].lon, _data[i].lat];
      var distanceToPrevious = getDistance(a2, [_data[i - 1].oldlon, _data[i - 1].oldlat]);
      var dist = distanceToPrevious + _distance;
      var za = _data[i].z;
      var zb = _data[i - 1].z;
      if (za < 0) {
        za = 0;
      }
      if (zb < 0) {
        zb = 0;
      }
      var slope = za - zb;
      if (slope < 0) {
        _distanceMinus += distanceToPrevious;
        _descendingElevation += slope;
      } else if (slope > 0) {
        _distancePlus += distanceToPrevious;
        _ascendingElevation += slope;
      }
      _distance = dist;
      _data[i].dist = dist;
      _slopes += slope ? Math.abs(Math.round(slope / distanceToPrevious * 100)) : 0;
      _data[i].slope = slope ? Math.abs(Math.round(slope / distanceToPrevious * 100)) : 0;
      var value2 = _data[i].slope;
      if (value2 > 15 && value2 < 30) {
        _data[i].color = "#005b4c";
      } else if (value2 > 30 && value2 < 45) {
        _data[i].color = "#00362d";
      } else if (value2 > 45) {
        _data[i].color = "#00120f";
      } else {
        _data[i].color = "#00B798";
      }
      _data[i].oldlat = _data[i].lat;
      _data[i].oldlon = _data[i].lon;
      _data[i].lat = Math.round(_data[i].lat * 1e5) / 1e5;
      _data[i].lon = Math.round(_data[i].lon * 1e5) / 1e5;
    }
    logger35.trace("List Distances", distances);
    var _altMin = _data[0].z;
    var _altMax = _data[0].z;
    var _greaterSlope = _data[0].slope;
    for (var ji = 0; ji < _data.length; ji++) {
      var d4 = _data[ji];
      if (d4.z < -100) {
        d4.z = 0;
      }
      if (d4.z > _altMax) {
        _altMax = d4.z;
      }
      if (d4.z < _altMin) {
        _altMin = d4.z;
      }
      if (d4.slope > _greaterSlope) {
        _greaterSlope = d4.slope;
      }
    }
    return {
      greaterSlope: _greaterSlope,
      // pente max
      meanSlope: Math.round(_slopes / _data.length),
      // pente moyenne
      distancePlus: _distancePlus,
      // distance cumulÃ©e positive
      distanceMinus: _distanceMinus,
      // distance cumulÃ©e nÃ©gative
      ascendingElevation: _ascendingElevation,
      // dÃ©nivelÃ© cumulÃ©e positive
      descendingElevation: _descendingElevation,
      // dÃ©nivelÃ© cumulÃ©e nÃ©gative
      altMin: _altMin.toLocaleString(),
      // altitude min TODO: inutile ?
      altMax: _altMax.toLocaleString(),
      // altitude max TODO: inutile ?
      distance: this._getLength(),
      // distance totale
      unit: _unit,
      // unitÃ© des mesures de distance
      points: _data
    };
  }
  /**
   * this method is called after service request (in case of success)
   * and display results
   *
   * @param {Array} elevations - array of elevation
   * @private
   */
  _displayProfile(elevations) {
    logger35.trace("ElevationPath::_displayProfile", elevations);
    this._updateInfoContainer();
    var container = this.options.displayProfileOptions.target;
    if (container) {
      container.appendChild(this._panelContainer);
    }
    container = this._profileContainer;
    var context = this;
    var displayFunction = this.options.displayProfileOptions.apply;
    displayFunction.call(this, elevations, container, context);
    var opts = this.options.displayProfileOptions;
    var element = document.getElementById("GPelevationPathPanelInfo-" + this._uid);
    if (element) {
      if (opts.totalDistance || opts.greaterSlope || opts.meanSlope || opts.ascendingElevation || opts.descendingElevation) {
        element.style.display = "block";
      }
    }
    this.dispatchEvent(this.COMPUTE_ELEVATION_EVENT);
  }
  /**
   * update info container
   *
   * @private
   */
  _updateInfoContainer() {
    logger35.trace("ElevationPath::_updateInfoContainer");
    var totalDistance = this.options.displayProfileOptions.totalDistance;
    var meanSlope = this.options.displayProfileOptions.meanSlope;
    var greaterSlope = this.options.displayProfileOptions.greaterSlope;
    var ascendingElevation = this.options.displayProfileOptions.ascendingElevation;
    var descendingElevation = this.options.displayProfileOptions.descendingElevation;
    var div = this._infoContainer;
    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }
    if (totalDistance) {
      this._addElevationPathInformationsItem("Distance totale", Math.round(this._data.distance).toLocaleString() + " m");
    }
    if (ascendingElevation) {
      this._addElevationPathInformationsItem("DÃ©nivelÃ© positif", this._data.ascendingElevation.toLocaleString() + " m");
    }
    if (descendingElevation) {
      this._addElevationPathInformationsItem("DÃ©nivelÃ© nÃ©gatif", this._data.descendingElevation.toLocaleString() + " m");
    }
    if (meanSlope) {
      this._addElevationPathInformationsItem("Pente moyenne", this._data.meanSlope.toLocaleString() + " %");
    }
    if (greaterSlope) {
      this._addElevationPathInformationsItem("Plus forte pente", this._data.greaterSlope.toLocaleString() + " %");
    }
  }
  /**
   * Remove measure
   * @private
   */
  _removeMeasure() {
    this._lastSketch = null;
    this._currentSketch = null;
    if (this._measureSource) {
      if (this._marker) {
        this._measureSource.removeFeature(this._marker);
        this._marker = null;
      }
      var _features = this._measureSource.getFeatures();
      for (var i = 0; i < _features.length; i++) {
        this._measureSource.removeFeature(_features[i]);
      }
    }
  }
  /**
   * Remove profile
   * @private
   */
  _removeProfile() {
    this._profile = null;
    if (this._profileContainer) {
      while (this._profileContainer.firstChild) {
        this._profileContainer.removeChild(this._profileContainer.firstChild);
      }
    }
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on '' picto
   * and enable or disable the entry of the path
   *
   * @param {Event} e - event
   * @private
   */
  onShowElevationPathClick(e) {
    var opened = this._pictoButton.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map, {
      current: "ElevationPath"
    });
    if (opened === "true") {
      if (this._profile === null) {
        this._panelContainer.style.display = "none";
      }
      this._initMeasureInteraction(map);
      this._addMeasureInteraction(map);
    } else {
      this._panelContainer.style.display = "none";
      if (e && e.target.dataset && e.target.dataset.removeMeasure) {
        if (e.target.dataset.removeMeasure === "true") {
          this._removeMeasure();
        } else {
          this._lastSketch = null;
          this._currentSketch = null;
        }
      } else {
        this._removeMeasure();
      }
      this._removeProfile();
      if (e && e.target.dataset && e.target.dataset.removeLayer) {
        this._removeMeasureInteraction(map, e.target.dataset.removeLayer === "true");
      } else {
        this._removeMeasureInteraction(map, true);
      }
    }
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
  }
  /**
   * this method is called by event 'click' on '' picto
   * (cf. this.),
   * and display the panel info
   *
   * @private
   */
  onOpenElevationPathInfoClick() {
    var div = this._infoContainer;
    if (div.className === "GPelementVisible gpf-visible") {
      clearTimeout(this._timerHdlr);
      div.className = "GPelementHidden gpf-hidden";
    } else {
      div.className = "GPelevationPathInformationsContainerVisible";
    }
    this._timerHdlr = setTimeout(function() {
      div.className = "GPelementHidden gpf-hidden";
    }, 4e3);
  }
};
/**
* Styles applied by default if stylesOptions property is not set.
*/
__publicField(_ElevationPath, "DEFAULT_STYLES", {
  // styling drawing by default
  // see => Measures.DEFAULTS_STYLES
  // stying marker to the profile by default
  MARKER: new Icon_default({
    src: Markers_default["lightOrange"],
    // image avec un mauvais ratio size 51/38 pixels
    // src : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAsCAYAAAAATWqyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABTtJREFUeNq8WGtsFUUU/rb3gtdCAykFG9AUDTQUKimhxUewEusrJYoBo4FfEgoqotHERH6oP9TGmJhIrIlWAf9hjAaEiME2pgFfVVpFii8sWqIQLLSx3EJLW7p+Z2Z2b2l7d/b23vZLTmZ2duacb2fmnDk7DlKA67rXs1hJKacsohRQppjXFygnKT9TDlH2O47zFzIFGnco91EOuqnjoBnr2Ow4FhIlLN6m3DykFTh3BGj/Doj/CfSe082xPCDnBmDWTUBeyXDVjZTHOUNHUiZCEs+weI0ySTV0/w0c2wa07gIungn+vOx8YN46oPhpYOp1Xms/5TmSeSMUERKImFnYqBoGuPRNL5LEW8BgX2rrmjWZZLYApS8BUW8r4T0zO5eTEjFr+S6lSjV0HgPqVwNdf6S30abNB+7aDeQWey3bKZtIxvU5DxvyrE/izJfAvuXpkxCIDtElOjWqjK2RM8LZWMbiG0oEnUc5kB7a14WMYvI04H56du5ieZKluZWz8r0/IyQh5TuKRH8cqFuTeRIC0Sm6xYbYok1j21+ahyhLVO3wC8D5VowbRLfY0FhibOulIavDLEoRZyD8sJDeMWBXKG5ZsIobsdDsg+OMq3u1m1u9KQo8zP45EqjRxOUpk6i50IRl4FuGjpZtwUoiMYa314GFj/EzIsN8n8v+C1e4kfvwcm+wnhsZY27xQ8oiWZpKrWRQB6tAElfxpKnjsCdGklDzG9HvpI/0DYLYEpsalVnmAAM6fgR62oMHl70C5N9mn3rpI32DILbEpkZ5ljlFgbPNFtebzij5VPhNKX1lTBASNtXSzPZ3cxCuvVOH7FTCu4yxeZDGbCES0z5+PniQ3uGpwTYmYTOWCPGTpgYP6u9OnYhtzBCbQkSH0NiM4EEdP6VOxDYmYbNLiJxQ1elFwYPaG3XQCn3QHddjgpCweUKI6K2bvzw4YROf//rJob6fZl/H2FRoFiINfqo3qyzYwD8MVIeYLw32J+8j76SP9A2C2BKbGg1CZL+EF/W4YKP9a3/fCeyhkrY9DOOXEu1SlzZ5J31sSNjqURm/OfQkY9qgvkYOvXhbuH0g505Oga7HT9rPF9+t5+pDL0ulwzt46FV5ROax+JUSRRtP0LoHMK64+xNg7iqVEVOKSKRVxRGpsKhRnaRD4SPjR0J0axKCGmP7ilQxm4X8d8xXmfvHJZlPkCR3WfODl9FLMlxCIhevSJ5Nwzo1XdKxYpe3hpmB6BKdmoS43VqPxIgsni+aWOg8biZ3f+nLmSMiuvKWek/P01az7QdLyNVT7lC/l59WAKcb0iMxhzpW1nvmvpDtSiKD1l9OkpnDgv8UyMWFU9wvTP8vdY6NhJwnD1JVtso2OiiLSeL0iJUbNfg6zikVVwRTyOn2HWOfjfLtHgnBhtFIJCViyNDZUatdmnGlaFPqJIoe1WM1aqlz71ivJbLNobgAA9zgu7nZ/vstHAk5WVdzaPRqmGC5lER6kjpV4OWJdq+1kkshSk4VH9izcy/bV66qSPQZV+0J9G7rTY6+XNmqHmYwyJVV24kse1X31dhKHdasygkzy+a64oC4nWr47F4e858nSbLv4V/KAe9JKpVDrx/SImLIXMOiRUKdujESl+49O8xVZxpXzVc/C/I/RxL/hgq8YYkYhev9q6kVO4d9B+sr3vdICNaHJTHWW8Ya/87wqy2uWwstUk/gTYw3aCRGOarMDfS67kfFWqSuIe9imAjQEC272nJHixYNaSvGRIIGN49ywbsZEw1zI11N6TZSHeaGORn+F2AAJtRIMx4t+hUAAAAASUVORK5CYII=",
    anchor: [0.5, 1],
    snapToPixel: true
  }),
  // styling service results points by default
  RESULTS: {
    // INFO orientÃ© maintenance !
    imageRadius: 5,
    imageFillColor: "rgba(128, 128, 128, 0.2)",
    imageStrokeColor: "rgba(0, 0, 0, 0.7)",
    imageStrokeWidth: 2
  }
  // FIXME ???
  // PROFILE : {
  //     type : "serial",
  //     pathToImages : "http://cdn.amcharts.com/lib/3/images/",
  //     categoryField : "dist",
  //     autoMarginOffset : 0,
  //     marginRight : 10,
  //     marginTop : 10,
  //     startDuration : 0,
  //     color : "#5E5E5E",
  //     fontSize : 10,
  //     theme : "light",
  //     thousandsSeparator : "",
  //     categoryAxis : {
  //         color : "#5E5E5E",
  //         gridPosition : "start",
  //         minHorizontalGap : 40,
  //         tickPosition : "start",
  //         title : "Distance (km)",
  //         titleColor : "#5E5E5E",
  //         startOnAxis : true
  //     },
  //     chartCursor : {
  //         animationDuration : 0,
  //         bulletsEnabled : true,
  //         bulletSize : 10,
  //         categoryBalloonEnabled : false,
  //         cursorColor : "#F90",
  //         graphBulletAlpha : 1,
  //         graphBulletSize : 1,
  //         zoomable : false
  //     },
  //     trendLines : [],
  //     graphs : [
  //         {
  //             balloonColor : "#CCCCCC",
  //             balloonText : "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/><span class='altiPathCoords'>(lat: [[lat]] / lon:[[lon]])</span>",
  //             bullet : "round",
  //             bulletAlpha : 0,
  //             bulletBorderColor : "#FFF",
  //             bulletBorderThickness : 2,currentSlope
  //             bulletColor : "#F90",
  //             bulletSize : 6,
  //             hidden : false,
  //             id : "AmGraph-1",
  //             fillAlphas : 0.4,
  //             fillColors : "#C77A04",
  //             lineAlpha : 1,
  //             lineColor : "#C77A04",
  //             lineThickness : 1,
  //             title : "Altitude",
  //             valueField : "z"
  //         }
  //     ],
  //     guides : [],
  //     valueAxes : [
  //         {
  //             id : "ValueAxis-1",
  //             minVerticalGap : 20,
  //             title : "Altitude (m)"
  //         }
  //     ],
  //     allLabels : [],
  //     balloon : {
  //         borderColor : "#CCCCCC",
  //         borderThickness : 1,
  //         fillColor : "#FFFFFF",
  //         showBullet : true
  //     },
  //     titles : []
  // }
});
var ElevationPath = _ElevationPath;
Object.assign(ElevationPath.prototype, ElevationPathDOM_default);
Object.assign(ElevationPath.prototype, Widget_default);
var ElevationPath_default = ElevationPath;
if (window.ol && window.ol.control) {
  window.ol.control.ElevationPath = ElevationPath;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/LayerImport/LayerImport.js
var logger36 = LoggerByDefault_default2.getLogger("layerimport");
var _LayerImport = class _LayerImport extends Control_default2 {
  /**
  * @constructor
  * @fires layerimport:mapbox:added
  * @fires layerimport:vector:added
  * @fires layerimport:service:added
  * @fires editor:loaded
  * @fires render:success
  * @fires render:failure
  * @param {Object} options - options for function call.
  * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
  * @param {Boolean} [options.collapsed = true] - Specify if LayerImport control should be collapsed at startup. Default is true.
  * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
  * @param {Array} [options.layerTypes = ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"]] - data types that could be imported : "KML", "GPX", "GeoJSON", "WMS", "WMTS" and "MAPBOX". Values will be displayed in the same order in widget list.
  * @param {Object} [options.webServicesOptions = {}] - Options to import WMS or WMTS layers
  * @param {String} [options.webServicesOptions.proxyUrl] - Proxy URL to avoid cross-domain problems. Mandatory to import WMS and WMTS layer.
  * @param {Array.<String>} [options.webServicesOptions.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing.
  * @param {Object} [options.vectorStyleOptions] - Options for imported vector layer styling (KML, GPX, GeoJSON)
  * @param {Object} [options.vectorStyleOptions.KML] - Options for KML layer styling
  * @param {Boolean} [options.vectorStyleOptions.KML.extractStyles = true] - Extract styles from the KML. Default is true.
  * @param {Boolean} [options.vectorStyleOptions.KML.showPointNames = true] - Show names as labels for KML placemarks which contain points. Default is true.
  * @param {Object} [options.vectorStyleOptions.KML.defaultStyle] - default style to be applied to KML imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
  * @param {Object} [options.vectorStyleOptions.GPX] - Options for GPX layer styling
  * @param {Object} [options.vectorStyleOptions.GPX.defaultStyle] - default style to be applied to GPX imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
  * @param {Object} [options.vectorStyleOptions.GeoJSON] - Options for GeoJSON layer styling
  * @param {Object} [options.vectorStyleOptions.GeoJSON.defaultStyle] - default style to be applied to GeoJSON imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
  * @param {Object} [options.vectorStyleOptions.MapBox] - Options for MapBox layer styling
  * @param {Object} [options.vectorStyleOptions.MapBox.defaultStyle] - default style to be applied to MapBox imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
  * @param {Object} [options.vectorStyleOptions.MapBox.editor] - options for tools editor
  * @param {Boolean} [options.vectorStyleOptions.MapBox.display = true] - display tools editor
  * @example
  *  var LayerImport = new ol.control.LayerImport({
  *      "collapsed" : false,
  *      "draggable" : true,
  *      "layerTypes" : ["KML", "GPX"],
  *      "webServicesOptions" : {
  *          "proxyUrl" : "http://localhost/proxy/php/proxy.php?url=",
  *          "noProxyDomains" : []
  *      },
  *      "vectorStyleOptions" : {
  *          "KML" : {
  *              extractStyles : true,
  *              defaultStyle : new ol.style.Style({
  *                  image : new ol.style.Icon({
  *                       src : "data:image/png;base64....",
  *                       size : [51, 38],
  *                  }),
  *                  stroke : new ol.style.Stroke({
  *                       color : "#ffffff",
  *                       width : 7
  *                  }),
  *                  fill : new ol.style.Fill({
  *                       color : "rgba(255, 183, 152, 0.2)"
  *                  }),
  *                  text : new ol.style.Text({
  *                      font : "16px Sans",
  *                      textAlign : "left",
  *                      fill : new ol.style.Fill({
  *                          color : "rgba(255, 255, 255, 1)"
  *                      }),
  *                      stroke : new ol.style.Stroke({
  *                          color : "rgba(0, 0, 0, 1)",
  *                          width : 2
  *                      })
  *                  })
  *              })
  *          },
  *          "GPX" : {
  *              defaultStyle : new ol.style.Style({
  *                  image : new ol.style.Icon({
  *                       src : "path/to/my/icon.png",
  *                       size : [51, 38],
  *                  }),
  *                  stroke : new ol.style.Stroke({
  *                       color : "#ffffff",
  *                       width : 7
  *                  })
  *              })
  *          }
  *      }
  *  });
   */
  constructor(options) {
    options = options || {};
    super(options);
    this.CLASSNAME = "LayerImport";
    if (!(this instanceof _LayerImport)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize(options);
    this._container = this._initContainer(options);
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      var self2 = this;
      map.getLayers().on(
        "remove",
        function(e) {
          if (e.element.gpResultLayerId === "layerimport:MAPBOX") {
            if (e.element.gpEditorId) {
              if (self2._mapBoxPanel && self2._importPanel) {
                self2.cleanMapBoxResults(e.element.gpEditorId);
                self2._mapBoxPanel.classList.replace("GPelementVisible", "GPelementHidden");
                self2._mapBoxPanel.classList.replace("gpf-visible", "gpf-hidden");
              }
            }
          }
        },
        self2
      );
      if (this.draggable) {
        Draggable_default.dragElement(
          this._importPanel,
          this._importPanelHeader,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this._showImportButton.setAttribute("aria-pressed", true);
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger36.error("[ERROR] LayerImport:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      this._panelCloseButton.click();
    } else {
      this._showImportButton.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Returns content of a static import (KML, GPX or GeoJSON)
   *
   * @returns {String} contentStatic  - content static
   */
  getStaticImportContent() {
    return this.contentStatic;
  }
  /**
   * Returns content of a service import (GetCapabilities)
   *
   * @returns {String} contentService  - content service
   */
  getServiceImportContent() {
    return this.contentService;
  }
  /**
   * Returns layer name
   *
   * @returns {String} name - layer name
   */
  getName() {
    return this._name;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize LayerImport control (called by LayerImport constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  _initialize(options) {
    this._checkInputOptions(options);
    this.options = {
      collapsed: true,
      draggable: false,
      layerTypes: ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"],
      webServicesOptions: {},
      vectorStyleOptions: {
        KML: {
          extractStyles: true,
          showPointNames: true,
          defaultStyle: {}
        },
        GPX: {
          defaultStyle: {}
        },
        GeoJSON: {
          defaultStyle: {}
        },
        MapBox: {
          defaultStyle: {},
          editor: {}
        }
      }
    };
    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.extractStyles) {
      this.options.vectorStyleOptions.KML.extractStyles = options.vectorStyleOptions.KML.extractStyles;
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.showPointNames) {
      this.options.vectorStyleOptions.KML.showPointNames = options.vectorStyleOptions.KML.showPointNames;
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.defaultStyle) {
      this.options.vectorStyleOptions.KML.defaultStyle = options.vectorStyleOptions.KML.defaultStyle;
    } else {
      this.options.vectorStyleOptions.KML.defaultStyle = new Style_default({
        image: _LayerImport.DefaultStyles.image,
        stroke: _LayerImport.DefaultStyles.stroke,
        fill: _LayerImport.DefaultStyles.fill,
        text: _LayerImport.DefaultStyles.text
      });
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.GPX && options.vectorStyleOptions.GPX.defaultStyle) {
      this.options.vectorStyleOptions.GPX.defaultStyle = options.vectorStyleOptions.GPX.defaultStyle;
    } else {
      this.options.vectorStyleOptions.GPX.defaultStyle = new Style_default({
        image: _LayerImport.DefaultStyles.image,
        stroke: _LayerImport.DefaultStyles.stroke,
        fill: _LayerImport.DefaultStyles.fill,
        text: _LayerImport.DefaultStyles.text
      });
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.GeoJSON && options.vectorStyleOptions.GeoJSON.defaultStyle) {
      this.options.vectorStyleOptions.GeoJSON.defaultStyle = options.vectorStyleOptions.GeoJSON.defaultStyle;
    } else {
      this.options.vectorStyleOptions.GeoJSON.defaultStyle = new Style_default({
        image: _LayerImport.DefaultStyles.image,
        stroke: _LayerImport.DefaultStyles.stroke,
        fill: _LayerImport.DefaultStyles.fill,
        text: _LayerImport.DefaultStyles.text
      });
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.defaultStyle) {
      this.options.vectorStyleOptions.MapBox.defaultStyle = options.vectorStyleOptions.MapBox.defaultStyle;
    } else {
      this.options.vectorStyleOptions.MapBox.defaultStyle = new Style_default({
        image: _LayerImport.DefaultStyles.image,
        stroke: _LayerImport.DefaultStyles.stroke,
        fill: _LayerImport.DefaultStyles.fill,
        text: _LayerImport.DefaultStyles.text
      });
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.editor) {
      this.options.vectorStyleOptions.MapBox.editor = options.vectorStyleOptions.MapBox.editor;
    } else {
      this.options.vectorStyleOptions.MapBox.editor = {
        title: true,
        collapse: false,
        themes: false,
        layers: true,
        style: true,
        filter: false,
        legend: true,
        group: false
      };
    }
    if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.hasOwnProperty("display")) {
      this.options.vectorStyleOptions.MapBox.display = options.vectorStyleOptions.MapBox.display;
    } else {
      this.options.vectorStyleOptions.MapBox.display = true;
    }
    if (Array.isArray(options.layerTypes)) {
      var layerTypes = [];
      for (var i = 0; i < options.layerTypes.length; i++) {
        layerTypes.push(options.layerTypes[i]);
      }
      this.options.layerTypes = layerTypes;
    }
    Helper_default2.mergeParams(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this._uid = this.options.id || SelectorID_default.generate();
    this._waiting = false;
    this._timer = null;
    this._initImportTypes();
    this._initDefaultStyles();
    this._showImportButton = null;
    this._importPanel = null;
    this._panelCloseButton = null;
    this._importPanelHeader = null;
    this._importPanelTitle = null;
    this._importPanelReturnPicto = null;
    this._formContainer = null;
    this._staticLocalImportInput = null;
    this._staticUrlImportInput = null;
    this._serviceUrlImportInput = null;
    this._getCapPanel = null;
    this._getCapPanelHeader = null;
    this._getCapResultsListContainer = null;
    this._mapBoxPanel = null;
    this._mapBoxPanelHeader = null;
    this._mapBoxResultsListContainer = null;
    this._waitingContainer = null;
    this._loadingContainer = null;
    this._hasGetCapResults = false;
    this._getCapRequestUrl = null;
    this._getCapResponseWMS = null;
    this._getCapResponseWMSLayers = [];
    this._getCapResponseWMTS = null;
    this._getCapResponseWMTSLayers = [];
    this._hasMapBoxResults = false;
    this.contentStatic = null;
    this._url = null;
    this._file = null;
    this._name = null;
  }
  /**
   * this method is called by this.initialize()
   * and makes sure input options are correctly formated
   *
   * @param {Object} options - control input options
   * @private
   */
  _checkInputOptions(options) {
    if (options.layerTypes) {
      var layerTypes = options.layerTypes;
      if (!Array.isArray(layerTypes)) {
        logger36.warn(`[ol.control.LayerImport] 'options.layerTypes' parameter should be an array. Set default values ["KML", "GPX", "GeoJSON", "WMS", "WMTS"]`);
        options.layerTypes = [
          "KML",
          "GPX",
          "GeoJSON",
          "WMS",
          "WMTS",
          "MAPBOX"
        ];
      } else {
        var typesList = [
          "KML",
          "GPX",
          "GEOJSON",
          "WMS",
          "WMTS",
          "WFS",
          "MAPBOX"
        ];
        var wrongTypesIndexes = [];
        for (var i = 0; i < layerTypes.length; i++) {
          if (typeof layerTypes[i] !== "string") {
            wrongTypesIndexes.push(i);
            logger36.warn("[ol.control.LayerImport] 'options.layerTypes' elements should be of type string (" + layerTypes[i] + ")");
          } else {
            layerTypes[i] = layerTypes[i].toUpperCase();
            if (typesList.indexOf(layerTypes[i]) === -1) {
              wrongTypesIndexes.push(i);
              logger36.log("[ol.control.LayerImport] options.layerTypes : " + layerTypes[i] + " is not a supported type");
            }
            if (layerTypes[i] === "GEOJSON") {
              layerTypes[i] = "GeoJSON";
            }
            if (layerTypes[i] === "MAPBOX") {
              layerTypes[i] = "MAPBOX";
            }
          }
        }
        if (wrongTypesIndexes.length !== 0) {
          for (var j2 = wrongTypesIndexes.length - 1; j2 >= 0; j2--) {
            layerTypes.splice(wrongTypesIndexes[j2], 1);
          }
        }
      }
    }
  }
  /**
   * this method is called by this.initialize()
   * and initializes default styles for vector layers (KML/GPX/GeoJSON)
   *
   * @private
   */
  _initDefaultStyles() {
    var kmlDefaultStyles = this.options.vectorStyleOptions.KML.defaultStyle;
    this._defaultKMLStyle = new Style_default({
      image: kmlDefaultStyles.image,
      stroke: kmlDefaultStyles.stroke,
      fill: kmlDefaultStyles.fill,
      text: kmlDefaultStyles.text
    });
    var gpxDefaultStyles = this.options.vectorStyleOptions.GPX.defaultStyle;
    this._defaultGPXStyle = new Style_default({
      image: gpxDefaultStyles.image,
      stroke: gpxDefaultStyles.stroke,
      fill: gpxDefaultStyles.fill,
      text: gpxDefaultStyles.text
    });
    var geoJSONDefaultStyles = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
    this._defaultGeoJSONStyle = new Style_default({
      image: geoJSONDefaultStyles.image,
      stroke: geoJSONDefaultStyles.stroke,
      fill: geoJSONDefaultStyles.fill,
      text: geoJSONDefaultStyles.text
    });
    var MapBoxDefaultStyles = this.options.vectorStyleOptions.MapBox.defaultStyle;
    this._defaultMapBoxStyle = new Style_default({
      image: MapBoxDefaultStyles.image,
      stroke: MapBoxDefaultStyles.stroke,
      fill: MapBoxDefaultStyles.fill,
      text: MapBoxDefaultStyles.text
    });
  }
  /**
   * this method is called by this.initialize()
   * and initializes import types parameter
   *
   * @private
   */
  _initImportTypes() {
    this._currentImportType = this.options.layerTypes[0] || "KML";
    if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
      this._isCurrentImportTypeStatic = true;
    } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this._isCurrentImportTypeStatic = false;
    }
    this._currentStaticImportType = "local";
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @private
   * @returns {HTMLElement} container - control main container
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var picto = this._showImportButton = this._createShowImportPictoElement();
    container.appendChild(picto);
    var importPanel = this._importPanel = this._createImportPanelElement();
    var importPanelPanelDiv = this._createImportPanelDivElement();
    importPanel.appendChild(importPanelPanelDiv);
    var panelHeader = this._importPanelHeader = this._createImportPanelHeaderElement();
    var panelReturn = this._importPanelReturnPicto = this._createImportPanelReturnPictoElement();
    panelHeader.appendChild(panelReturn);
    var panelTitle = this._importPanelTitle = this._createImportPanelTitleElement();
    panelHeader.appendChild(panelTitle);
    var panelClose = this._panelCloseButton = this._createImportPanelCloseElement();
    panelHeader.appendChild(panelClose);
    importPanelPanelDiv.appendChild(panelHeader);
    var importForm = this._formContainer = this._initInputFormElement();
    importPanelPanelDiv.appendChild(importForm);
    var getCapPanel = this._getCapPanel = this._createImportGetCapPanelElement();
    var importGetCapResultsList = this._getCapResultsListContainer = this._createImportGetCapResultsContainer();
    getCapPanel.appendChild(importGetCapResultsList);
    importPanelPanelDiv.appendChild(getCapPanel);
    var mapBoxPanel = this._mapBoxPanel = this._createImportMapBoxPanelElement();
    var importMapBoxResultsList = this._mapBoxResultsListContainer = this._createImportMapBoxResultsContainer();
    mapBoxPanel.appendChild(importMapBoxResultsList);
    var loading = this._loadingContainer = this._createLoadingElement();
    mapBoxPanel.appendChild(loading);
    importPanelPanelDiv.appendChild(mapBoxPanel);
    var waiting = this._waitingContainer = this._createImportWaitingElement();
    importPanelPanelDiv.appendChild(waiting);
    container.appendChild(importPanel);
    return container;
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @private
   * @returns {HTMLElement} importForm - form main container
   */
  _initInputFormElement() {
    var importForm = this._createImportPanelFormElement();
    var importTypeChoiceDiv = this._createImportTypeLineElement(this.options.layerTypes);
    importForm.appendChild(importTypeChoiceDiv);
    var importStaticParamsContainer = this._createImportStaticParamsContainer(this.options.layerTypes[0]);
    var staticNameLabel = this._createStaticNameLabel();
    importStaticParamsContainer.appendChild(staticNameLabel);
    var staticImportChoice = this._createStaticModeChoiceDiv();
    var staticLocalImportChoice = this._createStaticLocalChoiceDiv();
    staticImportChoice.appendChild(staticLocalImportChoice);
    var staticUrlImportChoice = this._createStaticUrlChoiceDiv();
    staticImportChoice.appendChild(staticUrlImportChoice);
    importStaticParamsContainer.appendChild(staticImportChoice);
    var staticLocalInputDiv = this._createStaticLocalInputDiv();
    staticLocalInputDiv.appendChild(this._createStaticLocalInputLabel());
    this._staticLocalImportInput = this._createStaticLocalInput();
    staticLocalInputDiv.appendChild(this._staticLocalImportInput);
    importStaticParamsContainer.appendChild(staticLocalInputDiv);
    var staticUrlInputDiv = this._createStaticUrlInputDiv();
    staticUrlInputDiv.appendChild(this._createStaticUrlInputLabel());
    this._staticUrlImportInput = this._createStaticUrlInput();
    staticUrlInputDiv.appendChild(this._staticUrlImportInput);
    importStaticParamsContainer.appendChild(staticUrlInputDiv);
    importForm.appendChild(importStaticParamsContainer);
    var importServiceParamsContainer = this._createServiceParamsContainer(this.options.layerTypes[0]);
    var importServiceUrlDiv = this._createServiceUrlDiv();
    importServiceUrlDiv.appendChild(this._createServiceUrlInputLabel());
    this._serviceUrlImportInput = this._createServiceUrlInput();
    importServiceUrlDiv.appendChild(this._serviceUrlImportInput);
    importServiceParamsContainer.appendChild(importServiceUrlDiv);
    importForm.appendChild(importServiceParamsContainer);
    var submit = this._createImportSubmitFormElement();
    importForm.appendChild(submit);
    return importForm;
  }
  // ################################################################### //
  // ######################### DOM events ############################## //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPshowImportPicto' picto
   * (cf. LayerImportDOM._createShowImportPictoElement),
   * and dispatch event change:collapsed (for tools listening this property)
   *
   * @param { Event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  _onShowImportClick(e) {
    var opened = this._showImportButton.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
    if (this._hasMapBoxResults) {
      this._mapBoxPanel.classList.replace("GPelementHidden", "GPelementVisible");
      this._mapBoxPanel.classList.replace("gpf-hidden", "gpf-visible");
      this._hideFormContainer();
    } else if (this._hasGetCapResults) {
      this._getCapPanel.classList.replace("GPelementHidden", "GPelementVisible");
      this._getCapPanel.classList.replace("gpf-hidden", "gpf-visible");
      this._hideFormContainer();
    } else {
      this._getCapPanel.classList.replace("GPelementVisible", "GPelementHidden");
      this._getCapPanel.classList.replace("gpf-visible", "gpf-hidden");
      this._mapBoxPanel.classList.replace("GPelementVisible", "GPelementHidden");
      this._mapBoxPanel.classList.replace("gpf-visible", "gpf-hidden");
      this._displayFormContainer();
    }
  }
  /**
   * this method is called by event 'change' on 'GPimportType' tag form
   * (cf. LayerImportDOM._createImportTypeLineElement),
   * and change current import type
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onImportTypeChange(e) {
    this._currentImportType = e.target.value;
    if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
      this._isCurrentImportTypeStatic = true;
    } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this._isCurrentImportTypeStatic = false;
    }
  }
  /**
   * this method is called by event 'change' on 'GPimportType' tag form
   * (cf. LayerImportDOM._createImportTypeLineElement),
   * and change current import type
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onStaticImportTypeChange(e) {
    this._currentStaticImportType = e.target.value;
  }
  /**
   * this method is called by event 'click' on 'GPimportGetCapPanelClose' tag form
   * (cf. LayerImportDOM._createImportGetCapPanelHeaderElement),
   * and reset getCapabilities information
   *
   * @private
   */
  _onGetCapPanelClose() {
    if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
      this.cleanGetCapResultsList();
    }
  }
  /**
   * this method is called by event 'click' on 'GPimportMapBoxPanelClose' tag form
   * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
   * and reset mapbox information
   *
   * @private
   */
  _onMapBoxPanelClose() {
    this.cleanMapBoxResultsList();
    this._loadingContainer.className = "";
    this._importPanelReturnPicto.classList.replace("GPelementVisible", "GPelementHidden");
    this._importPanelReturnPicto.classList.replace("gpf-visible", "gpf-hidden");
    this._mapBoxPanel.classList.replace("GPelementVisible", "GPelementHidden");
    this._mapBoxPanel.classList.replace("gpf-visible", "gpf-hidden");
  }
  /**
   * this method is called by event 'click' on 'GPimportPanelReturnPicto' tag form
   * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
   * and return to information
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onReturnPictoClick(e) {
    this._onGetCapPanelClose();
    this._onMapBoxPanelClose();
    this._loadingContainer.className = "";
  }
  // ################################################################### //
  // ######################## Submit form ############################## //
  // ################################################################### //
  /**
   * this method is called by event 'submit' on 'GPimportForm' tag form
   * (cf. LayerImportDOM._createImportPanelFormElement),
   * and import static layer or call getCap service (according to import type)
   *
   * @private
   */
  _onImportSubmit() {
    logger36.log("import d'une couche de type : " + this._currentImportType);
    this.contentStatic = null;
    this.contentService = null;
    if (this._isCurrentImportTypeStatic) {
      this.setCollapsed(true);
      this._importStaticLayer();
    } else {
      this._importServiceLayers();
    }
  }
  // ################################################################### //
  // ############## Import KML/GPX/GeoJSON/MapBox layers ############### //
  // ################################################################### //
  /**
   * this method is called by this_onImportSubmit method
   * and import static layer (KML/GPX/GeoJSON) from url or file
   *
   * @private
   */
  _importStaticLayer() {
    var layerName;
    var staticImportNameInput = document.getElementById(this._addUID("GPimportName"));
    if (staticImportNameInput) {
      layerName = staticImportNameInput.value || "";
      logger36.log("import layer name : " + layerName);
    }
    if (this._currentStaticImportType === "local") {
      logger36.log("import static layer from local file");
      this._importStaticLayerFromLocalFile(layerName);
    } else if (this._currentStaticImportType === "url") {
      logger36.log("import static layer from url");
      this._importStaticLayerFromUrl(layerName);
    }
  }
  /**
   * this method is called by _importStaticLayer method
   * and import static layer (KML/GPX/GeoJSON) from url
   *
   * @param {String} layerName - imported layer name
   * @private
   */
  _importStaticLayerFromUrl(layerName) {
    var url = this._staticUrlImportInput.value;
    logger36.log("url : ", url);
    if (url.length === 0) {
      logger36.error("[ol.control.LayerImport] url parameter is mandatory");
      return;
    }
    if (url.trim) {
      url = url.trim();
    }
    this._url = url;
    if (!layerName) {
      layerName = this._url.substring(this._url.lastIndexOf("/") + 1, this._url.lastIndexOf("."));
    }
    this._name = layerName;
    if (this.options.webServicesOptions && this.options.webServicesOptions.proxyUrl) {
      url = ProxyUtils_default.proxifyUrl(url, this.options.webServicesOptions);
    }
    var context = this;
    Gp_default.Protocols.XHR.call({
      url,
      method: "GET",
      timeOut: 15e3,
      // on success callback : display results in container
      onResponse: function(response) {
        context._hideWaitingContainer();
        context._addFeaturesFromImportStaticLayer(response, layerName);
      },
      // on error callback : log error
      onFailure: function(error) {
        context._hideWaitingContainer();
        logger36.error("[ol.control.LayerImport] KML/GPX/GeoJSON/MapBox request failed : ", error);
      }
    });
  }
  /**
   * this method is called by _importStaticLayer method
   * and import static layer (KML/GPX/GeoJSON) from local file
   *
   * @param {String} layerName - imported layer name
   * @private
   */
  _importStaticLayerFromLocalFile(layerName) {
    var file = this._staticLocalImportInput.files[0];
    if (!file) {
      logger36.warn("[ol.control.LayerImport] missing file");
      return;
    }
    this._file = file;
    if (!layerName) {
      layerName = this._file.name.substring(this._file.name.lastIndexOf("/") + 1, this._file.name.lastIndexOf("."));
    }
    this._name = layerName;
    var fReader = new FileReader();
    var context = this;
    fReader.onerror = (e) => {
      context._hideWaitingContainer();
      logger36.error("error fileReader : ", e);
    };
    fReader.onprogress = () => {
      logger36.log("onprogress");
    };
    fReader.onloadstart = () => {
      context._displayWaitingContainer();
      logger36.log("onloadstart");
    };
    fReader.onabort = () => {
      context._hideWaitingContainer();
      logger36.log("onabort");
    };
    fReader.onloadend = (e) => {
      logger36.log("onloadend : ", e);
    };
    fReader.onload = (e) => {
      logger36.log("fileReader onload - file content : ", e.target.result);
      context._hideWaitingContainer();
      context._addFeaturesFromImportStaticLayer(e.target.result, layerName);
    };
    fReader.readAsText(file);
  }
  /**
   * this method is called by _importStaticLayerFom* method
   * and add features to the map
   *
   * @param {String} fileContent - content file
   * @param {String} layerName - imported layer name
   * @private
   */
  _addFeaturesFromImportStaticLayer(fileContent, layerName) {
    var map = this.getMap();
    if (!map || !fileContent) {
      return;
    }
    var vectorLayer = null;
    var vectorSource = null;
    var vectorFormat = null;
    var vectorStyle = null;
    this.contentStatic = fileContent;
    if (this._currentImportType === "MAPBOX") {
      this._hasMapBoxResults = true;
      var self2 = this;
      var _glStyles = JSON.parse(fileContent);
      map.set("mapbox-style", _glStyles);
      var _glSources = _glStyles.sources;
      var _multiSources = Object.keys(_glSources).length > 1 ? 1 : 0;
      for (var _glSourceId in _glSources) {
        if (_glSources.hasOwnProperty(_glSourceId)) {
          var _title = "";
          var _description = "";
          var _quicklookUrl = null;
          var _legends = null;
          var _metadata = null;
          var _originators = null;
          if (_glStyles.metadata) {
            for (var ns in _glStyles.metadata) {
              if (_glStyles.metadata.hasOwnProperty(ns)) {
                var _keys = ns.split(":");
                if (_keys[0] === "geoportail") {
                  var key = _keys[1];
                  if (key === "title") {
                    _title = _glStyles.metadata[ns];
                    continue;
                  }
                  if (key === "description") {
                    _description = _glStyles.metadata[ns];
                    continue;
                  }
                  if (key === "quicklookUrl") {
                    _quicklookUrl = _glStyles.metadata[ns];
                    continue;
                  }
                  if (key === "legends") {
                    _legends = _glStyles.metadata[ns];
                    continue;
                  }
                  if (key === "metadata") {
                    _metadata = _glStyles.metadata[ns];
                    continue;
                  }
                  if (key === "originators") {
                    _originators = _glStyles.metadata[ns];
                    continue;
                  }
                }
              }
            }
          }
          if (!_title) {
            _title = "Couche MapBox";
          }
          if (!_description) {
            _description = "Couche MapBox";
          }
          _title = _multiSources ? _title + "(" + _glSourceId + ")" : _title;
          var _glSource = _glSources[_glSourceId];
          var _glType = _glSource.type;
          if (_glType === "vector") {
            var _glUrl = _glSource.url;
            var _glTiles = _glSource.tiles;
            var _glSprite = _glStyles.sprite;
            if (_glUrl && _glUrl.indexOf("mapbox://") === 0) {
              var _urlService = this._url;
              if (_urlService) {
                _glTiles = ["a", "b", "c", "d"].map(function(host) {
                  var path = _glUrl.replace("mapbox://", "");
                  var accessToken = _urlService.split("?")[1];
                  return "https://" + host + ".tiles.mapbox.com/v4/" + path + "/{z}/{x}/{y}.vector.pbf?" + accessToken;
                });
                if (_glSprite.indexOf("mapbox://") === 0) {
                  var s = _urlService.split("?");
                  _glStyles.sprite = s[0] + "/sprite?" + s[1];
                }
              } else {
                logger36.warn("Not yet implemented, can't use the local import scheme with a 'mapbox://' in the file.!");
              }
            }
            if (_glTiles) {
              vectorFormat = new MVT_default({
                featureClass: Feature_default
              });
              vectorSource = new VectorTile_default({
                attributions: _glSource.attribution,
                format: vectorFormat,
                // INFO
                // on supprime la grille pour forcer l'utilisation par defaut des tuiles en 512
                // sur du vecteur tuilÃ©
                // tileGrid : olCreateXYZTileGrid({ // TODO scheme tms ?
                //     extent : _glSource.bounds, // [minx, miny, maxx, maxy]
                //     maxZoom : _glSource.maxzoom || 22,
                //     minZoom : _glSource.minzoom || 1,
                //     tileSize : _glSource.tileSize || 256
                // }),
                urls: _glTiles
              });
              vectorSource._title = _title;
              vectorSource._description = _description;
              vectorSource._quicklookUrl = _quicklookUrl;
              vectorSource._metadata = _metadata;
              vectorSource._legends = _legends;
              vectorSource._originators = _originators;
              vectorSource.on("tileloadstart", function(e) {
                self2._loadingContainer.className = "GPmapLoadingVisible";
              });
              vectorSource.on("tileloadend", function(e) {
                self2._loadingContainer.className = "";
              });
              vectorSource.on("tileloaderror", function(e) {
                self2._loadingContainer.className = "";
              });
              vectorLayer = new VectorTile_default2({
                source: vectorSource,
                visible: false,
                // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
                declutter: true
                // TODO utile ?
              });
              vectorLayer.id = _glSourceId;
              vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
            } else if (_glUrl) {
              vectorFormat = new MVT_default({
                featureClass: Feature_default
              });
              vectorLayer = new VectorTile_default2({
                visible: false,
                // zIndex : 0
                declutter: true
              });
              vectorLayer.id = _glSourceId;
              vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
              var vectorTileJson = new TileJSON_default({
                url: _glUrl
              });
              var _key = vectorTileJson.on("change", function() {
                if (vectorTileJson.getState() === "ready") {
                  var _tileJSONDoc = vectorTileJson.getTileJSON();
                  var tiles = Array.isArray(_tileJSONDoc.tiles) ? _tileJSONDoc.tiles : [_tileJSONDoc.tiles];
                  for (var i = 0; i < tiles.length; i++) {
                    var tile2 = tiles[i];
                    if (tile2.indexOf("http") !== 0) {
                      tiles[i] = _glUrl + tile2;
                    }
                  }
                  vectorSource = new VectorTile_default({
                    attributions: vectorTileJson.getAttributions() || _tileJSONDoc.attribution,
                    format: vectorFormat,
                    // tileGrid : olCreateXYZTileGrid({
                    //     extent : _glSource.bounds, // [minx, miny, maxx, maxy]
                    //     maxZoom : _glSource.maxzoom || 22,
                    //     minZoom : _glSource.minzoom || 1,
                    //     tileSize : _glSource.tileSize || 256
                    // }),
                    urls: tiles
                  });
                  vectorSource._title = _title;
                  vectorSource._description = _description;
                  vectorSource._quicklookUrl = _quicklookUrl;
                  vectorSource._metadata = _metadata;
                  vectorSource._legends = _legends;
                  vectorSource._originators = _originators;
                  vectorSource.on("tileloadstart", function(e) {
                    self2._loadingContainer.className = "GPmapLoadingVisible";
                  });
                  vectorSource.on("tileloadend", function(e) {
                    self2._loadingContainer.className = "";
                  });
                  vectorLayer.setSource(vectorSource);
                  vectorLayer.set("mapbox-extension", _tileJSONDoc["vector_layers"]);
                  unByKey(_key);
                }
              });
            }
          } else if (_glType === "geojson") {
            var _glData = _glSource.data;
            vectorFormat = new GeoJSON_default2();
            vectorSource = new VectorTile_default({
              attributions: _glSource.attribution,
              format: vectorFormat,
              url: _glData
            });
            vectorSource._title = _title;
            vectorSource._description = _description;
            vectorSource._quicklookUrl = _quicklookUrl;
            vectorSource._metadata = _metadata;
            vectorSource._legends = _legends;
            vectorSource._originators = _originators;
            vectorLayer = new VectorTile_default2({
              source: vectorSource,
              visible: false,
              // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
              declutter: true
              // TODO utile ?
            });
            vectorLayer.id = _glSourceId;
            vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
          } else {
            logger36.warn("Type MapBox format unknown !");
            return;
          }
          var _glStyle = JSON.parse(JSON.stringify(_glStyles));
          if (_multiSources) {
            var _glLayers = _glStyle.layers;
            for (var ii = 0; ii < _glLayers.length; ii++) {
              var _glLayer = _glLayers[ii];
              if (_glLayer.source !== _glSourceId) {
                _glLayers.splice(ii, 1);
                continue;
              }
            }
            for (var keySource in _glStyle.sources) {
              if (_glStyle.sources.hasOwnProperty(keySource)) {
                if (keySource !== _glSourceId) {
                  delete _glStyle.sources[keySource];
                }
              }
            }
          }
          var params2 = {
            id: _glSourceId,
            styles: _glStyle,
            layer: vectorLayer,
            options: {
              title: layerName || _title,
              description: _description,
              quicklookUrl: _quicklookUrl,
              metadata: _metadata,
              legends: _legends,
              originators: _originators
            }
          };
          (function(p2) {
            var setStyle = () => {
              applyStyle(p2.layer, p2.styles, { source: p2.id }).then(function() {
                var visibility = true;
                p2.layer.setVisible(visibility);
                var opacity = 1;
                p2.layer.setOpacity(opacity);
              }).then(function() {
                var projCode = map.getView().getProjection().getCode();
                if (map.getView() && p2.styles.center && p2.styles.center.length) {
                  map.getView().setCenter(transform(p2.styles.center, "EPSG:4326", projCode));
                }
                if (map.getView() && (p2.styles.zoom || p2.styles.zoom === 0)) {
                  map.getView().setZoom(p2.styles.zoom);
                }
                var source = p2.layer.getSource();
                if (map.getView() && map.getSize()) {
                  var sourceExtent2 = null;
                  if (source && source.getExtent) {
                    sourceExtent2 = source.getExtent();
                  } else {
                    sourceExtent2 = source.getTileGrid().getExtent();
                  }
                  if (sourceExtent2 && sourceExtent2[0] !== Infinity) {
                    map.getView().fit(sourceExtent2, map.getSize());
                  }
                }
              }).then(function() {
                self2._hideFormContainer();
                self2._importPanelHeader.classList.replace("GPelementVisible", "GPelementHidden");
                self2._importPanelHeader.classList.replace("gpf-visible", "gpf-hidden");
                self2._importPanelTitle.innerHTML = "Edition des styles";
                var editor = new Editor_default({
                  target: self2._mapBoxResultsListContainer,
                  style: JSON.parse(JSON.stringify(p2.styles)),
                  // clone
                  scope: this,
                  events: {
                    "editor:onloaded": self2._onLoadedMapBox,
                    // utile ?
                    "editor:layer:onclickvisibility": self2._onChangeVisibilitySourceMapBox,
                    "editor:style:scale:onchangemin": self2._onChangeScaleMinSourceMapBox,
                    "editor:style:scale:onchangemax": self2._onChangeScaleMaxSourceMapBox,
                    "editor:legend:onchangevalue": self2._onChangeLegendValueSourceMapBox,
                    "editor:legend:onclickedition": self2._onDisplayLayerSourceMapBox
                  },
                  tools: self2.options.vectorStyleOptions.MapBox.editor
                });
                editor.setContext("map", map);
                editor.setContext("layer", p2.layer);
                return editor.createElement().then(function() {
                  if (editor.getLayers().length === 0) {
                    throw new Error("Il n'existe pas de styles pour la source demandÃ©e !?");
                  }
                }).then(function() {
                  if (self2.options.vectorStyleOptions.MapBox.display) {
                    self2._importPanelHeader.classList.replace("GPelementHidden", "GPelementVisible");
                    self2._importPanelHeader.classList.replace("gpf-hidden", "gpf-visible");
                    self2._mapBoxPanel.classList.replace("GPelementHidden", "GPelementVisible");
                    self2._mapBoxPanel.classList.replace("gpf-hidden", "gpf-visible");
                    self2._importPanelReturnPicto.classList.replace("GPelementHidden", "GPelementVisible");
                    self2._importPanelReturnPicto.classList.replace("gpf-hidden", "gpf-visible");
                  }
                }).then(function() {
                  var elements = self2._mapBoxResultsListContainer.getElementsByClassName("GPEditorMapBoxLayerTitleLabel");
                  for (let index2 = 0; index2 < elements.length; index2++) {
                    const element = elements[index2];
                    if (element.textContent === "bckgrd") {
                      element.textContent = "Couleur de remplissage";
                    }
                  }
                }).then(function() {
                  p2.layer.set("mapbox-editor", editor.getID());
                  setTimeout(function() {
                    map.dispatchEvent({
                      id: editor.getID(),
                      type: "editor:loaded",
                      style: p2.styles,
                      layer: p2.layer
                    });
                  }, 100);
                }).catch(function(e) {
                  throw e;
                });
              }).then(function() {
                map.dispatchEvent({
                  id: p2.id,
                  type: "render:success",
                  style: p2.styles
                });
              }).catch(function(e) {
                logger36.error(e);
                map.dispatchEvent({
                  id: p2.id,
                  type: "render:failure",
                  error: e
                });
              });
            };
            logger36.warn(p2.layer);
            var styles = map.get("mapbox-styles") || {};
            var id = p2.id;
            styles[id] = p2.styles;
            map.set("mapbox-styles", styles);
            p2.layer.set("mapbox-styles", p2.styles);
            map.addLayer(p2.layer);
            self2.dispatchEvent({
              type: "layerimport:mapbox:added",
              name: layerName,
              data: fileContent,
              layer: p2.layer,
              format: self2._currentImportType.toLowerCase() || "mapbox"
            });
            if (p2.layer.getSource()) {
              setStyle();
            } else {
              p2.layer.once("change:source", setStyle);
            }
            map.getControls().forEach(
              (control) => {
                if (control instanceof LayerSwitcher_default) {
                  control.addLayer(
                    p2.layer,
                    p2.options
                  );
                }
              }
            );
          })(params2);
        }
      }
    } else {
      if (this._currentImportType === "KML") {
        vectorStyle = this.options.vectorStyleOptions.KML.defaultStyle;
        vectorFormat = new KML_default2({
          showPointNames: this.options.vectorStyleOptions.KML.showPointNames,
          extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
          defaultStyle: [
            vectorStyle
          ]
        });
      } else if (this._currentImportType === "GPX") {
        vectorStyle = this.options.vectorStyleOptions.GPX.defaultStyle;
        vectorFormat = new GPX_default2({
          defaultStyle: vectorStyle
        });
      } else if (this._currentImportType === "GeoJSON") {
        vectorStyle = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
        vectorFormat = new GeoJSON_default2({
          defaultStyle: vectorStyle
        });
      }
      var fileProj = vectorFormat.readProjection(fileContent);
      var mapProj = this._getMapProjectionCode();
      var features = null;
      features = vectorFormat.readFeatures(
        fileContent,
        {
          dataProjection: fileProj,
          featureProjection: mapProj
        }
      );
      logger36.log("loaded features : ", features);
      vectorSource = new Vector_default({
        features: new Collection_default()
      });
      vectorSource.addFeatures(features);
      logger36.trace(vectorSource);
      vectorSource._title = vectorSource._description = layerName;
      vectorLayer = new Vector_default2({
        source: vectorSource,
        style: vectorStyle
      });
      vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
      var configControl = vectorFormat.readRootExtensions("geoportail:compute");
      if (configControl && Object.keys(configControl).length !== 0) {
        var authorizedControls = {
          route: { class: Route_default2, name: "itineraire" },
          isocurve: { class: Isocurve_default, name: "isocurve" },
          elevationpath: { class: ElevationPath_default, name: "profil altimetrique" }
        };
        var typeControl = configControl.type;
        var graphControl = configControl.transport;
        if (typeControl) {
          var nameControl = authorizedControls[typeControl].name;
          var titleControl = graphControl ? nameControl + " (" + graphControl + ")" : nameControl;
          var classControl = authorizedControls[typeControl].class;
          if (classControl) {
            vectorLayer.gpResultLayerId = "layerimport:COMPUTE";
            vectorLayer.set("control", typeControl);
            vectorLayer.set("name", nameControl);
            vectorLayer.set("graph", graphControl);
            vectorLayer.set("data", configControl);
            vectorLayer.set("title", titleControl);
            var formatGeoJSON = new GeoJSON_default2({
              defaultStyle: vectorStyle
            });
            var geojson = formatGeoJSON.writeFeatures(features, {
              dataProjection: "EPSG:4326",
              featureProjection: "EPSG:3857"
            });
            vectorLayer.set("geojson", geojson);
            this.getMap().getControls().forEach((control) => {
              if (control instanceof classControl) {
                control.setData(configControl);
                control.setLayer(vectorLayer);
                control.init();
              }
            });
          }
        }
      }
      map.addLayer(vectorLayer);
      if (map.getView() && map.getSize() && vectorSource.getExtent) {
        var sourceExtent = vectorSource.getExtent();
        if (sourceExtent && sourceExtent[0] !== Infinity) {
          map.getView().fit(sourceExtent, map.getSize());
        }
      }
      this.dispatchEvent({
        type: "layerimport:vector:added",
        name: layerName,
        data: fileContent,
        layer: vectorLayer,
        format: this._currentImportType.toLowerCase()
      });
    }
  }
  /**
   * NOT USE : this method is called by _importStaticLayerFom* method
   * and add features to the map
   *
   * @param {String} url - url
   * @param {String} layerName - imported layer name
   * @private
   */
  _addFeaturesFromImportStaticLayerUrl(url, layerName) {
    var map = this.getMap();
    if (!map || !url) {
      return;
    }
    var vectorSource;
    var vectorLayer;
    var vectorFormat;
    if (this._currentImportType === "MAPBOX") {
      logger36.trace("Not yet implemented !");
    } else {
      if (this._currentImportType === "KML") {
        vectorFormat = new KML_default2({
          showPointNames: true,
          // FIXME option !
          extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
          defaultStyle: [
            this.options.vectorStyleOptions.KML.defaultStyle
          ]
        });
      } else if (this._currentImportType === "GPX") {
        vectorFormat = new GPX_default2({
          defaultStyle: this.options.vectorStyleOptions.GPX.defaultStyle
        });
      } else if (this._currentImportType === "GeoJSON") {
        vectorFormat = new GeoJSON_default2({
          defaultStyle: this.options.vectorStyleOptions.GeoJSON.defaultStyle
        });
      }
      vectorSource = new Vector_default({
        url,
        format: vectorFormat
      });
      if (this._currentImportType === "GPX") {
        vectorSource.forEachFeature(
          function(feature) {
            if (feature.getStyle() == null) {
              logger36.log("[ol.control.LayerImport] set default style for GPX feature");
              feature.setStyle(
                this.options.vectorStyleOptions.GPX.defaultStyle
              );
            }
          }
        );
      }
      if (this._currentImportType === "GeoJSON") {
        vectorSource.forEachFeature(
          function(feature) {
            if (feature.getStyle() == null) {
              logger36.log("[ol.control.LayerImport] set default style for GeoJSON feature");
              feature.setStyle(
                this.options.vectorStyleOptions.GeoJSON.defaultStyle
              );
            }
          }
        );
      }
      vectorSource._title = vectorSource._description = layerName;
      vectorLayer = new Vector_default2({
        source: vectorSource
      });
    }
    vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
    map.addLayer(vectorLayer);
    if (map.getView() && map.getSize() && vectorSource.getExtent) {
      var sourceExtent = vectorSource.getExtent();
      if (sourceExtent && sourceExtent[0] !== Infinity) {
        map.getView().fit(sourceExtent, map.getSize());
      }
    }
    this.dispatchEvent({
      type: "layerimport:vector:added",
      name: layerName,
      url,
      layer: vectorLayer,
      format: this._currentImportType.toLowerCase()
    });
  }
  // Events MapBox DOM
  /**
   * this method is called when the editor is loaded
   *
   * @param {Object} e - editor
   * @private
   */
  _onLoadedMapBox(e) {
  }
  /**
   * this method is called on '_addImportMapBoxVisibilitySource' input click
   * and change visibility source to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onChangeVisibilitySourceMapBox(e) {
    var data = e.target.data.obj;
    var target2 = e.target.srcElement;
    var map = this.getContext("map");
    var layer = this.getContext("layer");
    if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
      var styles = layer.get("mapbox-styles");
      var layerMapBox;
      var layers = styles.layers;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].id === data.id) {
          var layout = layers[i].layout;
          if (layout) {
            layout.visibility = target2.checked ? "visible" : "none";
          } else {
            layers[i].layout = {
              visibility: target2.checked ? "visible" : "none"
            };
          }
          layerMapBox = layers[i];
          break;
        }
      }
      updateMapboxLayer(map, layerMapBox);
      Promise.resolve();
    }
  }
  /**
   * this method is called on '_addImportMapBoxScaleSource' input slide
   * and change zoom source to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onChangeScaleMinSourceMapBox(e) {
    var data = e.target.data.obj;
    var target2 = e.target.srcElement;
    var map = this.getContext("map");
    var layer = this.getContext("layer");
    if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
      var styles = layer.get("mapbox-styles");
      var layerMapBox;
      var layers = styles.layers;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].id === data.id) {
          layers[i].minzoom = target2.value;
          target2.title = target2.value;
          layerMapBox = layers[i];
          break;
        }
      }
      updateMapboxLayer(map, layerMapBox);
      Promise.resolve();
    }
  }
  /**
   * this method is called on '_addImportMapBoxScaleSource' input slide
   * and change zoom source to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onChangeScaleMaxSourceMapBox(e) {
    var data = e.target.data.obj;
    var target2 = e.target.srcElement;
    var map = this.getContext("map");
    var layer = this.getContext("layer");
    if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
      var styles = layer.get("mapbox-styles");
      var layerMapBox;
      var layers = styles.layers;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].id === data.id) {
          layers[i].maxzoom = target2.value;
          target2.title = target2.value;
          layerMapBox = layers[i];
          break;
        }
      }
      updateMapboxLayer(map, layerMapBox);
      Promise.resolve();
    }
  }
  /**
   * this method is called on ''
   * and change zoom source to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onChangeLegendValueSourceMapBox(e) {
    var data = e.target.data.obj;
    var target2 = e.target.srcElement;
    var map = this.getContext("map");
    var layer = this.getContext("layer");
    if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
      var styles = layer.get("mapbox-styles");
      var layerMapBox;
      var layers = styles.layers;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].id === data.id) {
          var paint = layers[i].paint;
          if (paint) {
            paint[target2.dataset.id] = target2.value;
          }
          layerMapBox = layers[i];
          break;
        }
      }
      updateMapboxLayer(map, layerMapBox);
      Promise.resolve();
    }
  }
  /**
   * this method is called on ''
   * and change zoom source to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onDisplayLayerSourceMapBox(e) {
    var data = e.target.data.obj;
    var layer = this.getContext("layer");
    if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
      var idDOM = e.target.currentTarget.parentNode.id;
      var id = idDOM.substring(idDOM.indexOf("-") + 1, idDOM.indexOf("_"));
      var l3 = this.getLayer(id);
      l3.collapse();
    }
  }
  // ################################################################### //
  // #################### Import WMS/WMTS layers ####################### //
  // ################################################################### //
  /**
   * this method is called by this_onImportSubmit method
   * and call getCap service from specified url, then display layers list in new panel
   *
   * @private
   */
  _importServiceLayers() {
    if (this._currentImportType === "WFS") {
      logger36.warn("[ol.control.LayerImport] WFS layer import is not implemented yet");
      return;
    }
    this.cleanGetCapResultsList();
    var url = this._getCapRequestUrl = this._serviceUrlImportInput.value;
    if (!url) {
      logger36.error("[ol.control.LayerImport] url parameter is mandatory");
      return;
    }
    logger36.log("url : ", url);
    if (url.trim) {
      url = url.trim();
    }
    var questionMarkIndex = url.indexOf("?");
    if (questionMarkIndex < 0) {
      url += "?SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
    } else if (questionMarkIndex === url.length - 1) {
      url += "SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
    }
    if (this.options.webServicesOptions && this.options.webServicesOptions.proxyUrl) {
      url = ProxyUtils_default.proxifyUrl(url, this.options.webServicesOptions);
    }
    this._displayWaitingContainer();
    var context = this;
    Gp_default.Protocols.XHR.call({
      url,
      method: "GET",
      timeOut: 15e3,
      // on success callback : display results in container
      onResponse: function(response) {
        context._hideWaitingContainer();
        context._displayGetCapResponseLayers(response);
      },
      // on error callback : log error
      onFailure: function(error) {
        context._hideWaitingContainer();
        logger36.error("[ol.control.LayerImport] getCapabilities request failed : ", error);
      }
    });
  }
  /**
   * this method is called by this._importServiceLayers method
   * and display layers list from getcapabilities response
   *
   * @param {Object} xmlResponse - getCapabilities response (xml format)
   * @private
   */
  _displayGetCapResponseLayers(xmlResponse) {
    var parser;
    var layers;
    var layerDescription = {
      content: null,
      title: null
    };
    var projection;
    this._getCapResponseWMSLayers = [];
    this.contentService = xmlResponse;
    this._hideFormContainer();
    this._getCapPanel.classList.replace("GPelementHidden", "GPelementVisible");
    this._getCapPanel.classList.replace("gpf-hidden", "gpf-visible");
    this._importPanelTitle.innerHTML = "Couches accessibles";
    this._importPanelReturnPicto.classList.replace("GPelementHidden", "GPelementVisible");
    this._importPanelReturnPicto.classList.replace("gpf-hidden", "gpf-visible");
    this._hasGetCapResults = true;
    if (this._currentImportType === "WMS") {
      parser = new WMSCapabilities_default();
      var getCapResponseWMS = this._getCapResponseWMS = parser.read(xmlResponse);
      logger36.log("getCapabilities response : ", getCapResponseWMS);
      if (getCapResponseWMS && getCapResponseWMS.Capability && getCapResponseWMS.Capability.Layer) {
        var getCapLayer = getCapResponseWMS.Capability.Layer;
        if (Array.isArray(getCapLayer)) {
          for (var i = 0; i < getCapLayer.length; i++) {
            this._displayGetCapResponseWMSLayer(getCapLayer[i]);
          }
        } else {
          this._displayGetCapResponseWMSLayer(getCapLayer);
        }
      }
    } else if (this._currentImportType === "WMTS") {
      parser = new WMTSCapabilities_default();
      var getCapResponseWMTS = this._getCapResponseWMTS = parser.read(xmlResponse);
      logger36.log("getCapabilities response : ", getCapResponseWMTS);
      if (getCapResponseWMTS && getCapResponseWMTS.Contents && getCapResponseWMTS.Contents.Layer) {
        layers = getCapResponseWMTS.Contents.Layer;
        if (Array.isArray(layers)) {
          this._getCapResponseWMTSLayers = layers;
          for (var j2 = 0; j2 < layers.length; j2++) {
            projection = this._getWMTSLayerProjection(layers[j2], getCapResponseWMTS);
            if (projection && typeof projection === "string") {
              if (get2(projection) || get2(projection.toUpperCase())) {
                layerDescription = {
                  content: layers[j2].Title,
                  title: layers[j2].Abstract || layers[j2].Title
                };
                if (this._getCapResultsListContainer) {
                  this._addImportGetCapResultLayer(layerDescription, j2, this._getCapResultsListContainer);
                }
              } else {
                logger36.warn("[ol.control.LayerImport] wmts layer cannot be added to map : unknown projection", layers[j2]);
                continue;
              }
            }
          }
        }
      }
    }
  }
  /**
   * this method is called by this._displayGetCapResponseLayers method
   * and display WMS layer in list from getcapabilities response
   *
   * @param {Object} layerObj - object corresponding to <Layer> content in WMS GetCapabilities response
   * @param {Object} [parentLayersInfos] - object corresponding to parents <Layer> content in WMS GetCapabilities response (without children <Layer> infos)
   * @private
   */
  _displayGetCapResponseWMSLayer(layerObj, parentLayersInfos) {
    if (!layerObj) {
      logger36.warn("[ol.control.LayerImport] _displayGetCapResponseWMSLayer : getCapabilities layer object not found");
      return;
    }
    logger36.log("[ol.control.LayerImport] _displayGetCapResponseWMSLayer - layerObj : ", layerObj);
    var mapProjCode = this._getMapProjectionCode();
    var projection;
    var layerDescription = {
      content: null,
      title: null
    };
    if (parentLayersInfos) {
      var key;
      var i;
      var addKeys = [
        "CRS",
        "Style"
        // "AuthorityURL" // TODO
      ];
      for (i = 0; i < addKeys.length; i++) {
        key = addKeys[i];
        if (Array.isArray(parentLayersInfos[key]) && parentLayersInfos[key].length !== 0) {
          if (Array.isArray(layerObj[key]) && layerObj[key].length !== 0) {
            for (var n = 0; n < parentLayersInfos[key].length; n++) {
              if (layerObj[key].indexOf(parentLayersInfos[key][n]) === -1) {
                layerObj[key].push(parentLayersInfos[key][n]);
              }
            }
          } else {
            layerObj[key] = parentLayersInfos[key];
          }
        }
      }
      var replaceKeys = [
        "BoundingBox",
        "EX_GeographicBoundingBox",
        "MaxScaleDenominator",
        "MinScaleDenominator",
        "Attribution",
        "Dimension",
        "queryable",
        "cascaded",
        "opaque",
        "noSubsets",
        "fixedWidth",
        "fixedHeight"
      ];
      for (i = 0; i < replaceKeys.length; i++) {
        key = replaceKeys[i];
        if (parentLayersInfos[key] && !layerObj[key]) {
          layerObj[key] = parentLayersInfos[key];
        }
      }
    } else {
      layerObj._isRootLayer = true;
      layerObj._container = this._getCapResultsListContainer;
      if (!layerObj.Title) {
        layerObj.Title = "Liste des couches";
      }
    }
    if (layerObj.Layer) {
      if (Array.isArray(layerObj.Layer)) {
        var _container = layerObj ? layerObj._container : parentLayersInfos._container;
        var _title = layerObj ? layerObj.Title : parentLayersInfos.Title;
        layerObj._container = this._addImportGetCapResultListRubrique(_title, _container).lastChild;
        for (var j2 = 0; j2 < layerObj.Layer.length; j2++) {
          var bRubriqueExist = false;
          var lstRubrique = layerObj._container.getElementsByClassName("GPimportGetCapRubriqueTitle");
          for (var ii = 0; ii < lstRubrique.length; ii++) {
            if (lstRubrique[ii].title === layerObj.Title) {
              bRubriqueExist = true;
              layerObj.Layer[j2]._container = lstRubrique[ii].parentElement;
            }
          }
          if (!bRubriqueExist) {
            layerObj.Layer[j2]._container = this._addImportGetCapResultRubrique(layerObj.Title, layerObj._container).lastChild;
          }
          this._displayGetCapResponseWMSLayer(layerObj.Layer[j2], layerObj);
        }
      }
    } else {
      var lastIndex = this._getCapResponseWMSLayers.length;
      projection = this._getWMSLayerProjection(layerObj, mapProjCode);
      if (!projection) {
        logger36.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection", layerObj);
      } else {
        layerObj._projection = projection;
        layerDescription = {
          content: layerObj.Title,
          title: layerObj.Abstract || layerObj.Title
        };
        var _isGoodContainer = layerObj._container;
        if (_isGoodContainer.localName === "ul") {
          _isGoodContainer = _isGoodContainer.lastChild;
        }
        this._addImportGetCapResultLayer(layerDescription, lastIndex, _isGoodContainer);
        this._getCapResponseWMSLayers[lastIndex] = layerObj;
      }
    }
  }
  /**
   * this method is called on 'GPimportGetCapProposal' div click
   * and add corresponding layer to map
   *
   * @param {Event} e - HTMLElement
   * @private
   */
  _onGetCapResponseLayerClick(e) {
    if (e.target && e.target.id) {
      var proposalId = parseInt(e.target.id.substr(23), 10);
      if (isNaN(proposalId)) {
        return;
      }
      var layerInfo;
      if (this._currentImportType === "WMS") {
        layerInfo = this._getCapResponseWMSLayers[proposalId];
        this._addGetCapWMSLayer(layerInfo);
      } else if (this._currentImportType === "WMTS") {
        layerInfo = this._getCapResponseWMTSLayers[proposalId];
        this._addGetCapWMTSLayer(layerInfo);
      }
    }
  }
  // ################################################################### //
  // ######### create WMS layer from getCapabilities response ######### //
  // ################################################################### //
  /**
   * this method is called by this._onGetCapResponseLayerClick
   * and add WMS layer to map using parameters from getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @private
   */
  _addGetCapWMSLayer(layerInfo) {
    var map = this.getMap();
    if (!map) {
      logger36.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : map is not defined");
      return;
    }
    if (!layerInfo) {
      logger36.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : layerInfo is not defined");
      return;
    }
    var mapProjCode = this._getMapProjectionCode();
    var wmsSourceOptions = {};
    var getMapUrl = this._getWMSLayerGetMapUrl();
    if (getMapUrl) {
      wmsSourceOptions.url = getMapUrl;
    } else {
      var questionMarkIndex = this._getCapRequestUrl.indexOf("?");
      if (questionMarkIndex !== -1) {
        wmsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
      } else {
        wmsSourceOptions.url = this._getCapRequestUrl;
      }
    }
    layerInfo.Url = getMapUrl || wmsSourceOptions.url;
    wmsSourceOptions.params = {};
    if (layerInfo.Name) {
      wmsSourceOptions.params["LAYERS"] = layerInfo.Name;
    } else {
      logger36.warn("[ol.control.LayerImport] unable to add wms layer : mandatory layer 'name' parameter cannot be found", layerInfo);
      return;
    }
    wmsSourceOptions.params["SERVICE"] = "WMS";
    if (this._getCapResponseWMS.version) {
      wmsSourceOptions.params["VERSION"] = this._getCapResponseWMS.version;
    }
    layerInfo.Version = this._getCapResponseWMS.version;
    var projection = layerInfo._projection;
    if (!projection) {
      logger36.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection");
      return;
    } else if (projection !== mapProjCode) {
      wmsSourceOptions.projection = projection;
    }
    layerInfo.Projection = projection || wmsSourceOptions.projection;
    var legend;
    if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
      var style = layerInfo.Style[0];
      wmsSourceOptions.params["STYLES"] = style.Name;
      if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
        legend = style.LegendURL[0].OnlineResource;
      }
    }
    var wmsSource = new TileWMS_default(wmsSourceOptions);
    this._getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource);
    var layerTileOptions = {};
    layerTileOptions["source"] = wmsSource;
    this._getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions);
    this._getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions);
    var wmsLayer = new Tile_default(layerTileOptions);
    wmsLayer.setExtent(layerTileOptions.extent);
    wmsLayer.gpResultLayerId = "layerimport:WMS";
    if (layerInfo.queryable) {
      wmsLayer.gpGFIparams = {
        queryable: true
      };
      if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetFeatureInfo && this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format && Array.isArray(this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format)) {
        wmsLayer.gpGFIparams.formats = this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format;
      }
    }
    map.addLayer(wmsLayer);
    if (map.getView() && map.getSize() && wmsLayer.getExtent) {
      var sourceExtent = wmsLayer.getExtent();
      if (sourceExtent && sourceExtent[0] !== Infinity) {
        map.getView().fit(sourceExtent, map.getSize());
      }
    }
    this.dispatchEvent({
      type: "layerimport:service:added",
      name: layerInfo.Name,
      data: layerInfo,
      layer: wmsLayer,
      format: "wms"
    });
  }
  /**
   * this method is called by this._addGetCapWMSLayer
   * and gets service getMap request url
   *
   * @returns {String} getmapurl - service getMap request url
   * @private
   */
  _getWMSLayerGetMapUrl() {
    var getmapurl;
    if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetMap) {
      var getmap = this._getCapResponseWMS.Capability.Request.GetMap;
      if (getmap.DCPType && Array.isArray(getmap.DCPType) && getmap.DCPType.length !== 0) {
        var url = getmap.DCPType[0];
        if (url && url.HTTP && url.HTTP.Get) {
          getmapurl = url.HTTP.Get.OnlineResource;
        }
      }
    }
    return getmapurl;
  }
  /**
   * this method is called by this._addGetCapWMSLayer
   * and gets a projection both available for a given layer and already defined in proj4js (ol.proj)
   * (openlayers raster reprojection will be then able to reproject layer in map projection)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @returns {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
   * @private
   */
  _getWMSLayerProjection(layerInfo, mapProjCode) {
    var projection;
    if (!layerInfo || typeof layerInfo !== "object") {
      logger36.warn("missing layer information (from getCapabilities)");
      return;
    }
    var CRSList = layerInfo.CRS;
    if (Array.isArray(CRSList)) {
      if (CRSList.includes(mapProjCode)) {
        projection = mapProjCode;
        return projection;
      }
      var layerCRS, i;
      for (i = 0; i < CRSList.length; i++) {
        layerCRS = CRSList[i];
        if (layerCRS && typeof layerCRS === "string") {
          if (get2(layerCRS) || get2(layerCRS.toUpperCase())) {
            projection = layerCRS;
            return projection;
          }
        }
      }
    }
    return projection;
  }
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets minResolution and maxResolution parameters for WMS layer (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
   * @private
   */
  _getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions) {
    var mapUnits = get2(mapProjCode).getUnits();
    if (mapUnits === "m") {
      if (layerInfo.MinScaleDenominator) {
        layerTileOptions.minResolution = layerInfo.MinScaleDenominator * 28e-5;
      }
      if (layerInfo.MaxScaleDenominator) {
        layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * 28e-5;
      }
    } else if (mapUnits === "degrees") {
      var cste = 28e-5 * 180 / (Math.PI * 6378137);
      if (layerInfo.MinScaleDenominator) {
        layerTileOptions.minResolution = layerInfo.MinScaleDenominator * cste;
      }
      if (layerInfo.MaxScaleDenominator) {
        layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * cste;
      }
    }
  }
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets extent for WMS layer in map projection (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
   * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
   * @private
   */
  _getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions) {
    if (!layerInfo) {
      logger36.warn("[ol.control.LayerImport] _getWMSLayerExtent error : layerInfo is not defined");
      return;
    }
    var exGeographicBoundingBox = layerInfo["EX_GeographicBoundingBox"];
    var boundingBox = layerInfo.BoundingBox;
    if (exGeographicBoundingBox && Array.isArray(exGeographicBoundingBox)) {
      if (mapProjCode === "EPSG:4326") {
        layerTileOptions.extent = exGeographicBoundingBox;
      } else {
        layerTileOptions.extent = transformExtent(exGeographicBoundingBox, "EPSG:4326", mapProjCode);
      }
    } else if (boundingBox && Array.isArray(boundingBox)) {
      var crs;
      var extent;
      for (var i = 0; i < boundingBox.length; i++) {
        crs = boundingBox[i].crs;
        extent = boundingBox[i].extent;
        if (crs) {
          if (crs === mapProjCode) {
            layerTileOptions.extent = extent;
            break;
          } else {
            if (typeof crs === "string") {
              var olProj = get2(crs) ? get2(crs) : get2(crs.toUpperCase());
              if (olProj) {
                if (olProj.getUnits() === "degrees" && crs.toUpperCase().indexOf("EPSG") === 0) {
                  var reversedExtent = [extent[1], extent[0], extent[3], extent[2]];
                  layerTileOptions.extent = transformExtent(reversedExtent, olProj, mapProjCode);
                } else {
                  layerTileOptions.extent = transformExtent(extent, olProj, mapProjCode);
                }
                break;
              }
            }
          }
        }
      }
    }
  }
  /**
   * this method is called by this._addGetCapWMSLayer
   * and sets more information about layer (legends, title, description, metadata, originators) for layerSwitcher or attributions controls
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {String} legend - legend url
   * @param {Object} wmsSource - options for ol.source.TileWMS (to be filled)
   * @private
   */
  _getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource) {
    if (layerInfo.Title) {
      wmsSource._title = layerInfo.Title;
      wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
    } else {
      wmsSource._title = layerInfo.Name;
      wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Name;
    }
    if (legend) {
      wmsSource._legends = [{
        url: legend
      }];
    }
    if (layerInfo.MetadataURL && Array.isArray(layerInfo.MetadataURL)) {
      wmsSource._metadata = [];
      for (var i = 0; i < layerInfo.MetadataURL.length; i++) {
        var metadata = layerInfo.MetadataURL[i].OnlineResource;
        if (metadata) {
          wmsSource._metadata.push({
            url: metadata
          });
        }
      }
    }
    if (layerInfo.Attribution) {
      var attribution = layerInfo.Attribution;
      wmsSource._originators = {};
      if (attribution.OnlineResource) {
        wmsSource._originators.url = attribution.OnlineResource;
      }
      if (attribution.Title) {
        wmsSource._originators.name = wmsSource._originators.attribution = attribution.Title;
      }
      if (attribution.LogoURL && attribution.LogoURL.OnlineResource) {
        wmsSource._originators.logo = attribution.LogoURL.OnlineResource;
      }
    }
  }
  // ################################################################### //
  // ######### create WMTS layer from getCapabilities response ######### //
  // ################################################################### //
  /**
   * this method is called by this._onGetCapResponseLayerClick
   * and add WMTS layer to map using parameters from getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @private
   */
  _addGetCapWMTSLayer(layerInfo) {
    if (!layerInfo || !layerInfo.Identifier) {
      logger36.warn("[ol.control.LayerImport] layer information not found in getCapabilities response for layer ");
      return;
    }
    var map = this.getMap();
    if (!map) {
      return;
    }
    var wmtsSourceOptions = {};
    wmtsSourceOptions.layer = layerInfo.Identifier;
    if (this._getCapResponseWMTS.version) {
      wmtsSourceOptions.version = this._getCapResponseWMTS.version;
    }
    layerInfo.Version = wmtsSourceOptions.version;
    var getMapUrl = this._getWMTSLayerGetTileUrl();
    if (getMapUrl) {
      wmtsSourceOptions.url = getMapUrl;
    } else {
      var questionMarkIndex = this._getCapRequestUrl.indexOf("?");
      if (questionMarkIndex !== -1) {
        wmtsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
      } else {
        wmtsSourceOptions.url = this._getCapRequestUrl;
      }
    }
    layerInfo.Url = getMapUrl || wmtsSourceOptions.url;
    var tmsOptions = this._getTMSParams(layerInfo);
    wmtsSourceOptions.matrixSet = tmsOptions.tms;
    wmtsSourceOptions.projection = tmsOptions.projCode;
    wmtsSourceOptions.tileGrid = new WMTS_default({
      resolutions: tmsOptions.resolutions,
      matrixIds: tmsOptions.matrixIds,
      origin: tmsOptions.origin
    });
    layerInfo.MatrixIds = tmsOptions.matrixIds;
    layerInfo.Projection = wmtsSourceOptions.projection;
    layerInfo.Resolutions = tmsOptions.resolutions;
    layerInfo.Origin = tmsOptions.origin;
    var defaultStyle;
    var legend;
    if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
      var style;
      for (var s = 0; s < layerInfo.Style.length; s++) {
        style = layerInfo.Style[s];
        defaultStyle = style.Identifier;
        if (style.isDefault) {
          break;
        }
        if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
          legend = style.LegendURL[0].href;
        }
      }
    }
    if (defaultStyle == null) {
      logger36.warn("[ol.control.LayerImport] style information not found in getCapabilities response for layer " + layerInfo.Identifier);
    }
    wmtsSourceOptions.style = defaultStyle;
    var format;
    if (layerInfo.Format && Array.isArray(layerInfo.Format)) {
      format = layerInfo.Format[0];
    }
    if (format == null) {
      logger36.warn("[ol.control.LayerImport] format information not found in getCapabilities response for layer " + layerInfo.Identifier);
    }
    wmtsSourceOptions.format = format;
    var wmtsSource = new WMTS_default2(wmtsSourceOptions);
    if (layerInfo.Title) {
      wmtsSource._title = layerInfo.Title;
      wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
    } else {
      wmtsSource._title = layerInfo.Identifier;
      wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Identifier;
    }
    if (legend) {
      wmtsSource._legends = [{
        url: legend
      }];
    }
    var layerTileOptions = {};
    layerTileOptions.source = wmtsSource;
    layerTileOptions.extent = this._getWMTSLayerExtent(layerInfo);
    var wmtsLayer;
    try {
      wmtsLayer = new Tile_default(layerTileOptions);
      wmtsLayer.setExtent(layerTileOptions.extent);
    } catch (e) {
      logger36.warn("[ol.control.LayerImport] an error occured while trying to create ol.layer.Tile from getCapabilities information. error : ", e);
      return;
    }
    wmtsLayer.gpResultLayerId = "layerimport:WMTS";
    map.addLayer(wmtsLayer);
    if (map.getView() && map.getSize() && wmtsLayer.getExtent) {
      var sourceExtent = wmtsLayer.getExtent();
      if (sourceExtent && sourceExtent[0] !== Infinity) {
        map.getView().fit(sourceExtent, map.getSize());
      }
    }
    this.dispatchEvent({
      type: "layerimport:service:added",
      name: layerInfo.Identifier,
      data: layerInfo,
      layer: wmtsLayer,
      format: "wmts"
    });
  }
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and gets service getTile request url
   *
   * @returns {String} gettileurl - service getTile request url
   * @private
   */
  _getWMTSLayerGetTileUrl() {
    var gettileurl;
    if (this._getCapResponseWMTS && this._getCapResponseWMTS.OperationsMetadata && this._getCapResponseWMTS.OperationsMetadata.GetTile) {
      var gettile = this._getCapResponseWMTS.OperationsMetadata.GetTile;
      if (gettile.DCP && gettile.DCP.HTTP && gettile.DCP.HTTP.Get && Array.isArray(gettile.DCP.HTTP.Get) && gettile.DCP.HTTP.Get.length !== 0) {
        gettileurl = gettile.DCP.HTTP.Get[0].href;
      }
    }
    return gettileurl;
  }
  /**
   * this method is called by this._displayGetCapResponseLayers
   * and gets layer TileMatrixSet projection if defined in proj4js
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @param {Object} getCapResponseWMTS - whole getCapabilities response
   * @returns {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
   * @private
   */
  _getWMTSLayerProjection(layerInfo, getCapResponseWMTS) {
    var projection;
    if (!layerInfo || typeof layerInfo !== "object") {
      logger36.warn("missing layer information (from getCapabilities)");
      return;
    }
    if (!getCapResponseWMTS || typeof getCapResponseWMTS !== "object") {
      logger36.warn("missing getCapabilities response");
      return;
    }
    if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
      var tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
      var crs;
      if (getCapResponseWMTS.Contents && Array.isArray(getCapResponseWMTS.Contents.TileMatrixSet)) {
        var tileMatrixSets = getCapResponseWMTS.Contents.TileMatrixSet;
        for (var i = 0; i < tileMatrixSets.length; i++) {
          if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
            var tileMatrixSet = tileMatrixSets[i];
            crs = tileMatrixSet.SupportedCRS;
            if (crs && typeof crs === "string") {
              if (get2(crs) || get2(crs.toUpperCase())) {
                projection = crs;
              }
            }
            break;
          }
        }
      }
    }
    ;
    return projection;
  }
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and get ol.tileGrid.WMTS parameters using getCapabilities response
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @returns {Object} tmsOptions - ol.tileGrid.WMTS options
   * @private
   */
  _getTMSParams(layerInfo) {
    var tmsOptions = {};
    var matrixIds = [];
    var resolutions = [];
    var origin = [];
    var tms;
    var projCode;
    var projection;
    var map = this.getMap();
    if (!map) {
      return;
    }
    if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
      tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
      if (this._getCapResponseWMTS.Contents && Array.isArray(this._getCapResponseWMTS.Contents.TileMatrixSet)) {
        var tileMatrixSets = this._getCapResponseWMTS.Contents.TileMatrixSet;
        for (var i = 0; i < tileMatrixSets.length; i++) {
          if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
            var tileMatrixSet = tileMatrixSets[i];
            var tilematrix;
            var id;
            var scaledenominator;
            var resolution;
            var units;
            if (tileMatrixSet.SupportedCRS) {
              projCode = tileMatrixSet.SupportedCRS;
              projection = get2(projCode);
            }
            if (projection && projection.getUnits) {
              units = projection.getUnits();
            }
            if (Array.isArray(tileMatrixSet.TileMatrix)) {
              for (var j2 = 0; j2 < tileMatrixSet.TileMatrix.length; j2++) {
                tilematrix = tileMatrixSet.TileMatrix[j2];
                if (tilematrix.Identifier != null) {
                  id = parseInt(tilematrix.Identifier, 10);
                  matrixIds.push(id);
                }
                scaledenominator = tilematrix.ScaleDenominator;
                if (units === "degrees") {
                  resolution = scaledenominator * 28e-5 * 180 / (Math.PI * 6378137);
                } else {
                  resolution = scaledenominator * 28e-5;
                }
                resolutions.push(resolution);
                origin = tilematrix.TopLeftCorner;
              }
            }
            if (resolutions.sort !== void 0) {
              resolutions.sort(
                function(x3, y3) {
                  return y3 - x3;
                }
              );
            }
            if (matrixIds.sort !== void 0) {
              matrixIds.sort(
                function(x3, y3) {
                  return x3 - y3;
                }
              );
            }
          }
        }
      } else {
        logger36.warn("[ol.control.LayerImport] TileMatrixSet data not found in getCapabilities response for layer " + layerInfo.Identifier);
      }
    } else {
      return;
    }
    tmsOptions.tms = tms;
    tmsOptions.projCode = projCode;
    tmsOptions.matrixIds = matrixIds;
    tmsOptions.resolutions = resolutions;
    tmsOptions.origin = origin;
    return tmsOptions;
  }
  /**
   * this method is called by this._addGetCapWMTSLayer
   * and sets extent for WMTS layer in map projection (if available in getCapabilities response)
   *
   * @param {Object} layerInfo - layer information from getCapabilities response
   * @returns {Array} extent - layer extent
   * @private
   */
  _getWMTSLayerExtent(layerInfo) {
    var extent;
    var mapProjCode = this._getMapProjectionCode();
    if (layerInfo.WGS84BoundingBox && Array.isArray(layerInfo.WGS84BoundingBox)) {
      extent = transformExtent(layerInfo.WGS84BoundingBox, "EPSG:4326", mapProjCode);
    }
    return extent;
  }
  // ################################################################### //
  // ################################ utils ############################ //
  // ################################################################### //
  /**
   * gets control map projection code
   *
   * @returns {String} mapProjCode - control map projection code (e.g. "EPSG:3857")
   * @private
   */
  _getMapProjectionCode() {
    var map = this.getMap();
    if (!map || !map.getView || !map.getView().getProjection) {
      logger36.warn("unable to get layerimport's map");
      return;
    }
    var mapProjCode = map.getView().getProjection().getCode();
    return mapProjCode;
  }
  // ################################################################### //
  // ################################ clean ############################ //
  // ################################################################### //
  /**
   * this method displays waiting container and sets a timeout
   *
   * @private
   */
  _displayWaitingContainer() {
    this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
    this._waiting = true;
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
    var context = this;
    this._timer = setTimeout(function() {
      if (context._waiting === true) {
        context._hideWaitingContainer();
      } else {
        if (context._timer) {
          clearTimeout(context._timer);
        }
      }
    }, 16e3);
  }
  /**
   * this method hides waiting container and clears timeout
   *
   * @private
   */
  _hideWaitingContainer() {
    if (this._waiting) {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
      this._waiting = false;
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  /**
   * @private
   */
  _displayFormContainer() {
    this._formContainer.classList.replace("GPelementHidden", "GPelementVisible");
    this._formContainer.classList.replace("gpf-hidden", "gpf-visible");
    this._importPanelTitle.innerHTML = "Import de donnÃ©es";
  }
  /**
   * @private
   */
  _hideFormContainer() {
    this._formContainer.classList.replace("GPelementVisible", "GPelementHidden");
    this._formContainer.classList.replace("gpf-visible", "gpf-hidden");
  }
  /**
   * this method empties getCap results list (DOM element)
   *
   * @private
   */
  cleanGetCapResultsList() {
    this._hasGetCapResults = false;
    this._getCapRequestUrl = null;
    this._getCapResponseWMS = null;
    this._getCapResponseWMTS = null;
    this._getCapResponseWMSLayers = null;
    this._getCapResponseWMTSLayers = null;
    if (this._getCapResultsListContainer) {
      while (this._getCapResultsListContainer.firstChild) {
        this._getCapResultsListContainer.removeChild(this._getCapResultsListContainer.firstChild);
      }
    }
  }
  /**
   * this method empties MapBox results list (DOM element)
   *
   * @private
   */
  cleanMapBoxResultsList() {
    this._hasMapBoxResults = false;
    if (this._mapBoxResultsListContainer) {
      while (this._mapBoxResultsListContainer.firstChild) {
        this._mapBoxResultsListContainer.removeChild(this._mapBoxResultsListContainer.firstChild);
      }
    }
  }
  /**
   * this method empties MapBox results list (DOM element)
   *
   * @param {*} id - DOM id
   * @private
   */
  cleanMapBoxResults(id) {
    this._hasMapBoxResults = false;
    if (this._mapBoxResultsListContainer) {
      var nodes = this._mapBoxResultsListContainer.childNodes;
      for (let index2 = 0; index2 < nodes.length; index2++) {
        const element = nodes[index2];
        if (element.id === "GPEditorMapBoxContainer_ID_" + id) {
          element.remove();
        }
      }
    }
  }
};
/**
* Default styles applyied to KML, GPX and GeoJSON features.
*
* @private
*/
__publicField(_LayerImport, "DefaultStyles", {
  image: new Icon_default({
    src: Markers_default["lightOrange"],
    anchor: [25.5, 38],
    anchorOrigin: "top-left",
    anchorXUnits: "pixels",
    anchorYUnits: "pixels"
  }),
  stroke: new Stroke_default({
    color: "rgba(0,42,80,0.8)",
    width: 4
  }),
  fill: new Fill_default({
    color: "rgba(0, 183, 152, 0.5)"
  }),
  text: new Text_default({
    font: "16px Sans",
    textAlign: "left",
    fill: new Fill_default({
      color: "rgba(255, 255, 255, 1)"
    }),
    stroke: new Stroke_default({
      color: "rgba(0, 0, 0, 1)",
      width: 2
    })
  })
});
var LayerImport = _LayerImport;
Object.assign(LayerImport.prototype, LayerImportDOM_default);
Object.assign(LayerImport.prototype, Widget_default);
var LayerImport_default = LayerImport;
if (window.ol && window.ol.control) {
  window.ol.control.LayerImport = LayerImport;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Attribution/GeoportalAttribution.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Attribution/GPFattribution.css";
var logger37 = LoggerByDefault_default2.getLogger("geoportalattribution");
var GeoportalAttribution = class _GeoportalAttribution extends Attribution_default {
  /**
   * @constructor
   * @param {Object} options - ol.control.Attribution options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Attribution.html ol.Control.Attribution})
   * @fires attributions:update
   * @example
   * var attribution = new ol.control.GeoportalAttribution({
   *   collapsed : false
   * });
   * map.addControl(attribution);
   * // listeners for attributions update :
   * attribution.on("attributions:update", function (e) {});
   */
  constructor(options) {
    options = options || {};
    options.collapsible = true;
    options.collapsed = true;
    super(options);
    if (!(this instanceof _GeoportalAttribution)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    return this;
  }
  /**
   * Overload setMap function, that enables to catch map events,
   * such as movend events.
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map != null) {
      var ctrls = map.getControls();
      ctrls.forEach(
        (ctrl) => {
          if (ctrl instanceof _GeoportalAttribution) {
            return;
          }
          if (ctrl) {
            var classList = ctrl.element.classList;
            for (var i = 0; i < classList.length; i++) {
              if (classList[i] === "ol-attribution") {
                ctrls.remove(ctrl);
                break;
              }
            }
          }
        }
      );
      this._updateAttributions(map);
      map.on(
        "moveend",
        () => {
          this._updateAttributions(map);
        }
      );
      map.getLayers().on(
        "add",
        () => {
          this._updateAttributions(map);
        }
      );
      map.getLayers().on(
        "remove",
        () => {
          this._updateAttributions(map);
        }
      );
    }
    super.setMap(map);
  }
  /**
   * Update map layers attributions
   *
   * @param {Map} map - Map.
   * @private
   */
  _updateAttributions(map) {
    var mapAttributions = {};
    var view = map.getView();
    var extent = view.calculateExtent(map.getSize());
    var mapProjection = view.getProjection().getCode();
    var geoExtent = transformExtent(extent, mapProjection, "EPSG:4326");
    var standardExtent = [geoExtent[3], geoExtent[0], geoExtent[1], geoExtent[2]];
    var zoom = view.getZoom();
    var layers = map.getLayers().getArray();
    for (var i = 0; i < layers.length; i++) {
      if (layers[i].getSource) {
        this._updateLayerAttributions(layers[i], mapAttributions, standardExtent, mapProjection, zoom);
      } else if (layers[i].getLayers) {
        var lyrs = layers[i].getLayers();
        lyrs.forEach(
          (lyr) => {
            if (lyr.getSource) {
              this._updateLayerAttributions(lyr, mapAttributions, standardExtent, mapProjection, zoom);
            } else {
              logger37.log("cannot find layer source in layergroup ", layers[i]);
            }
          }
        );
      }
    }
  }
  /**
   * Update a layer attributions
   *
   * @param {Layer} layer - layer
   * @param {Object} mapAttributions - object recensing attributions already added, to prevent displaying twice the same producer
   * @param {Array} mapExtent - map current extent
   * @param {String} mapCrs - map current crs
   * @param {Number} mapZoom - map current zoom
   * @private
   */
  _updateLayerAttributions(layer, mapAttributions, mapExtent, mapCrs, mapZoom) {
    if (!layer) {
      logger37.trace("layer is null !?");
      return;
    }
    var src = layer.getSource();
    if (!src) {
      logger37.trace("source is not yet loaded !");
      return;
    }
    if (!mapAttributions) {
      mapAttributions = {};
    }
    var attributions = [];
    var visibility = layer.getVisible();
    var originators = src._originators;
    if (typeof originators !== "undefined") {
      src.setAttributions();
    }
    if (originators && visibility) {
      var layerAttributions = LayerUtils_default.getAttributions({
        extent: mapExtent,
        crs: mapCrs,
        zoom: mapZoom,
        visibility,
        originators
      });
      for (var j2 = 0; j2 < layerAttributions.length; j2++) {
        var attributionj = layerAttributions[j2];
        if (!mapAttributions.hasOwnProperty(attributionj)) {
          attributions.push(attributionj);
          mapAttributions[attributionj] = true;
        }
      }
      ;
      if (attributions.length !== 0) {
        src.setAttributions(attributions);
        this.dispatchEvent({
          type: "attributions:update",
          attributions
        });
      }
    }
  }
};
var GeoportalAttribution_default = GeoportalAttribution;
if (window.ol && window.ol.control) {
  window.ol.control.GeoportalAttribution = GeoportalAttribution;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureLength.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Measures/GPFmeasureLength.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureLengthDOM.js
var MeasureLengthDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureLength");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowMeasureLengthPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowMeasureLengthPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto gpf-btn gpf-btn--tertiary gpf-btn-icon gpf-btn-icon-length fr-btn fr-btn--tertiary";
    button.setAttribute("aria-label", "Mesurer une distance");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureLengthClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureLengthClick(e);
      });
    }
    return button;
  }
};
var MeasureLengthDOM_default = MeasureLengthDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureLength.js
var logger38 = LoggerByDefault_default2.getLogger("measurelength");
var MeasureLength = class _MeasureLength extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - options for function call.
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {Boolean} [options.geodesic = true] - If true, length will be computed on the global sphere using the {@link https://openlayers.org/en/latest/apidoc/module-ol_sphere.html#haversineDistance ol.Sphere.haversineDistance()} function. Otherwise, length will be computed on the projected plane.
   * @param {String} [options.unit] - If not specified, the measure will be displayed in m until 999m, then in km. Values possible : m or km.
   * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
   * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the path. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
   * @param {Object} [options.styles.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * @param {Object} [options.styles.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
   * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
   * @param {String} [options.layerDescription.title = "Mesures de distance"] - Layer title to be displayed in LayerSwitcher
   * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
   * @example
   * var measureLength = new ol.control.MeasureLength({
   *    geodesic : false
   * });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _MeasureLength)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "MeasureLength";
    this._uid = options.id || SelectorID_default.generate();
    this._pictoContainer = null;
    this._initialize(options);
    this._container = this._initializeContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    logger38.trace("setMap()");
    var className = this.CLASSNAME;
    if (map) {
      if (!this.options.target && !this.options.position) {
        MeasureToolBox_default.add(map, this);
      }
    } else {
      this.clean();
    }
    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement() : null
    });
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }
      context.gpShareMeasures[className] = this.tools[className];
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */
  _initialize(options) {
    logger38.trace("call MeasureLength::_initialize() : ", options);
    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : true;
    this.options.unit = typeof options.unit !== "undefined" ? options.unit : null;
    this.options.position = typeof options.position !== "undefined" ? options.position : null;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.gutter = typeof options.gutter !== "undefined" ? options.gutter : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures de distance",
      description: "Mes mesures"
    };
    this.createStylingMeasureInteraction(options.styles);
  }
  /**
   * initialize component container (DOM)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initializeContainer() {
    logger38.trace("call MeasureLength::_initializeContainer() : ", this._uid);
    var container = this._createMainContainerElement();
    var picto = this._pictoContainer = this._createShowMeasureLengthPictoElement();
    container.appendChild(picto);
    return container;
  }
  // ################################################################### //
  // ########################## methods ################################ //
  // ################################################################### //
  /**
   * Add all events on map
   *
   * @private
   */
  addMeasureEvents() {
    logger38.trace("call MeasureLength::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", (e) => this.onPointerMoveHandler(e));
    map.on("pointermove", (e) => this.onPointerMoveHandler(e));
    this.eventLayerRemove = map.getLayers().on("remove", (e) => {
      if (e.element === this.measureVector) {
        this.clean();
      }
    });
  }
  /**
   * Remove all events on map
   *
   * @private
   */
  removeMeasureEvents() {
    logger38.trace("call MeasureLength::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", (e) => this.onPointerMoveHandle(e));
    map.un("pointermove", (e) => this.onPointerMoveHandler(e));
    if (this.eventLayerRemove) {
      unByKey(this.eventLayerRemove);
    }
  }
  /**
   * Format length output.
   *
   * @param {ol.geom.Line} line - geometry line.
   * @returns {String} The formatted output.
   * @private
   */
  format(line) {
    logger38.trace("call MeasureLength::format()");
    var map = this.getMap();
    var measure;
    if (this.options.geodesic) {
      var coordinates = line.getCoordinates();
      measure = 0;
      var sourceProj = map.getView().getProjection();
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var c1 = transform(coordinates[i], sourceProj, "EPSG:4326");
        var c2 = transform(coordinates[i + 1], sourceProj, "EPSG:4326");
        measure += getDistance(c1, c2);
      }
    } else {
      measure = Math.round(line.getLength() * 100) / 100;
    }
    var output;
    if (this.options.unit === "km") {
      output = Math.round(measure / 1e3 * 100) / 100 + " km";
    } else if (this.options.unit === "m") {
      output = Math.round(measure * 100) / 100 + " m";
    } else {
      if (measure > 1e3) {
        output = Math.round(measure / 1e3 * 100) / 100 + " km";
      } else {
        output = Math.round(measure * 100) / 100 + " m";
      }
    }
    return output;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   *
   * @private
   */
  onShowMeasureLengthClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger38.trace("call MeasureLength::onShowMeasureLengthClick()", e);
    this.onShowMeasureClick(e, "LineString");
  }
};
Object.assign(MeasureLength.prototype, Measures_default);
Object.assign(MeasureLength.prototype, MeasureLengthDOM_default);
Object.assign(MeasureLength.prototype, Widget_default);
var MeasureLength_default = MeasureLength;
if (window.ol && window.ol.control) {
  window.ol.control.MeasureLength = MeasureLength;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureArea.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Measures/GPFmeasureArea.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureAreaDOM.js
var MeasureAreaDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureArea");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowMeasureAreaPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowMeasureAreaPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto gpf-btn gpf-btn--tertiary gpf-btn-icon gpf-btn-icon-area fr-btn fr-btn--tertiary";
    button.setAttribute("aria-label", "Mesurer une surface");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureAreaClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureAreaClick(e);
      });
    }
    return button;
  }
};
var MeasureAreaDOM_default = MeasureAreaDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureArea.js
var logger39 = LoggerByDefault_default2.getLogger("measurearea");
var MeasureArea = class _MeasureArea extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - options for function call.
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {Boolean} [options.geodesic = true] - If true, area will be computed on the global sphere using the {@link https://openlayers.org/en/latest/apidoc/module-ol_sphere.html#geodesicArea ol.Sphere.geodesicArea()} function. Otherwise, area will be computed on the projected plane.
   * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
   * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the polygon to measure. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
   * @param {Object} [options.styles.start = {}] - Polygon Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * @param {Object} [options.styles.finish = {}] - Polygon Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
   * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
   * @param {String} [options.layerDescription.title = "Mesures de surface"] - Layer title to be displayed in LayerSwitcher
   * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
   * @example
   * var measureArea = new ol.control.MeasureArea({
   *    geodesic : false
   * });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _MeasureArea)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "MeasureArea";
    this._uid = options.id || SelectorID_default.generate();
    this._pictoContainer = null;
    this._initialize(options);
    this._container = this._initializeContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    logger39.trace("setMap()");
    var className = this.CLASSNAME;
    if (map) {
      if (!this.options.target && !this.options.position) {
        MeasureToolBox_default.add(map, this);
      }
    } else {
      this.clean();
    }
    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement() : null
    });
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }
      context.gpShareMeasures[className] = this.tools[className];
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */
  _initialize(options) {
    logger39.trace("call MeasureArea::_initialize() : ", options);
    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : true;
    this.options.position = typeof options.position !== "undefined" ? options.position : null;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.gutter = typeof options.gutter !== "undefined" ? options.gutter : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures de surface",
      description: "Mes mesures"
    };
    this.createStylingMeasureInteraction(options.styles);
  }
  /**
   * initialize component container (DOM)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initializeContainer() {
    logger39.trace("call MeasureArea::_initializeContainer() : ", this._uid);
    var container = this._createMainContainerElement();
    ;
    var picto = this._pictoContainer = this._createShowMeasureAreaPictoElement();
    container.appendChild(picto);
    return container;
  }
  // ################################################################### //
  // ##################### overridden methods ########################## //
  // ################################################################### //
  /**
   * Add all events on map
   *
   * @private
   */
  addMeasureEvents() {
    logger39.trace("call MeasureArea::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", (e) => this.onPointerMoveHandler(e));
    map.on("pointermove", (e) => this.onPointerMoveHandler(e));
    this.eventLayerRemove = map.getLayers().on("remove", (e) => {
      if (e.element === this.measureVector) {
        this.clean();
      }
    });
  }
  /**
   * Remove all events on map
   *
   * @private
   */
  removeMeasureEvents() {
    logger39.trace("call MeasureArea::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", (e) => this.onPointerMoveHandler(e));
    map.un("pointermove", (e) => this.onPointerMoveHandler(e));
    if (this.eventLayerRemove) {
      unByKey(this.eventLayerRemove);
    }
  }
  /**
   * Format length output.
   *
   * @param {ol.geom.Polygon} polygon - geometry polygon.
   * @returns {String} The formatted output.
   * @private
   */
  format(polygon) {
    logger39.trace("call MeasureArea::format()");
    var measure;
    if (this.options.geodesic) {
      var geom = polygon.clone();
      var coordinates = geom.getLinearRing(0).getCoordinates();
      measure = Math.abs(getArea(new Polygon_default([coordinates])));
    } else {
      measure = polygon.getArea();
    }
    var output;
    if (measure > 1e6) {
      output = Math.round(measure / 1e6 * 100) / 100 + " km<sup>2</sup>";
    } else if (measure > 1e5) {
      output = Math.round(measure / 1e6 * 1e3) / 1e3 + " km<sup>2</sup>";
    } else if (measure > 1e3) {
      output = Math.round(measure / 10) * 10 + " m<sup>2</sup>";
    } else {
      output = Math.round(measure * 100) / 100 + " m<sup>2</sup>";
    }
    return output;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   *
   * @private
   */
  onShowMeasureAreaClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger39.trace("call MeasureArea::onShowMeasureAreaClick()", e);
    this.onShowMeasureClick(e, "Polygon");
  }
};
Object.assign(MeasureArea.prototype, Measures_default);
Object.assign(MeasureArea.prototype, MeasureAreaDOM_default);
Object.assign(MeasureArea.prototype, Widget_default);
var MeasureArea_default = MeasureArea;
if (window.ol && window.ol.control) {
  window.ol.control.MeasureArea = MeasureArea;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureAzimuth.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Measures/GPFmeasureAzimuth.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureAzimuthDOM.js
var MeasureAzimuthDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPmeasureAzimuth");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowMeasureAzimuthPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowMeasureAzimuthPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto gpf-btn gpf-btn--tertiary gpf-btn-icon gpf-btn-icon-azimuth fr-btn fr-btn--tertiary";
    button.setAttribute("aria-label", "Mesurer un azimut");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureAzimuthClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowMeasureAzimuthClick(e);
      });
    }
    return button;
  }
};
var MeasureAzimuthDOM_default = MeasureAzimuthDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Measures/MeasureAzimuth.js
var logger40 = LoggerByDefault_default2.getLogger("measureazimut");
var MeasureAzimuth = class _MeasureAzimuth extends Control_default2 {
  /**
   * @constructor
   * @param {Object} options - options for function call.
   * @param {Number} [options.id] - Ability to add an identifier on the widget (advanced option)
   * @param {Boolean} [options.geodesic = false] - If true, azimuth will be computed on the global sphere. Otherwise, it will be computed on the projected plane.
   * @param {Object} [options.styles = {}] - styles used when drawing. Specified with following properties.
   * @param {Object} [options.styles.pointer = {}] - Style for mouse pointer when drawing the line. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
   * @param {Object} [options.styles.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * @param {Object} [options.styles.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Style-Style.htmll ol.style.Style} object.
   * <!-- @param {Object} [options.tooltip = {}] - NOT YET IMPLEMENTED ! -->
   * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
   * @param {String} [options.layerDescription.title = "Mesures d'azimuth"] - Layer title to be displayed in LayerSwitcher
   * @param {String} [options.layerDescription.description = "Mes mesures"] - Layer description to be displayed in LayerSwitcher
   * @example
   * var measure = new ol.control.MeasureAzimuth({
   *   geodesic : true
   * });
   * 
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _MeasureAzimuth)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "MeasureAzimuth";
    this._uid = options.id || SelectorID_default.generate();
    this._pictoContainer = null;
    this._initialize(options);
    this._container = this._initializeContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    logger40.trace("setMap()");
    var className = this.CLASSNAME;
    if (map) {
      if (!this.options.target && !this.options.position) {
        MeasureToolBox_default.add(map, this);
      }
    } else {
      this.clean();
    }
    this.tools[className].push({
      instance: map ? this : null,
      active: false,
      map: map ? map.getTargetElement() : null
    });
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      if (!context.gpShareMeasures) {
        context.gpShareMeasures = {};
      }
      context.gpShareMeasures[className] = this.tools[className];
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Setter for option Geodesic
   *
   * @param {Boolean} value - geodesic value
   */
  setGeodesic(value2) {
    this.options.geodesic = typeof value2 !== "undefined" ? value2 : false;
  }
  /**
   * Getter for option Geodesic
   *
   * @returns {Boolean} geodesic value
   */
  isGeodesic() {
    return this.options.geodesic;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize measure control (called by constructor)
   *
   * @param {Object} options - options
   *
   * @private
   */
  _initialize(options) {
    logger40.trace("call MeasureAzimuth::_initialize() : ", options);
    this.options = {};
    this.options.geodesic = typeof options.geodesic !== "undefined" ? options.geodesic : false;
    this.options.position = typeof options.position !== "undefined" ? options.position : null;
    this.options.target = typeof options.target !== "undefined" ? options.target : null;
    this.options.render = typeof options.render !== "undefined" ? options.render : null;
    this.options.gutter = typeof options.gutter !== "undefined" ? options.gutter : null;
    this.options.layerDescription = typeof options.layerDescription !== "undefined" ? options.layerDescription : {
      title: "Mesures d'azimuth",
      description: "Mes mesures"
    };
    this.createStylingMeasureInteraction(options.styles);
  }
  /**
   * initialize component container (DOM)
   *
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initializeContainer() {
    logger40.trace("call MeasureAzimuth::_initializeContainer() : ", this._uid);
    var container = this._createMainContainerElement();
    ;
    var picto = this._pictoContainer = this._createShowMeasureAzimuthPictoElement();
    container.appendChild(picto);
    return container;
  }
  // ################################################################### //
  // ##################### overridden methods ########################## //
  // ################################################################### //
  /**
   * Add all events on map
   *
   * @private
   */
  addMeasureEvents() {
    logger40.trace("call MeasureAzimuth::addMeasureEvents()");
    var map = this.getMap();
    map.on("singleclick", (e) => this.onPointerMoveAzimutHandler(e));
    map.on("pointermove", (e) => this.onPointerMoveAzimutHandler(e));
    this.eventLayerRemove = map.getLayers().on("remove", (e) => {
      if (e.element === this.measureVector) {
        this.clean();
      }
    });
  }
  /**
   * Remove all events on map
   *
   * @private
   */
  removeMeasureEvents() {
    logger40.trace("call MeasureAzimuth::removeMeasureEvents()");
    var map = this.getMap();
    map.un("singleclick", (e) => this.onPointerMoveAzimutHandler(e));
    map.un("pointermove", (e) => this.onPointerMoveAzimutHandler(e));
    if (this.eventLayerRemove) {
      unByKey(this.eventLayerRemove);
    }
  }
  /**
   * Format length output.
   *
   * @param {ol.geom.LineString} line - geometry line.
   * @returns {String} The formatted output.
   * @private
   */
  format(line) {
    logger40.trace("call MeasureAzimuth::format()");
    var map = this.getMap();
    var sourceProj = map.getView().getProjection();
    var c1 = transform(line.getFirstCoordinate(), sourceProj, "EPSG:4326");
    var c2 = transform(line.getLastCoordinate(), sourceProj, "EPSG:4326");
    if (!this.options.geodesic) {
      var lengthGeodesic = getDistance(c1, c2);
      logger40.trace("measure between 2 points with geodesic method", lengthGeodesic);
      if (lengthGeodesic > 500) {
        var fraction = 500 / lengthGeodesic;
        logger40.trace("%", fraction);
        c2 = transform(line.getCoordinateAt(fraction), sourceProj, "EPSG:4326");
      }
    }
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var lon1 = degrees2radians * c1[0];
    var lon2 = degrees2radians * c2[0];
    var lat1 = degrees2radians * c1[1];
    var lat2 = degrees2radians * c2[1];
    var a2 = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b3 = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    var atan = Math.atan2(a2, b3);
    var azimut = radians2degrees * atan;
    logger40.trace("azimut", azimut);
    if (azimut < 0) {
      azimut += 360;
    }
    var output = Math.round(azimut * 100) / 100 + " Â°";
    return output;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on picto
   *
   * @param {Object} e - HTMLElement
   * @private
   */
  onShowMeasureAzimuthClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger40.trace("call MeasureAzimuth::onShowMeasureAzimuthClick()", e);
    this.onShowMeasureClick(e, "LineString");
  }
  /**
   * Handle pointer click.
   *
   * @param {ol.MapBrowserEvent} e - The event.
   * @private
   */
  onPointerMoveAzimutHandler(e) {
    this.onPointerMoveHandler(e);
    if (this.sketch) {
      var geom = (
        /** @type {ol.geom.LineString} */
        this.sketch.getGeometry()
      );
      if (geom.getCoordinates().length > 2) {
        this.measureDraw.finishDrawing();
      }
    }
  }
};
Object.assign(MeasureAzimuth.prototype, Measures_default);
Object.assign(MeasureAzimuth.prototype, MeasureAzimuthDOM_default);
Object.assign(MeasureAzimuth.prototype, Widget_default);
var MeasureAzimuth_default = MeasureAzimuth;
if (window.ol && window.ol.control) {
  window.ol.control.MeasureAzimuth = MeasureAzimuth;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Zoom/GeoportalZoom.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Zoom/GPFzoom.css";
var logger41 = LoggerByDefault_default2.getLogger("zoom");
var GeoportalZoom = class extends Zoom_default {
  /**
   * @constructor
   * @param {Object} options - ol.control.Zoom options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Zoom.html ol.Control.Zoom})
   * @fires zoom:in
   * @fires zoom:out
   * @example
   * var zoom = new ol.control.GeoportalZoom({
   *   position: "top-left"
   * });
   * map.addControl(zoom);
   */
  constructor(options) {
    options = options || {};
    var className = "ol-custom-zoom";
    options.className = className;
    super(options);
    this.container = null;
    this.options = options;
  }
  /**
   * ...
   * @param {Map} map - ...
   * @private
   */
  _createContainerPosition(map) {
    this.container = map.getOverlayContainerStopEvent();
    if (this.options.position) {
      this.options.target = this.container;
      var id = "position-container-" + this.options.position;
      if (!document.getElementById(id)) {
        var div = document.createElement("div");
        div.id = id;
        div.classList.add("position");
        div.classList.add(id);
        this.container.appendChild(div);
      }
      this.options.target = this.container.children[id];
    }
  }
  /**
   * @private
   */
  _initContainer() {
    this._uid = this.options.id || SelectorID_default.generate();
    this.element.id = "GPzoom-" + this._uid;
    this.element.classList.add("GPwidget", "gpf-widget", "gpf-widget-button");
    this.element.classList.add(this.options.className);
    this.element.classList.remove("ol-zoom", "ol-unselectable", "ol-control");
    var self2 = this;
    var buttons = this.element.childNodes;
    for (let index2 = 0; index2 < buttons.length; index2++) {
      const btn = buttons[index2];
      if (btn.classList.contains(this.options.className + "-in")) {
        btn.classList.add("GPzoomIn", "GPshowOpen", "GPshowAdvancedToolPicto", "gpf-btn-icon-zoom-in", "fr-btn", "fr-btn--tertiary", "gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon");
        btn.id = "GPzoomIn";
        btn.innerHTML = "";
        btn.removeAttribute("title");
        btn.setAttribute("aria-label", "Zoomer");
        var span = document.createElement("span");
        btn.appendChild(span);
        if (btn.addEventListener) {
          btn.addEventListener("click", function() {
            self2.dispatchEvent("zoom:in");
          });
        } else if (btn.attachEvent) {
          btn.attachEvent("onclick", function() {
            self2.dispatchEvent("zoom:in");
          });
        }
      }
      if (btn.classList.contains(this.options.className + "-out")) {
        btn.classList.add("GPzoomOut", "GPshowOpen", "GPshowAdvancedToolPicto", "gpf-btn-icon-zoom-out", "fr-btn", "fr-btn--tertiary", "gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon");
        btn.id = "GPzoomOut";
        btn.innerHTML = "";
        btn.removeAttribute("title");
        btn.setAttribute("aria-label", "DÃ©zoomer");
        var span = document.createElement("span");
        btn.appendChild(span);
        if (btn.addEventListener) {
          btn.addEventListener("click", function() {
            self2.dispatchEvent("zoom:out");
          });
        } else if (btn.attachEvent) {
          btn.attachEvent("onclick", function() {
            self2.dispatchEvent("zoom:out");
          });
        }
      }
    }
    if (this.options.position) {
      this.element.style.position = "unset";
    }
    if (this.options.gutter === false) {
      this.element.classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Overload setMap function
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._createContainerPosition(map);
      this._initContainer();
      var controls = map.getControls();
      controls.forEach((ctrl) => {
        if (ctrl.element.classList.contains("ol-zoom")) {
          ctrl.element.classList.add("ol-hidden");
          ctrl.element.style.display = "none";
        }
      });
    }
    this.setTarget(this.options.target);
    super.setMap(map);
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
};
var GeoportalZoom_default = GeoportalZoom;
if (window.ol && window.ol.control) {
  window.ol.control.GeoportalZoom = GeoportalZoom;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/FullScreen/GeoportalFullScreen.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/FullScreen/GPFfullScreen.css";

// node_modules/ol/control/FullScreen.js
var events = ["fullscreenchange", "webkitfullscreenchange"];
var FullScreenEventType = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
var FullScreen = class extends Control_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.keys_ = options.keys !== void 0 ? options.keys : false;
    this.source_ = options.source;
    this.isInFullscreen_ = false;
    this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this);
    this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    this.documentListeners_ = [];
    this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [this.cssClassName_ + "-true"];
    this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const label = options.label !== void 0 ? options.label : "â¤¢";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    const labelActive = options.labelActive !== void 0 ? options.labelActive : "Ã—";
    this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    const tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button");
    this.button_.title = tipLabel;
    this.button_.setAttribute("type", "button");
    this.button_.appendChild(this.labelNode_);
    this.button_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    this.setClassName_(this.button_, this.isInFullscreen_);
    this.element.className = `${this.cssClassName_} ${CLASS_UNSELECTABLE} ${CLASS_CONTROL}`;
    this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      let element;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(element, fullscreen) {
    if (fullscreen) {
      element.classList.remove(...this.inactiveClassName_);
      element.classList.add(...this.activeClassName_);
    } else {
      element.classList.remove(...this.activeClassName_);
      element.classList.add(...this.inactiveClassName_);
    }
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
    super.setMap(map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const listeners = this.documentListeners_;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      unlistenByKey(listeners[i]);
    }
    listeners.length = 0;
    const map = this.getMap();
    if (map) {
      const doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (let i = 0, ii = events.length; i < ii; ++i) {
        listeners.push(
          listen(doc, events[i], this.handleFullScreenChange_, this)
        );
      }
      this.handleFullScreenChange_();
    }
  }
};
function isFullScreenSupported(doc) {
  const body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}
var FullScreen_default = FullScreen;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/FullScreen/GeoportalFullScreen.js
var logger42 = LoggerByDefault_default2.getLogger("fullscreen");
var GeoportalFullScreen = class extends FullScreen_default {
  /**
   * @constructor
  * @param {Object} options - ol.control.FullScreen options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.FullScreen.html ol.Control.FullScreen})
  * @example
  * var zoom = new ol.control.GeoportalFullScreen({
  *   position: "top-left"
  * });
  * map.addControl(zoom);
   */
  constructor(options) {
    options = options || {};
    var className = "ol-custom-full-screen";
    options.className = options.className || className;
    options.label = options.label || "";
    options.labelActive = options.labelActive || "";
    options.activeClassName = options.activeClassName || className + "-true";
    options.inactiveClassName = options.inactiveClassName || className + "-false";
    options.tipLabel = options.tipLabel || "Basculer en mode plein Ã©cran";
    super(options);
    this.CLASSNAME = "FullScreen";
    this.container = null;
    this.options = options;
  }
  /**
   * ...
   * @param {Map} map - ...
   * @private
   */
  _createContainerPosition(map) {
    this.container = map.getOverlayContainerStopEvent();
    this.options.target = this.container;
    if (this.options.position) {
      var id = "position-container-" + this.options.position;
      if (!document.getElementById(id)) {
        var div = document.createElement("div");
        div.id = id;
        div.classList.add("position");
        div.classList.add(id);
        this.container.appendChild(div);
      }
      this.options.target = this.container.children[id];
    }
  }
  /**
   * ...
   * @private
   */
  _initContainer() {
    this._uid = this.options.id || SelectorID_default.generate();
    this.element.id = "GPfullScreen-" + this._uid;
    this.element.classList.add("GPwidget", "gpf-widget", "gpf-widget-button");
    this.element.classList.add(this.options.className);
    this.element.classList.remove("ol-full-screen", "ol-unselectable", "ol-control");
    var button = this.element.childNodes[0];
    var span = document.createElement("span");
    button.appendChild(span);
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPfullScreenPicto");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.classList.add("gpf-btn--tertiary", "gpf-btn", "gpf-btn-icon");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    button.removeAttribute("title");
    button.setAttribute("aria-label", this.options.tipLabel);
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
      });
    }
    if (this.options.position) {
      this.element.style.position = "unset";
    }
    if (this.options.gutter === false) {
      this.element.classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Overload setMap function
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._createContainerPosition(map);
      this._initContainer();
      var controls = map.getControls();
      controls.forEach((ctrl) => {
        if (ctrl.element.classList.contains("ol-full-screen")) {
          ctrl.element.classList.add("ol-hidden");
          ctrl.element.style.display = "none";
        }
      });
    }
    this.setTarget(this.options.target);
    super.setMap(map);
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
};
var GeoportalFullScreen_default = GeoportalFullScreen;
if (window.ol && window.ol.control) {
  window.ol.control.GeoportalFullScreen = GeoportalFullScreen;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/OverviewMap/GeoportalOverviewMap.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/OverviewMap/GPFoverviewMap.css";

// node_modules/ol/control/OverviewMap.js
var MAX_RATIO = 0.75;
var MIN_RATIO = 0.1;
var OverviewMap = class extends Control_default {
  /**
   * @param {Options} [options] OverviewMap options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this);
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    this.viewExtent_ = void 0;
    const className = options.className !== void 0 ? options.className : "ol-overviewmap";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "â€¹";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "â€º";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    const button = document.createElement("button");
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    this.ovmapDiv_ = document.createElement("div");
    this.ovmapDiv_.className = "ol-overviewmap-map";
    this.view_ = options.view;
    const ovmap = new Map_default({
      view: options.view,
      controls: new Collection_default(),
      interactions: new Collection_default()
    });
    this.ovmap_ = ovmap;
    if (options.layers) {
      options.layers.forEach(function(layer) {
        ovmap.addLayer(layer);
      });
    }
    const box = document.createElement("div");
    box.className = "ol-overviewmap-box";
    box.style.boxSizing = "border-box";
    this.boxOverlay_ = new Overlay_default({
      position: [0, 0],
      positioning: "center-center",
      element: box
    });
    this.ovmap_.addOverlay(this.boxOverlay_);
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.ovmapDiv_);
    element.appendChild(button);
    const overlay = this.boxOverlay_;
    const overlayBox = this.boxOverlay_.getElement();
    const computeDesiredMousePosition = (mousePosition) => {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };
    const move = function(event) {
      const position = (
        /** @type {?} */
        computeDesiredMousePosition(event)
      );
      const coordinates = ovmap.getEventCoordinate(
        /** @type {MouseEvent} */
        position
      );
      overlay.setPosition(coordinates);
    };
    const endMoving = (event) => {
      const coordinates = ovmap.getEventCoordinateInternal(event);
      const map = this.getMap();
      map.getView().setCenterInternal(coordinates);
      const ownerDocument = map.getOwnerDocument();
      ownerDocument.removeEventListener("pointermove", move);
      ownerDocument.removeEventListener("pointerup", endMoving);
    };
    this.ovmapDiv_.addEventListener("pointerdown", (event) => {
      const ownerDocument = this.getMap().getOwnerDocument();
      if (event.target === overlayBox) {
        ownerDocument.addEventListener("pointermove", move);
      }
      ownerDocument.addEventListener("pointerup", endMoving);
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (map === oldMap) {
      return;
    }
    if (oldMap) {
      const oldView = oldMap.getView();
      if (oldView) {
        this.unbindView_(oldView);
      }
      this.ovmap_.setTarget(null);
    }
    super.setMap(map);
    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push(
        listen(
          map,
          ObjectEventType_default.PROPERTYCHANGE,
          this.handleMapPropertyChange_,
          this
        )
      );
      const view = map.getView();
      if (view) {
        this.bindView_(view);
      }
      if (!this.ovmap_.isRendered()) {
        this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */
  handleMapPropertyChange_(event) {
    if (event.key === MapProperty_default.VIEW) {
      const oldView = (
        /** @type {import("../View.js").default} */
        event.oldValue
      );
      if (oldView) {
        this.unbindView_(oldView);
      }
      const newView = this.getMap().getView();
      this.bindView_(newView);
    } else if (!this.ovmap_.isRendered() && (event.key === MapProperty_default.TARGET || event.key === MapProperty_default.SIZE)) {
      this.ovmap_.updateSize();
    }
  }
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  bindView_(view) {
    if (!this.view_) {
      const newView = new View_default({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }
    view.addChangeListener(
      ViewProperty_default.ROTATION,
      this.boundHandleRotationChanged_
    );
    this.handleRotationChanged_();
    if (view.isDef()) {
      this.ovmap_.updateSize();
      this.resetExtent_();
    }
  }
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  unbindView_(view) {
    view.removeChangeListener(
      ViewProperty_default.ROTATION,
      this.boundHandleRotationChanged_
    );
  }
  /**
   * Handle rotation changes to the main map.
   * @private
   */
  handleRotationChanged_() {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  }
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */
  validateExtent_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    const mapSize = (
      /** @type {import("../size.js").Size} */
      map.getSize()
    );
    const view = map.getView();
    const extent = view.calculateExtentInternal(mapSize);
    if (this.viewExtent_ && equals(extent, this.viewExtent_)) {
      return;
    }
    this.viewExtent_ = extent;
    const ovmapSize = (
      /** @type {import("../size.js").Size} */
      ovmap.getSize()
    );
    const ovview = ovmap.getView();
    const ovextent = ovview.calculateExtentInternal(ovmapSize);
    const topLeftPixel = ovmap.getPixelFromCoordinateInternal(
      getTopLeft(extent)
    );
    const bottomRightPixel = ovmap.getPixelFromCoordinateInternal(
      getBottomRight(extent)
    );
    const boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    const boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    const ovmapWidth = ovmapSize[0];
    const ovmapHeight = ovmapSize[1];
    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!containsExtent(ovextent, extent)) {
      this.recenter_();
    }
  }
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */
  resetExtent_() {
    if (MAX_RATIO === 0 || MIN_RATIO === 0) {
      return;
    }
    const map = this.getMap();
    const ovmap = this.ovmap_;
    const mapSize = (
      /** @type {import("../size.js").Size} */
      map.getSize()
    );
    const view = map.getView();
    const extent = view.calculateExtentInternal(mapSize);
    const ovview = ovmap.getView();
    const steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    const ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    scaleFromCenter(extent, ratio);
    ovview.fitInternal(fromExtent(extent));
  }
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */
  recenter_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    const view = map.getView();
    const ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  }
  /**
   * Update the box using the main map extent
   * @private
   */
  updateBox_() {
    const map = this.getMap();
    const ovmap = this.ovmap_;
    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }
    const mapSize = (
      /** @type {import("../size.js").Size} */
      map.getSize()
    );
    const view = map.getView();
    const ovview = ovmap.getView();
    const rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    const overlay = this.boxOverlay_;
    const box = this.boxOverlay_.getElement();
    const center = view.getCenter();
    const resolution = view.getResolution();
    const ovresolution = ovview.getResolution();
    const width = mapSize[0] * resolution / ovresolution;
    const height = mapSize[1] * resolution / ovresolution;
    overlay.setPosition(center);
    if (box) {
      box.style.width = width + "px";
      box.style.height = height + "px";
      const transform3 = "rotate(" + rotation + "rad)";
      box.style.transform = transform3;
    }
  }
  /**
   * @private
   */
  updateBoxAfterOvmapIsRendered_() {
    if (this.ovmapPostrenderKey_) {
      return;
    }
    this.ovmapPostrenderKey_ = listenOnce(
      this.ovmap_,
      MapEventType_default.POSTRENDER,
      (event) => {
        delete this.ovmapPostrenderKey_;
        this.updateBox_();
      }
    );
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    const ovmap = this.ovmap_;
    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = void 0;
        ovmap.render();
        return;
      }
      ovmap.updateSize();
      this.resetExtent_();
      this.updateBoxAfterOvmapIsRendered_();
    }
  }
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */
  setRotateWithView(rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }
    this.rotateWithView_ = rotateWithView;
    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }
      this.viewExtent_ = void 0;
      this.validateExtent_();
      this.updateBox_();
    }
  }
  /**
   * Return the overview map.
   * @return {import("../Map.js").default} Overview map.
   * @api
   */
  getOverviewMap() {
    return this.ovmap_;
  }
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  }
};
var OverviewMap_default = OverviewMap;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/OverviewMap/GeoportalOverviewMap.js
var logger43 = LoggerByDefault_default2.getLogger("overviewMap");
var GeoportalOverviewMap = class extends OverviewMap_default {
  /**
   * @constructor
   * @param {Object} options - ol.control.OverviewMap options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.OverviewMap.html ol.Control.OverviewMap})
   * @fires overviewmap:toggle
   * @example
   * var overviewmap = new ol.control.GeoportalOverviewMap({
   *   position: "top-left"
   * });
   * map.addControl(overviewmap);
   */
  constructor(options) {
    options = options || {};
    const LAYER_CONFIG = {
      "name": "GEOGRAPHICALGRIDSYSTEMS.MAPS.OVERVIEW",
      "globalConstraint": {
        "maxScaleDenominator": 27954113201435894e-8,
        "minScaleDenominator": 2.1839150938621787e6,
        "bbox": {
          "left": -179.5,
          "right": 179.5,
          "top": 75,
          "bottom": -75
        }
      },
      "params": {
        "url": "https://data.geopf.fr/wmts",
        "styles": "normal",
        "version": "1.0.0",
        "format": "image/jpeg",
        "projection": "EPSG:3857",
        "minScale": 2.1839150938621787e6,
        "maxScale": 27954113201435894e-8,
        "extent": {
          "left": -179.5,
          "right": 179.5,
          "top": 75,
          "bottom": -75
        },
        "legends": [
          {
            "format": "image/jpeg",
            "url": "https://data.geopf.fr/annexes/ressources/legendes/LEGEND.jpg",
            "minScaleDenominator": "200"
          }
        ],
        "title": "Carte Mondiale pour la mini-vue",
        "description": "Carte Mondiale pour la mini-vue",
        "tileMatrixSetLimits": {
          "1": {
            "minTileRow": "0",
            "maxTileRow": "1",
            "minTileCol": "0",
            "maxTileCol": "1"
          },
          "2": {
            "minTileRow": "0",
            "maxTileRow": "3",
            "minTileCol": "0",
            "maxTileCol": "3"
          },
          "3": {
            "minTileRow": "1",
            "maxTileRow": "6",
            "minTileCol": "0",
            "maxTileCol": "7"
          },
          "4": {
            "minTileRow": "2",
            "maxTileRow": "13",
            "minTileCol": "0",
            "maxTileCol": "15"
          },
          "5": {
            "minTileRow": "5",
            "maxTileRow": "26",
            "minTileCol": "0",
            "maxTileCol": "31"
          },
          "6": {
            "minTileRow": "11",
            "maxTileRow": "52",
            "minTileCol": "0",
            "maxTileCol": "63"
          },
          "7": {
            "minTileRow": "22",
            "maxTileRow": "105",
            "minTileCol": "0",
            "maxTileCol": "127"
          },
          "8": {
            "minTileRow": "45",
            "maxTileRow": "210",
            "minTileCol": "0",
            "maxTileCol": "255"
          }
        },
        "TMSLink": "PM_1_8",
        "matrixIds": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8"
        ],
        "tileMatrices": {
          "1": {
            "matrixId": "1",
            "matrixHeight": 2,
            "matrixWidth": 2,
            "scaleDenominator": 27954113201435894e-8,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "2": {
            "matrixId": "2",
            "matrixHeight": 4,
            "matrixWidth": 4,
            "scaleDenominator": 1397705660071793e-7,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "3": {
            "matrixId": "3",
            "matrixHeight": 8,
            "matrixWidth": 8,
            "scaleDenominator": 6988528300358965e-8,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "4": {
            "matrixId": "4",
            "matrixHeight": 16,
            "matrixWidth": 16,
            "scaleDenominator": 3494264150179486e-8,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "5": {
            "matrixId": "5",
            "matrixHeight": 32,
            "matrixWidth": 32,
            "scaleDenominator": 1747132075089743e-8,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "6": {
            "matrixId": "6",
            "matrixHeight": 64,
            "matrixWidth": 64,
            "scaleDenominator": 8735660375448715e-9,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "7": {
            "matrixId": "7",
            "matrixHeight": 128,
            "matrixWidth": 128,
            "scaleDenominator": 4.3678301877243575e6,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          },
          "8": {
            "matrixId": "8",
            "matrixHeight": 256,
            "matrixWidth": 256,
            "scaleDenominator": 2.1839150938621787e6,
            "tileHeight": 256,
            "tileWidth": 256,
            "topLeftCorner": {
              "x": -200375083427892e-7,
              "y": 200375083427892e-7
            }
          }
        },
        "nativeResolutions": [
          "78271.51696402048",
          "39135.75848201023",
          "19567.87924100512",
          "9783.939620502561",
          "4891.969810251280",
          "2445.984905125640",
          "1222.992452562820",
          "611.4962262814100"
        ]
      }
    };
    var className = "ol-overviewmap";
    options.className = options.className || className;
    options.collapseLabel = options.collapseLabel || "";
    options.collapsed = options.collapsed;
    if (options.collapsed === void 0) {
      options.collapsed = true;
    }
    options.label = options.label || "";
    options.tipLabel = "Carte gÃ©nÃ©rale";
    options.layers = options.layers || [
      new LayerWMTS_default({
        layer: "GEOGRAPHICALGRIDSYSTEMS.MAPS.OVERVIEW",
        configuration: LAYER_CONFIG
      })
    ];
    options.view = options.view || new View_default({
      minZoom: 1,
      maxZoom: 8
    });
    super(options);
    this.CLASSNAME = "OverviewMap";
    this.container = null;
    this.options = options;
  }
  /**
   * ...
   * @param {Map} map - ...
   */
  _createContainerPosition(map) {
    this.container = map.getOverlayContainerStopEvent();
    this.options.target = this.container;
    if (this.options.position) {
      var id = "position-container-" + this.options.position;
      if (!document.getElementById(id)) {
        var div = document.createElement("div");
        div.id = id;
        div.classList.add("position");
        div.classList.add(id);
        this.container.appendChild(div);
      }
      this.options.target = this.container.children[id];
    }
  }
  /** @private */
  _initContainer() {
    this._uid = this.options.id || SelectorID_default.generate();
    this.element.id = "GPoverviewMap-" + this._uid;
    this.element.classList.add("GPwidget", "gpf-widget", "gpf-widget-button");
    this.element.classList.remove("ol-control");
    var elements = this.element.childNodes;
    var button = elements[1];
    button.id = "GPshowOverviewMap-" + this._uid;
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowOverviewMapPicto");
    button.classList.add("gpf-btn-icon", "gpf-btn--tertiary", "gpf-btn-icon-overviewmap");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", !this.options.collapsed);
    button.setAttribute("type", "button");
    button.removeAttribute("title");
    button.setAttribute("aria-label", this.options.tipLabel);
    var self2 = this;
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.dispatchEvent({
          type: "overviewmap:toggle",
          status
        });
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.dispatchEvent({
          type: "overviewmap:toggle",
          status
        });
      });
    }
    if (this.options.position) {
      this.element.style.position = "unset";
    }
    if (this.options.gutter === false) {
      this.element.classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Overload setMap function
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this._createContainerPosition(map);
      this._initContainer();
    }
    this.setTarget(this.options.target);
    super.setMap(map);
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
};
var GeoportalOverviewMap_default = GeoportalOverviewMap;
if (window.ol && window.ol.control) {
  window.ol.control.GeoportalOverviewMap = GeoportalOverviewMap;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Legends/Legends.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Legends/GPFlegends.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Legends/LegendsDOM.js
var LegendsDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPlegends");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show Legends
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowLegendsPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowLegendsPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowLegendsPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-legends");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Afficher les lÃ©gendes");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowLegendsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowLegendsClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createLegendsPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPlegendsPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createLegendsPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__legends";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createLegendsPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "gpf-panel__header_legends";
    return container;
  },
  _createLegendsPanelIconElement: function() {
    var label = document.createElement("label");
    label.className = "gpf-btn-header-legends gpf-btn-icon-header-legends";
    label.title = "LÃ©gendes";
    return label;
  },
  _createLegendsPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__title_legends";
    div.innerHTML = "LÃ©gendes";
    return div;
  },
  _createLegendsPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.className = "gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline";
    btnClose.title = "Fermer le panneau";
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowLegendsPicto")).click();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowLegendsPicto")).click();
      });
    }
    return btnClose;
  },
  // ################################################################### //
  // ####################### Methods dynamics ########################## //
  // ################################################################### //
  _createLegendElement: function() {
    var div = document.createElement("div");
    div.className = "legends-entries gpf-panel__body fr-modal__body";
    return div;
  },
  _createLegendEntry: function(o) {
    const stringToHTML5 = (str) => {
      var support = function() {
        if (!window.DOMParser) {
          return false;
        }
        var parser2 = new DOMParser();
        try {
          parser2.parseFromString("x", "text/html");
        } catch (err) {
          return false;
        }
        return true;
      };
      if (support()) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(str, "text/html");
        return doc.body;
      }
      var dom = document.createElement("div");
      dom.innerHTML = str;
      return dom;
    };
    if (o) {
      if (o.legends && o.legends.length) {
        var url = o.legends[0].url;
        var entry = stringToHTML5(`
                    <div
                        id="${o.id}"
                        class="legend-entry-container gpf-panel__content fr-modal__content">
                        <label class="legend-entry-title gpf-label-legends-name fr-label">${o.title}</label>
                        <button
                            id="GPcollapseLegend_ID_${o.id}"
                            class="legend-entry-show gpf-btn gpf-btn-icon gpf-btn-icon-legends-collapse fr-btn fr-btn--tertiary gpf-btn--tertiary"
                            type="button"
                            title=""
                            tabindex="0"
                            aria-pressed="false"></button>
                        <div id="GPlegend_ID_${o.id}" class="legend-entry-image gpf-hidden">
                            <img src="${url}" alt="${o.desc}">
                        </div>
                    </div>
                `);
        var button = entry.firstChild.querySelector("button");
        if (button) {
          button.addEventListener("click", (e) => {
            var status = e.target.ariaPressed === "true";
            e.target.setAttribute("aria-pressed", !status);
            var element = document.getElementById("GPlegend_ID_" + o.id);
            status ? element.classList.replace("gpf-visible", "gpf-hidden") : element.classList.replace("gpf-hidden", "gpf-visible");
          });
        }
        return entry.firstChild;
      }
    }
  }
};
var LegendsDOM_default = LegendsDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Legends/Legends.js
var logger44 = LoggerByDefault_default2.getLogger("legends");
var Legends = class _Legends extends Control_default2 {
  /**
   * @param {LegendsOptions} [options] - options
   * @constructor
   * @public
   * @fires legends:add
   * @fires legends:remove
   * @fires legends:modify
   * @example
   * var legends = new ol.control.Legends();
   * map.addControl(legends);
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Legends)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Legends";
    this.initialize(options);
    this.container = this.initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      if (this.draggable) {
        Draggable_default.dragElement(
          this.panelLegendsContainer,
          this.panelLegendsHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this.buttonLegendsShow.setAttribute("aria-pressed", true);
      }
      if (this.auto) {
        var self2 = this;
        map.getLayers().forEach((layer) => {
          self2.add(layer);
        });
      }
      if (this.auto) {
        this.addEventsListeners(map);
      }
    } else {
      if (this.auto) {
        this.removeEventsListeners();
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // ################### getters / setters ############################# //
  // ################################################################### //
  /**
   * Get all meta informations of a IGN's layer
   *
   * @param {Layer} layer - layer
   * @returns {*} informations
   * @public
   * @example
   * getLegends() :
   * "legends" : [
   *  {
   *     "format" : "image/jpeg",
   *     "url" : "https:*data.geopf.fr/annexes/ressources/legendes/LEGEND.jpg",
   *     "minScaleDenominator" : "200"
   *   }
   *  ],
   */
  getMetaInformations(layer) {
    if (layer.hasOwnProperty("name")) {
      return {
        id: layer.name,
        title: layer.getTitle(),
        legends: layer.getLegends(),
        metadatas: layer.getMetadata(),
        desc: layer.getDescription(),
        url: layer.getQuicklookUrl(),
        partners: layer.getOriginators()
      };
    }
    return;
  }
  /**
   * Add legends from layers
   * @param {Layer[]} layers - Array of layers
   * @public
   */
  adds(layers) {
    if (layers) {
      for (let index2 = 0; index2 < layers.length; index2++) {
        if (!this.add(layers[index2])) {
          continue;
        }
      }
    }
  }
  /**
   * Add a legend from a layer
   * @param {Layer} layer  - ...
   * @returns {Boolean} - true|false
   * @public
   */
  add(layer) {
    if (layer) {
      var entry = this._createLegendEntry(this.getMetaInformations(layer));
      if (entry) {
        if (this.exist(entry)) {
          return false;
        }
        this.panelLegendsEntriesContainer.prepend(entry);
        this.legends.push({
          obj: layer,
          dom: entry
        });
        return true;
      }
    }
    return false;
  }
  /**
   * Remove a legend from a layer
   * @param {Layer} layer - ...
   * @returns  {Boolean} - true|false
   * @public
   */
  remove(layer) {
    var found = false;
    if (layer) {
      for (let i = 0; i < this.legends.length; i++) {
        const legend = this.legends[i];
        if (layer.name === legend.obj.name && layer.service === legend.obj.service) {
          if (legend.dom) {
            this.legends[i].dom.remove();
          }
          this.legends.splice(i, 1);
          found = true;
          break;
        }
      }
    }
    return found;
  }
  /**
   * Has already a DOM legend
   * @param {HTMLElement} dom  - ...
   * @returns {Boolean} - true|false
   * @public
   */
  exist(dom) {
    var found = false;
    for (let i = 0; i < this.legends.length; i++) {
      const legend = this.legends[i];
      if (legend.dom.id === dom.id) {
        found = true;
        break;
      }
    }
    return found;
  }
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize Legends control (called by Legends constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this.uid = options.id || SelectorID_default.generate();
    this.options = {
      collapsed: true,
      draggable: false,
      auto: true,
      panel: false
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this.auto = this.options.auto;
    this.buttonLegendsShow = null;
    this.panelLegendsContainer = null;
    this.panelLegendsEntriesContainer = null;
    this.panelLegendsHeaderContainer = null;
    this.buttonLegendsClose = null;
    this.eventsListeners = [];
    this.legends = [];
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  initContainer() {
    var container = this._createMainContainerElement();
    var picto = this.buttonLegendsShow = this._createShowLegendsPictoElement();
    container.appendChild(picto);
    var legendsPanel = this.panelLegendsContainer = this._createLegendsPanelElement();
    var legendsPanelDiv = this._createLegendsPanelDivElement();
    legendsPanel.appendChild(legendsPanelDiv);
    var legendsEntriesDiv = this.panelLegendsEntriesContainer = this._createLegendElement();
    legendsPanel.appendChild(legendsEntriesDiv);
    if (this.options.panel) {
      var legendsPanelHeader = this.panelLegendsHeaderContainer = this._createLegendsPanelHeaderElement();
      var legendsPanelIcon = this._createLegendsPanelIconElement();
      legendsPanelHeader.appendChild(legendsPanelIcon);
      var legendsPanelTitle = this._createLegendsPanelTitleElement();
      legendsPanelHeader.appendChild(legendsPanelTitle);
      var legendsCloseBtn = this.buttonLegendsClose = this._createLegendsPanelCloseElement();
      legendsPanelHeader.appendChild(legendsCloseBtn);
      legendsPanelDiv.appendChild(legendsPanelHeader);
    }
    container.appendChild(legendsPanel);
    logger44.log(container);
    return container;
  }
  /**
   * Add events listeners on map (called by setMap)
   *
   * @param {Map} map - map
   * @private
   * @todo listener on change:position
   */
  addEventsListeners(map) {
    var self2 = this;
    this.eventsListeners["layer:add"] = function(e) {
      logger44.trace(e);
      if (!self2.add(e.element)) {
        logger44.error("Layer already added...");
        return;
      }
    };
    this.eventsListeners["layer:remove"] = function(e) {
      logger44.trace(e);
      if (!self2.remove(e.element)) {
        logger44.error("Layer already removed...");
        return;
      }
    };
    this.eventsListeners["layer:change:position"] = function(e) {
      logger44.trace(e);
    };
    this.eventsListeners["view:change:resolution"] = function(e) {
      logger44.trace(e);
      var map2 = self2.getMap();
      for (let j2 = 0; j2 < self2.legends.length; j2++) {
        const legend = self2.legends[j2];
        var infos = self2.getMetaInformations(legend.obj);
        if (!infos) {
          continue;
        }
        var resolution = map2.getView().getResolution() || map2.getView().getResolutionForZoom(map2.getZoom());
        var scaleDenominator = resolution * 3570;
        var cloneInfoLegends = infos.legends.slice();
        var bestInfoLegend = cloneInfoLegends[0];
        for (let i = 0; i < cloneInfoLegends.length; ++i) {
          const InfoLegend = cloneInfoLegends[i];
          if (!InfoLegend.minScaleDenominator) {
            InfoLegend.minScaleDenominator = 0;
          }
          if (scaleDenominator > bestInfoLegend.minScaleDenominator && InfoLegend.minScaleDenominator > bestInfoLegend.minScaleDenominator && InfoLegend.minScaleDenominator < scaleDenominator || scaleDenominator < bestInfoLegend.minScaleDenominator && InfoLegend.minScaleDenominator < bestInfoLegend.minScaleDenominator) {
            bestInfoLegend = InfoLegend;
          }
        }
        if (infos.legends[0] === bestInfoLegend) {
          continue;
        }
        infos.legends = [];
        infos.legends.push(bestInfoLegend);
        var newEntry = self2._createLegendEntry(infos);
        var oldEntry = legend.dom;
        oldEntry.replaceWith(newEntry);
        legend.dom = newEntry;
      }
    };
    map.getLayers().on("add", this.eventsListeners["layer:add"]);
    map.getLayers().on("remove", this.eventsListeners["layer:remove"]);
    map.getLayers().on("change:zIndex", this.eventsListeners["layer:change:position"]);
    map.getView().on("change:resolution", this.eventsListeners["view:change:resolution"]);
  }
  /**
   * Remove events listeners on map (called by setMap)
   * @private
   */
  removeEventsListeners() {
    var map = this.getMap();
    map.getLayers().un("add", this.eventsListeners["layer:add"]);
    map.getLayers().un("remove", this.eventsListeners["layer:remove"]);
    map.getLayers().un("change:zIndex", this.eventsListeners["layer:change:position"]);
    map.getView().un("change:resolution", this.eventsListeners["view:change:resolution"]);
    delete this.eventsListeners["layer:add"];
    delete this.eventsListeners["layer:remove"];
    delete this.eventsListeners["layer:change:position"];
    delete this.eventsListeners["view:change:resolution"];
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {PointerEvent} e - ...
   * @private
   */
  onShowLegendsClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger44.trace(e);
    var opened = this.buttonLegendsShow.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
};
Object.assign(Legends.prototype, LegendsDOM_default);
Object.assign(Legends.prototype, Widget_default);
var Legends_default = Legends;
if (window.ol && window.ol.control) {
  window.ol.control.Legends = Legends;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Catalog/Catalog.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Catalog/GPFcatalog.css";

// node_modules/geopf-extensions-openlayers/src/packages/Utils/TMS.json
var TMS_default = {
  "2154_10cm": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "209715.2",
      "104857.6",
      "52428.8",
      "26214.4",
      "13107.2",
      "6553.6",
      "3276.8",
      "1638.4",
      "819.2",
      "409.6",
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4",
      "0.2",
      "0.1"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 7489828571428572e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 3744914285714286e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 1872457142857143e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 2,
        matrixWidth: 1,
        scaleDenominator: 9362285714285715e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 4,
        matrixWidth: 1,
        scaleDenominator: 46811428571428575e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 7,
        matrixWidth: 1,
        scaleDenominator: 23405714285714287e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 13,
        matrixWidth: 2,
        scaleDenominator: 11702857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 26,
        matrixWidth: 4,
        scaleDenominator: 5851428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 52,
        matrixWidth: 7,
        scaleDenominator: 2925714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 103,
        matrixWidth: 13,
        scaleDenominator: 1462857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 210205,
        matrixWidth: 25200,
        scaleDenominator: 714.2857142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 420409,
        matrixWidth: 50400,
        scaleDenominator: 357.14285714285717,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "2154_10cm_10_20": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4",
      "0.2"
    ],
    tileMatrices: {
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 210205,
        matrixWidth: 25200,
        scaleDenominator: 714.2857142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "2154_10cm_6_19": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "3276.8",
      "1638.4",
      "819.2",
      "409.6",
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 13,
        matrixWidth: 2,
        scaleDenominator: 11702857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 26,
        matrixWidth: 4,
        scaleDenominator: 5851428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 52,
        matrixWidth: 7,
        scaleDenominator: 2925714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 103,
        matrixWidth: 13,
        scaleDenominator: 1462857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "2154_10cm_6_20": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "3276.8",
      "1638.4",
      "819.2",
      "409.6",
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4",
      "0.2"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 13,
        matrixWidth: 2,
        scaleDenominator: 11702857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 26,
        matrixWidth: 4,
        scaleDenominator: 5851428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 52,
        matrixWidth: 7,
        scaleDenominator: 2925714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 103,
        matrixWidth: 13,
        scaleDenominator: 1462857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 210205,
        matrixWidth: 25200,
        scaleDenominator: 714.2857142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "2154_5cm": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "209715.2",
      "104857.6",
      "52428.8",
      "26214.4",
      "13107.2",
      "6553.6",
      "3276.8",
      "1638.4",
      "819.2",
      "409.6",
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4",
      "0.2",
      "0.1",
      "0.05"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 7489828571428572e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 3744914285714286e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 1872457142857143e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 2,
        matrixWidth: 1,
        scaleDenominator: 9362285714285715e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 4,
        matrixWidth: 1,
        scaleDenominator: 46811428571428575e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 7,
        matrixWidth: 1,
        scaleDenominator: 23405714285714287e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 13,
        matrixWidth: 2,
        scaleDenominator: 11702857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 26,
        matrixWidth: 4,
        scaleDenominator: 5851428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 52,
        matrixWidth: 7,
        scaleDenominator: 2925714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 103,
        matrixWidth: 13,
        scaleDenominator: 1462857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 210205,
        matrixWidth: 25200,
        scaleDenominator: 714.2857142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 420409,
        matrixWidth: 50400,
        scaleDenominator: 357.14285714285717,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "22": {
        matrixId: "22",
        matrixHeight: 840818,
        matrixWidth: 100800,
        scaleDenominator: 178.57142857142858,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "2154_5cm_6_22": {
    projection: "EPSG:2154",
    nativeResolutions: [
      "3276.8",
      "1638.4",
      "819.2",
      "409.6",
      "204.8",
      "102.4",
      "51.2",
      "25.6",
      "12.8",
      "6.4",
      "3.2",
      "1.6",
      "0.8",
      "0.4",
      "0.2",
      "0.1",
      "0.05"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 13,
        matrixWidth: 2,
        scaleDenominator: 11702857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 26,
        matrixWidth: 4,
        scaleDenominator: 5851428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 52,
        matrixWidth: 7,
        scaleDenominator: 2925714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 103,
        matrixWidth: 13,
        scaleDenominator: 1462857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 206,
        matrixWidth: 25,
        scaleDenominator: 731428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 411,
        matrixWidth: 50,
        scaleDenominator: 365714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 822,
        matrixWidth: 99,
        scaleDenominator: 182857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 1643,
        matrixWidth: 197,
        scaleDenominator: 91428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 3285,
        matrixWidth: 394,
        scaleDenominator: 45714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 6569,
        matrixWidth: 788,
        scaleDenominator: 22857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 13138,
        matrixWidth: 1575,
        scaleDenominator: 11428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 26276,
        matrixWidth: 3150,
        scaleDenominator: 5714.285714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 52552,
        matrixWidth: 6300,
        scaleDenominator: 2857.1428571428573,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 105102,
        matrixWidth: 12600,
        scaleDenominator: 1428.5714285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 210205,
        matrixWidth: 25200,
        scaleDenominator: 714.2857142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 420409,
        matrixWidth: 50400,
        scaleDenominator: 357.14285714285717,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "22": {
        matrixId: "22",
        matrixHeight: 840818,
        matrixWidth: 100800,
        scaleDenominator: 178.57142857142858,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "LAMB93_2.5m": {
    projection: "IGNF:LAMB93",
    nativeResolutions: [
      "163840",
      "81920",
      "40960",
      "20480",
      "10240",
      "5120",
      "2560",
      "1280",
      "640",
      "320",
      "160",
      "80",
      "40",
      "20",
      "10",
      "5",
      "2.5"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5851428571428572e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 2925714285714286e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 2,
        matrixWidth: 1,
        scaleDenominator: 1462857142857143e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 3,
        matrixWidth: 1,
        scaleDenominator: 7314285714285715e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 5,
        matrixWidth: 1,
        scaleDenominator: 36571428571428575e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 9,
        matrixWidth: 1,
        scaleDenominator: 18285714285714287e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 17,
        matrixWidth: 2,
        scaleDenominator: 9142857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 33,
        matrixWidth: 4,
        scaleDenominator: 4571428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 66,
        matrixWidth: 8,
        scaleDenominator: 2285714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 132,
        matrixWidth: 16,
        scaleDenominator: 1142857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 263,
        matrixWidth: 32,
        scaleDenominator: 571428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 526,
        matrixWidth: 63,
        scaleDenominator: 285714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 1051,
        matrixWidth: 126,
        scaleDenominator: 142857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 2102,
        matrixWidth: 252,
        scaleDenominator: 71428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 4204,
        matrixWidth: 504,
        scaleDenominator: 35714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 8408,
        matrixWidth: 1008,
        scaleDenominator: 17857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 16816,
        matrixWidth: 2016,
        scaleDenominator: 8928.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  "LAMB93_2.5m_3_16": {
    projection: "IGNF:LAMB93",
    nativeResolutions: [
      "20480",
      "10240",
      "5120",
      "2560",
      "1280",
      "640",
      "320",
      "160",
      "80",
      "40",
      "20",
      "10",
      "5",
      "2.5"
    ],
    tileMatrices: {
      "3": {
        matrixId: "3",
        matrixHeight: 3,
        matrixWidth: 1,
        scaleDenominator: 7314285714285715e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 5,
        matrixWidth: 1,
        scaleDenominator: 36571428571428575e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 9,
        matrixWidth: 1,
        scaleDenominator: 18285714285714287e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 17,
        matrixWidth: 2,
        scaleDenominator: 9142857142857144e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 33,
        matrixWidth: 4,
        scaleDenominator: 4571428571428572e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 66,
        matrixWidth: 8,
        scaleDenominator: 2285714285714286e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 132,
        matrixWidth: 16,
        scaleDenominator: 1142857142857143e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 263,
        matrixWidth: 32,
        scaleDenominator: 571428.5714285715,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 526,
        matrixWidth: 63,
        scaleDenominator: 285714.28571428574,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 1051,
        matrixWidth: 126,
        scaleDenominator: 142857.14285714287,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 2102,
        matrixWidth: 252,
        scaleDenominator: 71428.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 4204,
        matrixWidth: 504,
        scaleDenominator: 35714.28571428572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 8408,
        matrixWidth: 1008,
        scaleDenominator: 17857.14285714286,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 16816,
        matrixWidth: 2016,
        scaleDenominator: 8928.57142857143,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: 0,
          y: 12e6
        }
      }
    }
  },
  PM: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697",
      "0.1492910708694849",
      "0.0746455354347424"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 1048576,
        matrixWidth: 1048576,
        scaleDenominator: 533.1823959624465,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 2097152,
        matrixWidth: 2097152,
        scaleDenominator: 266.5911979812229,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_14: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_16: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_18: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_19: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_21: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697",
      "0.1492910708694849",
      "0.0746455354347424"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 1048576,
        matrixWidth: 1048576,
        scaleDenominator: 533.1823959624465,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 2097152,
        matrixWidth: 2097152,
        scaleDenominator: 266.5911979812229,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_6: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_0_8: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "156543.0339280410",
      "78271.51696402048",
      "39135.75848201023",
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100"
    ],
    tileMatrices: {
      "0": {
        matrixId: "0",
        matrixHeight: 1,
        matrixWidth: 1,
        scaleDenominator: 5590822640287179e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "1": {
        matrixId: "1",
        matrixHeight: 2,
        matrixWidth: 2,
        scaleDenominator: 27954113201435894e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "2": {
        matrixId: "2",
        matrixHeight: 4,
        matrixWidth: 4,
        scaleDenominator: 1397705660071793e-7,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_10_12: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813"
    ],
    tileMatrices: {
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_15_18: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395"
    ],
    tileMatrices: {
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_3_15: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "19567.87924100512",
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516"
    ],
    tileMatrices: {
      "3": {
        matrixId: "3",
        matrixHeight: 8,
        matrixWidth: 8,
        scaleDenominator: 6988528300358965e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_4_10: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525"
    ],
    tileMatrices: {
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_4_18: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395"
    ],
    tileMatrices: {
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_4_19: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "9783.939620502561",
      "4891.969810251280",
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697"
    ],
    tileMatrices: {
      "4": {
        matrixId: "4",
        matrixHeight: 16,
        matrixWidth: 16,
        scaleDenominator: 3494264150179486e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "5": {
        matrixId: "5",
        matrixHeight: 32,
        matrixWidth: 32,
        scaleDenominator: 1747132075089743e-8,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_11: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_14: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_15: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_16: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_17: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_18: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_19: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_21: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395",
      "0.2985821417389697",
      "0.1492910708694849",
      "0.0746455354347424"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "19": {
        matrixId: "19",
        matrixHeight: 524288,
        matrixWidth: 524288,
        scaleDenominator: 1066.364791924893,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "20": {
        matrixId: "20",
        matrixHeight: 1048576,
        matrixWidth: 1048576,
        scaleDenominator: 533.1823959624465,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "21": {
        matrixId: "21",
        matrixHeight: 2097152,
        matrixWidth: 2097152,
        scaleDenominator: 266.5911979812229,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_6_9: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "2445.984905125640",
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048"
    ],
    tileMatrices: {
      "6": {
        matrixId: "6",
        matrixHeight: 64,
        matrixWidth: 64,
        scaleDenominator: 8735660375448715e-9,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_7_17: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879"
    ],
    tileMatrices: {
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_7_18: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "1222.992452562820",
      "611.4962262814100",
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758",
      "1.194328566955879",
      "0.5971642834779395"
    ],
    tileMatrices: {
      "7": {
        matrixId: "7",
        matrixHeight: 128,
        matrixWidth: 128,
        scaleDenominator: 4.3678301877243575e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "8": {
        matrixId: "8",
        matrixHeight: 256,
        matrixWidth: 256,
        scaleDenominator: 2.1839150938621787e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "17": {
        matrixId: "17",
        matrixHeight: 131072,
        matrixWidth: 131072,
        scaleDenominator: 4265.459167699572,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "18": {
        matrixId: "18",
        matrixHeight: 262144,
        matrixWidth: 262144,
        scaleDenominator: 2132.7295838497826,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  },
  PM_9_16: {
    projection: "EPSG:3857",
    nativeResolutions: [
      "305.7481131407048",
      "152.8740565703525",
      "76.43702828517624",
      "38.21851414258813",
      "19.10925707129406",
      "9.554628535647032",
      "4.777314267823516",
      "2.388657133911758"
    ],
    tileMatrices: {
      "9": {
        matrixId: "9",
        matrixHeight: 512,
        matrixWidth: 512,
        scaleDenominator: 1.0919575469310894e6,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "10": {
        matrixId: "10",
        matrixHeight: 1024,
        matrixWidth: 1024,
        scaleDenominator: 545978.7734655464,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "11": {
        matrixId: "11",
        matrixHeight: 2048,
        matrixWidth: 2048,
        scaleDenominator: 272989.38673277217,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "12": {
        matrixId: "12",
        matrixHeight: 4096,
        matrixWidth: 4096,
        scaleDenominator: 136494.69336638608,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "13": {
        matrixId: "13",
        matrixHeight: 8192,
        matrixWidth: 8192,
        scaleDenominator: 68247.34668319322,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "14": {
        matrixId: "14",
        matrixHeight: 16384,
        matrixWidth: 16384,
        scaleDenominator: 34123.673341596535,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "15": {
        matrixId: "15",
        matrixHeight: 32768,
        matrixWidth: 32768,
        scaleDenominator: 17061.83667079829,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      },
      "16": {
        matrixId: "16",
        matrixHeight: 65536,
        matrixWidth: 65536,
        scaleDenominator: 8530.918335399145,
        tileHeight: 256,
        tileWidth: 256,
        topLeftCorner: {
          x: -200375083427892e-7,
          y: 200375083427892e-7
        }
      }
    }
  }
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/LayerConfigUtils.js
var LayerConfigUtils = {
  /**
   * Get the layer configuration from the given config object.
   *
   * @param {*} config The configuration object containing layer information.
   * @returns {*} An object containing the extracted layer configuration parameters.
   */
  getLayerConfig: function(config) {
    var params2 = {};
    if (config) {
      var service = config.serviceParams.id.split(/:/)[1];
      var key = Object.keys(config.serviceParams.serverUrl)[0];
      params2.url = config.serviceParams.serverUrl[key];
      if (service !== "WFS") {
        const wmsTypeRegex = /\/v\//;
        if (wmsTypeRegex.test(params2.url)) {
          params2.styles = " ";
        } else {
          params2.styles = config.styles[0].name;
        }
      }
      params2.version = config.serviceParams.version;
      params2.format = config.formats && config.formats.length ? config.formats[0].name : "";
      params2.projection = config.defaultProjection;
      params2.minScale = config.globalConstraint ? config.globalConstraint.minScaleDenominator : null;
      params2.maxScale = config.globalConstraint ? config.globalConstraint.maxScaleDenominator : null;
      params2.extent = config.globalConstraint ? config.globalConstraint.bbox : null;
      params2.legends = config.legends;
      params2.title = config.title;
      params2.description = config.description;
      if (service === "WMS") {
        params2.metadata = config.metadata;
      }
      if (config.wmtsOptions) {
        params2.tileMatrixSetLimits = config.wmtsOptions.tileMatrixSetLimits;
        var TMSLink = config.wmtsOptions.tileMatrixSetLink;
        if (TMSLink) {
          params2.TMSLink = TMSLink;
          var tmsConf = this.getTMSConfig(TMSLink);
          params2.matrixIds = Object.keys(tmsConf.tileMatrices);
          params2.tileMatrices = tmsConf.tileMatrices;
          params2.nativeResolutions = tmsConf.nativeResolutions || this.getTMSConfig("PM").nativeResolutions;
        }
      }
    }
    return {
      params: params2
    };
  },
  /**
   * Get the TMS configuration for a given ID.
   *
   * @param {*} id The ID of the TMS configuration to retrieve.
   * @returns {*} The TMS configuration object corresponding to the given ID.
   */
  getTMSConfig: function(id) {
    return TMS_default[id];
  }
};
var LayerConfigUtils_default = LayerConfigUtils;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Catalog/CatalogDOM.js
var stringToHTML2 = (str) => {
  var support = function() {
    if (!window.DOMParser) {
      return false;
    }
    var parser2 = new DOMParser();
    try {
      parser2.parseFromString("x", "text/html");
    } catch (err) {
      return false;
    }
    return true;
  };
  if (support()) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(str, "text/html");
    return doc.body;
  }
  var dom = document.createElement("div");
  dom.innerHTML = str;
  return dom;
};
var CatalogDOM = {
  /**
   * Generate an ID from a text
   *
   * @param {String} text - text
   * @returns {String} id - id
   */
  generateID: function(text) {
    return Math.abs(Array.from(text).reduce((s, c) => Math.imul(31, s) + c.charCodeAt(0) | 0, 0));
  },
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPcatalog");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show Catalog
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowCatalogPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowCatalogPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowCatalogPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-catalog");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Catalogue de donnÃ©es");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowCatalogClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowCatalogClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createCatalogPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPcatalogPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  /**
   * Container Panel Size
   * @param {*} size - sm, md, lg
   * @returns  {HTMLElement} DOM element
   * @fixme revoir le fonctionnement des tailles !?
   * @description
   * - sm : small (default)
   * - md : medium
   * - lg : large
   * - xl : extra large
   * cf. https://www.systeme-de-design.gouv.fr/elements-d-interface/composants/modale#taille
   */
  _createCatalogPanelDivSizeElement: function(size) {
    if (!size) {
      size = "md";
    }
    var className = "";
    switch (size) {
      case "sm":
        className = "fr-col-8";
        break;
      case "md":
        className = "fr-col-10";
        break;
      case "lg":
        className = "fr-col-12";
        break;
      case "xl":
        className = "fr-col-14";
        break;
      default:
        break;
    }
    var div = document.createElement("div");
    div.className = className;
    return div;
  },
  _createCatalogPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  _createCatalogPanelContentDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__content fr-modal__content";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createCatalogPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header_catalog";
    return container;
  },
  _createCatalogPanelTitleElement: function(title3) {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title_catalog";
    div.innerHTML = title3;
    return div;
  },
  _createCatalogPanelIconElement: function(title3) {
    var label = document.createElement("label");
    label.className = "gpf-btn-header-catalog gpf-btn-icon-header-catalog";
    label.title = title3;
    return label;
  },
  _createCatalogPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.id = this._addUID("GPcatalogPanelClose");
    btnClose.className = "GPpanelClose GPcatalogPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline";
    btnClose.title = "Fermer le panneau";
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowCatalogPicto")).click();
        self2.onCloseCatalogClick();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowCatalogPicto")).click();
        self2.onCloseCatalogClick();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-hidden";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    return btnClose;
  },
  // ################################################################### //
  // ####################### Methods for panel ######################### //
  // ################################################################### //
  _createCatalogContentDivElement: function() {
    var container = stringToHTML2(`<div class="catalog-container-content" style=""></div>`);
    return container.firstChild;
  },
  _createCatalogContentTitleElement: function(title3) {
    var container = stringToHTML2(`
        <!-- titre -->
        <div class="catalog-container-title">
            <div class="fr-title">
                <h5 style="margin:unset">${title3}</h5>
            </div>
        </div>
        `);
    return container.firstChild;
  },
  _createCatalogContentSearchGlobalElement: function(label) {
    var strContainer = `
        <!-- barre de recherche globale -->
        <!-- https://www.systeme-de-design.gouv.fr/composants-et-modeles/composants/barre-de-recherche -->
        <div class="catalog-container-search-global" style="padding:10px;">
            <div class="fr-search-bar" id="catalog-header-search-global" role="search" style="justify-content: center;">
                <label class="fr-label" for="catalog-input-search-global">
                    Recherche
                </label>
                <div class="input-wrapper" style="width:100%;">
                    <input class="fr-input" placeholder="${label}" type="text" id="catalog-input-search-global" name="search-input" incremental>
                    <button type="button" id="catalog-button-reset-search-global" class="clear-btn" aria-label="Effacer le texte">
                        <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="10" cy="10" r="9" stroke="currentColor" stroke-opacity="0.8"/>
                            <line x1="6" y1="6" x2="14" y2="14"/>
                            <line x1="14" y1="6" x2="6" y2="14"/>
                        </svg>
                    </button>
                </div>
                <button id="catalog-button-search-global" class="fr-btn" title="${label}">
                    Rechercher
                </button>
            </div>
        </div>
        `;
    var container = stringToHTML2(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById("catalog-button-search-global");
    if (button) {
      button.addEventListener("click", (e) => {
        e.target.value = input.value;
        this.onSearchGlobalCatalogButtonClick(e);
      });
    }
    var reset = shadow.getElementById("catalog-button-reset-search-global");
    if (reset) {
      reset.addEventListener("click", (e) => {
        input.value = "";
        this.onSearchGlobalCatalogButtonResetClick(e);
      });
    }
    var input = shadow.getElementById("catalog-input-search-global");
    if (input) {
      input.addEventListener("input", (e) => {
        if (e.target.value.length < 3 && e.target.value.length > 0) {
          return;
        }
        this.onSearchGlobalCatalogInputChange(e);
      });
    }
    return shadow;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createCatalogWaitingElement: function() {
    var div = document.createElement("div");
    div.id = this._addUID("GPcatalogCalcWaitingContainer");
    div.className = "GPwaitingContainerHidden gpf-waiting--hidden";
    var p2 = document.createElement("p");
    p2.className = "GPwaitingContainerInfo gpf-waiting_info";
    p2.innerHTML = "Recherche en cours...";
    div.appendChild(p2);
    return div;
  },
  /**
   * Create Catalog Content Categories Tabs
   * 
   * @param {Categories} categories - categories to create tabs
   * @param {Boolean} tabHeightAuto - size auto or fixe
   * @returns {HTMLElement} DOM element
   * @description
   * - create the tabs for categories
   * - each tab has a button to select the category
   * - each tab has a panel with subcategories (if any)
   * - each subcategory has a radio button to select it
   * - each subcategory has a panel with layers
   */
  _createCatalogContentCategoriesTabs: function(categories, tabHeightAuto) {
    var strCategoriesTabButtons = "";
    var tmplCategoryTabButton = (i, id, title3, selected) => {
      var className = "GPtabButton fr-tabs__tab";
      var value2 = "false";
      var tabindex = -1;
      if (selected) {
        className = "GPtabButton GPtabButtonActive fr-tabs__tab";
        value2 = "true";
        tabindex = 0;
      }
      return `
            <li class="GPtabList" role="presentation">
                <button 
                    id="tabbutton-${i}_${id}" 
                    class="${className}" 
                    data-category="${id}"
                    tabindex="${tabindex}" 
                    role="tabbutton" 
                    aria-selected="${value2}" 
                    aria-controls="tabpanel-${i}-panel_${id}">
                    ${title3}
                </button>
            </li>
            `;
    };
    var tmplSearchSpecificBar = (active, title3) => {
      var className = "gpf-hidden";
      if (active) {
        className = "fr-tabs__panel--selected";
      }
      return `
            <!-- barre de recherche spÃ©cifique Ã  la catÃ©gorie -->
            <div id="catalog-container-search-specific" class="fr-tabs__list ${className}" style="padding:10px;justify-content:center;">
                <div class="fr-search-bar" id="catalog-header-search-specific" role="search" style="width:100%;">
                    <label class="fr-label" for="catalog-input-search-specific">
                        Recherche dans la catÃ©gorie
                    </label>
                    <div class="input-wrapper" style="width:100%">
                        <input class="fr-input" placeholder="${title3}" type="text" id="catalog-input-search-specific" name="search-input-specific" incremental>
                        <button type="button" id="catalog-button-reset-search-specific" class="clear-btn" aria-label="Effacer le texte">
                            <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="10" cy="10" r="9" stroke="currentColor" stroke-opacity="0.8"/>
                                <line x1="6" y1="6" x2="14" y2="14"/>
                                <line x1="14" y1="6" x2="6" y2="14"/>
                            </svg>
                        </button>
                    </div>
                    <button id="catalog-button-search-specific" class="fr-btn" title="${title3}">
                        Rechercher
                    </button>
                </div>
            </div>
            `;
    };
    var tmplSubCategoryRadio = (id, subcategory) => {
      var checked = subcategory.default ? "checked" : "";
      return `
            <div class="fr-fieldset__element fr-fieldset__element--inline">
                <div class="fr-radio-group fr-radio-group--sm">
                    <input 
                        type="radio" 
                        ${checked} 
                        id="radio-inline_${subcategory.id}" 
                        data-category="${subcategory.id}"
                        name="radio-inline-${id}" 
                        role="radio-inline-section"
                        aria-controls="tabcontent-${subcategory.id}">
                    <label class="fr-label" for="radio-inline_${subcategory.id}">
                        ${subcategory.title}
                    </label>
                </div>
            </div>
            `;
    };
    var tmplSubCategoriesRadios = (id, subcategories) => {
      var strTabContents = "";
      var strSubCategoriesRadios = "";
      for (let j2 = 0; j2 < subcategories.length; j2++) {
        const subcategory = subcategories[j2];
        strSubCategoriesRadios += tmplSubCategoryRadio(id, subcategory);
        var hidden = "";
        if (!subcategory.default) {
          hidden = "GPelementHidden gpf-hidden";
        }
        strTabContents += `<div class="tabcontent ${hidden}" data-category="${id}" role="tabpanel-section" id="tabcontent-${subcategory.id}"></div>`;
      }
      return `
            <!-- boutons radio des sous categories -->
            <fieldset class="fr-fieldset" id="radio-inline_${id}" aria-labelledby="radio-inline-legend radio-inline-messages" style="margin:unset;">
                ${strSubCategoriesRadios}
                <div class="fr-messages-group" id="radio-inline-messages" aria-live="assertive"></div>
            </fieldset>
            <!-- panneaux des sous categories -->
            ${strTabContents}
            `;
    };
    var strCategoriesTabPanelContents = "";
    var tmplCategoryTabPanelContent = (i, id, selected, search, subcategories, active) => {
      var className = "GPtabContent fr-tabs__panel";
      var tabindex = -1;
      if (selected) {
        className = "GPtabContent GPtabContentSelected fr-tabs__panel fr-tabs__panel--selected";
        tabindex = 0;
      }
      var strTabContent = `<div class="tabcontent" data-category="${id}" style="content-visibility: auto;contain-intrinsic-size:50px;"></div>`;
      if (subcategories) {
        strTabContent = tmplSubCategoriesRadios(id, subcategories);
      }
      var height = "330px";
      if (active && !search) {
        height = "390px";
      }
      return `
            <!-- panneaux -->
            <div id="tabpanel-${i}-panel_${id}" 
                class="${className}" 
                role="tabpanel" 
                aria-labelledby="tabbutton-${i}_${id}" 
                tabindex="${tabindex}" 
                style="max-height: ${height};overflow-y: auto; padding: 1em; contain: content;">
                ${strTabContent}
            </div>
            `;
    };
    var currentActiveBar = false;
    var hasActiveBar = false;
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];
      if (category.search) {
        hasActiveBar = true;
      }
      if (category.default && category.search) {
        currentActiveBar = true;
      }
    }
    for (let j2 = 0; j2 < categories.length; j2++) {
      const category = categories[j2];
      strCategoriesTabButtons += tmplCategoryTabButton(j2, category.id, category.title, category.default);
      strCategoriesTabPanelContents += tmplCategoryTabPanelContent(j2, category.id, category.default, category.search, category.items, hasActiveBar);
    }
    const titleSpecifBar = "Rechercher une donnÃ©e dans la catÃ©gorie";
    var strSearchSpecificBar = tmplSearchSpecificBar(currentActiveBar, titleSpecifBar);
    var classTabHeight = "gpf-catalog-tabs-fixe";
    if (hasActiveBar) {
      classTabHeight = "gpf-catalog-tabs-fixe-with-bar";
    }
    var strContainer = `
        <!-- onglets -->
        <div id="GPcatalogContainerTabs" class="catalog-container-tabs">
            <div class="GPtabs fr-tabs ${tabHeightAuto ? "" : classTabHeight}">
                <ul class="GPtabsList fr-tabs__list" role="tablist" aria-label="presentation">
                    ${strCategoriesTabButtons}
                </ul>
                ${strSearchSpecificBar}
                ${strCategoriesTabPanelContents}
            </div>
        </div>
        `;
    var container = stringToHTML2(strContainer.trim());
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var panelSections = shadow.querySelectorAll('[role="tabpanel-section"]');
    var radios = shadow.querySelectorAll('[role="radio-inline-section"]');
    if (radios) {
      radios.forEach((radio) => {
        radio.addEventListener("change", (e) => {
          for (let j2 = 0; j2 < panelSections.length; j2++) {
            const section = panelSections[j2];
            var category = section.getAttribute("data-category");
            if (category === e.target.name.split("-")[2]) {
              section.classList.add("gpf-hidden");
              section.classList.add("GPelementHidden");
            }
          }
          var panel = document.getElementById(e.target.getAttribute("aria-controls"));
          panel.classList.remove("gpf-hidden");
          panel.classList.remove("GPelementHidden");
          this.onToggleCatalogRadioChange(e, e.target.getAttribute("data-category"));
        });
      });
    }
    var panelContents = shadow.querySelectorAll('[role="tabpanel"]');
    var buttons = shadow.querySelectorAll('[role="tabbutton"]');
    if (buttons) {
      buttons.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          for (let i = 0; i < buttons.length; i++) {
            const button = buttons[i];
            button.setAttribute("tabindex", -1);
            button.ariaSelected = false;
            button.classList.remove("GPtabButtonActive");
          }
          e.target.setAttribute("tabindex", 0);
          e.target.ariaSelected = true;
          e.target.classList.add("GPtabButtonActive");
          for (let j2 = 0; j2 < panelContents.length; j2++) {
            const panel2 = panelContents[j2];
            panel2.setAttribute("tabindex", -1);
            panel2.classList.remove("fr-tabs__panel--selected");
            panel2.classList.remove("GPtabContentSelected");
            panel2.classList.add("gpf-hidden");
            panel2.classList.add("GPelementHidden");
          }
          var panel = document.getElementById(e.target.getAttribute("aria-controls"));
          panel.setAttribute("tabindex", 0);
          panel.classList.add("fr-tabs__panel--selected");
          panel.classList.add("GPtabContentSelected");
          panel.classList.remove("gpf-hidden");
          panel.classList.remove("GPelementHidden");
          this.onSelectCatalogTabClick(e, e.target.getAttribute("data-category"));
        });
      });
    }
    var searchBtn = shadow.getElementById("catalog-button-search-specific");
    if (searchBtn) {
      searchBtn.addEventListener("click", (e) => {
        e.target.value = searchInput.value;
        this.onSearchSpecificCatalogButtonClick(e);
      });
    }
    var resetBtn = shadow.getElementById("catalog-button-reset-search-specific");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        searchInput.value = "";
        this.onSearchSpecificCatalogButtonResetClick(e);
      });
    }
    var searchInput = shadow.getElementById("catalog-input-search-specific");
    if (searchInput) {
      searchInput.addEventListener("input", (e) => {
        if (e.target.value.length < 3 && e.target.value.length > 0) {
          return;
        }
        this.onSearchSpecificCatalogInputChange(e);
      });
    }
    return shadow;
  },
  /**
   * Create Catalog Content Category Tab Content (layers)
   *
   * @param {Categories} category - category to create tab content
   * @param {*} layersFiltered - filtered layers for the category
   * @param {Boolean} nodata - do not write the data to the DOM
   * @returns {HTMLElement} DOM element
   * @description
   * - create the content for a category tab
   * - each layer has a checkbox to select it
   * - each layer has a panel with information
   */
  _createCatalogContentCategoryTabContent: async function(category, layersFiltered, nodata) {
    var layers = Object.values(layersFiltered).sort((a2, b3) => a2.title.localeCompare(b3.title, "fr", { sensitivity: "base" }));
    const batchSize = 10;
    var blocks = [];
    var strElements = "";
    var tmplElement = (i, name, title3, service, description, informations, thumbnail, categoryId) => {
      var tmplThumbnail = (thumbnail2) => {
        if (thumbnail2) {
          if (thumbnail2.startsWith("data:") || thumbnail2.startsWith("http")) {
            return `
                        <div class="catalog-thumbnail" style="width:50px; height:50px; margin-right:10px; flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                            <img src="${thumbnail2}" alt="AperÃ§u de la couche" style="min-width:100%;min-height:100%;object-fit:cover;"/>
                        </div>
                        `;
          } else {
            thumbnail2 = "default";
          }
          if (thumbnail2 === "default") {
            return `<div class="catalog-thumbnail-default" style="width:50px; height:50px; margin-right:10px; flex-shrink:0; display:flex; align-items:center; justify-content:center; overflow:hidden;"></div>`;
          }
        }
        return "";
      };
      var producerName = informations.producers ? informations.producers[0].name : "";
      var tmplProducers = (producers) => {
        if (!producers) {
          return ``;
        }
        var data = "";
        for (let i2 = 0; i2 < producers.length; i2++) {
          const producer = producers[i2];
          data += `
                        <a href="${producer.url}" target="_blank" class="fr-tag fr-tag--sm fr-icon-arrow-right-line fr-tag--icon-left">
                            ${producer.name}
                        </a>
                    `;
        }
        return data;
      };
      var tmplMetadatas = (metadatas) => {
        if (!metadatas) {
          return ``;
        }
        var data = "";
        for (let i2 = 0; i2 < metadatas.length; i2++) {
          const metadata = metadatas[i2];
          if (metadata.includes("catalogue/dataset")) {
            return `
                            <a href="${metadata}" target="_blank" class="fr-link fr-icon-arrow-right-line fr-link--icon-right">
                                Voir la fiche dÃ©taillÃ©e
                            </a>
                        `;
          }
        }
        return data;
      };
      var tmplThematics = (thematics) => {
        if (!thematics) {
          return ``;
        }
        var data = "";
        for (let i2 = 0; i2 < thematics.length; i2++) {
          const thematic = thematics[i2];
          data += `
                        <a href="${thematic.url}" target="_blank" class="fr-tag fr-tag--sm fr-icon-arrow-right-line fr-tag--icon-left">
                            ${thematic.name}
                        </a>
                    `;
        }
        return data;
      };
      return `
            <div 
                class="fr-fieldset__element" 
                id="fieldset-${categoryId}_${name}-${service}"
                style="contain: content;">
                <div class="fr-checkbox-group gpf-flex" style="justify-content:flex-start;padding-top:5px;padding-bottom:5px;box-shadow: inset 0 1px 0 0 var(--border-default-grey),0 0 0 0 var(--border-default-grey);">
                    <input
                        class="fr-input"
                        name="checkboxes-${categoryId}"
                        id="checkboxes-${categoryId}-${i}_${name}-${service}"
                        type="checkbox"
                        data-layer="${name}:${service}"/>
                    <label 
                        for="checkboxes-${categoryId}-${i}_${name}-${service}"
                        style="position: relative; bottom: 12px;">
                    </label>
                    <div class="catalog-thumbnail-container" style="">
                        ${tmplThumbnail(thumbnail)}
                    </div>
                    <div style="width: 100%;">
                        <label 
                            class="GPlabelActive fr-label"
                            role="label-collapse-more-${categoryId}"
                            aria-controls="catalog-collapse-more-${i}-${categoryId}"
                            title="${title3}"
                            style="display: -webkit-box; width: 100%; text-overflow: ellipsis; overflow: hidden; white-space: normal; cursor: pointer; line-height: 1.9em; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                            ${title3}
                        </label>
                        <span class="GPlabelActive fr-label fr-hint-text">${producerName}</span>
                    </div>
                    <button 
                        id="catalog-collapse-more-${i}-${categoryId}"
                        role="button-collapse-more-${categoryId}"
                        class="catalog-collapse-show gpf-btn gpf-btn-icon gpf-btn-icon-catalog-collapse fr-btn fr-btn--tertiary gpf-btn--tertiary" 
                        type="button" 
                        title="En savoir plus sur la couche" 
                        tabindex="0" 
                        aria-pressed="false"
                        aria-controls="catalog-info-more-${i}-${categoryId}"
                        style="position: relative;">
                    </button>
                </div>
                <div class="gpf-hidden" id="catalog-info-more-${i}-${categoryId}">
                    <p>
                        <span class="fr-label fr-message" style="word-break: break-all;">${name} - ${service}</span>
                        ${tmplProducers(informations.producers)}
                    </p>
                    <p>
                        ${description}
                    </p>
                    ${tmplMetadatas(informations.metadatas)}
                </div>
            </div>
            `;
    };
    var strSections = "";
    var tmplSection = (id2, categoryId, title3, icon2, count2, data) => {
      var classNameIcon = icon2 && icon2.startsWith("fr-icon") ? icon2 : "";
      var idCollapseSection = `section-accordion-${categoryId}-${id2}`;
      return `
            <!-- section -->
            <section 
                id="section-${categoryId}-${id2}" 
                data-category="${categoryId}"
                data-id="${id2}"
                class="fr-accordion" style="contain: content;">
                <h3 class="fr-accordion__title">
                    <button class="GPcatalogButtonSection fr-accordion__btn gpf-accordion__btn" role="section-collapse-${categoryId}" aria-expanded="false" aria-controls="${idCollapseSection}">
                        <span class="GPshowCatalogAdvancedTools gpf-hidden"></span>
                        <span class="catalog-section-icon ${classNameIcon}" role="section-icon-collapse-${categoryId}" style="width: calc(100% - 2rem);">${title3}</span>
                        <span class="catalog-section-count" role="section-count-collapse-${categoryId}" id="section-count-${categoryId}-${id2}" style="position: absolute; right: 1.25rem;">${count2}</span>
                    </button>
                </h3>
                <div class="fr-collapse GPelementHidden" id="${idCollapseSection}">
                    ${data}
                </div>
            </section>
            `;
    };
    var isSection = category.section;
    if (isSection) {
      layers = layers.sort((a2, b3) => {
        return a2[category.filter.field][0].localeCompare(b3[category.filter.field][0]);
      });
    }
    var sections = {};
    var lstElements = [];
    for (let i = 0; i < layers.length; i += batchSize) {
      for (let j2 = i; j2 < Math.min(i + batchSize, layers.length); j2++) {
        const layer = layers[j2];
        const infos = {
          producers: layer.producer_urls,
          // tableau d'objets [{name,url}]
          thematics: layer.thematic_urls,
          // tableau d'objets [{name,url}]
          metadatas: layer.metadata_urls
          // tableau
        };
        var strElement = tmplElement(j2, layer.name, layer.label, layer.service, layer.description, infos, layer.thumbnail, category.id);
        if (isSection) {
          var value2 = layer[category.filter.field];
          if (Array.isArray(value2)) {
            value2 = value2[0];
          }
          if (value2) {
            if (!sections.hasOwnProperty(value2)) {
              sections[value2] = "";
            }
            sections[value2] += strElement;
          } else {
            if (!sections.hasOwnProperty("Autres")) {
              sections["Autres"] = "";
            }
            sections["Autres"] += strElement;
          }
        } else {
          strElements += strElement;
          lstElements.push(strElement);
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    if (strElements !== "") {
      var container = stringToHTML2(strElements);
      const shadow2 = container.attachShadow({ mode: "open" });
      shadow2.innerHTML = strElements.trim();
      blocks.push({
        domid: `checkboxes-${category.id}`,
        rows: lstElements,
        fragment: shadow2,
        debug: {
          type: "layers",
          desc: "liste des couches pour une categorie",
          title: category.title
        }
      });
      if (nodata) {
        strElements = "";
      }
    }
    if (isSection) {
      category.sections = [];
      for (const title3 in sections) {
        if (Object.prototype.hasOwnProperty.call(sections, title3)) {
          const data = sections[title3];
          var lstElementsBySection = [];
          var array = [...data.matchAll(/"fr-fieldset__element"/g)];
          for (let index2 = 0; index2 < array.length; index2++) {
            const el = array[index2];
            lstElementsBySection.push(el.input);
          }
          var count = array.length;
          var id = this.generateID(title3);
          var icon = "";
          if (category.icon && category.iconJson) {
            const found = category.iconJson.find((obj) => obj.name === title3);
            if (found) {
              icon = found.icon;
            } else {
              icon = "fr-icon-folder-2-fill";
            }
          }
          var strSection = tmplSection(id, category.id, title3, icon, count, nodata ? "" : data);
          strSections += strSection;
          category.sections.push(title3);
          if (strSection !== "") {
            var container = stringToHTML2(data);
            const shadow2 = container.attachShadow({ mode: "open" });
            shadow2.innerHTML = data.trim();
            blocks.push({
              domid: `section-accordion-${category.id}-${id}`,
              rows: lstElementsBySection,
              fragment: shadow2,
              debug: {
                type: "section",
                desc: "liste des couches pour une section",
                title: title3,
                id,
                category: category.id
              }
            });
          }
        }
      }
    }
    var strContainer = `
            <!-- liste de donnÃ©es -->
            <div class="fr-accordions-group" 
                id="checkboxes-${category.id}" 
                data-category="${category.id}"
                data-sections="${strSections ? true : false}"
                aria-labelledby="checkboxes-legend checkboxes-messages"
                style="contain: content;">
                ${strSections || strElements}
            </div>
        `;
    var container = stringToHTML2(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    return {
      dom: shadow,
      blocks
    };
  },
  /**
   * Update DOM listeners
   * @param {HTMLElement} content - ...
   * @param {String} id  - ...
   */
  _updateListenersLayersDOM: function(content, id) {
    var inputName = `checkboxes-${id}`;
    var inputs = content.querySelectorAll('[name="' + inputName + '"]');
    if (inputs) {
      inputs.forEach((input) => {
        input.addEventListener("click", (e) => {
          this.onSelectCatalogEntryClick(e);
        });
      });
    }
    var buttonName = `section-collapse-${id}`;
    var buttons = content.querySelectorAll('[role="' + buttonName + '"]');
    if (buttons) {
      buttons.forEach((button) => {
        button.addEventListener("click", (e) => {
          e.target.ariaExpanded = !(e.target.ariaExpanded === "true");
          var collapseId = e.target.getAttribute("aria-controls");
          var collapse = document.getElementById(collapseId);
          if (!collapse) {
            return;
          }
          var sectionId = collapseId.replace("section-accordion", "section");
          var section = document.getElementById(sectionId);
          var categoryId = section ? section.dataset.category : null;
          if (e.target.ariaExpanded === "true") {
            collapse.classList.add("fr-collapse--expanded");
            collapse.classList.remove("GPelementHidden");
            if (section) {
              section.classList.add("catalog-section-full");
              this.updateVisibilitySectionsByCategory(sectionId, categoryId, false);
            }
            const container = button.closest('div[id^="tabpanel-"]');
            const buttonRect = button.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const offset = buttonRect.top - containerRect.top;
            container.scrollTo({
              top: container.scrollTop + offset,
              behavior: "smooth"
            });
          } else {
            collapse.classList.remove("fr-collapse--expanded");
            collapse.classList.add("GPelementHidden");
            if (section) {
              section.classList.remove("catalog-section-full");
              this.updateVisibilitySectionsByCategory(sectionId, categoryId, true);
            }
          }
          this.onToggleCatalogSectionClick(e, categoryId, collapseId);
        }, false);
      });
    }
    var buttonNameMore = `button-collapse-more-${id}`;
    var buttonsMore = content.querySelectorAll('[role="' + buttonNameMore + '"]');
    if (buttonsMore) {
      buttonsMore.forEach((button) => {
        button.addEventListener("click", (e) => {
          e.target.ariaPressed = !(e.target.ariaPressed === "true");
          var collapse = document.getElementById(e.target.getAttribute("aria-controls"));
          if (!collapse) {
            return;
          }
          if (e.target.ariaPressed === "true") {
            collapse.classList.add("gpf-visible");
            collapse.classList.remove("gpf-hidden");
            button.closest('div[id^="tabpanel-"]');
            const container = button.closest('div[id^="tabpanel-"]');
            const buttonRect = button.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const offset = buttonRect.top - containerRect.top;
            container.scrollTo({
              top: container.scrollTop + offset,
              behavior: "smooth"
            });
          } else {
            collapse.classList.remove("gpf-visible");
            collapse.classList.add("gpf-hidden");
          }
          this.onToggleCatalogMoreLearnClick(e);
        }, false);
      });
    }
    var labelNameMore = `label-collapse-more-${id}`;
    var labelsMore = content.querySelectorAll('[role="' + labelNameMore + '"]');
    if (labelsMore) {
      labelsMore.forEach((label) => {
        label.addEventListener("click", (e) => {
          var button = document.getElementById(e.target.getAttribute("aria-controls"));
          if (!button) {
            return;
          }
          button.click();
        }, false);
      });
    }
    var spanIconName = `section-icon-collapse-${id}`;
    var spanIcons = content.querySelectorAll('[role="' + spanIconName + '"]');
    if (spanIcons) {
      spanIcons.forEach((span) => {
        span.addEventListener("click", (e) => {
          e.target.parentElement.click();
        });
      });
    }
    var spanCountName = `section-count-collapse-${id}`;
    var spanCounts = content.querySelectorAll('[role="' + spanCountName + '"]');
    if (spanCounts) {
      spanCounts.forEach((span) => {
        span.addEventListener("click", (e) => {
          e.target.parentElement.click();
        });
      });
    }
  },
  updateVisibilitySectionsByCategory(sectionId, categoryId, visible) {
    var selector = `[id^="section-${categoryId}-"]`;
    var sections = document.querySelectorAll(selector);
    for (let i = 0; i < sections.length; i++) {
      const section = sections[i];
      if (section.id === sectionId) {
        continue;
      }
      if (visible) {
        var idCount = `section-count-${categoryId}-${section.getAttribute("data-id")}`;
        var countDom = document.getElementById(idCount);
        var count = parseInt(countDom.textContent, 10);
        if (count === 0) {
          continue;
        }
        section.classList.remove("gpf-hidden");
        section.classList.remove("GPelementHidden");
      } else {
        section.classList.add("gpf-hidden");
        section.classList.add("GPelementHidden");
      }
    }
  }
};
var CatalogDOM_default = CatalogDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Catalog/topics.json
var topics_default = {
  thematic: [
    {
      id: "biota",
      name: "Biologie, faune et flore",
      icon: "fr-icon-plant-fill"
    },
    {
      id: "boundaries",
      name: "Limites politiques et administratives",
      icon: "fr-icon-france-line"
    },
    {
      id: "climatologyMeteorologyAtmosphere",
      name: "Climatologie, mÃ©tÃ©orologie, atmosphÃ¨re",
      icon: "fr-icon-heavy-showers-fill"
    },
    {
      id: "economy",
      name: "Ã‰conomie",
      icon: "fr-icon-bar-chart-box-fill"
    },
    {
      id: "elevation",
      name: "AltimÃ©trie",
      icon: "fr-icon-line-chart-fill"
    },
    {
      id: "environment",
      name: "Environnement",
      icon: "fr-icon-leaf-fill"
    },
    {
      id: "farming",
      name: "Agriculture",
      icon: "fr-icon-seedling-fill"
    },
    {
      id: "geoscientificInformation",
      name: "Sciences de la terre, gÃ©osciences",
      icon: "fr-icon-earth-fill"
    },
    {
      id: "health",
      name: "SantÃ©",
      icon: "fr-icon-first-aid-kit-fill"
    },
    {
      id: "imageryBaseMapsEarthCover",
      name: "Carte de rÃ©fÃ©rence de la couverture terrestre",
      icon: "fr-icon-global-fill"
    },
    {
      id: "intelligenceMilitary",
      name: "Infrastructures militaires",
      icon: "fr-icon-medal-fill"
    },
    {
      id: "inlandWaters",
      name: "Eaux intÃ©rieures, Hydrographie",
      icon: "fr-icon-drop-fill"
    },
    {
      id: "location",
      name: "Localisation",
      icon: "fr-icon-road-map-fill"
    },
    {
      id: "oceans",
      name: "OcÃ©ans",
      icon: "fr-icon-fr--submersion-fill"
    },
    {
      id: "planningCadastre",
      name: "Cadastre, amÃ©nagement",
      icon: "fr-icon-layout-grid-fill"
    },
    {
      id: "society",
      name: "SociÃ©tÃ©",
      icon: "fr-icon-capsule-fill"
    },
    {
      id: "structure",
      name: "Constructions et ouvrages",
      icon: "fr-icon-community-fill"
    },
    {
      id: "transportation",
      name: "Infrastructures de transport",
      icon: "fr-icon-bus-fill"
    },
    {
      id: "utilitiesCommunication",
      name: "TÃ©lÃ©communication, approvisionnement et Ã©nergie",
      icon: "fr-icon-lightbulb-fill"
    }
  ],
  service: [
    { id: "wmts", name: "WMTS", icon: "fr-icon-earth-line" },
    { id: "wfs", name: "WFS", icon: "fr-icon-earth-fill" },
    { id: "wms", name: "WMS", icon: "fr-icon-earth-line" },
    { id: "tms", name: "TMS", icon: "fr-icon-earth-fill" }
  ],
  producer: [
    { id: "ign", name: "IGN", icon: "fr-icon-government-fill" }
  ]
};

// node_modules/marked/lib/marked.esm.js
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var T = L();
function G(l3) {
  T = l3;
}
var E = { exec: () => null };
function d(l3, e = "") {
  let t = typeof l3 == "string" ? l3 : l3.source, n = { replace: (r2, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r2, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var be = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return false;
  }
})();
var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l3) => new RegExp(`^( {0,3}${l3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}#`), htmlBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}<(?:[a-z].*>|!--)`, "i") };
var Re = /^(?:[ \t]*(?:\n|$))+/;
var Te = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var Oe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var I2 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var we = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var F = /(?:[*+-]|\d{1,9}[.)])/;
var ie = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var oe = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var ye = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var Pe = /^[^\n]+/;
var Q = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/;
var Se = d(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var $e = d(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F).getRegex();
var v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var _e = d("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var ae = d(j).replace("hr", I2).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex();
var Le = d(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ae).getRegex();
var K = { blockquote: Le, code: Te, def: Se, fences: Oe, heading: we, hr: I2, html: _e, lheading: oe, list: $e, newline: Re, paragraph: ae, table: E, text: Pe };
var re = d("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", I2).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex();
var Me = { ...K, lheading: ye, table: re, paragraph: d(j).replace("hr", I2).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() };
var ze = { ...K, html: d(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: d(j).replace("hr", I2).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", oe).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() };
var Ae = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var Ee = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var le = /^( {2,}|\\)\n(?!\s*$)/;
var Ie = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var D = /[\p{P}\p{S}]/u;
var W = /[\s\p{P}\p{S}]/u;
var ue = /[^\s\p{P}\p{S}]/u;
var Ce = d(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex();
var pe = /(?!~)[\p{P}\p{S}]/u;
var Be = /(?!~)[\s\p{P}\p{S}]/u;
var qe = /(?:[^\s\p{P}\p{S}]|~)/u;
var ve = d(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", be ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex();
var ce = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var De = d(ce, "u").replace(/punct/g, D).getRegex();
var He = d(ce, "u").replace(/punct/g, pe).getRegex();
var he = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var Ze = d(he, "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex();
var Ge = d(he, "gu").replace(/notPunctSpace/g, qe).replace(/punctSpace/g, Be).replace(/punct/g, pe).getRegex();
var Ne = d("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex();
var Fe = d(/\\(punct)/, "gu").replace(/punct/g, D).getRegex();
var je = d(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var Qe = d(U).replace("(?:-->|$)", "-->").getRegex();
var Ue = d("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Qe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var q = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/;
var Ke = d(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var de = d(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex();
var ke = d(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex();
var We = d("reflink|nolink(?!\\()", "g").replace("reflink", de).replace("nolink", ke).getRegex();
var se = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;
var X = { _backpedal: E, anyPunctuation: Fe, autolink: je, blockSkip: ve, br: le, code: Ee, del: E, emStrongLDelim: De, emStrongRDelimAst: Ze, emStrongRDelimUnd: Ne, escape: Ae, link: Ke, nolink: ke, punctuation: Ce, reflink: de, reflinkSearch: We, tag: Ue, text: Ie, url: E };
var Xe = { ...X, link: d(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: d(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() };
var N = { ...X, emStrongRDelimAst: Ge, emStrongLDelim: He, url: d(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", se).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: d(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", se).getRegex() };
var Je = { ...N, br: d(le).replace("{2,}", "*").getRegex(), text: d(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
var C = { normal: K, gfm: Me, pedantic: ze };
var M2 = { normal: X, gfm: N, breaks: Je, pedantic: Xe };
var Ve = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
var ge = (l3) => Ve[l3];
function w(l3, e) {
  if (e) {
    if (m.escapeTest.test(l3)) return l3.replace(m.escapeReplace, ge);
  } else if (m.escapeTestNoEncode.test(l3)) return l3.replace(m.escapeReplaceNoEncode, ge);
  return l3;
}
function J(l3) {
  try {
    l3 = encodeURI(l3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l3;
}
function V2(l3, e) {
  var _a2;
  let t = l3.replace(m.findPipe, (i, s, a2) => {
    let o = false, p2 = s;
    for (; --p2 >= 0 && a2[p2] === "\\"; ) o = !o;
    return o ? "|" : " |";
  }), n = t.split(m.splitPipe), r2 = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !((_a2 = n.at(-1)) == null ? void 0 : _a2.trim()) && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r2 < n.length; r2++) n[r2] = n[r2].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l3, e, t) {
  let n = l3.length;
  if (n === 0) return "";
  let r2 = 0;
  for (; r2 < n; ) {
    let i = l3.charAt(n - r2 - 1);
    if (i === e && !t) r2++;
    else if (i !== e && t) r2++;
    else break;
  }
  return l3.slice(0, n - r2);
}
function fe(l3, e) {
  if (l3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < l3.length; n++) if (l3[n] === "\\") n++;
  else if (l3[n] === e[0]) t++;
  else if (l3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function me(l3, e, t, n, r2) {
  let i = e.href, s = e.title || null, a2 = l3[1].replace(r2.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let o = { type: l3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: a2, tokens: n.inlineTokens(a2) };
  return n.state.inLink = false, o;
}
function Ye(l3, e, t) {
  let n = l3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r2 = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [a2] = s;
    return a2.length >= r2.length ? i.slice(r2.length) : i;
  }).join(`
`);
}
var y = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = e || T;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r2 = Ye(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r2 };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r2 = z(n, "#");
        (this.options.pedantic || !r2 || this.rules.other.endingSpaceChar.test(r2)) && (n = r2.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r2 = "", i = "", s = [];
      for (; n.length > 0; ) {
        let a2 = false, o = [], p2;
        for (p2 = 0; p2 < n.length; p2++) if (this.rules.other.blockquoteStart.test(n[p2])) o.push(n[p2]), a2 = true;
        else if (!a2) o.push(n[p2]);
        else break;
        n = n.slice(p2);
        let u = o.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r2 = r2 ? `${r2}
${u}` : u, i = i ? `${i}
${c}` : c;
        let g = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(c, s, true), this.lexer.state.top = g, n.length === 0) break;
        let h = s.at(-1);
        if ((h == null ? void 0 : h.type) === "code") break;
        if ((h == null ? void 0 : h.type) === "blockquote") {
          let R2 = h, f = R2.raw + `
` + n.join(`
`), O2 = this.blockquote(f);
          s[s.length - 1] = O2, r2 = r2.substring(0, r2.length - R2.raw.length) + O2.raw, i = i.substring(0, i.length - R2.text.length) + O2.text;
          break;
        } else if ((h == null ? void 0 : h.type) === "list") {
          let R2 = h, f = R2.raw + `
` + n.join(`
`), O2 = this.list(f);
          s[s.length - 1] = O2, r2 = r2.substring(0, r2.length - h.raw.length) + O2.raw, i = i.substring(0, i.length - R2.raw.length) + O2.raw, n = f.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r2, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r2 = n.length > 1, i = { type: "list", raw: "", ordered: r2, start: r2 ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r2 ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r2 ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), a2 = false;
      for (; e; ) {
        let p2 = false, u = "", c = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        u = t[0], e = e.substring(u.length);
        let g = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H) => " ".repeat(3 * H.length)), h = e.split(`
`, 1)[0], R2 = !g.trim(), f = 0;
        if (this.options.pedantic ? (f = 2, c = g.trimStart()) : R2 ? f = t[1].length + 1 : (f = t[2].search(this.rules.other.nonSpaceChar), f = f > 4 ? 1 : f, c = g.slice(f), f += t[1].length), R2 && this.rules.other.blankLine.test(h) && (u += h + `
`, e = e.substring(h.length + 1), p2 = true), !p2) {
          let H = this.rules.other.nextBulletRegex(f), ee = this.rules.other.hrRegex(f), te = this.rules.other.fencesBeginRegex(f), ne = this.rules.other.headingBeginRegex(f), xe = this.rules.other.htmlBeginRegex(f);
          for (; e; ) {
            let Z2 = e.split(`
`, 1)[0], A5;
            if (h = Z2, this.options.pedantic ? (h = h.replace(this.rules.other.listReplaceNesting, "  "), A5 = h) : A5 = h.replace(this.rules.other.tabCharGlobal, "    "), te.test(h) || ne.test(h) || xe.test(h) || H.test(h) || ee.test(h)) break;
            if (A5.search(this.rules.other.nonSpaceChar) >= f || !h.trim()) c += `
` + A5.slice(f);
            else {
              if (R2 || g.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(g) || ne.test(g) || ee.test(g)) break;
              c += `
` + h;
            }
            !R2 && !h.trim() && (R2 = true), u += Z2 + `
`, e = e.substring(Z2.length + 1), g = A5.slice(f);
          }
        }
        i.loose || (a2 ? i.loose = true : this.rules.other.doubleBlankLine.test(u) && (a2 = true));
        let O2 = null, Y;
        this.options.gfm && (O2 = this.rules.other.listIsTask.exec(c), O2 && (Y = O2[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!O2, checked: Y, loose: false, text: c, tokens: [] }), i.raw += u;
      }
      let o = i.items.at(-1);
      if (o) o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let p2 = 0; p2 < i.items.length; p2++) if (this.lexer.state.top = false, i.items[p2].tokens = this.lexer.blockTokens(i.items[p2].text, []), !i.loose) {
        let u = i.items[p2].tokens.filter((g) => g.type === "space"), c = u.length > 0 && u.some((g) => this.rules.other.anyLine.test(g.raw));
        i.loose = c;
      }
      if (i.loose) for (let p2 = 0; p2 < i.items.length; p2++) i.items[p2].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r2 = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r2, title: i };
    }
  }
  table(e) {
    var _a2;
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V2(t[1]), r2 = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = ((_a2 = t[3]) == null ? void 0 : _a2.trim()) ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r2.length) {
      for (let a2 of r2) this.rules.other.tableAlignRight.test(a2) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(a2) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(a2) ? s.align.push("left") : s.align.push(null);
      for (let a2 = 0; a2 < n.length; a2++) s.header.push({ text: n[a2], tokens: this.lexer.inline(n[a2]), header: true, align: s.align[a2] });
      for (let a2 of i) s.rows.push(V2(a2, s.header.length).map((o, p2) => ({ text: o, tokens: this.lexer.inline(o), header: false, align: s.align[p2] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = fe(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, o).trim(), t[3] = "";
        }
      }
      let r2 = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r2);
        s && (r2 = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r2 = r2.trim(), this.rules.other.startAngleBracket.test(r2) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r2 = r2.slice(1) : r2 = r2.slice(1, -1)), me(t, { href: r2 && r2.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r2 = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r2.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return me(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r2 = this.rules.inline.emStrongLDelim.exec(e);
    if (!r2 || r2[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r2[1] || r2[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r2[0]].length - 1, a2, o, p2 = s, u = 0, c = r2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, t = t.slice(-1 * e.length + s); (r2 = c.exec(t)) != null; ) {
        if (a2 = r2[1] || r2[2] || r2[3] || r2[4] || r2[5] || r2[6], !a2) continue;
        if (o = [...a2].length, r2[3] || r2[4]) {
          p2 += o;
          continue;
        } else if ((r2[5] || r2[6]) && s % 3 && !((s + o) % 3)) {
          u += o;
          continue;
        }
        if (p2 -= o, p2 > 0) continue;
        o = Math.min(o, o + p2 + u);
        let g = [...r2[0]][0].length, h = e.slice(0, s + r2.index + g + o);
        if (Math.min(s, o) % 2) {
          let f = h.slice(1, -1);
          return { type: "em", raw: h, text: f, tokens: this.lexer.inlineTokens(f) };
        }
        let R2 = h.slice(2, -2);
        return { type: "strong", raw: h, text: R2, tokens: this.lexer.inlineTokens(R2) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r2 = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r2 && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r2;
      return t[2] === "@" ? (n = t[1], r2 = "mailto:" + n) : (n = t[1], r2 = n), { type: "link", raw: t[0], text: n, href: r2, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    var _a2;
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r2;
      if (t[2] === "@") n = t[0], r2 = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = ((_a2 = this.rules.inline._backpedal.exec(t[0])) == null ? void 0 : _a2[0]) ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r2 = "http://" + t[0] : r2 = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r2, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var x = class l {
  constructor(e) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || T, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: C.normal, inline: M2.normal };
    this.options.pedantic ? (t.block = C.pedantic, t.inline = M2.pedantic) : this.options.gfm && (t.block = C.gfm, this.options.breaks ? t.inline = M2.breaks : t.inline = M2.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: C, inline: M2 };
  }
  static lex(e, t) {
    return new l(t).lex(e);
  }
  static lexInline(e, t) {
    return new l(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    var _a2, _b, _c;
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r2;
      if ((_b = (_a2 = this.options.extensions) == null ? void 0 : _a2.block) == null ? void 0 : _b.some((s) => (r2 = s.call({ lexer: this }, e, t)) ? (e = e.substring(r2.raw.length), t.push(r2), true) : false)) continue;
      if (r2 = this.tokenizer.space(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        r2.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.code(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        (s == null ? void 0 : s.type) === "paragraph" || (s == null ? void 0 : s.type) === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.at(-1).src = s.text) : t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.fences(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.heading(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.hr(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.blockquote(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.list(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.html(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.def(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        (s == null ? void 0 : s.type) === "paragraph" || (s == null ? void 0 : s.type) === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r2.tag] || (this.tokens.links[r2.tag] = { href: r2.href, title: r2.title }, t.push(r2));
        continue;
      }
      if (r2 = this.tokenizer.table(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.lheading(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      let i = e;
      if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
        let s = 1 / 0, a2 = e.slice(1), o;
        this.options.extensions.startBlock.forEach((p2) => {
          o = p2.call({ lexer: this }, a2), typeof o == "number" && o >= 0 && (s = Math.min(s, o));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r2 = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && (s == null ? void 0 : s.type) === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r2), n = i.length !== e.length, e = e.substring(r2.raw.length);
        continue;
      }
      if (r2 = this.tokenizer.text(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        (s == null ? void 0 : s.type) === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r2);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    var _a2, _b, _c, _d, _e2;
    let n = e, r2 = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r2 = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r2[0].slice(r2[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r2.index) + "[" + "a".repeat(r2[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r2 = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r2.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let i;
    for (; (r2 = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) i = r2[2] ? r2[2].length : 0, n = n.slice(0, r2.index + i) + "[" + "a".repeat(r2[0].length - i - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = ((_b = (_a2 = this.options.hooks) == null ? void 0 : _a2.emStrongMask) == null ? void 0 : _b.call({ lexer: this }, n)) ?? n;
    let s = false, a2 = "";
    for (; e; ) {
      s || (a2 = ""), s = false;
      let o;
      if ((_d = (_c = this.options.extensions) == null ? void 0 : _c.inline) == null ? void 0 : _d.some((u) => (o = u.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let u = t.at(-1);
        o.type === "text" && (u == null ? void 0 : u.type) === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, a2)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let p2 = e;
      if ((_e2 = this.options.extensions) == null ? void 0 : _e2.startInline) {
        let u = 1 / 0, c = e.slice(1), g;
        this.options.extensions.startInline.forEach((h) => {
          g = h.call({ lexer: this }, c), typeof g == "number" && g >= 0 && (u = Math.min(u, g));
        }), u < 1 / 0 && u >= 0 && (p2 = e.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(p2)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (a2 = o.raw.slice(-1)), s = true;
        let u = t.at(-1);
        (u == null ? void 0 : u.type) === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return t;
  }
};
var P = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = e || T;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    var _a2;
    let r2 = (_a2 = (t || "").match(m.notSpaceStart)) == null ? void 0 : _a2[0], i = e.replace(m.endingNewline, "") + `
`;
    return r2 ? '<pre><code class="language-' + w(r2) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r2 = "";
    for (let a2 = 0; a2 < e.items.length; a2++) {
      let o = e.items[a2];
      r2 += this.listitem(o);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r2 + "</" + i + `>
`;
  }
  listitem(e) {
    var _a2;
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? ((_a2 = e.tokens[0]) == null ? void 0 : _a2.type) === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r2 = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let a2 = 0; a2 < s.length; a2++) n += this.tablecell(s[a2]);
      r2 += this.tablerow({ text: n });
    }
    return r2 && (r2 = `<tbody>${r2}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r2 + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r2 = this.parser.parseInline(n), i = J(e);
    if (i === null) return r2;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r2 + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r2 }) {
    r2 && (n = this.parser.parseInline(r2, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var $ = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var b = class l2 {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = e || T, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
  }
  static parse(e, t) {
    return new l2(t).parse(e);
  }
  static parseInline(e, t) {
    return new l2(t).parseInline(e);
  }
  parse(e, t = true) {
    var _a2, _b;
    let n = "";
    for (let r2 = 0; r2 < e.length; r2++) {
      let i = e[r2];
      if ((_b = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b[i.type]) {
        let a2 = i, o = this.options.extensions.renderers[a2.type].call({ parser: this }, a2);
        if (o !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(a2.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let a2 = s, o = this.renderer.text(a2);
          for (; r2 + 1 < e.length && e[r2 + 1].type === "text"; ) a2 = e[++r2], o += `
` + this.renderer.text(a2);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: o, text: o, tokens: [{ type: "text", raw: o, text: o, escaped: true }] }) : n += o;
          continue;
        }
        default: {
          let a2 = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a2), "";
          throw new Error(a2);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    var _a2, _b;
    let n = "";
    for (let r2 = 0; r2 < e.length; r2++) {
      let i = e[r2];
      if ((_b = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b[i.type]) {
        let a2 = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (a2 !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += a2 || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let a2 = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a2), "";
          throw new Error(a2);
        }
      }
    }
    return n;
  }
};
var _a;
var S = (_a = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = e || T;
  }
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? x.lex : x.lexInline;
  }
  provideParser() {
    return this.block ? b.parse : b.parseInline;
  }
}, __publicField(_a, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"])), __publicField(_a, "passThroughHooksRespectAsync", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _a);
var B = class {
  constructor(...e) {
    __publicField(this, "defaults", L());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", b);
    __publicField(this, "Renderer", P);
    __publicField(this, "TextRenderer", $);
    __publicField(this, "Lexer", x);
    __publicField(this, "Tokenizer", y);
    __publicField(this, "Hooks", S);
    this.use(...e);
  }
  walkTokens(e, t) {
    var _a2, _b;
    let n = [];
    for (let r2 of e) switch (n = n.concat(t.call(this, r2)), r2.type) {
      case "table": {
        let i = r2;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let a2 of s) n = n.concat(this.walkTokens(a2.tokens, t));
        break;
      }
      case "list": {
        let i = r2;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r2;
        ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[i.type]) ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let a2 = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(a2, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r2 = { ...n };
      if (r2.async = this.defaults.async || r2.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...a2) {
            let o = i.renderer.apply(this, a2);
            return o === false && (o = s.apply(this, a2)), o;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r2.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let a2 = s, o = n.renderer[a2], p2 = i[a2];
          i[a2] = (...u) => {
            let c = o.apply(i, u);
            return c === false && (c = p2.apply(i, u)), c || "";
          };
        }
        r2.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let a2 = s, o = n.tokenizer[a2], p2 = i[a2];
          i[a2] = (...u) => {
            let c = o.apply(i, u);
            return c === false && (c = p2.apply(i, u)), c;
          };
        }
        r2.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new S();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let a2 = s, o = n.hooks[a2], p2 = i[a2];
          S.passThroughHooks.has(s) ? i[a2] = (u) => {
            if (this.defaults.async && S.passThroughHooksRespectAsync.has(s)) return (async () => {
              let g = await o.call(i, u);
              return p2.call(i, g);
            })();
            let c = o.call(i, u);
            return p2.call(i, c);
          } : i[a2] = (...u) => {
            if (this.defaults.async) return (async () => {
              let g = await o.apply(i, u);
              return g === false && (g = await p2.apply(i, u)), g;
            })();
            let c = o.apply(i, u);
            return c === false && (c = p2.apply(i, u)), c;
          };
        }
        r2.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r2.walkTokens = function(a2) {
          let o = [];
          return o.push(s.call(this, a2)), i && (o = o.concat(i.call(this, a2))), o;
        };
      }
      this.defaults = { ...this.defaults, ...r2 };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return x.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return b.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r2) => {
      let i = { ...r2 }, s = { ...this.defaults, ...i }, a2 = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return a2(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return a2(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return a2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      if (s.hooks && (s.hooks.options = s, s.hooks.block = e), s.async) return (async () => {
        let o = s.hooks ? await s.hooks.preprocess(n) : n, u = await (s.hooks ? await s.hooks.provideLexer() : e ? x.lex : x.lexInline)(o, s), c = s.hooks ? await s.hooks.processAllTokens(u) : u;
        s.walkTokens && await Promise.all(this.walkTokens(c, s.walkTokens));
        let h = await (s.hooks ? await s.hooks.provideParser() : e ? b.parse : b.parseInline)(c, s);
        return s.hooks ? await s.hooks.postprocess(h) : h;
      })().catch(a2);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let p2 = (s.hooks ? s.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s);
        s.hooks && (p2 = s.hooks.processAllTokens(p2)), s.walkTokens && this.walkTokens(p2, s.walkTokens);
        let c = (s.hooks ? s.hooks.provideParser() : e ? b.parse : b.parseInline)(p2, s);
        return s.hooks && (c = s.hooks.postprocess(c)), c;
      } catch (o) {
        return a2(o);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r2 = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r2) : r2;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function k(l3, e) {
  return _.parse(l3, e);
}
k.options = k.setOptions = function(l3) {
  return _.setOptions(l3), k.defaults = _.defaults, G(k.defaults), k;
};
k.getDefaults = L;
k.defaults = T;
k.use = function(...l3) {
  return _.use(...l3), k.defaults = _.defaults, G(k.defaults), k;
};
k.walkTokens = function(l3, e) {
  return _.walkTokens(l3, e);
};
k.parseInline = _.parseInline;
k.Parser = b;
k.parser = b.parse;
k.Renderer = P;
k.TextRenderer = $;
k.Lexer = x;
k.lexer = x.lex;
k.Tokenizer = y;
k.Hooks = S;
k.parse = k;
var Zt = k.options;
var Gt = k.setOptions;
var Nt = k.use;
var Ft = k.walkTokens;
var jt = k.parseInline;
var Ut = b.parse;
var Kt = x.lex;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Catalog/Catalog.js
var import_clusterize = __toESM(require_clusterize());
var Test = import_clusterize.default.default;
var logger45 = LoggerByDefault_default2.getLogger("widget");
var Catalog = class _Catalog extends Control_default2 {
  /**
   * @constructor
   * @param {CatalogOptions} options - options for function call.
   *
   * @fires catalog:loaded
   * @fires catalog:layer:add
   * @fires catalog:layer:remove
   * * {@link schema | https://raw.githubusercontent.com/IGNF/geoportal-configuration/new-url/doc/schema.json}
   * * {@link jsdoc | https://raw.githubusercontent.com/IGNF/geoportal-configuration/new-url/doc/schema.jsdoc}
   * @example
   * var widget = new ol.control.Catalog({
   *           collapsed : true,
   *           draggable : false,
   *           titlePrimary : "",
   *           titleSecondary : "GÃ©rer vos couches de donnÃ©es",
   *           layerLabel : "title",
   *           layerThumbnail : true,
   *           search : {
   *               display : true,
   *               label : "Rechercher une donnÃ©e",
   *               criteria : [
   *                   "name",
   *                   "title",
   *                   "description"
   *               ]
   *           },
   *           addToMap : true,
   *           categories : [
   *               {
   *                   title : "DonnÃ©es",
   *                   id : "data",
   *                   default : true,
   *                   search : false,
   *                   filter : null
   *                   // sous categories
   *                   // items : [
   *                   //     {
   *                   //         title : "",
   *                   //         default : true,
   *                   //         section : true, // avec section (ex. regroupement par themes)
   *                   //         icon : true, // icone pour les sections (svg ou lien http ou dsfr classe)
   *                   //         filter : {
   *                   //             field : "",
   *                   //             value : ""
   *                   //         }
   *                   //     }
   *                   // ]
   *               }
   *           ],
   *           configuration : {
   *               type : "json",
   *               urls : [ // data:{}
   *                   "https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/layers.json",
   *                   "https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/edito.json"
   *               ]
   *           }
   * });
   * widget.on("catalog:loaded", (e) => { console.log(e.data); });
   * widget.on("catalog:layer:add", (e) => { console.log(e); });
   * widget.on("catalog:layer:remove", (e) => { console.log(e); });
   * map.addControl(widget);
   *
   * @todo validation du schema
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Catalog)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Catalog";
    this.initialize(options);
    this.container = this.initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    this.showWaiting();
    this.initConfigData().then((data) => {
      logger45.trace(this, data);
      this.hideWaiting();
      this.configData = data;
      this.dispatchEvent({
        type: this.LOADED_CATALOG_EVENT,
        data
      });
    }).catch((e) => {
      this.hideWaiting();
      logger45.error(e);
    });
    return this;
  }
  /**
   * Overwrite OpenLayers setMap method
   * This method sets the map for the Catalog control.
   * It initializes event listeners for the map and sets up the control's draggable and collapsed states.
   * It also checks for existing layers on the map and updates the control accordingly.
   * 
   * @param {Map} map - Map instance to set for the control.
   */
  setMap(map) {
    if (map) {
      this.on("catalog:loaded", this.checkLayersOnMap);
      if (this.draggable) {
        Draggable_default.dragElement(
          this.panelCatalogContainer,
          this.panelCatalogHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this.buttonCatalogShow.setAttribute("aria-pressed", true);
      }
      if (this.auto) {
        this.addEventsListeners(map);
      }
    } else {
      this.un("catalog:loaded", this.checkLayersOnMap);
      if (this.auto) {
        this.removeEventsListeners();
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger45.error("[ERROR] Catalog:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      this.buttonCatalogClose.click();
    } else {
      this.buttonCatalogShow.click();
    }
    this.collapsed = collapsed;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Add a layer config
   * This method processes a configuration object containing layer definitions.
   * 
   * @param {Config} conf conf
   */
  addLayerConfig(conf) {
    for (const key in conf) {
      if (Object.prototype.hasOwnProperty.call(conf, key)) {
        const layer = conf[key];
        if (layer.serviceParams) {
          var service = layer.serviceParams.id.split(":").slice(-1)[0];
          layer.service = service;
          layer.categories = [];
          layer.producer_urls = this.createCatalogLinks("producer", layer.producer);
          layer.thematic_urls = this.createCatalogLinks("thematic", layer.thematic);
          this.layersList[key] = layer;
        }
      }
    }
    var element = document.getElementById("GPcatalogContainerTabs");
    if (element) {
      element.remove();
    }
    this.layersList.sort((a2, b3) => a2.title.localeCompare(b3.title, "fr", { sensitivity: "base" }));
    this.createCatalogContentEntries(this.layersList);
  }
  /**
   * Activate a layer by its ID
   * This method activates a layer based on its ID, which is expected to be in the format "name$service".
   * It splits the ID to extract the layer name and service, then calls the `activeLayer` method.
   * 
   * @param {*} id - Layer ID in the format "name$service".
   * @example
   * activeLayerByID("GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2$WMTS");
   * activeLayerByID("PLAN.IGN$GEOPORTAIL:TMS");
   */
  activeLayerByID(id) {
    var name = id.split("$")[0];
    var service = id.split(":").slice(-1)[0];
    this.activeLayer(name, service);
  }
  /**
   * Disable a layer by its ID
   * This method disables a layer based on its ID, which is expected to be in the format "name$service".
   * It splits the ID to extract the layer name and service, then calls the `disableLayer` method.
   * @param {*} id - Layer ID in the format "name$service".
   * @example
   * disableLayerByID("GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2$WMTS");
   * disableLayerByID("PLAN.IGN$GEOPORTAIL:TMS");
   * @todo
   * - ajouter un test pour vÃ©rifier si l'ID est valide
   * - ajouter un test pour vÃ©rifier si la couche est dÃ©jÃ  active
   * - ajouter un test pour vÃ©rifier si la couche est dÃ©jÃ  dÃ©sactivÃ©e
   */
  disableLayerByID(id) {
    var name = id.split("$")[0];
    var service = id.split(":").slice(-1)[0];
    this.disableLayer(name, service);
  }
  /**
   * Activate a layer
   * This method activates a layer by its name and service.
   * It checks if the layer exists in the `layersList` and if it does, it adds the layer to the map if `addToMap` is true.
   * It then dispatches an event indicating that the layer has been added to the catalog.
   * @param {String} name - Layer name.
   * @param {String} service - Layer service.
   * @example
   * activeLayer("GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2", "WMTS");
   * activeLayer("PLAN.IGN", "GEOPORTAIL:TMS");
   */
  activeLayer(name, service) {
    var id = this.getLayerId(name, service);
    if (id) {
      var layer = {};
      if (this.options.addToMap) {
        layer = this.addLayer(name, service);
      }
      this.dispatchEvent({
        type: this.ADD_CATALOG_LAYER_EVENT,
        name,
        service,
        layer
      });
    }
  }
  /**
   * Disable a layer
   * This method disables a layer by its name and service.
   * It checks if the layer exists in the `layersList` and if it does, it removes the layer from the map if `addToMap` is true.
   * It then dispatches an event indicating that the layer has been removed from the catalog.
   * @param {String} name - Layer name.
   * @param {String} service - Layer service.
   * @example
   * disableLayer("GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2", "WMTS");
   * disableLayer("PLAN.IGN", "GEOPORTAIL:TMS");
   */
  disableLayer(name, service) {
    var id = this.getLayerId(name, service);
    if (id) {
      var layer = {};
      if (this.options.addToMap) {
        layer = this.removeLayer(name, service);
      }
      this.dispatchEvent({
        type: this.REMOVE_CATALOG_LAYER_EVENT,
        name,
        service,
        layer
      });
    }
  }
  /**
   * Get long layer ID
   * 
   * @param {*} name - nom de la couche
   * @param {*} service - service de la couche
   * @return {String|null} - long layer ID or null if not found
   * @description
   * This method retrieves the long layer ID based on the provided name and service.
   * It searches through the `layersList` object for a key that matches the pattern of "name.*service".
   * If a match is found, it returns the key; otherwise, it returns null.
   * @example
   * getLayerId("GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2", "WMTS");
   * getLayerId("PLAN.IGN", "GEOPORTAIL:TMS");
   */
  getLayerId(name, service) {
    if (!this.layersList || typeof this.layersList !== "object") {
      return null;
    }
    var regex = new RegExp(name + ".*" + service);
    for (const key in this.layersList) {
      if (Object.prototype.hasOwnProperty.call(this.layersList, key)) {
        if (regex.test(key)) {
          return key;
        }
      }
    }
    return null;
  }
  /**
   * Get layers by category
   * This method filters the layers based on the provided category.
   * It checks if the category has a filter defined and applies it to the layers.
   * If the filter matches, the layer is added to the `layersCategorised` object.
   * It also updates the `categories` property of each layer to include the category ID.
   * 
   * @param {*} category - Category object containing the filter.
   * @param {*} layers - Object containing all layers.
   * @return {Object} - Filtered layers categorized by the provided category.
   */
  getLayersByCategory(category, layers) {
    var layersCategorised = layers;
    var filter = category.filter;
    if (filter) {
      layersCategorised = {};
      for (const key in layers) {
        if (Object.prototype.hasOwnProperty.call(layers, key)) {
          const layer = layers[key];
          if (layer[filter.field]) {
            var condition = Array.isArray(filter.value) ? filter.value.includes(layer[filter.field].toString()) : filter.value === "*" || layer[filter.field].toString() === filter.value;
            if (condition) {
              layersCategorised[key] = layer;
              this.layersList[key].categories.push(category.id);
            }
          }
        }
      }
    }
    return layersCategorised;
  }
  // ################################################################### //
  // ################### getters / setters ############################# //
  // ################################################################### //
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize Catalog control (called by Catalog constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this.uid = options.id || SelectorID_default.generate();
    this.clusterOptions = {
      rows_in_block: 50,
      blocks_in_cluster: 4
    };
    this.options = {
      collapsed: true,
      draggable: false,
      auto: true,
      titlePrimary: "GÃ©rer vos couches de donnÃ©es",
      titleSecondary: "",
      layerLabel: "title",
      layerThumbnail: false,
      tabHeightAuto: false,
      optimisation: "none",
      // none | clusterize | on-demand
      size: "md",
      search: {
        display: true,
        // barre de recherche globale
        label: "Rechercher une donnÃ©e",
        criteria: [
          "name",
          "title",
          "description"
        ]
      },
      addToMap: true,
      categories: [
        {
          // INFO
          // categories : sous forme d'un onglet par categorie
          title: "DonnÃ©es",
          id: "data",
          cluster: true,
          clusterOptions: this.clusterOptions,
          default: true,
          filter: null
          // INFO
          // subcategories : sous forme d'un bouton radio par sous categoris
          // items : [
          //     {
          //         title : "",
          //         default : true,
          //         cluster : false,
          //         section : true, // avec section (ex. regroupement par themes)
          //         icon : true, // icone pour les sections (svg ou lien http ou dsfr classe)  
          //         filter : {
          //             field : "thematic",
          //             value : ""
          //         }
          //     }
          //     {
          //         title : "Toutes les donnÃ©es",
          //         default : false,
          //         section : false, // sans section
          //         cluster : false,
          //         filter : null // sans filtre, on prend toutes les donnÃ©es
          //     }
          // ]
        }
      ],
      configuration: {
        type: "json",
        // TODO type:"service"
        urls: [
          // data:{}
          // ex.
          // "https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/layers.json",
          // "https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/edito.json",
          "https://raw.githubusercontent.com/IGNF/geoportal-configuration/new-url/dist/entreeCarto.json"
        ]
      }
    };
    var searchOptions = Helper_default2.assign(this.options.search, options.search);
    Helper_default2.assign(this.options, options);
    Helper_default2.assign(this.options.search, searchOptions);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this.auto = this.options.auto;
    this.eventsListeners = [];
    this.buttonCatalogShow = null;
    this.panelCatalogContainer = null;
    this.panelCatalogHeaderContainer = null;
    this.buttonCatalogClose = null;
    this.contentCatalogContainer = null;
    this.waitingContainer = null;
    this.configData = {};
    this.layersList = {};
    this.clusterizeRef = {};
    this.clusterizeSections = {};
    this.dataOnDemand = {};
    this.categories = this.options.categories.map((cat) => {
      var items = cat.items;
      if (cat.items) {
        items = cat.items.map((i) => {
          return {
            title: i.title,
            id: i.id || this.generateID(i.title),
            default: i.hasOwnProperty("default") ? i.default : false,
            section: i.hasOwnProperty("section") ? i.section : false,
            sections: [],
            // liste des valeurs des sections remplie ulterieurement !
            subcategory: true,
            // new property !
            icon: i.hasOwnProperty("icon") ? i.icon : false,
            iconJson: i.iconJson || [],
            // liste des icones (json) pour les sections
            cluster: i.hasOwnProperty("cluster") ? i.cluster : false,
            clusterOptions: i.hasOwnProperty("clusterOptions") ? i.clusterOptions : this.clusterOptions,
            filter: i.filter || null
          };
        });
      }
      return {
        title: cat.title,
        id: cat.id || this.generateID(cat.title),
        default: cat.hasOwnProperty("default") ? cat.default : false,
        search: cat.hasOwnProperty("search") ? cat.search : false,
        cluster: cat.hasOwnProperty("cluster") ? cat.cluster : false,
        clusterOptions: cat.hasOwnProperty("clusterOptions") ? cat.clusterOptions : this.clusterOptions,
        filter: cat.filter || null,
        items: items || null
      };
    });
    this.categoryId = (() => {
      var index2 = this.categories.findIndex((category) => category.default);
      if (index2 === -1) {
        index2 = 0;
        this.categories[index2].default = true;
      }
      return this.categories[index2].id;
    })();
    this.layersListOnMap = {};
    this._searchTimeout = null;
    this.ADD_CATALOG_LAYER_EVENT = "catalog:layer:add";
    this.REMOVE_CATALOG_LAYER_EVENT = "catalog:layer:remove";
    this.LOADED_CATALOG_EVENT = "catalog:loaded";
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  initContainer() {
    var container = this._createMainContainerElement();
    var picto = this.buttonCatalogShow = this._createShowCatalogPictoElement();
    container.appendChild(picto);
    var widgetPanel = this.panelCatalogContainer = this._createCatalogPanelElement();
    var widgetPanelSize = this._createCatalogPanelDivSizeElement(this.options.size);
    widgetPanel.appendChild(widgetPanelSize);
    var widgetPanelDiv = this._createCatalogPanelDivElement();
    widgetPanelSize.appendChild(widgetPanelDiv);
    var widgetPanelHeader = this.panelCatalogHeaderContainer = this._createCatalogPanelHeaderElement();
    var widgetPanelIcon = this._createCatalogPanelIconElement(this.options.titlePrimary);
    widgetPanelHeader.appendChild(widgetPanelIcon);
    var widgetPanelTitle = this._createCatalogPanelTitleElement(this.options.titlePrimary);
    widgetPanelHeader.appendChild(widgetPanelTitle);
    var widgetCloseBtn = this.buttonCatalogClose = this._createCatalogPanelCloseElement();
    widgetPanelHeader.appendChild(widgetCloseBtn);
    widgetPanelDiv.appendChild(widgetPanelHeader);
    var widgetContentDiv = this._createCatalogPanelContentDivElement();
    var widgetContentElementDiv = this.contentCatalogContainer = this._createCatalogContentDivElement();
    widgetContentElementDiv.appendChild(this._createCatalogContentTitleElement(this.options.titleSecondary));
    if (this.options.search.display) {
      widgetContentElementDiv.appendChild(this._createCatalogContentSearchGlobalElement(this.options.search.label));
    }
    var waiting = this.waitingContainer = this._createCatalogWaitingElement();
    widgetContentElementDiv.appendChild(waiting);
    widgetContentDiv.appendChild(widgetContentElementDiv);
    widgetPanelDiv.appendChild(widgetContentDiv);
    container.appendChild(widgetPanel);
    return container;
  }
  /**
   * Check layers already present on the map
   * This method checks the layers already present on the map
   * and marks them as checked in the catalog.
   * @private
   */
  checkLayersOnMap() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var layers = map.getLayers();
    layers.forEach((layer) => {
      if (layer.name && layer.service) {
        this.layersListOnMap[layer.name + ":" + layer.service] = layer;
        var inputs = document.querySelectorAll(`input[data-layer="${layer.name}:${layer.service}"]`);
        if (inputs) {
          inputs.forEach((input) => {
            input.checked = true;
          });
        }
      }
    });
  }
  /**
   * Initialize layers list and other properties
   * This method initializes the layers list from the configuration data.
   * It can load data from a local object or fetch it from URLs.
   * It processes the layers to add additional properties such as `service`, `categories`, and URLs for producers and thematics.
   * It also creates the catalog content entries based on the layers.
   *
   * @returns {Promise} - promise
   * @private
   */
  async initConfigData() {
    var data = null;
    if (this.options.configuration.data) {
      data = this.options.configuration.data || {};
      if (Config_default2.isConfigLoaded()) {
        Helper_default2.mergeParams(data, Config_default2.configuration);
      }
      this.checkConfigLayers(data.layers);
      this.layersList = data.layers;
      this.createCatalogContentEntries(data);
      return new Promise((resolve, reject) => {
        resolve(data);
      });
    }
    if (this.options.configuration.urls) {
      var fetchUrls = [];
      for (let i = 0; i < this.options.configuration.urls.length; i++) {
        const url = this.options.configuration.urls[i];
        const fetchUrl = function() {
          return fetch(url, {}).then(function(response) {
            if (response.ok) {
              return response.json().then(function(json) {
                return json;
              }).catch((error) => {
                logger45.warn("fetch json exception :", error);
              });
            } else {
              var err = new Error("HTTP status code: " + response.status);
              throw err;
            }
          }).catch((error) => {
            return new Promise((resolve, reject) => {
              logger45.error("fetch json exception :", error);
              reject(error);
            });
          });
        };
        fetchUrls.push(fetchUrl());
      }
      try {
        const values = await Promise.all(fetchUrls);
        data = values[0];
        for (let i = 1; i < values.length; i++) {
          const value2 = values[i];
          Helper_default2.mergeParams(data, value2);
        }
        if (Config_default2.isConfigLoaded()) {
          Helper_default2.mergeParams(data, Config_default2.configuration);
        }
        this.checkConfigLayers(data.layers);
        this.layersList = data.layers;
        this.createCatalogContentEntries(data);
        return await new Promise((resolve, reject) => {
          resolve(data);
        });
      } catch (e) {
        return await new Promise((resolve, reject) => {
          reject(e);
        });
      }
    }
  }
  /**
   * Check configuration layers
   * This method checks the configuration of layers to ensure they have valid service parameters.
   * It also adds additional properties to each layer, such as `service`, `categories`, and URLs for producers and thematics.
   * It cleans the list of layers by removing those without valid configuration and adds a default thumbnail if enabled and not present.
   * 
   * @param {Array<ConfigLayer>} layers - list of layers
   * @private
   */
  checkConfigLayers(layers) {
    for (const key in layers) {
      if (Object.prototype.hasOwnProperty.call(layers, key)) {
        const layer = layers[key];
        if (layer.serviceParams) {
          const isHTML = (str) => {
            const doc = document.createElement("div");
            doc.innerHTML = str.trim();
            return doc.childNodes.length > 0 && doc.firstChild.nodeType === 1;
          };
          if (isHTML(layer.description)) {
            logger45.error(`layer description contains HTML code, which is not allowed. Layer: ${key}`);
            logger45.error("Please use Markdown syntax for layer descriptions instead.");
            logger45.error(layer.description);
            delete layers[key];
            continue;
          }
          var service = layer.serviceParams.id.split(":").slice(-1)[0];
          layer.service = service;
          layer.categories = [];
          layer.producer_urls = this.createCatalogProducerLinks(layer.producer);
          layer.thematic_urls = this.createCatalogThematicLinks(layer.thematic);
          layer.label = this.options.layerLabel ? layer[this.options.layerLabel] || layer.title : layer.title;
          layer.description = k.parse(layer.description);
          if (this.options.layerThumbnail) {
            if (!layer.thumbnail) {
              layer.thumbnail = "default";
            }
          } else {
            if (layer.thumbnail) {
              delete layer.thumbnail;
            }
          }
        } else {
          delete layers[key];
        }
      }
    }
  }
  /**
   * Create DOM content categories and entries
   * @param {Config} data - data
   * @private
   */
  createCatalogContentEntries(data) {
    var container = this.contentCatalogContainer;
    var widgetContentEntryTabs = this._createCatalogContentCategoriesTabs(this.categories, this.options.tabHeightAuto);
    container.appendChild(widgetContentEntryTabs);
    var categories = [];
    this.categories.forEach((category) => {
      if (category.items) {
        for (let i = 0; i < category.items.length; i++) {
          const element = category.items[i];
          if (element.icon && element.iconJson.length === 0 && element.section && element.filter) {
            const tag = element.filter.field;
            if (data.topics && data.topics[tag]) {
              element.iconJson = data.topics[tag];
            } else if (data[tag]) {
              element.iconJson = data[tag];
            } else if (topics_default[tag]) {
              element.iconJson = topics_default[tag];
            } else {
              element.iconJson = [];
            }
          }
          element.subcategory = true;
          categories.push(element);
        }
      } else {
        categories.push(category);
      }
    });
    var activeIndex = categories.findIndex((cat) => cat.id === this.categoryId);
    if (activeIndex === -1) {
      activeIndex = 0;
    }
    var contents = container.querySelectorAll(".tabcontent");
    for (let i = 0; i < contents.length; i++) {
      const content = contents[i];
      if (i === activeIndex) {
      }
      var layersCategorised = this.getLayersByCategory(categories[i], data.layers);
      var nodata = categories[i].cluster && this.options.optimisation === "clusterize" || this.options.optimisation === "on-demand";
      this._createCatalogContentCategoryTabContent(categories[i], layersCategorised, nodata).then((data2) => {
        const fragment = document.createDocumentFragment();
        if (data2.dom) {
          fragment.appendChild(data2.dom);
          content.appendChild(fragment);
          console.log(`Content for category ${categories[i].title} created.`);
          if (categories[i].cluster && this.options.optimisation === "clusterize") {
            if (categories[i].section) {
              console.warn(`No clustering at initialization for sections : ${categories[i].title} !`);
              this.clusterizeSections[categories[i].id] = data2.blocks.reduce((acc, item) => {
                acc[item.domid] = item.rows;
                return acc;
              }, {});
              this._updateListenersLayersDOM(content, categories[i].id);
            } else {
              this.clusterizeRef[categories[i].id] = new import_clusterize.default({
                scrollId: content.parentElement.id,
                contentId: data2.blocks[0].domid,
                rows: data2.blocks[0].rows,
                rows_in_block: categories[i].clusterOptions.rows_in_block,
                blocks_in_cluster: categories[i].clusterOptions.blocks_in_cluster,
                callbacks: {
                  clusterChanged: () => {
                    logger45.trace("cluster changed");
                    this._updateListenersLayersDOM(content, categories[i].id);
                    this.checkLayersOnMap();
                  }
                }
              });
            }
          } else if (this.options.optimisation === "on-demand") {
            if (categories[i].section) {
              this.dataOnDemand[categories[i].id] = data2.blocks.reduce((acc, item) => {
                acc[item.domid] = item.fragment;
                return acc;
              }, {});
            } else {
              this.dataOnDemand[categories[i].id] = data2.blocks[0].fragment;
              if (categories[i].default) {
                const cloneFragment = (fragment2) => {
                  const clone2 = document.createDocumentFragment();
                  fragment2.childNodes.forEach((node) => {
                    clone2.appendChild(node.cloneNode(true));
                  });
                  return clone2;
                };
                const fragmentDocument = cloneFragment(this.dataOnDemand[categories[i].id]);
                content.querySelector(`#checkboxes-${categories[i].id}`).appendChild(fragmentDocument);
              }
            }
            this._updateListenersLayersDOM(content, categories[i].id);
          } else {
            this._updateListenersLayersDOM(content, categories[i].id);
            this.checkLayersOnMap();
          }
        }
      });
    }
  }
  /**
   * Create links information to the catalog for thematic
   * @param {*} value - ...
   * @private
   * @returns {Array<Object>} fiche d'information
   * @todo rÃ©cuperer l'url du service du catalogue selon l'environnement !
   * @example
   * // pour les thÃ©matiques
   * createCatalogThematicLinks(["Agriculture", "Transports", "Autres"]);
   * // OUTPUT
   * [
   *   {
   *     name : "Agriculture",
   *     url : "https://cartes.gouv.fr/catalogue/search?topic=farming"
   *   }
   * ]
   * @see [mapping - https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/topics.json]
   */
  createCatalogThematicLinks(value2) {
    if (!value2) {
      return null;
    }
    var url = "https://cartes.gouv.fr/catalogue/search?";
    var data = [];
    for (let j2 = 0; j2 < value2.length; j2++) {
      const element = value2[j2];
      if (element === "Autres") {
        continue;
      }
      var mapping = topics_default.thematic.find((o) => o.name === element);
      if (mapping) {
        data.push({
          name: element,
          url: url + "topic=" + mapping.id
        });
      }
    }
    if (data.length === 0) {
      data = null;
    }
    return data;
  }
  /**
   * Create links information to the catalog for producer
   * @param {*} value - ...
   * @private
   * @returns {Array<Object>} fiche d'information
   * @todo rÃ©cuperer l'url du service du catalogue selon l'environnement !
   * @example
   * // pour les producteurs
   * createCatalogProducerLinks(["IGN", "IGNF", "Autres"]);
   * 
   * // OUTPUT
   * [
   *   {
   *      name : "IGN",
   *      url : "https://cartes.gouv.fr/catalogue/search?organization=IGN"
   *   }
   * ]
   * @see [mapping - https://raw.githubusercontent.com/IGNF/cartes.gouv.fr-entree-carto/main/public/data/topics.json]
   */
  createCatalogProducerLinks(value2) {
    if (!value2) {
      return null;
    }
    var url = "https://cartes.gouv.fr/catalogue/search?";
    var data = [];
    for (let i = 0; i < value2.length; i++) {
      const element = value2[i];
      if (element === "Autres") {
        continue;
      }
      data.push({
        name: element,
        url: url + "organization=" + element
      });
    }
    if (data.length === 0) {
      data = null;
    }
    return data;
  }
  // ################################################################### //
  // ######################## methods on listeners ##################### //
  // ################################################################### //
  /**
   * Add events listeners on map (called by setMap)
   *
   * @param {Map} map - map
   * @private
   */
  addEventsListeners(map) {
    var self2 = this;
    this.eventsListeners["map:add"] = function(e) {
      logger45.trace(e);
      var name = e.element.name;
      var service = e.element.service;
      self2.layersListOnMap[name + ":" + service] = e.element;
      var inputs = document.querySelectorAll(`input[data-layer="${name}:${service}"]`);
      if (inputs) {
        inputs.forEach((input) => {
          input.checked = true;
        });
      }
    };
    map.getLayers().on("add", this.eventsListeners["map:add"]);
    this.eventsListeners["map:remove"] = function(e) {
      logger45.trace(e);
      var name = e.element.name;
      var service = e.element.service;
      delete self2.layersListOnMap[name + ":" + service];
      var inputs = document.querySelectorAll(`input[data-layer="${name}:${service}"]`);
      if (inputs) {
        inputs.forEach((input) => {
          input.checked = false;
        });
      }
    };
    map.getLayers().on("remove", this.eventsListeners["map:remove"]);
  }
  /**
   * Remove events listeners on map (called by setMap)
   * @private
   */
  removeEventsListeners() {
    var map = this.getMap();
    map.getLayers().un("add", this.eventsListeners["map:add"]);
    delete this.eventsListeners["map:add"];
    map.getLayers().un("remove", this.eventsListeners["map:remove"]);
    delete this.eventsListeners["map:remove"];
  }
  // ################################################################### //
  // ######################## methods on map ########################### //
  // ################################################################### //
  /**
   * Add layer on map
   *
   * @param {*} name - layer name
   * @param {*} service - layer service
   * @returns {Object} - layer config
   * @private
   */
  addLayer(name, service) {
    var layerConf = null;
    var layer = null;
    var id = this.getLayerId(name, service);
    if (!id) {
      return;
    }
    var c = !Config_default2.isConfigLoaded() ? LayerConfigUtils_default.getLayerConfig(this.layersList[id]) : null;
    switch (service) {
      case "WMS":
        layer = new LayerWMS_default({
          layer: name,
          configuration: c
        });
        break;
      case "WMTS":
        layer = new LayerWMTS_default({
          layer: name,
          configuration: c
        });
        break;
      case "TMS":
        layer = new LayerMapBox_default({
          layer: name,
          configuration: c
        }, {
          declutter: true
        });
        break;
      case "WFS":
        layer = new LayerWFS_default({
          layer: name,
          configuration: c
        });
        break;
      default:
        break;
    }
    if (layer) {
      var map = this.getMap();
      map.addLayer(layer);
      this.layersListOnMap[name + ":" + service] = layer;
      layerConf = layer.getConfiguration();
    }
    return layerConf;
  }
  /**
   * Remove Layer on map
   *
   * @param {*} name - layer name
   * @param {*} service - layer service
   * @returns {Object} - layer config
   * @private
   */
  removeLayer(name, service) {
    var layerConf = null;
    var layer = this.layersListOnMap[name + ":" + service];
    if (layer) {
      layerConf = layer.getConfiguration();
      var map = this.getMap();
      map.removeLayer(layer);
      delete this.layersListOnMap[name + ":" + service];
    }
    return layerConf;
  }
  // ################################################################### //
  // ######################## methods waiting ########################## //
  // ################################################################### //
  hideWaiting() {
    this.waitingContainer.className = "GPwaitingContainerHidden  gpf-waiting--hidden";
  }
  showWaiting() {
    this.waitingContainer.className = "GPwaitingContainerVisible gpf-waiting--visible";
  }
  // ################################################################### //
  // ######################## methods search ########################### //
  // ################################################################### //
  /**
   * Reset filtered layers
   * @private
   */
  resetFilteredLayersList() {
    for (const key in this.layersList) {
      if (Object.prototype.hasOwnProperty.call(this.layersList, key)) {
        const layer = this.layersList[key];
        layer.hidden = false;
        this.updateVisibilityFilteredLayers(layer.name, layer.service, layer.hidden);
      }
    }
  }
  /**
   * Set filtered layers
   *
   * @param {*} value - value
   * @private
   */
  setFilteredLayersList(value2) {
    var criteria = this.options.search.criteria;
    for (const key in this.layersList) {
      if (Object.prototype.hasOwnProperty.call(this.layersList, key)) {
        const layer = this.layersList[key];
        var words = "";
        for (let i = 0; i < criteria.length; i++) {
          const c = criteria[i];
          if (layer[c]) {
            words += layer[c].toLowerCase();
          }
        }
        layer.hidden = !words.includes(value2.toLowerCase());
        if (!layer.hidden) {
          logger45.info(`Filtering layer ${layer.name} with words : ${words}`);
        }
        this.updateVisibilityFilteredLayers(layer.name, layer.service, layer.hidden);
      }
    }
    this.updateVisibilityFilteredSections();
  }
  /**
   * Update DOM layer visibility
   *
   * @param {*} name - ...
   * @param {*} service  - ...
   * @param {*} hidden  - ...
   * @private
   */
  updateVisibilityFilteredLayers(name, service, hidden) {
    const escapeSelector = (str) => {
      return str.replace(/\./g, "\\.");
    };
    var categories = [];
    this.categories.forEach((category) => {
      if (category.items) {
        for (let i = 0; i < category.items.length; i++) {
          const element = category.items[i];
          categories.push(element);
        }
      } else {
        categories.push(category);
      }
    });
    const findContainerLayer = (category, name2, service2) => {
      var container2 = document.getElementById(`fieldset-${category.id}_${name2}-${service2}`);
      if (this.options.optimisation === "on-demand") {
        if (category.section) {
          for (const sectionId in this.dataOnDemand[category.id]) {
            const fragment = this.dataOnDemand[category.id][sectionId];
            if (fragment) {
              var id = escapeSelector(`#fieldset-${category.id}_${name2}-${service2}`);
              container2 = fragment.querySelector(id);
              if (container2) {
                break;
              }
            }
          }
        }
      }
      return container2;
    };
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];
      var container = findContainerLayer(category, name, service);
      if (container) {
        if (hidden) {
          container.classList.add("gpf-hidden");
          container.classList.add("GPelementHidden");
        } else {
          container.classList.remove("gpf-hidden");
          container.classList.remove("GPelementHidden");
          logger45.info(`Layer ${name}:${service} visibility updated to hidden=${hidden} in category ${category.id} (${container.id}).`);
        }
      }
    }
  }
  /**
   * Update DOM sections visibility if no layers are visible
   *
   * @private
   */
  updateVisibilityFilteredSections() {
    const countLayersInSection = (categoryId, sectionId) => {
      var count2 = 0;
      if (this.options.optimisation === "on-demand") {
        var fragment = this.dataOnDemand[categoryId][sectionId];
        if (fragment) {
          count2 = fragment.querySelectorAll(".fr-fieldset__element:not(.gpf-hidden):not(.GPelementHidden)").length;
        }
      } else {
        var container2 = document.getElementById(sectionId);
        if (container2) {
          var data = container2.innerHTML;
          count2 = [...data.matchAll(/"fr-fieldset__element"/g)].length;
        }
      }
      return count2;
    };
    for (let i = 0; i < this.categories.length; i++) {
      const category = this.categories[i];
      if (category.items) {
        for (let j2 = 0; j2 < category.items.length; j2++) {
          const subcategory = category.items[j2];
          if (subcategory.section) {
            for (let k3 = 0; k3 < subcategory.sections.length; k3++) {
              const section = subcategory.sections[k3];
              var container = document.getElementById(`section-${subcategory.id}-${this.generateID(section)}`);
              if (container) {
                var id = `section-accordion-${subcategory.id}-${this.generateID(section)}`;
                var count = countLayersInSection(subcategory.id, id);
                var countDom = document.getElementById(`section-count-${subcategory.id}-${this.generateID(section)}`);
                if (count === 0) {
                  container.classList.add("gpf-hidden");
                  container.classList.add("GPelementHidden");
                  if (countDom) {
                    countDom.textContent = count;
                  }
                } else {
                  if (countDom) {
                    countDom.textContent = count;
                  }
                  container.classList.remove("gpf-hidden");
                  container.classList.remove("GPelementHidden");
                }
              }
            }
          }
        }
      }
    }
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onShowCatalogClick(e) {
    var opened = e.target.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    logger45.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onCloseCatalogClick(e) {
    logger45.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {String} categoryId - ...
   * @private
   */
  onSelectCatalogTabClick(e, categoryId) {
    logger45.trace(e);
    var categories = [];
    this.categories.forEach((category2) => {
      if (category2.items) {
        for (let i = 0; i < category2.items.length; i++) {
          const element = category2.items[i];
          categories.push(element);
        }
      } else {
        categories.push(category2);
      }
    });
    var prevcontainer = document.getElementById(`checkboxes-${this.categoryId}`);
    if (prevcontainer) {
      var oldCategory = categories.find((cat) => cat.id == this.categoryId);
      if (this.options.optimisation === "on-demand" && !oldCategory.section) {
        prevcontainer.innerHTML = "";
      }
    }
    this.categoryId = categoryId;
    var category = categories.find((cat) => cat.id == categoryId);
    const cloneFragment = (fragment2) => {
      const clone2 = document.createDocumentFragment();
      fragment2.childNodes.forEach((node) => {
        clone2.appendChild(node.cloneNode(true));
      });
      return clone2;
    };
    var selected = e.target.ariaSelected === "true";
    var container = document.getElementById(`checkboxes-${categoryId}`);
    if (container && container.children.length === 0) {
      if (this.options.optimisation === "on-demand") {
        if (selected) {
          var fragment = this.dataOnDemand[category.id];
          if (fragment) {
            container.appendChild(cloneFragment(fragment));
            this._updateListenersLayersDOM(container, category.id);
            this.checkLayersOnMap();
          }
        }
      }
      if (category.cluster && this.options.optimisation === "clusterize") {
      }
    }
    var searchSpecific = document.getElementById("catalog-container-search-specific");
    if (searchSpecific) {
      var o = this.categories.find((c) => c.id == categoryId);
      if (o && o.search) {
        searchSpecific.classList.remove("gpf-hidden");
        searchSpecific.classList.add("fr-tabs__panel--selected");
      } else {
        searchSpecific.classList.add("gpf-hidden");
        searchSpecific.classList.remove("fr-tabs__panel--selected");
      }
    }
    var inputSpecific = document.getElementById("catalog-input-search-specific");
    if (inputSpecific) {
      if (inputSpecific.value !== "") {
        inputSpecific.value = "";
        this.setFilteredLayersList("");
      }
    }
    var inputGlobal = document.getElementById("catalog-input-search-global");
    if (inputGlobal) {
      if (this.options.optimisation === "on-demand") {
        if (inputGlobal.value !== "") {
          this.setFilteredLayersList(inputGlobal.value);
        }
      }
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSelectCatalogEntryClick(e) {
    logger45.trace(e);
    var ds = e.target.dataset.layer;
    var name = ds.substring(0, ds.lastIndexOf(":"));
    var service = ds.substring(ds.lastIndexOf(":") + 1);
    var layer = {};
    if (e.target.checked) {
      if (this.options.addToMap) {
        layer = this.addLayer(name, service);
      }
      this.dispatchEvent({
        type: this.ADD_CATALOG_LAYER_EVENT,
        name,
        service,
        layer
      });
    } else {
      if (this.options.addToMap) {
        layer = this.removeLayer(name, service);
      }
      this.dispatchEvent({
        type: this.REMOVE_CATALOG_LAYER_EVENT,
        name,
        service,
        layer
      });
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onToggleCatalogMoreLearnClick(e) {
    logger45.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {String} categoryId - ...
   * @param {String} sectionId - ...
   * @private
   */
  onToggleCatalogSectionClick(e, categoryId, sectionId) {
    logger45.trace(e);
    const cloneFragment = (fragment2) => {
      const clone2 = document.createDocumentFragment();
      fragment2.childNodes.forEach((node) => {
        clone2.appendChild(node.cloneNode(true));
      });
      return clone2;
    };
    var categories = [];
    this.categories.forEach((category2) => {
      if (category2.items) {
        for (let i = 0; i < category2.items.length; i++) {
          const element = category2.items[i];
          categories.push(element);
        }
      } else {
        categories.push(category2);
      }
    });
    var category = categories.find((cat) => cat.id == categoryId);
    var opened = e.target.ariaExpanded === "true";
    var container = document.getElementById(sectionId);
    if (container) {
      if (this.options.optimisation === "on-demand") {
        if (opened) {
          var fragment = this.dataOnDemand[category.id][sectionId];
          if (fragment) {
            container.appendChild(cloneFragment(fragment));
            this._updateListenersLayersDOM(container, category.id);
            this.checkLayersOnMap();
          }
        } else {
          container.innerHTML = "";
        }
      }
      if (category.cluster && this.options.optimisation === "clusterize") {
        if (opened) {
          if (this.clusterizeRef[category.id] && this.clusterizeRef[category.id][sectionId] && this.clusterizeRef[category.id][sectionId].destroyed) {
            this.clusterizeRef[category.id][sectionId].refresh(true);
          } else {
            var rows = this.clusterizeSections[category.id][sectionId];
            if (!this.clusterizeRef[category.id]) {
              this.clusterizeRef[category.id] = {};
            }
            this.clusterizeRef[category.id][sectionId] = new import_clusterize.default({
              scrollId: container.parentElement.id,
              contentId: sectionId,
              rows,
              rows_in_block: category.clusterOptions.rows_in_block,
              blocks_in_cluster: category.clusterOptions.blocks_in_cluster,
              callbacks: {
                clusterChanged: () => {
                  logger45.trace("cluster changed");
                  this._updateListenersLayersDOM(container, category.id);
                  this.checkLayersOnMap();
                }
              }
            });
          }
        } else {
          if (this.clusterizeRef[category.id] && this.clusterizeRef[category.id][sectionId] && !this.clusterizeRef[category.id][sectionId].destroyed) {
            this.clusterizeRef[category.id][sectionId].destroy(true);
          }
        }
      }
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {String} categoryId - ...
   * @private
   */
  onToggleCatalogRadioChange(e, categoryId) {
    logger45.trace(e, categoryId);
    var categories = [];
    this.categories.forEach((category2) => {
      if (category2.items) {
        for (let i = 0; i < category2.items.length; i++) {
          const element = category2.items[i];
          categories.push(element);
        }
      } else {
        categories.push(category2);
      }
    });
    var category = categories.find((cat) => cat.id == categoryId);
    var prevcontainer = document.getElementById(`checkboxes-${this.categoryId}`);
    if (prevcontainer && !category.section) {
      if (this.options.optimisation === "on-demand") {
        prevcontainer.innerHTML = "";
      }
    }
    this.categoryId = categoryId;
    const cloneFragment = (fragment2) => {
      const clone2 = document.createDocumentFragment();
      fragment2.childNodes.forEach((node) => {
        clone2.appendChild(node.cloneNode(true));
      });
      return clone2;
    };
    var container = document.getElementById(`checkboxes-${categoryId}`);
    if (container && container.children.length === 0) {
      if (this.options.optimisation === "on-demand") {
        if (e.target.checked) {
          var fragment = this.dataOnDemand[category.id];
          if (fragment) {
            container.appendChild(cloneFragment(fragment));
            this._updateListenersLayersDOM(container, category.id);
            this.checkLayersOnMap();
          }
        }
      }
      if (category.cluster && this.options.optimisation === "clusterize") {
      }
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSearchGlobalCatalogButtonClick(e) {
    var value2 = e.target.value;
    this.setFilteredLayersList(value2);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSearchGlobalCatalogInputChange(e) {
    clearTimeout(this._searchTimeout);
    this._searchTimeout = setTimeout(() => {
      this.onSearchGlobalCatalogButtonClick(e);
    }, 200);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSearchGlobalCatalogButtonResetClick(e) {
    this.resetFilteredLayersList();
    this.updateVisibilityFilteredSections();
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSearchSpecificCatalogButtonClick(e) {
    var value2 = e.target.value;
    this.setFilteredLayersList(value2);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onSearchSpecificCatalogInputChange(e) {
    clearTimeout(this._searchTimeout);
    this._searchTimeout = setTimeout(() => {
      this.onSearchSpecificCatalogButtonClick(e);
    }, 200);
  }
  onSearchSpecificCatalogButtonResetClick(e) {
    this.resetFilteredLayersList();
    this.updateVisibilityFilteredSections();
  }
};
Object.assign(Catalog.prototype, CatalogDOM_default);
Object.assign(Catalog.prototype, Widget_default);
var Catalog_default = Catalog;
if (window.ol && window.ol.control) {
  window.ol.control.Catalog = Catalog;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Territories/Territories.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Territories/GPFterritories.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Territories/Territories.json
var Territories_default = [
  {
    id: "FXX",
    title: "France mÃ©tropolitaine",
    description: "",
    zoom: null,
    bbox: [-9.86, 41.15, 10.38, 51.56],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/fxx.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/fxx.svg"
  },
  {
    id: "GLP",
    title: "Guadeloupe",
    description: "",
    zoom: null,
    bbox: [-61.97, 15.72, -60.93, 16.66],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/glp.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/glp.svg"
  },
  {
    id: "GUF",
    title: "Guyane",
    description: "",
    zoom: null,
    bbox: [-55.65, 1.49, -51.2, 6.21],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/guf.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/guf.svg"
  },
  {
    id: "MTQ",
    title: "Martinique",
    description: "",
    zoom: null,
    bbox: [-61.4, 14.25, -60.67, 15.04],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/mtq.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/mtq.svg"
  },
  {
    id: "REU",
    title: "RÃ©union",
    description: "",
    zoom: null,
    bbox: [55.07, -21.46, 55.86, -20.79],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/reu.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/reu.svg"
  },
  {
    id: "SPM",
    title: "Saint-Pierre-et-Miquelon",
    description: "",
    zoom: null,
    bbox: [-56.48, 46.69, -56.07, 47.19],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/spm.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/spm.svg"
  },
  {
    id: "IDF",
    title: "Paris petite couronne",
    description: "",
    zoom: null,
    bbox: [2.18, 48.77, 2.52, 48.95],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/idf.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/idf.svg"
  },
  {
    id: "MYT",
    title: "Mayotte",
    description: "",
    zoom: null,
    bbox: [44.95, -13.049, 45.32, -12.57],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/myt.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/myt.svg"
  },
  {
    id: "NCL",
    title: "Nouvelle CalÃ©donie",
    description: "",
    zoom: null,
    bbox: [163.02, -23.08, 167.86, -19.5],
    thumbnail: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/thumbnails/ncl.png",
    icon: "https://data.geopf.fr/annexes/cartes.gouv.fr-config/public/resources/territories/ncl.svg"
  }
];

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Territories/TerritoriesDOM.js
var stringToHTML3 = (str) => {
  var support = function() {
    if (!window.DOMParser) {
      return false;
    }
    var parser2 = new DOMParser();
    try {
      parser2.parseFromString("x", "text/html");
    } catch (err) {
      return false;
    }
    return true;
  };
  if (support()) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(str, "text/html");
    return doc.body;
  }
  var dom = document.createElement("div");
  dom.innerHTML = str;
  return dom;
};
var TerritoriesDOM = {
  /**
   * Add uuid to the tag ID
   * @param {String} id - id selector
   * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
   * https://github.com/SortableJS/Sortable?tab=readme-ov-file#options
   * @param {*} elementDraggable - element to make draggable
   * @param {*} context - context for the draggable element
   * @returns {*} Sortable instance
   */
  createDraggableElement: function(elementDraggable, context) {
    const sortable = sortable_esm_default.create(elementDraggable, {
      animation: 150,
      handle: ".gpf-btn-icon-territories-draggable",
      draggable: ".draggable-territories-view",
      ghostClass: "gpf-territories-view-ghost",
      onEnd: function(e) {
        context.onReorderTerritoriesViews(e);
      }
    });
    return sortable;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPterritories");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show Territories
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowTerritoriesPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowTerritoriesPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowTerritoriesPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-territories");
    button.classList.add("fr-icon-france-line");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "SÃ©lecteur de territoire");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowTerritoriesClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowTerritoriesClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createTerritoriesPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPterritoriesPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createTerritoriesPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__territories";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createTerritoriesPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "gpf-panel__header_territories";
    return container;
  },
  _createTerritoriesPanelIconElement: function() {
    var label = document.createElement("label");
    label.className = "gpf-btn-header-territories gpf-btn-icon-header-territories";
    label.title = "Selecteur de territoires";
    return label;
  },
  _createTerritoriesPanelTitleElement: function(title3) {
    var div = document.createElement("div");
    div.className = "gpf-panel__title_territories";
    div.innerHTML = title3;
    return div;
  },
  _createTerritoriesPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.id = "GPterritoriesPanelClose";
    btnClose.className = "gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    btnClose.title = "Fermer le panneau";
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowTerritoriesPicto")).click();
        self2.onCloseTerritoriesClick();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowTerritoriesPicto")).click();
        self2.onCloseTerritoriesClick();
      });
    }
    return btnClose;
  },
  _createTerritoriesPanelOptionsElement: function(title3, description) {
    var self2 = this;
    var content = "&#x2630";
    var idButton = "gpf-territories-button-option-id";
    var idInputUpload = "gpf-territories-upload-id";
    var idClose = "gpf-territories-upload-close-id";
    var idToggle = "gpf-territories-toggle-messages";
    var idBtnApply = "gpf-territories-apply-id";
    var strContainer = `
        <div>
            <button type="button" 
                id="${idButton}"
                class="fr-btn fr-btn--tertiary-no-outline" 
                role="territories-button-options" 
                aria-expanded="false" 
                aria-controls="gpf-territories-upload-container-id">
                ${content}
            </button>
            <dialog id="gpf-territories-upload-container-id" class="fr-modal__body fr-upload-group gpf-hidden">
                <div class="gpf-territories-header-upload">
                    <button 
                        id="${idClose}"
                        type="button" 
                        class="gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w"
                        aria-expanded="false"
                        title="Fermer le panneau">
                        <span>Fermer</span>
                    </button>
                </div>
                <label class="fr-label">
                    ${title3}
                    <span class="fr-hint-text">${description}</span>
                </label>
                <fieldset class="fr-fieldset">
                    <div class="fr-fieldset__element">
                        <div class="fr-toggle fr-m-2v">
                            <input 
                                id="${idToggle}" 
                                class="fr-toggle__input" 
                                type="checkbox" 
                                aria-describedby="gpf-territories-toggle-messages">
                            <label class="fr-toggle__label" for="${idToggle}">ComplÃ©ter la liste</label>
                            <div class="fr-messages-group" id="gpf-territories-toggle-messages" aria-live="polite"></div>
                        </div>
                    </div>
                    <div class="fr-fieldset__element">
                        <input 
                            id="${idInputUpload}" 
                            class="fr-upload" 
                            aria-describedby="gpf-territories-upload-id-messages" 
                            type="file" 
                            name="upload">
                        <div class="fr-messages-group" id="gpf-territories-upload-id-messages" aria-live="polite"></div>
                    </div>
                </fieldset>
                <fieldset class="fr-fieldset">
                    <button 
                        id="${idBtnApply}" 
                        class="gpf-button gpf-button fr-btn fr-btn--tertiary" 
                        aria-describedby="gpf-territories-apply-id-messages">Appliquer</button>
                    <div class="fr-messages-group" id="gpf-territories-apply-id-messages" aria-live="polite"></div>
                </fieldset>
            </dialog>
        </div>
        `;
    var container = stringToHTML3(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById(idButton);
    if (button) {
      button.addEventListener("click", (e) => {
        e.target.ariaExpanded = !(e.target.ariaExpanded === "true");
        var collapse = document.getElementById(e.target.getAttribute("aria-controls"));
        if (!collapse) {
          return;
        }
        if (e.target.ariaExpanded === "true") {
          collapse.classList.add("gpf-visible");
          collapse.classList.remove("gpf-hidden");
        } else {
          collapse.classList.remove("gpf-visible");
          collapse.classList.add("gpf-hidden");
        }
      }, false);
    }
    var close = shadow.getElementById(idClose);
    if (close) {
      close.addEventListener("click", (e) => {
        e.target.ariaExpanded = !(e.target.ariaExpanded === "true");
        var button2 = document.getElementById(idButton);
        button2.click();
      });
    }
    var inputUpload = shadow.getElementById(idInputUpload);
    if (inputUpload) {
      inputUpload.addEventListener("change", (e) => {
        self2.onUploadFileClick(e);
      }, false);
    }
    var toggle = shadow.getElementById(idToggle);
    if (idToggle) {
      toggle.addEventListener("click", (e) => {
        console.log(e.target.checked);
        self2.onUploadToggleClick(e);
      });
    }
    var inputApply = shadow.getElementById(idBtnApply);
    if (inputApply) {
      inputApply.addEventListener("click", (e) => {
        self2.onApplyTerritoriesClick(e);
      }, false);
    }
    return shadow.firstChild;
  },
  // ################################################################### //
  // ####################### Methods for dialog  ####################### //
  // ################################################################### //
  _createTerritoriesPanelMenuViewsDivElement: function(title3, description) {
    var div = document.createElement("div");
    div.className = "territories-views gpf-panel__menuviews_territories";
    div.appendChild(this._createTerritoriesButtonOpenMenuViewsElement(title3, description));
    div.appendChild(this._createTerritoriesPanelMenuViewsElement(title3));
    return div;
  },
  _createTerritoriesButtonOpenMenuViewsElement: function(title3, description) {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = "gpf-territories-button-open-views-id";
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", title3);
    button.setAttribute("title", description);
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("aria-controls", "gpf-territories-views-container-id");
    button.setAttribute("type", "button");
    button.innerHTML = title3;
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        var collapse = document.getElementById(e.target.getAttribute("aria-controls"));
        if (!collapse) {
          return;
        }
        if (status) {
          collapse.classList.remove("gpf-visible");
          collapse.classList.add("gpf-hidden");
        } else {
          collapse.classList.add("gpf-visible");
          collapse.classList.remove("gpf-hidden");
        }
        self2.onShowTerritoriesViewsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        var collapse = document.getElementById(e.target.getAttribute("aria-controls"));
        if (!collapse) {
          return;
        }
        if (status) {
          collapse.classList.remove("gpf-visible");
          collapse.classList.add("gpf-hidden");
        } else {
          collapse.classList.add("gpf-visible");
          collapse.classList.remove("gpf-hidden");
        }
        self2.onShowTerritoriesViewsClick(e);
      });
    }
    return button;
  },
  _createTerritoriesPanelMenuViewsElement: function(title3) {
    var dialog = document.createElement("dialog");
    dialog.id = "gpf-territories-views-container-id";
    dialog.className = "fr-modal__body gpf-panel__views_territories-menu gpf-hidden";
    dialog.appendChild(this._createTerritoriesMenuAddViewElement(title3));
    dialog.appendChild(this._createTerritoriesMenuListViewElement());
    return dialog;
  },
  _createTerritoriesMenuAddViewElement: function(title3) {
    var self2 = this;
    var buttonId = "gpf-territories-views-back-button-id";
    var inputId = "gpf-territories-views-input-id";
    var formId = "gpf-territories-views-form-id";
    var submitId = "gpf-territories-views-submit-id";
    var strContainer = `
        <div>
            <button 
                id="${buttonId}" 
                class="fr-btn fr-icon-arrow-left-line fr-btn--icon-left fr-btn--tertiary-no-outline"
                aria-pressed="false" 
                aria-controls="gpf-territories-views-container-id gpf-territories-button-open-views-id"
                title="Retour au sÃ©lecteur de territoires" 
                type="button">
                ${title3}
            </button>
            <form id="${formId}">
                <fieldset 
                    class="fr-fieldset" 
                    id="add-view-form-fieldset" 
                    aria-labelledby="add-view-form-fieldset-legend add-view-form-fieldset-messages">
                    <legend 
                        class="fr-fieldset__legend" 
                        id="add-view-form-fieldset-legend"> 
                        Ajouter la vue actuelle 
                    </legend>
                    <div class="fr-fieldset__element">
                        <div class="fr-input-group" id="${inputId}-input-group-view">
                            <label class="fr-label" for="${inputId}"> Nom </label>
                            <input class="fr-input" aria-describedby="${inputId}-messages" id="${inputId}" type="text">
                            <div class="fr-messages-group" id="${inputId}-messages" aria-live="polite"></div>
                        </div>
                    </div>
                    <div class="fr-messages-group" id="add-view-form-fieldset-messages" aria-live="polite">
                        <p class="fr-message fr-message--error gpf-hidden" id="${inputId}-message-error-duplicate-id">Ce nom est dÃ©jÃ  utilisÃ©</p>
                        <p class="fr-message fr-message--error gpf-hidden" id="${inputId}-message-error-empty-id">Le nom est vide</p>
                    </div>
                </fieldset>
            </form>
            <input type="submit" id="${submitId}" value="Ajouter" class="fr-btn">
            <hr class="fr-m-1v"/>
        </div>
        `;
    var container = stringToHTML3(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById(buttonId);
    if (button) {
      button.addEventListener("click", (e) => {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        var controls = e.target.getAttribute("aria-controls").split(" ");
        var collapse = document.getElementById(controls[0]);
        if (!collapse) {
          return;
        }
        collapse.classList.remove("gpf-visible");
        collapse.classList.add("gpf-hidden");
        var button2 = document.getElementById(controls[1]);
        if (!button2) {
          return;
        }
        button2.setAttribute("aria-pressed", "false");
        var input = document.getElementById(inputId);
        if (input) {
          input.value = "";
          var emptyMessage = document.getElementById(inputId + "-message-error-empty-id");
          var duplicateMessage = document.getElementById(inputId + "-message-error-duplicate-id");
          if (emptyMessage) {
            emptyMessage.classList.add("gpf-hidden");
          }
          if (duplicateMessage) {
            duplicateMessage.classList.add("gpf-hidden");
          }
        }
        self2.onCloseTerritoriesViewsClick(e);
      }, false);
    }
    var form = shadow.getElementById(formId);
    if (form) {
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        var input = document.getElementById(inputId);
        if (input) {
          self2.onAddTerritoriesViewClick(e, input.value);
        }
      }, false);
    }
    var submit = shadow.getElementById(submitId);
    if (submit) {
      submit.addEventListener("click", (e) => {
        e.preventDefault();
        var input = document.getElementById(inputId);
        if (input) {
          var territory = self2.territories.find((e2) => e2.data.title === input.value);
          var emptyMessage = document.getElementById(inputId + "-message-error-empty-id");
          var duplicateMessage = document.getElementById(inputId + "-message-error-duplicate-id");
          if (input.value === "") {
            if (emptyMessage) {
              emptyMessage.classList.remove("gpf-hidden");
            }
            if (duplicateMessage) {
              duplicateMessage.classList.add("gpf-hidden");
            }
            return;
          }
          if (territory) {
            if (duplicateMessage) {
              duplicateMessage.classList.remove("gpf-hidden");
            }
            if (emptyMessage) {
              emptyMessage.classList.add("gpf-hidden");
            }
            return;
          }
          if (emptyMessage) {
            emptyMessage.classList.add("gpf-hidden");
          }
          if (duplicateMessage) {
            duplicateMessage.classList.add("gpf-hidden");
          }
          self2.onAddTerritoriesViewClick(e, input.value);
        }
      }, false);
    }
    return shadow.firstChild;
  },
  _createTerritoriesMenuListViewElement: function() {
    var self2 = this;
    var buttonId = "gpf-territories-views-reset-button-id";
    var countId = "gpf-territories-views-count-id";
    var strContainer = `
        <div class="gpf-panel__views_territories-listview">
            <!-- Menu de la liste des vues -->
            <div class="gpf-panel__views_territories-listview-header">
                <div class="gpf-panel__views_territories-listview-count">
                    <span class="fr-label" style="padding-right: 10px;"> Territoires </span>
                    <span 
                        class="fr-message" 
                        id="${countId}"> 0 </span>
                </div>
                <button 
                    id="${buttonId}" 
                    class="fr-btn fr-btn--sm fr-btn--tertiary-no-outline"
                    title="RÃ©initialiser la liste des territoires" 
                    type="button">
                    RÃ©initialiser
                </button>
            </div>
            <!-- Liste des vues -->
            <div 
                id="gpf-territories-views-listview-entries-id"
                class="gpf-panel__views_territories-listview-entries">
            </div>
        </div>
        `;
    var container = stringToHTML3(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById(buttonId);
    if (button) {
      button.addEventListener("click", (e) => {
        self2.onResetTerritoriesViewClick(e);
      }, false);
    }
    return shadow.firstChild;
  },
  // ################################################################### //
  // ####################### Methods for entries ####################### //
  // ################################################################### //
  _createTerritoriesElement: function() {
    var div = document.createElement("div");
    div.className = "territories-entries gpf-panel__body_territories fr-modal__body";
    return div;
  },
  _createTerritoryEntry: function(o) {
    var self2 = this;
    if (o) {
      var DefaultImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFvSURBVHgB7ZfBisIwEIb/aIWKHsXH8OCT+lBevHgRjwp6EBEREdRqTbKZLN3FXT20yRyK80FIqJR8mf4drDqfjUWNaKBmiDA3IsyNCHMjwtyIMDcizI0Ic/O5wsYA7bZCkjxfb7UQlWjCnY7CaJRhNtM/0nSAyUQjTRViEU3Yug+t8Tj3ws2mcpVVWCw0Gm4Hmv9Wvioq1jcdRaLbVX6+XCyUK+p0ql2VgevVYjhM/LVQolSYqni7AVlm/aB4UKXT9LvyFI35PE40goVJ9nSiYb0cPfrVyvh1Aa21BjYb4+KCIIKFiwhQNzgcSFphvTb/ugMdZLnULhbq6TBlCcowSex2v7dTRvd74+PxLq90kMEg8dGpQuUKF1GgR01VpvF4AP1+A3lu/frVOB4ttltT+QWsXGHakN7+V5mkQ9zv7++l33s95efS+4ZEIqRNVc1xUDu3UTp4OeTfGjcizI0IcyPC3IgwNyLMjQhzUzvhL49qosB5TImnAAAAAElFTkSuQmCC";
      var thumbnail = o.thumbnail || DefaultImage;
      var iconDiv = "";
      var icon = o.icon || DefaultImage;
      if (icon.startsWith("fr-icon-")) {
        iconDiv = `
                <button 
                    type="button" 
                    class="fr-btn fr-btn--lg ${icon} fr-btn--tertiary-no-outline">
                </button>`;
      } else {
        iconDiv = `
                <svg>       
                    <image id="icon-${o.id}" xlink:href="${icon}" style="width:100%;"/>    
                </svg>`;
      }
      var id = o.id.toLowerCase();
      var entry = stringToHTML3(`
            <div class="gpf-tile fr-tile fr-tile--sm">
                <div class="fr-tile__body">
                    <div class="fr-tile__content">
                        <p class="fr-tile__title">
                            <label class="gpf-label fr-label" title="${o.description}">${o.title}</label>
                        </p>
                    </div>
                </div>
                <div class="gpf-tile__header fr-tile__header">
                    <div class="fr-tile__pictogram fr-tile__thumbnail">
                        <img id="thumbnail-${o.id}" src="${thumbnail}" width="100%" height="100%" title="${o.description}"/>
                    </div>
                    <div class="fr-tile__pictogram fr-tile__icon fr-tile__icon--${id}">
                        ${iconDiv}
                    </div>
                </div>
            </div>
            `);
      var div = entry.firstChild;
      if (div) {
        div.addEventListener("click", (e) => {
          self2.onImageTerritoriesClick(e, o.id);
        });
      }
      return entry.firstChild;
    }
  },
  _createTerritoryView: function(o) {
    var self2 = this;
    var buttonId = "gpf-territories-view-entry-button-id-" + o.id;
    if (o) {
      var entry = stringToHTML3(`
            <div class="gpf-panel__views_territories-listview-entry draggable-territories-view">
                <!-- ${o.title} -->
                <div style="display: flex;flex-direction: row;align-items: center;">    
                    <span class="gpf-btn gpf-btn-icon-territories-draggable gpf-btn--tertiary"></span>
                    <label class="gpf-label fr-label" title="${o.description}">${o.title}</label>
                </div>
                <button 
                    id="${buttonId}" 
                    type="button" 
                    class="fr-btn fr-btn--sm fr-btn--icon-left fr-btn--tertiary-no-outline gpf-btn gpf-btn-icon-territories-remove gpf-btn--tertiary"></button>
            </div>
            `);
      var div = entry.firstChild;
      if (div) {
        div.addEventListener("click", (e) => {
          self2.onViewTerritoryClick(e, o.id);
        });
        var button = entry.querySelector("#" + buttonId);
        if (button) {
          button.addEventListener("click", (e) => {
            e.stopPropagation();
            self2.onViewTerritoryRemoveClick(e, o.id);
          });
        }
      }
      return entry.firstChild;
    }
  }
};
var TerritoriesDOM_default = TerritoriesDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Territories/Territories.js
var logger46 = LoggerByDefault_default2.getLogger("territories");
var Territories = class _Territories extends Control_default2 {
  /**
   * @constructor
   * @param {TerritoriesOptions} options - options for function call.
   *
   * @fires territories:loaded
   * @fires territories:change
   * @fires territories:add
   * @fires territories:remove
   * @public
   * @example
   * var territories = new ol.control.Territories({
   *   collapsed: true,
   *   panel: true,
   *   auto: true
   * });
   * map.addControl(territories);
   *
   * or/and
   *
   * var territories = new ol.control.Territories({});
   * territories.setTerritory({id: "MTQ", title: "Martinique", description: "", bbox: [], thumbnail: "data:image/png;base64,..."});
   * territories.setTerritory({id: "GLP", title: "Guadeloupe", description: "", bbox: [], thumbnail: "http://..."});
   * map.addControl(territories);
   * territories.on("territories:loaded", (e) => { console.log(e.data); });
   * territories.on("territories:add", (e) => { console.log(e); });
   * territories.on("territories:remove", (e) => { console.log(e); });
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _Territories)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "Territories";
    this.initialize(options);
    this.container = this.initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      if (this.draggable) {
        Draggable_default.dragElement(
          this.panelTerritoriesContainer,
          this.panelTerritoriesHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this.buttonTerritoriesShow.setAttribute("aria-pressed", true);
      }
      var territories = this.auto ? Territories_default : this.options.territories;
      for (let index2 = 0; index2 < territories.length; index2++) {
        const territory = territories[index2];
        this.setTerritory(territory);
      }
    } else {
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
    var self2 = this;
    this.createDraggableElement(
      self2.element.querySelector("#gpf-territories-views-listview-entries-id"),
      self2
    );
    this.dispatchEvent({
      type: "territories:loaded"
    });
  }
  // ################################################################### //
  // ################### getters / setters ############################# //
  // ################################################################### //
  /**
   * Add a territory
   *
   * @param {Territory} territory  - territory
   * @param {Boolean} [isAdded=false] - specify if territory is added manually with "Add view" button
   * @returns {Boolean} - true|false
   * @public
   * @example
   * territories.setTerritory ({
   *  id: "MTQ",
   *  title: "Martinique",
   *  description: "",
   *  bbox: [minx, miny, maxx, maxy],
   *  thumbnail: "data:image/png;base64,..."
   * });
   */
  setTerritory(territory, isAdded = false) {
    var founded = this.territories.some((e) => e.data.id === territory.id);
    if (territory && !founded) {
      var entry = this._createTerritoryEntry(territory);
      var view = this._createTerritoryView(territory);
      if (entry && view) {
        this.panelTerritoriesEntriesContainer.appendChild(entry);
        this.panelTerritoriesViewsContainer.appendChild(view);
        var count = this.element.querySelector("#gpf-territories-views-count-id");
        if (count) {
          var nb = this.territories.filter((t) => !t.isRemoved).length + 1;
          count.innerText = nb;
        }
        this.territories.push({
          isRemoved: false,
          isAdded,
          data: territory,
          initialIndex: this.territories.length,
          domEntry: entry,
          domView: view
        });
        return true;
      }
    }
    return false;
  }
  /**
   * Load a new configuration
   * 
   * @param {Array<Territory>} territories - file config
   */
  setTerritories(territories) {
    for (let j2 = 0; j2 < territories.length; j2++) {
      const territory = territories[j2];
      this.setTerritory(territory);
    }
  }
  /**
   * Remove a territory
   *
   * @param {String} territory - territory id (FRA, MTQ, ...)
   * @param {Boolean} [force=false] - force removal
   * @returns {Boolean} - true|false
   * @public
   * @example
   * territories.removeTerritory("MTQ"); // id du territoire
   */
  removeTerritory(territory, force = false) {
    var found = false;
    if (territory) {
      for (let i = 0; i < this.territories.length; i++) {
        const o = this.territories[i];
        if (o.data.id === territory.data.id) {
          if (!force) {
            this.territories[i].isRemoved = true;
            this.territories[i].domEntry.classList.add("gpf-hidden");
            this.territories[i].domView.style.display = "none";
          } else {
            this.territories[i].domEntry.remove();
            this.territories[i].domView.remove();
            this.territories.splice(i, 1);
          }
          found = true;
          var count = this.element.querySelector("#gpf-territories-views-count-id");
          if (count) {
            var nb = this.territories.filter((t) => !t.isRemoved).length;
            count.innerText = nb;
          }
          break;
        }
      }
    }
    return found;
  }
  /**
   * Remove all territories
   */
  removeTerritories() {
    for (let i = 0; i < this.territories.length; i++) {
      const territory = this.territories[i];
      territory.domEntry.remove();
      territory.domView.remove();
    }
    this.territories = [];
  }
  /**
   * Set collapse
   *
   * @param {Boolean} collapsed - true|false
   * @todo ...
   * @public
   */
  setCollapse(collapsed) {
    if (collapsed === void 0) {
      logger46.log("[ERROR] Territory:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      document.getElementById("GPterritoriesPanelClose").click();
    } else {
      this.buttonTerritoriesShow.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Mode reduit des tuiles (uniquement le nom du territoire)
   *
   * @param {*} reduce - true|false
   * @public
   */
  setReduce(reduce) {
    if (reduce) {
      this.panelTerritoriesEntriesContainer.classList.add("tiles-reduce");
    } else {
      this.panelTerritoriesEntriesContainer.classList.remove("tiles-reduce");
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize Territories control (called by Territories constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this.uid = options.id || SelectorID_default.generate();
    this.options = {
      collapsed: true,
      draggable: false,
      panel: true,
      // titre
      upload: {
        active: false,
        title: "Ajouter un fichier de configuration",
        description: ""
      },
      // menu du upload
      view: {
        active: false,
        title: "Modifier les territoires",
        description: ""
      },
      // menu du vues
      title: "SÃ©lectionner un territoire",
      auto: false,
      // chargement auto des territoires par defaut
      thumbnail: false,
      // imagette des territoires
      reduce: false,
      // tuiles reduites par defaut
      tiles: 3,
      // nombre de tuiles affichables, 0 = toutes !
      territories: []
    };
    var uploadOpts = Helper_default2.assign(this.options.upload, options.upload);
    Helper_default2.assign(this.options, options);
    Helper_default2.assign(this.options.upload, uploadOpts);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this.auto = this.options.auto;
    this.territories = [];
    this.uploadConfig = null;
    this.append = false;
    this.buttonTerritoriesShow = null;
    this.panelTerritoriesContainer = null;
    this.panelTerritoriesHeaderContainer = null;
    this.buttonTerritoriesClose = null;
    this.containerTerritoriesOptions = null;
    this.panelTerritoriesEntriesContainer = null;
    this.panelTerritoriesViewsContainer = null;
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  initContainer() {
    var container = this._createMainContainerElement();
    var picto = this.buttonTerritoriesShow = this._createShowTerritoriesPictoElement();
    container.appendChild(picto);
    var territoriesPanel = this.panelTerritoriesContainer = this._createTerritoriesPanelElement();
    territoriesPanel.classList.add("tiles-direction");
    territoriesPanel.classList.add("tiles-" + this.options.tiles);
    var territoriesPanelDiv = this._createTerritoriesPanelDivElement();
    territoriesPanel.appendChild(territoriesPanelDiv);
    var territoriesPanelMenuViewsDiv = this._createTerritoriesPanelMenuViewsDivElement(this.options.view.title, this.options.view.description);
    territoriesPanel.appendChild(territoriesPanelMenuViewsDiv);
    this.panelTerritoriesViewsContainer = territoriesPanelMenuViewsDiv.querySelector("#gpf-territories-views-listview-entries-id");
    if (this.options.view && !this.options.view.active) {
      territoriesPanelMenuViewsDiv.style.display = "none";
    }
    var territoriesEntriesDiv = this.panelTerritoriesEntriesContainer = this._createTerritoriesElement();
    territoriesEntriesDiv.classList.add("tiles-direction");
    territoriesEntriesDiv.classList.add("tiles-" + this.options.tiles);
    if (this.options.reduce) {
      territoriesEntriesDiv.classList.add("tiles-reduce");
    }
    if (this.options.thumbnail) {
      territoriesEntriesDiv.classList.add("tiles-thumbnail");
    } else {
      territoriesEntriesDiv.classList.add("tiles-icon");
    }
    territoriesPanel.appendChild(territoriesEntriesDiv);
    if (this.options.panel) {
      var territoriesPanelHeader = this.panelTerritoriesHeaderContainer = this._createTerritoriesPanelHeaderElement();
      var territoriesPanelIcon = this._createTerritoriesPanelIconElement();
      territoriesPanelHeader.appendChild(territoriesPanelIcon);
      var territoriesPanelTitle = this._createTerritoriesPanelTitleElement(this.options.title);
      territoriesPanelHeader.appendChild(territoriesPanelTitle);
      if (this.options.upload && this.options.upload.active) {
        var territoriesPanelOptions = this.containerTerritoriesOptions = this._createTerritoriesPanelOptionsElement(this.options.upload.title, this.options.upload.description);
        territoriesPanelHeader.appendChild(territoriesPanelOptions);
      }
      var territoriesCloseBtn = this.buttonTerritoriesClose = this._createTerritoriesPanelCloseElement();
      territoriesPanelHeader.appendChild(territoriesCloseBtn);
      territoriesPanelDiv.appendChild(territoriesPanelHeader);
    }
    container.appendChild(territoriesPanel);
    logger46.log(container);
    return container;
  }
  /**
   * Close panel option
   * @private
   */
  closePanelUpLoad() {
    var button = this.containerTerritoriesOptions.children[0];
    if (button) {
      button.setAttribute("aria-expanded", "false");
    }
    var dialog = this.containerTerritoriesOptions.children[1];
    if (dialog) {
      dialog.classList.add("gpf-hidden");
      dialog.classList.remove("gpf-visible");
    }
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onShowTerritoriesClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger46.trace(e);
    this.collapsed = !this.collapsed;
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onCloseTerritoriesClick(e) {
    logger46.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {*} id - ...
   * @private
   */
  onImageTerritoriesClick(e, id) {
    logger46.trace(e, id);
    var territory = this.territories.find((e2) => e2.data.id === id);
    if (territory) {
      var zoom = territory.data.zoom;
      var bbox = territory.data.bbox;
      var point = territory.data.point;
      if (bbox && !bbox.length) {
        return;
      }
      if (!point && !bbox) {
        return;
      }
      var map = this.getMap();
      var proj = map.getView().getProjection().getCode();
      if (bbox) {
        var extent = transformExtent(bbox, "EPSG:4326", proj);
        map.getView().fit(extent, {
          size: map.getSize()
        });
      }
      if (point) {
        var coord = transform(point, "EPSG:4326", proj);
        map.getView().setCenter(coord);
      }
      if (zoom) {
        map.getView().setZoom(zoom);
      }
      this.setCollapse(true);
      this.dispatchEvent({
        type: "territories:change",
        territory: territory.data
      });
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onUploadFileClick(e) {
    var file = e.target.files[0];
    var target2 = e.target;
    if (!file) {
      logger46.warn("Missing file to upload !");
      return;
    }
    var fReader = new FileReader();
    var self2 = this;
    fReader.onerror = (e2) => {
      logger46.log("onerror");
    };
    fReader.onprogress = (e2) => {
      logger46.log("onprogress");
    };
    fReader.onloadstart = (e2) => {
      logger46.log("onloadstart");
    };
    fReader.onabort = (e2) => {
      logger46.log("onabort");
    };
    fReader.onloadend = (e2) => {
      logger46.log("onloadend : ", e2);
    };
    fReader.onload = (e2) => {
      logger46.log("file content : ", e2.target.result);
      try {
        self2.uploadConfig = JSON.parse(e2.target.result);
        if (!self2.uploadConfig) {
          console.error("Invalid configuration file !");
          return;
        }
      } catch (err) {
        console.error("Error parsing configuration file : ", err);
        return;
      }
    };
    fReader.readAsText(file);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onUploadToggleClick(e) {
    this.append = e.target.checked;
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onApplyTerritoriesClick(e) {
    logger46.trace(e);
    this.closePanelUpLoad();
    if (!this.uploadConfig) {
      logger46.error("No configuration to apply !");
      return;
    }
    if (!this.append) {
      this.removeTerritories();
    }
    this.setTerritories(this.uploadConfig);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onShowTerritoriesViewsClick(e) {
    logger46.trace(e);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onCloseTerritoriesViewsClick(e) {
    logger46.trace(e);
    this.closePanelUpLoad();
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {String} viewName - ...
   * @private
   */
  onAddTerritoriesViewClick(e, viewName) {
    logger46.trace(e, viewName);
    var id = Math.abs(Array.from(viewName).reduce((s, c) => Math.imul(31, s) + c.charCodeAt(0) | 0, 0));
    var view = this.getMap().getView();
    var proj = view.getProjection().getCode();
    var coord = transform(view.getCenter(), proj, "EPSG:4326");
    var zoom = view.getZoom();
    var territory = {
      "id": id.toString(),
      "title": viewName,
      "description": "Vue personnalisÃ©e",
      "point": coord,
      "zoom": zoom,
      "thumbnail": "",
      "icon": "fr-icon-map-pin-2-line"
      // icone DSFR ou svg
    };
    this.setTerritory(territory, true);
    this.dispatchEvent({
      type: "territories:add",
      territory
    });
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onResetTerritoriesViewClick(e) {
    logger46.trace(e);
    for (let index2 = 0; index2 < this.territories.length; index2++) {
      const territory = this.territories[index2];
      if (territory.isAdded) {
        this.removeTerritory(territory, true);
      } else {
        if (territory.isRemoved) {
          territory.domEntry.classList.remove("gpf-hidden");
          territory.domView.style.display = "";
          territory.isRemoved = false;
        }
      }
    }
    this.territories.sort((a2, b3) => a2.initialIndex - b3.initialIndex);
    this.panelTerritoriesEntriesContainer.innerHTML = "";
    this.territories.forEach((territory) => {
      this.panelTerritoriesEntriesContainer.appendChild(territory.domEntry);
    });
    this.panelTerritoriesViewsContainer.innerHTML = "";
    this.territories.forEach((territory) => {
      this.panelTerritoriesViewsContainer.appendChild(territory.domView);
    });
    var count = this.element.querySelector("#gpf-territories-views-count-id");
    if (count) {
      var nb = this.territories.filter((t) => !t.isRemoved).length;
      count.innerText = nb;
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {*} id - ...
   * @private
   */
  onViewTerritoryClick(e, id) {
    logger46.trace(e, id);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @param {*} id - ...
   * @private
   */
  onViewTerritoryRemoveClick(e, id) {
    logger46.trace(e, id);
    var territory = this.territories.find((e2) => e2.data.id === id);
    if (territory) {
      this.removeTerritory(territory, territory.isAdded);
      this.dispatchEvent({
        type: "territories:remove",
        territory: territory.data
      });
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onReorderTerritoriesViews(e) {
    logger46.trace(e);
    const domViews = Array.from(this.panelTerritoriesViewsContainer.children);
    const newOrderTerritories = [];
    domViews.forEach((domView) => {
      const found = this.territories.find((territory) => territory.domView === domView);
      if (found) {
        newOrderTerritories.push(found);
      }
    });
    this.territories = newOrderTerritories;
    this.panelTerritoriesEntriesContainer.innerHTML = "";
    this.territories.forEach((territory) => {
      this.panelTerritoriesEntriesContainer.appendChild(territory.domEntry);
    });
  }
};
Object.assign(Territories.prototype, TerritoriesDOM_default);
Object.assign(Territories.prototype, Widget_default);
var Territories_default2 = Territories;
if (window.ol && window.ol.control) {
  window.ol.control.Territories = Territories;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ControlList/ControlList.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/ControlList/GPFcontrolList.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ControlList/ControlListDOM.js
var ControlListDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPcontrolList");
    container.className = "GPwidget gpf-widget gpf-widget-button gpf-mobile-fullscreen";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //
  /**
   * Show control
   * see event !
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowControlListPictoElement: function() {
    var context = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowControlListPicto");
    button.classList.add("GPshowOpen", "GPshowAdvancedToolPicto", "GPshowControlListPicto");
    button.classList.add("gpf-btn", "gpf-btn--tertiary", "gpf-btn-icon", "gpf-btn-icon-controllist");
    button.classList.add("fr-btn", "fr-btn--tertiary");
    button.setAttribute("aria-label", "Tous mes outils");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowControlListPanelClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowControlListPanelClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //
  /**
   * Create Container Panel
   * @returns {HTMLElement} DOM element
   */
  _createControlListPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPcontrolListPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createControlListPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createControlListPanelHeaderElement: function() {
    var self2 = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-pt-4w";
    div.innerHTML = "Mes outils";
    container.appendChild(div);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPcontrolListPanelClose");
    divClose.className = "GPpanelClose GPcontrolListPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    divClose.title = "Fermer le panneau";
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowControlListPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowControlListPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Create Content Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createControlListPanelContentElement: function() {
    var container = document.createElement("div");
    container.className = "gpf-panel__content fr-modal__content";
    return container;
  },
  /**
   * Create Footer Panel
   *
   * @param {HTMLElement} controlCatalogelement - DOM element
   * @returns {HTMLElement} DOM element
   */
  _createControlListPanelFooterElement: function(controlCatalogelement) {
    var container = document.createElement("div");
    container.className = "GPpanelFooter gpf-panel__footer fr-modal__footer";
    var addToolsBtn = document.createElement("button");
    addToolsBtn.classList.add("gpf-btn", "gpf-btn--tertiary", "fr-btn", "fr-btn--tertiary");
    addToolsBtn.innerText = "+ Ajouter plus d'outils";
    addToolsBtn.addEventListener("click", function() {
      controlCatalogelement.click();
    });
    container.appendChild(addToolsBtn);
    return container;
  },
  /**
   * Create div for control
   *
   * @param {ol.Control} control control to add in the panel
   * @returns {HTMLElement} DOM element
   */
  _createControlListPanelControl: function(control) {
    let controlContainer;
    try {
      controlContainer = control.getContainer();
    } catch (e) {
      controlContainer = control.container;
    }
    var container = document.createElement("div");
    var btn = controlContainer.querySelector(".GPshowOpen").cloneNode();
    btn.id = btn.id + "-controllist";
    btn.classList.add("inside-control-list");
    container.appendChild(btn);
    var divText = document.createElement("div");
    var spanTitle = document.createElement("span");
    divText.appendChild(spanTitle);
    if (controlContainer.querySelector(".GPshowOpen").ariaLabel) {
      spanTitle.innerText = controlContainer.querySelector(".GPshowOpen").ariaLabel;
    } else if (controlContainer.querySelector(".GPpanelTitle")) {
      spanTitle.innerText = controlContainer.querySelector(".GPpanelTitle").innerText;
    } else if (controlContainer.querySelector("[class^='gpf-btn-header-']")) {
      spanTitle.innerText = controlContainer.querySelector("[class^='gpf-btn-header-']").title;
    }
    if (control.description) {
      var spanDescription = document.createElement("span");
      spanDescription.innerText = control.description;
      divText.appendChild(spanDescription);
    }
    container.appendChild(divText);
    container.addEventListener("click", function() {
      controlContainer.querySelector(".GPshowOpen").click();
    });
    return container;
  }
};
var ControlListDOM_default = ControlListDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ControlList/ControlList.js
var logger47 = LoggerByDefault_default2.getLogger("controlList");
var ControlList = class _ControlList extends Control_default2 {
  /**
   * @constructor
   * @param {ControlListOptions} options - ControlList control options
   */
  constructor(options) {
    options = options || {};
    super(options);
    if (!(this instanceof _ControlList)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    if (options.controlCatalogElement) {
      this.controlCatalogElement = options.controlCatalogElement;
    } else {
      this.controlCatalogElement = null;
    }
    this.CLASSNAME = "ControlList";
    this.initialize(options);
    this._container = this._initContainer();
    this.element ? this.element.appendChild(this._container) : this.element = this._container;
    return this;
  }
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      if (this.draggable) {
        Draggable_default.dragElement(
          this._ControlListPanelContainer,
          this._ControlListPanelHeaderContainer,
          map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this._pictoControlListButton.setAttribute("aria-pressed", true);
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      logger47.log("[ERROR] ControlList:setCollapsed - missing collapsed parameter");
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      document.getElementById("GPcontrolListPanelClose-" + this._uid).click();
    } else {
      this._pictoIsoButton.click();
    }
    this.collapsed = collapsed;
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this._container;
  }
  /**
   * Clean UI : reinit control
   */
  clean() {
    this._clearIsoInputs();
    this._originPoint.clearResults();
    document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
    document.getElementById("GPlocationOriginCoords_1-" + this._uid).value = "";
    document.getElementById("GPlocationOrigin_1-" + this._uid).value = "";
    document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
    document.getElementById("GPlocationOriginPointer_1-" + this._uid).checked = false;
    document.getElementById("GPlocationOrigin_1-" + this._uid).className = "GPlocationOriginVisible gpf-visible";
    document.getElementById("GPlocationOriginCoords_1-" + this._uid).className = "GPlocationOriginHidden gpf-hidden";
    this._currentIsoResults = null;
    this.setLayer();
  }
  // ################################################################### //
  // ##################### init component ############################## //
  // ################################################################### //
  /**
   * Initialize control (called by constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    if (options.collapsed === "true") {
      options.collapsed = true;
    }
    if (options.collapsed === "false") {
      options.collapsed = false;
    }
    this.options = {
      collapsed: true,
      draggable: false
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this._uid = this.options.id || SelectorID_default.generate();
  }
  // ################################################################### //
  // ######################## DOM initialize ########################### //
  // ################################################################### //
  /**
   * initialize component container (DOM)
   * @returns {HTMLElement} DOM element
   *
   * @private
   */
  _initContainer() {
    var container = this._createMainContainerElement();
    var picto = this._pictoControlListButton = this._createShowControlListPictoElement();
    container.appendChild(picto);
    var panel = this._ControlListPanelContainer = this._createControlListPanelElement();
    var panelDiv = this._createControlListPanelDivElement();
    panel.appendChild(panelDiv);
    var header = this._ControlListPanelHeaderContainer = this._createControlListPanelHeaderElement();
    panelDiv.appendChild(header);
    var content = this._ControlListPanelContentContainer = this._createControlListPanelContentElement();
    panelDiv.appendChild(content);
    if (this.controlCatalogElement) {
      var footer = this._createControlListPanelFooterElement(this.controlCatalogElement);
      panelDiv.appendChild(footer);
    }
    container.appendChild(panel);
    return container;
  }
  // ################################################################### //
  // ####################### handlers events to dom #################### //
  // ################################################################### //
  /**
   * this method is called by event 'click' on 'GPshowControlListPicto' picto
   * (cf. this._createShowControlListPictoElement),
   *
   * @param { Event } e Ã©vÃ¨nement associÃ© au clic
   * @private
   */
  onShowControlListPanelClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    var map = this.getMap();
    Interactions_default.unset(map);
    var opened = this._pictoControlListButton.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
    if (!this.collapsed) {
      const controls = this.getMap().getControls().getArray();
      controls.forEach((control) => {
        if (control.listable) {
          let element = this._createControlListPanelControl(control);
          this._ControlListPanelContentContainer.appendChild(element);
        }
      });
    } else {
      this._ControlListPanelContentContainer.innerHTML = "";
    }
  }
};
Object.assign(ControlList.prototype, ControlListDOM_default);
Object.assign(ControlList.prototype, Widget_default);
var ControlList_default = ControlList;
if (window.ol && window.ol.control) {
  window.ol.control.ControlList = ControlList;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ContextMenu/ContextMenu.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/ContextMenu/GPFcontextMenu.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Utils/OGCRequest.js
var OGCRequest = {
  /**
  * Computes data for a given layer of Geoplateforme's WFS
  * @param {String} layer name of the WFS layer
  * @param {Array} attributes list of strings of the relevant attributes to return
  * @param {Number} around distance around the point in km for the query, default 0
  * @param {String} geom_name name of the geometry column, default "geom"
  * @param {String} additional_cql cql filter needed other than geometry, e.g. "AND nature_de_l_objet='Bois'", default ""
  * @param {Number} epsg epsg number of the layer's CRS, default 4326
  * @param {Boolean} getGeom whether to get the geometry
  * @param {Number} lat Latitude
  * @param {Number} lng Longitude
  * @returns {Promise[]} results of each attributes (no duplicates)
  */
  computeGenericGPFWFS: async function(layer, attributes, around = 0, geom_name = "geom", additional_cql = "", epsg = 4326, getGeom = false, lat, lng) {
    let coord1 = lng;
    let coord2 = lat;
    if (epsg !== 4326) {
      [coord1, coord2] = lib_default(lib_default.defs("EPSG:4326"), lib_default.defs(`EPSG:${epsg}`), [lng, lat]);
    }
    let cql_filter = `INTERSECTS(${geom_name},Point(${coord1}%20${coord2}))`;
    if (around > 0) {
      cql_filter = `DWITHIN(${geom_name},Point(${coord1}%20${coord2}),${around},kilometers)`;
    }
    if (additional_cql) {
      cql_filter += ` ${additional_cql}`;
    }
    const results = await fetch(
      `https://data.geopf.fr/wfs/ows?SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature&typename=${layer}&outputFormat=json&count=50&CQL_FILTER=${cql_filter}`
    );
    const json = await results.json();
    const results_attributes = [];
    json.features.forEach((feature) => {
      const feature_attributes = [];
      attributes.forEach((attribute) => {
        feature_attributes.push(feature.properties[attribute]);
      });
      if (getGeom) {
        feature_attributes.push(feature.geometry);
      }
      if (attributes.length === 1 && feature_attributes[0] !== null && !getGeom) {
        results_attributes.push(feature_attributes[0]);
      } else if (attributes.length > 1 || getGeom) {
        results_attributes.push(feature_attributes);
      }
    });
    return results_attributes;
  }
};
var OGCRequest_default = OGCRequest;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ContextMenu/ContextMenuDOM.js
var title = "contextMenu";
var ContextMenuDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPpointInfo");
    container.className = "GPpointInfo GPwidget gpf-widget";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
  * Show PointInfo
  *
  * @returns {HTMLElement} DOM element
  */
  _createShowPointInfoPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowPointInfoPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowPointInfoPicto gpf-btn gpf-btn-icon gpf-btn-icon-widget fr-btn";
    button.title = `${title}`;
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowPointInfoClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowPointInfoClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
  * Create Container Panel
  *
  * @returns {HTMLElement} DOM element
  */
  _createPointInfoPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPpointInfoPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createPointInfoPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__pointInfo";
    return div;
  },
  /**
  * Create Header Panel
  *
  * @returns {HTMLElement} DOM element
  */
  _createPointInfoPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "GPpointInfoHeader gpf-panel__header_pointInfo";
    return container;
  },
  _createPointInfoPanelIconElement: function() {
    var label = document.createElement("label");
    label.className = "GPpanelHeader gpf-btn-header-pointInfo gpf-btn-icon-header-pointInfo";
    label.title = `Adresse et coordonnÃ©es`;
    return label;
  },
  _createPointInfoPanelTitleElement: function() {
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title_pointInfo fr-pt-4w";
    div.innerHTML = `Adresse et coordonnÃ©es`;
    return div;
  },
  _createPointInfoPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.className = "GPpanelClose GPpointInfoPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline";
    btnClose.title = "Fermer le panneau";
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function() {
        document.getElementById(self2._addUID("GPshowPointInfoPicto")).click();
        self2.onClosePointInfoClick();
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function() {
        document.getElementById(self2._addUID("GPshowPointInfoPicto")).click();
        self2.onClosePointInfoClick();
      });
    }
    return btnClose;
  },
  // ################################################################### //
  // ####################### Methods for entries ####################### //
  // ################################################################### //
  _createEntriesElement: function() {
    var div = document.createElement("div");
    div.className = "point-info-content gpf-panel__body fr-modal__body";
    var divContent = document.createElement("div");
    div.appendChild(divContent);
    return div;
  },
  _createPinDOMOverlay: function(ImgURL) {
    var div = document.createElement("div");
    var img = document.createElement("img");
    img.src = ImgURL;
    div.appendChild(img);
    return div;
  }
};
var ContextMenuDOM_default = ContextMenuDOM;

// node_modules/ol-contextmenu/dist/ol-contextmenu.js
var k2 = Object.defineProperty;
var I3 = (n, t, e) => t in n ? k2(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var a = (n, t, e) => I3(n, typeof t != "symbol" ? t + "" : t, e);
var S2 = { exports: {} };
function x2() {
}
x2.prototype = {
  on: function(n, t, e) {
    var s = this.e || (this.e = {});
    return (s[n] || (s[n] = [])).push({
      fn: t,
      ctx: e
    }), this;
  },
  once: function(n, t, e) {
    var s = this;
    function o() {
      s.off(n, o), t.apply(e, arguments);
    }
    return o._ = t, this.on(n, o, e);
  },
  emit: function(n) {
    var t = [].slice.call(arguments, 1), e = ((this.e || (this.e = {}))[n] || []).slice(), s = 0, o = e.length;
    for (s; s < o; s++)
      e[s].fn.apply(e[s].ctx, t);
    return this;
  },
  off: function(n, t) {
    var e = this.e || (this.e = {}), s = e[n], o = [];
    if (s && t)
      for (var i = 0, l3 = s.length; i < l3; i++)
        s[i].fn !== t && s[i].fn._ !== t && o.push(s[i]);
    return o.length ? e[n] = o : delete e[n], this;
  }
};
S2.exports = x2;
var _2 = S2.exports.TinyEmitter = x2;
var L2 = ((n) => (n.CONTEXTMENU = "contextmenu", n.CLICK = "click", n.DBLCLICK = "dblclick", n))(L2 || {});
var p = ((n) => (n.BEFOREOPEN = "beforeopen", n.OPEN = "open", n.CLOSE = "close", n.ADD_MENU_ENTRY = "add-menu-entry", n))(p || {});
var w2 = class extends MapBrowserEvent_default {
  constructor(t) {
    super(t.type, t.map, t.originalEvent);
  }
};
var z2 = {
  width: 150,
  scrollAt: 4,
  eventType: L2.CONTEXTMENU,
  defaultItems: true,
  items: []
};
var d2 = "ol-ctx-menu";
var r = {
  namespace: d2,
  container: `${d2}-container`,
  separator: `${d2}-separator`,
  submenu: `${d2}-submenu`,
  hidden: `${d2}-hidden`,
  icon: `${d2}-icon`,
  zoomIn: `${d2}-zoom-in`,
  zoomOut: `${d2}-zoom-out`,
  unselectable: "ol-unselectable"
};
var C2 = [
  {
    text: "Zoom In",
    classname: `${r.zoomIn} ${r.icon}`,
    callback: (n, t) => {
      const e = t.getView();
      e.animate({
        zoom: Number(e.getZoom()) + 1,
        duration: 700,
        center: n.coordinate
      });
    }
  },
  {
    text: "Zoom Out",
    classname: `${r.zoomOut} ${r.icon}`,
    callback: (n, t) => {
      const e = t.getView();
      e.animate({
        zoom: Number(e.getZoom()) - 1,
        duration: 700,
        center: n.coordinate
      });
    }
  }
];
function y2(n) {
  const t = document.createDocumentFragment(), e = document.createElement("div");
  for (e.innerHTML = n; e.firstChild; )
    t.append(e.firstChild);
  return t;
}
function P2(n) {
  var _a2, _b;
  const t = document.importNode(n), e = n.offsetWidth;
  t.style.cssText = `position: fixed; top: 0; left: 0; overflow: auto; visibility: hidden; pointer-events: none; height: unset; max-height: unset; width: ${e}px`;
  const s = y2("<span>Foo</span>"), o = y2("<span>Foo</span>"), i = document.createElement("li"), l3 = document.createElement("li");
  i.append(s), l3.append(o), t.append(i), t.append(l3), (_a2 = n.parentNode) == null ? void 0 : _a2.append(t);
  const c = t.offsetHeight / 2;
  return (_b = n.parentNode) == null ? void 0 : _b.removeChild(t), c;
}
function N2({
  parentNode: n,
  item: t,
  isSubmenu: e = false,
  isInsideSubmenu: s = false,
  emitter: o
}) {
  const i = `_${Math.random().toString(36).slice(2, 11)}`;
  if (typeof t != "string" && "text" in t) {
    const E2 = `<span>${t.text}</span>`, m2 = y2(E2), u = document.createElement("li");
    t.classname = t.classname || "", t.icon && (t.classname === "" ? t.classname = r.icon : t.classname.includes(r.icon) === false && (t.classname += ` ${r.icon}`), u.setAttribute("style", `background-image:url(${t.icon})`)), u.id = i, u.className = t.classname, u.append(m2), n.append(u);
    const v2 = {
      id: i,
      isSubmenu: e,
      isInsideSubmenu: s,
      isSeparator: false,
      callback: "callback" in t ? t.callback : null,
      data: "data" in t ? t.data : null
    };
    return o.emit(p.ADD_MENU_ENTRY, v2, u), u;
  }
  const l3 = `<li id="${i}" class="${r.separator}"><hr></li>`, c = y2(l3);
  n.append(c);
  const f = n.lastChild, g = {
    id: i,
    isSubmenu: false,
    isInsideSubmenu: false,
    isSeparator: true,
    callback: null,
    data: null
  };
  return o.emit(p.ADD_MENU_ENTRY, g, f), f;
}
function M3({
  container: n,
  items: t,
  menuWidth: e,
  isInsideSubmenu: s,
  emitter: o
}) {
  t.forEach((i) => {
    if (typeof i != "string" && "items" in i && Array.isArray(i.items)) {
      const l3 = N2({ parentNode: n, item: i, isSubmenu: true, emitter: o });
      l3.classList.add(r.submenu);
      const c = document.createElement("ul");
      c.classList.add(r.container), c.style.width = `${e}px`, l3.append(c), M3({
        emitter: o,
        menuWidth: e,
        container: c,
        items: i.items,
        isInsideSubmenu: true
      });
    } else
      N2({
        parentNode: n,
        item: i,
        isSubmenu: false,
        isInsideSubmenu: s,
        emitter: o
      });
  });
}
function b2(n, t) {
  if (!n) throw new Error(t);
}
var R = class extends Control_default {
  constructor(e = {}) {
    b2(typeof e == "object", "@param `opts` should be object type!");
    const s = document.createElement("div");
    super({ element: s });
    a(this, "map");
    a(this, "emitter", new _2());
    a(this, "container");
    a(this, "coordinate", []);
    a(this, "pixel", []);
    a(this, "contextMenuEventListener");
    a(this, "entryCallbackEventListener");
    a(this, "mapMoveListener");
    a(this, "lineHeight", 0);
    a(this, "disabled");
    a(this, "opened");
    a(this, "items", []);
    a(this, "menuEntries", /* @__PURE__ */ new Map());
    a(this, "options");
    this.options = { ...z2, ...e };
    const o = document.createElement("ul");
    s.append(o), s.style.width = `${this.options.width}px`, s.classList.add(
      r.container,
      r.unselectable,
      r.hidden
    ), this.container = s, this.contextMenuEventListener = (i) => {
      this.handleContextMenu(i);
    }, this.entryCallbackEventListener = (i) => {
      this.handleEntryCallback(i);
    }, this.mapMoveListener = () => {
      this.handleMapMove();
    }, this.disabled = false, this.opened = false, window.addEventListener(
      "beforeunload",
      () => {
        this.removeListeners();
      },
      { once: true }
    );
  }
  clear() {
    for (const e of this.menuEntries.keys())
      this.removeMenuEntry(e);
    this.container.replaceChildren(), this.container.append(document.createElement("ul"));
  }
  enable() {
    this.disabled = false;
  }
  disable() {
    this.disabled = true;
  }
  getDefaultItems() {
    return C2;
  }
  countItems() {
    return this.menuEntries.size;
  }
  extend(e) {
    b2(Array.isArray(e), "@param `items` should be an Array."), M3({
      items: e,
      emitter: this.emitter,
      menuWidth: this.options.width,
      container: this.container.firstElementChild
    });
  }
  closeMenu() {
    this.opened = false, this.container.classList.add(r.hidden), this.dispatchEvent(p.CLOSE);
  }
  isOpen() {
    return this.opened;
  }
  updatePosition(e) {
    b2(Array.isArray(e), "@param `pixel` should be an Array."), this.isOpen() && (this.pixel = e, this.positionContainer());
  }
  pop() {
    const e = Array.from(this.menuEntries.keys()).pop();
    e && this.removeMenuEntry(e);
  }
  shift() {
    const e = Array.from(this.menuEntries.keys()).shift();
    e && this.removeMenuEntry(e);
  }
  push(e) {
    e && this.extend([e]);
  }
  setMap(e) {
    if (super.setMap(e), e) {
      this.map = e, e.getViewport().addEventListener(
        this.options.eventType,
        this.contextMenuEventListener,
        false
      ), e.on("movestart", () => {
        this.handleMapMove();
      }), this.emitter.on(
        p.ADD_MENU_ENTRY,
        (o, i) => {
          this.handleAddMenuEntry(o, i);
        },
        this
      ), this.items = this.options.defaultItems ? this.options.items.concat(C2) : this.options.items, M3({
        items: this.items,
        emitter: this.emitter,
        menuWidth: this.options.width,
        container: this.container.firstElementChild
      });
      const s = this.getMenuEntriesLength();
      this.lineHeight = s > 0 ? this.container.offsetHeight / s : P2(this.container);
    } else
      this.removeListeners(), this.clear();
  }
  removeListeners() {
    this.map.getViewport().removeEventListener(this.options.eventType, this.contextMenuEventListener, false), this.emitter.off(p.ADD_MENU_ENTRY);
  }
  removeMenuEntry(e) {
    let s = document.getElementById(e);
    s == null ? void 0 : s.remove(), s = null, this.menuEntries.delete(e);
  }
  handleContextMenu(e) {
    var _a2;
    this.coordinate = this.map.getEventCoordinate(e), this.pixel = this.map.getEventPixel(e), this.dispatchEvent(
      new w2({
        map: this.map,
        originalEvent: e,
        type: p.BEFOREOPEN
      })
    ), !this.disabled && (this.options.eventType === L2.CONTEXTMENU && (e.stopPropagation(), e.preventDefault()), setTimeout(() => {
      this.openMenu(e);
    }), (_a2 = e.target) == null ? void 0 : _a2.addEventListener(
      "pointerdown",
      (s) => {
        this.opened && (s.stopPropagation(), this.closeMenu());
      },
      { once: true }
    ));
  }
  openMenu(e) {
    this.opened = true, this.positionContainer(), this.container.classList.remove(r.hidden), this.dispatchEvent(
      new w2({
        map: this.map,
        originalEvent: e,
        type: p.OPEN
      })
    );
  }
  getMenuEntriesLength() {
    return Array.from(this.menuEntries).filter(
      ([, e]) => e.isSeparator === false && e.isSubmenu === false && e.isInsideSubmenu === false
    ).length;
  }
  positionContainer() {
    const e = this.map.getSize() || [0, 0], s = {
      w: e[0] - this.pixel[0],
      h: e[1] - this.pixel[1]
    }, o = this.getMenuEntriesLength(), i = {
      w: this.container.offsetWidth,
      // a cheap way to recalculate container height
      // since offsetHeight is like cached
      h: Math.round(this.lineHeight * o)
    }, l3 = s.w >= i.w ? this.pixel[0] + 5 : this.pixel[0] - i.w;
    this.container.style.left = `${l3}px`, this.container.style.top = s.h >= i.h ? `${this.pixel[1] - 10}px` : `${this.pixel[1] - i.h}px`, this.container.style.right = "auto", this.container.style.bottom = "auto", s.w -= i.w;
    const c = (E2) => Array.from(E2.children).filter(
      (m2) => m2.tagName === "LI" && m2.classList.contains(r.submenu)
    );
    let f = 0;
    const g = (E2, m2) => {
      f += 1, c(E2).forEach((v2) => {
        const A5 = m2 >= i.w ? i.w - 8 : (i.w + 8) * -1, h = v2.querySelector(
          `ul.${r.container}`
        ), $2 = Math.round(
          this.lineHeight * Array.from(h.children).filter((T2) => T2.tagName === "LI").length
        );
        h.style.left = `${A5}px`, h.style.right = "auto", h.style.top = s.h >= $2 + i.h ? "0" : `-${h.offsetHeight - 25}px`, h.style.bottom = "auto", h.style.zIndex = String(f), c(h).length > 0 && g(h, m2 - i.w);
      });
    };
    g(this.container.firstElementChild, s.w);
  }
  handleMapMove() {
    this.closeMenu();
  }
  handleEntryCallback(e) {
    var _a2;
    e.preventDefault(), e.stopPropagation();
    const s = e.currentTarget, o = this.menuEntries.get(s.id);
    if (!o) return;
    const i = {
      data: o.data,
      coordinate: this.coordinate
    };
    this.closeMenu(), (_a2 = o.callback) == null ? void 0 : _a2.call(o, i, this.map);
  }
  handleAddMenuEntry(e, s) {
    this.menuEntries.set(e.id, e), this.positionContainer(), "callback" in e && typeof e.callback == "function" && s.addEventListener("click", this.entryCallbackEventListener, false);
  }
};

// node_modules/geopf-extensions-openlayers/src/packages/Controls/ContextMenu/ContextMenu.js
var logger48 = LoggerByDefault_default2.getLogger("contextMenu");
var ContextMenu = class _ContextMenu extends Control_default2 {
  /**
   * @constructor
   * @param {ContextMenuOptions} options - options for function call.
   *    la clÃ© contextMenuItemsOptions permet de paramÃ©trer 
   *    un tableau d'item dont le format est hÃ©ritÃ© de la librairie
   *    {@link https://www.npmjs.com/package/ol-contextmenu}
   * 
   *    ex : { contextMenuItemsOptions : itemsOpt }
   * 
   * @example
   * var contextMenu = new ol.control.ContextMenu();
   * map.addControl(contextMenu);
   */
  constructor(options) {
    options = options || {};
    super({
      element: options.element,
      target: options.target,
      render: options.render
    });
    if (!(this instanceof _ContextMenu)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this.CLASSNAME = "ContextMenu";
    this.initialize(options);
    this.container = this.initContainer();
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      map.addControl(this.contextmenu);
      map.addOverlay(this._marker);
      if (this.auto) {
        this.addEventsListeners();
      }
    } else {
      if (this.auto) {
        this.removeEventsListeners();
      }
    }
    super.setMap(map);
  }
  // ################################################################### //
  // ################### getters / setters ############################# //
  // ################################################################### //
  // ################################################################### //
  // #################### privates methods ############################# //
  // ################################################################### //
  /**
   * Initialize ContextMenu control (called by ContextMenu constructor)
   *
   * @param {Object} options - constructor options
   * @private
   */
  initialize(options) {
    this.uid = SelectorID_default.generate();
    this.options = {
      collapsed: true,
      draggable: false,
      auto: true,
      panel: true,
      contextMenuItemsOptions: []
    };
    Helper_default2.assign(this.options, options);
    this.collapsed = this.options.collapsed;
    this.draggable = this.options.draggable;
    this.auto = this.options.auto;
    this.buttonContextMenuShow = null;
    this.panelContextMenuContainer = null;
    this.panelContextMenuHeaderContainer = null;
    this.buttonContextMenuClose = null;
    this.panelContextMenuEntriesContainer = null;
    this.eventsListeners = [];
    this.controlList = [];
    this.itiPoints = new Array(7);
    this._marker = new Overlay_default({
      element: this._createPinDOMOverlay(Markers_default["lightOrange"]),
      stopEvent: false,
      offset: Markers_default.defaultOffset
    });
    ;
    var contextMenuItems = this.getAvailableContextMenuControls.call(this);
    this.contextMenuItemsOptions = [];
    if (options.contextMenuItemsOptions instanceof Array && options.contextMenuItemsOptions && options.contextMenuItemsOptions.length > 0) {
      this.contextMenuItemsOptions = options.contextMenuItemsOptions.map((item) => ({ ...item, classname: "ol-context-menu-custom fr-text--md" }));
    }
    this.contextmenu = new R(
      {
        defaultItems: false,
        // defaultItems are (for now) Zoom In/Zoom Out
        width: 250,
        items: contextMenuItems
      }
    );
  }
  /**
   * Create control main container (DOM initialize)
   *
   * @returns {HTMLElement} DOM element
   * @private
   */
  initContainer() {
    var container = this._createMainContainerElement();
    var picto = this.buttonPointInfoShow = this._createShowPointInfoPictoElement();
    container.appendChild(picto);
    var pointInfoPanel = this.panelPointInfoContainer = this._createPointInfoPanelElement();
    var pointInfoPanelDiv = this._createPointInfoPanelDivElement();
    pointInfoPanel.appendChild(pointInfoPanelDiv);
    var pointInfoEntriesDiv = this.panelPointInfoEntriesContainer = this._createEntriesElement();
    pointInfoPanel.appendChild(pointInfoEntriesDiv);
    var pointInfoPanelHeader = this.panelPointInfoHeaderContainer = this._createPointInfoPanelHeaderElement();
    var pointInfoPanelIcon = this._createPointInfoPanelIconElement();
    pointInfoPanelHeader.appendChild(pointInfoPanelIcon);
    var pointInfoPanelTitle = this._createPointInfoPanelTitleElement();
    pointInfoPanelHeader.appendChild(pointInfoPanelTitle);
    var pointInfoCloseBtn = this.buttonPointInfoClose = this._createPointInfoPanelCloseElement();
    pointInfoPanelHeader.appendChild(pointInfoCloseBtn);
    pointInfoPanelDiv.appendChild(pointInfoPanelHeader);
    container.appendChild(pointInfoPanel);
    logger48.log(container);
    return container;
  }
  /**
   * Add events listeners on map (called by setMap)
   * 
   * @private
   */
  addEventsListeners() {
    this.contextmenu.on("open", (evt) => {
      evt.this = this;
      this.onOpenContextMenu(evt);
    });
    this.contextmenu.on("close", (evt) => {
      evt.this = this;
      this.onCloseContextMenu(evt);
    });
  }
  /**
   * Remove events listeners on map (called by setMap)
   * @private
   */
  removeEventsListeners() {
  }
  /**
   * Add tools if added to the map Controls list
   * @private
   * @returns { Object } liste d'items par dÃ©faut du menu contextuel si control actif sur la carte
   */
  getAvailableContextMenuControls() {
    var allItems = [
      {
        text: "Informations sur des couches",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.getFeatureInfo.bind(this),
        control_CLASSNAME: "GetFeatureInfo"
      },
      {
        text: "Adresse / CoordonnÃ©es",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.displayAdressAndCoordinate.bind(this),
        control_CLASSNAME: "ContextMenu"
      },
      {
        text: "ItinÃ©raire depuis ce lieu",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.defineStartPoint.bind(this),
        control_CLASSNAME: "Route"
      },
      {
        text: "ItinÃ©raire vers ce lieu",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.defineEndPoint.bind(this),
        control_CLASSNAME: "Route"
      },
      {
        text: "Zone selon temps de trajet",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.computeIsochrone.bind(this),
        control_CLASSNAME: "Isocurve"
      },
      {
        text: "Ajouter des cartes / donnÃ©es",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.openCatalogue.bind(this),
        control_CLASSNAME: "Catalog"
      },
      "separator",
      {
        text: "Afficher la lÃ©gende",
        classname: "ol-context-menu-custom fr-text--md",
        callback: this.displayLegend.bind(this),
        control_CLASSNAME: "Legends"
      }
    ];
    var map = this.getMap();
    var controls = [];
    if (map) {
      controls = map.getControls().getArray();
    }
    var items = allItems.filter((item) => {
      let control = controls.filter((control2) => control2.CLASSNAME && control2.CLASSNAME == item.control_CLASSNAME);
      if (control.length > 0 || item == "separator") {
        return item;
      }
    });
    Array.prototype.push.apply(items, this.contextMenuItemsOptions);
    return items;
  }
  // ################################################################### //
  // ######################## Contextmenu specific code ################################ //
  // ################################################################### //
  /**
   * 
   * ---- Ajouter un point sur la carte 
   * 
   * Fonction utilisÃ©e lors d'un clique droit sur la carte 
   * Il s'agit d'afficher un marqueur et de stocker les coordonnÃ©es de ce point
   * Et tout cela en intÃ©ragissant avec le formulaire des paramÃ¨tres de l'itinÃ©raire 
   * @param {*} evt event
   * 
   */
  defineStartPoint(evt) {
    let clickedCoordinate = this.to4326(evt.coordinate);
    var route = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Route")[0];
    route._showRouteButton.click();
    route._showRouteButton.setAttribute("aria-pressed", true);
    this.itiPoints[0] = clickedCoordinate;
    route.setData({ points: this.itiPoints });
  }
  /**
   * ---- Ajouter un point sur la carte 
   * 
   * Fonction utilisÃ©e lors d'un clique droit sur la carte 
   * Il s'agit d'afficher un marqueur et de stocker les coordonnÃ©es de ce point
   * Et tout cela en intÃ©ragissant avec le formulaire des paramÃ¨tres de l'itinÃ©raire 
   * 
   * @param {*} evt event
   */
  defineEndPoint(evt) {
    let clickedCoordinate = this.to4326(evt.coordinate);
    var route = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Route")[0];
    route._showRouteButton.click();
    route._showRouteButton.setAttribute("aria-pressed", true);
    this.itiPoints[6] = clickedCoordinate;
    route.setData({ points: this.itiPoints });
  }
  /**
   * Convertit les coordonnÃ©es en EPSG:4326
   *  
   * @param { Array } coord CoordonnÃ©es en 3857
   * @returns { Array } tableau de coordonnÃ©es en 4326
   */
  to4326(coord) {
    return transform([
      parseFloat(coord[0]),
      parseFloat(coord[1])
    ], "EPSG:3857", "EPSG:4326");
  }
  /**
   * Fonction qui lance le calcul d'isochrone 
   * pour les coordonnÃ©es sous le clic
   * 
   * @param {*} evt event
   */
  computeIsochrone(evt) {
    var isocurve = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Isocurve")[0];
    isocurve._pictoIsoButton.click();
    isocurve._pictoIsoButton.setAttribute("aria-pressed", true);
    let clickedCoordinate = this.to4326(evt.coordinate);
    var data = isocurve.getData();
    data.point = clickedCoordinate;
    isocurve.setData(data);
  }
  /**
   * Fonction qui lance le GFI 
   * pour les coordonnÃ©es sous le clic
   * 
   * @param {*} evt event
   */
  getFeatureInfo(evt) {
    var gfi = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "GetFeatureInfo")[0];
    var activatedGFI;
    if (gfi.buttonGetFeatureInfoShow.getAttribute("aria-pressed") === "false") {
      activatedGFI = false;
    }
    gfi.buttonGetFeatureInfoShow.click();
    gfi.buttonGetFeatureInfoShow.setAttribute("aria-pressed", true);
    let pixel = this.getMap().getPixelFromCoordinate(evt.coordinate);
    let fakeEvent = {
      pixel,
      map: this.getMap(),
      coordinate: evt.coordinate
    };
    this.getMap().dispatchEvent({ type: "singleclick", ...fakeEvent });
    if (activatedGFI === false) {
      gfi.buttonGetFeatureInfoShow.setAttribute("aria-pressed", false);
    }
  }
  /**
   * Fonction qui ouvre le widget des lÃ©gendes
   * 
   * @param {*} evt event
   */
  displayLegend(evt) {
    var legend = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Legends")[0];
    legend.buttonLegendsShow.click();
    legend.buttonLegendsShow.setAttribute("aria-pressed", true);
  }
  /**
   * Fonction qui ouvre le widget Catalogue
   * 
   * @param {*} evt event
   */
  openCatalogue(evt) {
    var catalog = this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Catalog")[0];
    catalog.buttonCatalogShow.click();
    catalog.buttonCatalogShow.setAttribute("aria-pressed", true);
  }
  /**
   * Fonction qui ouvre un panel qui affiche les coordonnÃ©es et l'adresse sous le clic
   * 
   * @param {*} evt event
   */
  displayAdressAndCoordinate(evt) {
    let clickedCoordinate = this.to4326(evt.coordinate);
    this.panelPointInfoEntriesContainer.innerHTML = "";
    this._marker.setPosition(fromLonLat(clickedCoordinate));
    this.buttonPointInfoShow.click();
    this.buttonPointInfoShow.setAttribute("aria-pressed", true);
    var coordinate = document.createElement("div");
    coordinate.innerHTML = clickedCoordinate[1].toFixed(6) + ", " + clickedCoordinate[0].toFixed(6);
    var address = document.createElement("div");
    var parcel = document.createElement("div");
    var altitude = document.createElement("div");
    this.panelPointInfoEntriesContainer.appendChild(coordinate);
    this.panelPointInfoEntriesContainer.appendChild(address);
    this.panelPointInfoEntriesContainer.appendChild(parcel);
    this.panelPointInfoEntriesContainer.appendChild(altitude);
    var altiOptions = {
      rawResponse: false,
      // true|false
      scope: null,
      // this
      onSuccess: function(json) {
        if (json.elevations.length > 0 && json.elevations[0].z) {
          altitude.innerHTML = "Altitude : " + json.elevations[0].z + "m";
        }
      },
      onFailure: function(error) {
      },
      // spÃ©cifique au service
      positions: [{ lon: clickedCoordinate[0], lat: clickedCoordinate[1] }],
      outputFormat: "json"
      // json|xml
    };
    Gp_default.Services.getAltitude(altiOptions);
    var geocodageParcelOptions = {
      onSuccess: function(json) {
        if (json.locations.length > 0) {
          parcel.innerHTML = "Parcelle : " + json.locations[0].placeAttributes.districtcode + " / " + json.locations[0].placeAttributes.section + " / " + json.locations[0].placeAttributes.number;
        }
      },
      onFailure: function(error) {
      },
      // spÃ©cifique au service
      position: { lon: clickedCoordinate[1], lat: clickedCoordinate[0] },
      searchGeometry: { type: "Circle", coordinates: [clickedCoordinate[1], clickedCoordinate[0]], radius: 100 },
      index: "CadastralParcel",
      maximumResponses: 1
    };
    Gp_default.Services.reverseGeocode(geocodageParcelOptions);
    var getCommuneName = async function() {
      let config = {
        id: "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune",
        layer: "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune",
        attributes: ["code_postal", "nom_officiel"]
      };
      const result = await OGCRequest_default.computeGenericGPFWFS(
        config.layer,
        config.attributes,
        config.around || 0,
        config.geom_name || "geometrie",
        config.additional_cql || "",
        config.epsg || 4326,
        config.get_geom || false,
        clickedCoordinate[0],
        clickedCoordinate[1]
      );
      if (result.length) {
        address.innerHTML = result[0].join(", ");
      }
    };
    var geocodageAdressOptions = {
      onSuccess: function(json) {
        if (json.locations.length > 0) {
          address.innerHTML = json.locations[0].placeAttributes.label;
        } else {
          getCommuneName();
        }
      },
      onFailure: function(error) {
        getCommuneName();
      },
      // spÃ©cifique au service
      position: { lon: clickedCoordinate[0], lat: clickedCoordinate[1] },
      searchGeometry: { type: "Circle", coordinates: [clickedCoordinate[0], clickedCoordinate[1]], radius: 100 },
      index: "StreetAddress",
      maximumResponses: 1
    };
    Gp_default.Services.reverseGeocode(geocodageAdressOptions);
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onShowPointInfoClick(e) {
    if (e.target.ariaPressed === "true") {
      this.onPanelOpen();
    }
    logger48.trace(e);
    var opened = this.buttonPointInfoShow.ariaPressed;
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.options.position && !this.collapsed) {
      this.updatePosition(this.options.position);
    }
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onClosePointInfoClick(e) {
    logger48.trace(e);
    this._marker.setPosition(void 0);
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onCloseContextMenu(e) {
    e.target.clear();
  }
  /**
   * ...
   * @param {Event} e - ...
   * @private
   */
  onOpenContextMenu(e) {
    const mapViewport = this.getMap().getViewport();
    const canvas = mapViewport.querySelector("canvas");
    if (!canvas || e.originalEvent.target !== canvas) {
      this.contextmenu.clear();
      this.contextmenu.closeMenu();
      return;
    }
    var addMenuToolsEventListeners = () => {
      e.this.controlList = [];
      var controlArray = e.this.getMap().getControls().getArray().filter((control) => control.CLASSNAME == "Route");
      if (controlArray.length > 0) {
        controlArray[0].on("route:newresults", () => {
          e.this.itiPoints = new Array(7);
        });
      }
    };
    var contextMenuItems = e.this.getAvailableContextMenuControls();
    e.target.clear();
    e.target.extend(contextMenuItems);
    addMenuToolsEventListeners();
  }
};
Object.assign(ContextMenu.prototype, ContextMenuDOM_default);
Object.assign(ContextMenu.prototype, ContextMenu);
Object.assign(ContextMenu.prototype, Widget_default);
var ContextMenu_default = ContextMenu;
if (window.ol && window.ol.control) {
  window.ol.control.ContextMenu = ContextMenu;
}

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Reporting/Reporting.js
import "/home/JPBazonnais/Projets/PORTAIL/cartes.gouv.fr-entree-carto-fix/node_modules/geopf-extensions-openlayers/src/packages/CSS/Controls/Reporting/GPFreporting.css";

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Reporting/ReportingDOM.js
var title2 = "reporting";
var stringToHTML4 = (str) => {
  var support = function() {
    if (!window.DOMParser) {
      return false;
    }
    var parser2 = new DOMParser();
    try {
      parser2.parseFromString("x", "text/html");
    } catch (err) {
      return false;
    }
    return true;
  };
  if (support()) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(str, "text/html");
    return doc.body;
  }
  var dom = document.createElement("div");
  dom.innerHTML = str;
  return dom;
};
var ReportingDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {HTMLElement} DOM element
   */
  _createMainContainerElement: function() {
    var container = document.createElement("div");
    container.id = this._addUID("GPreporting");
    container.className = "gpf-widget gpf-widget-button gpf-mobile-fullscreen gpf-button-no-gutter";
    return container;
  },
  // ################################################################### //
  // ################### Methods of main container ##################### //
  // ################################################################### //
  /**
   * Show Reporting
   *
   * @returns {HTMLElement} DOM element
   */
  _createShowReportingPictoElement: function() {
    var self2 = this;
    var button = document.createElement("button");
    var span = document.createElement("span");
    button.appendChild(span);
    button.id = this._addUID("GPshowReportingPicto");
    button.className = "gpf-btn gpf-btn--tertiary gpf-btn-icon gpf-btn-icon-reporting fr-btn fr-btn--tertiary ";
    button.title = `${title2}`;
    button.setAttribute("aria-label", "Signalement");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    button.setAttribute("type", "button");
    if (button.addEventListener) {
      button.addEventListener("click", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowReportingClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function(e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self2.onShowReportingClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################### Methods of panel container #################### //
  // ################################################################### //
  /**
   * Create Container Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReportingPanelElement: function() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPreportingPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createReportingPanelDivElement: function() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {HTMLElement} DOM element
   */
  _createReportingPanelHeaderElement: function() {
    var container = document.createElement("div");
    container.className = "gpf-panel__header fr-modal__header gpf-panel__header_reporting";
    return container;
  },
  _createReportingPanelIconElement: function() {
    var self2 = this;
    var label = document.createElement("label");
    label.className = "gpf-btn-header gpf-btn-icon-header-reporting";
    label.title = "Retour Ã  l'Ã©tape prÃ©cÃ©dente";
    label.addEventListener("click", function(e) {
      self2.onPrevReportingClick(e);
    });
    return label;
  },
  _createReportingPanelTitleElement: function(title3) {
    var div = document.createElement("div");
    div.className = "gpf-panel__title fr-modal__title fr-pt-4w";
    div.innerHTML = title3 || "";
    return div;
  },
  _createReportingPanelCloseElement: function() {
    var self2 = this;
    var btnClose = document.createElement("button");
    btnClose.className = "gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--tertiary-no-outline fr-m-1w";
    btnClose.title = "Fermer le panneau";
    if (btnClose.addEventListener) {
      btnClose.addEventListener("click", function(e) {
        document.getElementById(self2._addUID("GPshowReportingPicto")).click();
        self2.onCloseReportingClick(e);
      }, false);
    } else if (btnClose.attachEvent) {
      btnClose.attachEvent("onclick", function(e) {
        document.getElementById(self2._addUID("GPshowReportingPicto")).click();
        self2.onCloseReportingClick(e);
      });
    }
    var span = document.createElement("span");
    span.className = "gpf-visible";
    span.innerText = "Fermer";
    btnClose.appendChild(span);
    return btnClose;
  },
  /**
   * Create Reporting Panel Footer
   * @returns {HTMLElement} DOM element
   * @todo
   */
  _createReportingPanelFooterElement: function() {
    var container = document.createElement("div");
    container.className = "gpf-panel__footer fr-modal__footer gpf-panel__footer_reporting gpf-visible";
    return container;
  },
  _createReportingButtonAnnulerFooterElement: function() {
    var self2 = this;
    var btnAnnuler = document.createElement("button");
    btnAnnuler.className = "gpf-btn gpf-btn--tertiary gpf-btn-icon-annuler fr-btn fr-btn--tertiary fr-m-1w";
    btnAnnuler.title = "Annuler";
    btnAnnuler.textContent = "Annuler";
    if (btnAnnuler.addEventListener) {
      btnAnnuler.addEventListener("click", function(e) {
        self2.onCancelReportingClick(e);
      }, false);
    } else if (btnAnnuler.attachEvent) {
      btnAnnuler.attachEvent("onclick", function(e) {
        self2.onCancelReportingClick(e);
      });
    }
    return btnAnnuler;
  },
  _createReportingButtonSuivantFooterElement: function() {
    var self2 = this;
    var btnSuivant = document.createElement("button");
    btnSuivant.className = "gpf-btn gpf-btn--primary gpf-btn-icon-suivant fr-btn fr-btn--primary fr-m-1w";
    btnSuivant.title = "Suivant";
    btnSuivant.textContent = "Suivant";
    if (btnSuivant.addEventListener) {
      btnSuivant.addEventListener("click", function(e) {
        self2.onNextReportingClick(e);
      }, false);
    } else if (btnSuivant.attachEvent) {
      btnSuivant.attachEvent("onclick", function(e) {
        self2.onNextReportingClick(e);
      });
    }
    return btnSuivant;
  },
  // ################################################################### //
  // ############################# windows ############################# //
  // ################################################################### //
  /**
   * Create input panel
   * @returns {HTMLElement} The input panel DOM element
   */
  _createReportingPanelInputElement: function() {
    var panel = document.createElement("div");
    panel.id = this._addUID("GPreportingPanelInput");
    panel.className = "gpf-panel__content fr-modal__content fr-px-3w gpf-hidden";
    var p2 = document.createElement("p");
    p2.innerHTML = "Cliquez sur la carte Ã  l'endroit que vous souhaitez corriger.";
    p2.className = "gpf-label fr-label";
    panel.appendChild(p2);
    return panel;
  },
  /**
   * Create panel form
   * @param {Array} thematics - List of thematics for the reporting form
   * @returns {HTMLElement} DOM element
   */
  _createReportingPanelFormElement: function(thematics) {
    var self2 = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPreportingForm");
    form.className = "gpf-panel__content fr-modal__content gpf-hidden";
    form.addEventListener("submit", function(e) {
      e.preventDefault();
      var nameValue = document.getElementById(idName).value;
      var descValue = document.getElementById(idDesc).value;
      var themeContainer = document.getElementById(idTheme);
      var themeValue = themeContainer.options[themeContainer.selectedIndex].textContent;
      self2.onReportingFormSubmit({
        target: e.target,
        name: nameValue,
        desc: descValue,
        theme: themeValue
      });
      return false;
    });
    var idName = this._addUID("GPreportingFormLabelName");
    var divName = `
        <div class="fr-input-group">
            <label class="gpf-label fr-label" for="${idName}">Titre (obligatoire)</label>
            <input class="gpf-input fr-input" type="text" id="${idName}" name="GPreportingLabelName" required>
        </div>
        `;
    var idTheme = this._addUID("GPreportingFormSelectTheme");
    var divTheme = `
        <div class="fr-select-group">
            <label class="gpf-label fr-label" for="${idTheme}">
                Objet du signalement (obligatoire)
            </label>
            <select class="gpf-select fr-select" id="${idTheme}" name="GPreportingSelectTheme" required>
                <option value="" selected disabled >SÃ©lectionner une option</option>
                ${thematics.map((theme) => {
      return `<option value="${theme}">${theme}</option>`;
    }).join("")}
            </select>
        </div>
        `;
    var idDesc = this._addUID("GPreportingFormTextDesc");
    var divDesc = `
        <div class="fr-input-group">
            <label class="gpf-label fr-label" for="${idDesc}">
                Description (obligatoire)
            </label>
            <textarea class="gpf-input fr-input" id="${idDesc}" name="GPreportingTextDesc" required></textarea>
        </div>
        `;
    var idBtn = this._addUID("GPreportingFormButtonDrawing");
    var divBtn = `
        <div class="gpf-btn-group">
            <button id="${idBtn}" class="gpf-btn fr-btn fr-btn--secondary fr-btn--icon-left fr-icon-edit-box-line">
                Dessiner sur la carte
            </button>
        </div>
        `;
    var strContainer = `
        <fieldset class="fr-fieldset" id="GPreportingFormFieldset" role="group" aria-labelledby="GPreportingFormFieldsetMessages">
            ${divName}
            ${divTheme}
            ${divDesc}
            <div class="fr-messages-group gpf-hidden" id="GPreportingFormFieldsetMessages" aria-live="polite">
                <p class="fr-message fr-message--error" id="GPreportingFormFieldsetMessage">Les champs sont obligatoires</p>
            </div>
            ${divBtn}
        </fieldset>
        `;
    var container = stringToHTML4(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById(idBtn);
    if (button) {
      button.addEventListener("click", (e) => {
        this.onShowFormDrawingReportingClick(e);
      });
    }
    var input = shadow.getElementById(idName);
    if (input) {
      input.addEventListener("change", (e) => {
        this.onEntryFormNameReportingChange(e);
      });
    }
    var select = shadow.getElementById(idTheme);
    if (select) {
      select.addEventListener("change", (e) => {
        this.onSelectFormThemeReportingChange(e);
      });
    }
    var text = shadow.getElementById(idDesc);
    if (text) {
      text.addEventListener("change", (e) => {
        this.onEntryFormDescReportingChange(e);
      });
    }
    form.appendChild(shadow);
    return form;
  },
  /**
   * Create the submit button
   *
   * @returns {HTMLElement} DOM element
   * @description Create the submit button for the reporting form.
   * This button is used to submit the reporting form.
   * It is hidden.
   * The form will be submitted when the user clicks on the button "Suivant".
   */
  _createReportingSubmitFormElement: function() {
    var input = document.createElement("input");
    input.id = this._addUID("GPreportingSubmit");
    input.className = "gpf-btn fr-btn gpf-hidden";
    input.type = "submit";
    input.value = "";
    return input;
  },
  /**
   * Create panel drawing
   * @returns {HTMLElement} The drawing panel DOM element
   */
  _createReportingPanelDrawingElement: function() {
    var panel = document.createElement("div");
    panel.id = this._addUID("GPreportingPanelDrawing");
    panel.className = "gpf-panel__content fr-modal__content gpf-hidden";
    return panel;
  },
  /**
   * Create panel send reporting
   * @returns {HTMLElement} The send reporting panel DOM element
   */
  _createReportingPanelSendElement: function() {
    var panel = document.createElement("div");
    panel.id = this._addUID("GPreportingPanelSend");
    panel.className = "gpf-panel__content fr-modal__content fr-px-3w gpf-hidden";
    var idMail = this._addUID("GPreportingLabelEmail");
    var divMail = `
        <div class="fr-input-group">
            <label class="gpf-label fr-label" for="${idMail}">Adresse courriel
                <span class="fr-hint-text">Pour valider le signalement, renseignez votre adresse courriel. Nous vous tiendrons informÃ©s de sa prise en compte.</span>
            </label>
            <input class="gpf-input fr-input" type="text" id="${idMail}" name="GPreportingLabelEmail" required>
        </div>
        `;
    var idBtn = this._addUID("GPreportingButtonEnvoyer");
    var divBtn = `
        <div class="gpf-btn-group fr-pb-1w">
            <button id="${idBtn}" class="gpf-btn fr-btn fr-btn--primary">
                Envoyer
            </button>
        </div>
        `;
    var strContainer = `
        <fieldset class="fr-fieldset" id="GPreportingSendFieldset" role="group" aria-labelledby="GPreportingSendFieldsetMessages">
            ${divMail}
            ${divBtn}
            <div class="fr-messages-group gpf-hidden" id="GPreportingSendFieldsetMessages" aria-live="polite">
                <p class="fr-message fr-message--error" id="GPreportingSendFieldsetMessage">Le champ est obligatoire</p>
            </div>
        </fieldset>
        `;
    var container = stringToHTML4(strContainer);
    const shadow = container.attachShadow({ mode: "open" });
    shadow.innerHTML = strContainer.trim();
    var button = shadow.getElementById(idBtn);
    if (button) {
      button.addEventListener("click", (e) => {
        this.onShowSendReportingClick({
          target: e.target,
          mail: document.getElementById(idMail).value
        });
      });
    }
    var input = shadow.getElementById(idMail);
    if (input) {
      input.addEventListener("change", (e) => {
        this.onEntrySendMailReportingChange(e);
      });
    }
    panel.appendChild(shadow);
    return panel;
  },
  _createReportingErrorSendElement: function() {
    var idError = this._addUID("GPreportingSpanError");
    var spanError = document.createElement("span");
    spanError.id = idError;
    spanError.className = "gpf-error fr-error fr-error-text gpf-hidden";
    spanError.innerHTML = "Une erreur est survenue lors de l'envoi du signalement. <br> Veuillez rÃ©essayer plus tard.";
    return spanError;
  }
};
var ReportingDOM_default = ReportingDOM;

// node_modules/geopf-extensions-openlayers/src/packages/Controls/Reporting/Reporting.js
var logger49 = LoggerByDefault_default2.getLogger("reporting");
var InputActionByDefaut = class {
  /**
   * @classdesc
   * Input action for the Reporting control.
   * This class handles user input on the map, specifically capturing single click events
   * to set coordinates for a reporting action.
   * @constructor
   * @alias InputActionByDefaut
   * @param {Map} [map] - Optional OpenLayers map instance.
   * @description
   * The constructor initializes the action with an optional map instance.
   * If no map is provided, it defaults to null.
   * It also initializes properties for data, coordinates, and event listeners.
   */
  constructor(map) {
    logger49.info("InputActionByDefaut constructor");
    this.map = map || null;
    this.data = null;
    this.coordinate = null;
    this.listener = null;
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAzNiIgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4Ij48cGF0aCBmaWxsPSIjMDAwMDkxIiBkPSJNMTguMzY0IDMuNjM2YTkgOSAwIDAgMSAwIDEyLjcyOEwxMiAyMi43MjhsLTYuMzY0LTYuMzY0QTkgOSAwIDAgMSAxOC4zNjQgMy42MzZaTTEyIDhhMiAyIDAgMSAwIDAgNCAyIDIgMCAwIDAgMC00WiIvPjwvc3ZnPg==";
  }
  // ######################################################## //
  // ########################## API ######################### //
  /**
   * Set the map for this action
   * @api
   * @param {Map} map - Map.
   */
  setMap(map) {
    logger49.info("InputActionByDefaut map");
    this.map = map;
  }
  /**
   * Set the icon for this action
   * @api
   * @param {String} icon - Icon URL or base64 encoded string.
   * @description
   * This method sets the icon for the input action.
   * It updates the icon property with the provided value.
   * If the icon is not provided, it defaults to a base64 encoded SVG string.
   */
  setIcon(icon) {
    logger49.info("InputActionByDefaut icon");
    if (icon) {
      this.icon = icon;
    }
  }
  /**
   * Get the data for this action
   * @api
   * @returns {Object} data - Data for this action.
   * @description
   * This method returns a GeoJSON FeatureCollection with a single Point feature.
   * The Point's coordinates are set to the last clicked coordinate on the map.
   * The FeatureCollection also includes a CRS (Coordinate Reference System) definition
   * based on the map's current projection.
   * @example
   * var data = inputAction.getData();
   * console.log(data);
   * // Output:
   * // {
   * //   location: {
   * //     type: "FeatureCollection",
   * //     crs: {
   * //       type: "name",
   * //       properties: {
   * //         name: "EPSG:4326"
   * //       }
   * //     },
   * //     features: [
   * //       {
   * //         type: "Feature",
   * //         geometry: {
   * //           type: "Point",
   * //           coordinates: [longitude, latitude]
   * //         },
   * //         properties: {
   * //           description: "Point de signalement",
   * //           date: "2023-10-01T12:00:00Z",
   * //         },
   * //       }
   * //     ]
   * //   }
   * // }
   */
  getData() {
    logger49.info("InputActionByDefaut data");
    var projection = this.map.getView().getProjection();
    if (!this.coordinate) {
      this.coordinate = this.map.getView().getCenter();
    }
    var geometry = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: projection.getCode()
        }
      },
      features: [
        {
          type: "Feature",
          crs: {
            type: "name",
            properties: {
              name: projection.getCode()
            }
          },
          geometry: {
            type: "Point",
            coordinates: this.coordinate || [0, 0]
          },
          properties: {
            description: "Point de signalement",
            date: (/* @__PURE__ */ new Date()).toISOString(),
            author: "Anonyme"
          }
        }
      ]
    };
    this.data = {
      location: geometry
    };
    return this.data || { location: null };
  }
  /**
   * Clear the data and remove the event listener
   * @api
   * @description
   * This method resets the data and coordinate properties to null,
   * and removes the event listener if it exists.
   */
  clear() {
    logger49.info("InputActionByDefaut clear");
    this.data = null;
    this.coordinate = null;
    if (this.listener) {
      unByKey(this.listener);
      this.listener = null;
    }
    if (this.marker != null) {
      this.map.removeOverlay(this.marker);
      this.marker = null;
    }
  }
  /**
   * Activate the action by adding event listeners
   * @api
   * @description
   * This method sets up the action to listen for single click events on the map.
   * When a single click occurs, it triggers the handler method to capture the coordinates.
   */
  active() {
    this._addEventsListeners();
  }
  /**
   * Disable the action by removing event listeners
   * @api
   * @description
   * This method removes the event listeners that were added during activation.
   */
  disable() {
    this._removeEventsListeners();
  }
  // ######################################################## //
  // ######################### privates ##################### //
  _addEventsListeners() {
    logger49.info("InputActionByDefaut active");
    if (!this.map) {
      return;
    }
    this.listener = this.map.on("singleclick", this._handler.bind(this));
  }
  _removeEventsListeners() {
    logger49.info("InputActionByDefaut disable");
    if (!this.map) {
      return;
    }
    unByKey(this.listener);
  }
  _handler(e) {
    logger49.info("InputActionByDefaut handler", e);
    if (!this.map) {
      return;
    }
    this.coordinate = e.coordinate;
    if (this.marker != null) {
      this.map.removeOverlay(this.marker);
      this.marker = null;
    }
    var markerDiv = document.createElement("img");
    markerDiv.src = this.icon;
    this.marker = new Overlay_default({
      position: this.coordinate,
      positioning: "center-center",
      element: markerDiv,
      stopEvent: false
    });
    this.map.addOverlay(this.marker);
  }
};
var FormActionByDefaut = class {
  /**
   * @classdesc
   * Form action for the Reporting control.
   * This class handles form submission and captures data from the form fields.
   * @constructor
   * @alias FormActionByDefaut
   * @param {HTMLFormElement} form - The form element to be managed by this action.
   * @description
   * The constructor initializes the action with a form element.
   * It sets up properties for data, form, and submit button.
   * The form and submit button will be set by the IoC (Inversion of Control) container.
   * The data property is initialized to null, indicating no data has been captured yet.
   */
  constructor(form) {
    logger49.info("FormActionByDefaut constructor");
    this.data = null;
    this.form = null;
    this.submit = null;
    this.error = null;
    this.message = null;
  }
  /**
   * Activate the action by adding event listeners
   * @api
   * @description
   * This method sets up the action to listen for the form submission event.
   * When the form is submitted, it triggers the handler method to capture the form data.
   */
  active() {
    logger49.info("FormActionByDefaut active");
    this._addEventsListeners();
  }
  /**
   * Disable the action by removing event listeners
   * @api
   * @description
   * This method does not perform any action in this implementation.
   * It is intended to be overridden in subclasses if needed.
   */
  disable() {
    logger49.info("FormActionByDefaut disable");
  }
  /**
   * Set the form for this action
   * @api
   * @param {HTMLElement} form DOM element - The form element to be set for this action.
   */
  setForm(form) {
    logger49.info("FormActionByDefaut form");
    this.form = form;
    this.submit = this.form.querySelector('input[type="submit"]');
    this.error = this.form.querySelector("#GPreportingFormFieldset");
    this.message = this.form.querySelector("#GPreportingFormFieldsetMessages");
  }
  /**
   * Get the data for this action
   * @api
   * @returns {Object} data - Data for this action.
   * @description
   * This method retrieves the data captured from the form submission.
   * It simulates a form submission by clicking the submit button,
   * and returns the data as an object.
   * @example
   * var data = formAction.getData();
   * console.log(data);
   * // Output:
   * // {
   * //   name: "Report Name",
   * //   desc: "Report Description",
   * //   theme: "Selected Theme"
   * // }
   */
  getData() {
    logger49.info("FormActionByDefaut data");
    this.submit.click();
    if (!this.data) {
      this.error.classList.add("fr-fieldset--error");
      this.message.classList.replace("gpf-hidden", "gpf-visible");
    } else {
      this.error.classList.remove("fr-fieldset--error");
      this.message.classList.replace("gpf-visible", "gpf-hidden");
    }
    return this.data;
  }
  /**
   * Clear the data and reset the form
   * @api
   * @description
   * This method resets the data property to null,
   * effectively clearing any previously captured form data.
   * It is intended to be called when the form needs to be reset or cleared.
   */
  clear() {
    logger49.info("FormActionByDefaut clear");
    this.data = null;
  }
  // ######################################################## //
  // ######################### privates ##################### //
  _addEventsListeners() {
    this.form.addEventListener("submit", this._handler.bind(this), { once: true });
  }
  _handler(e) {
    logger49.info("FormActionByDefaut handler", e);
    e.preventDefault();
    var formData = new FormData(e.target);
    var name = formData.get("GPreportingLabelName");
    var desc = formData.get("GPreportingTextDesc");
    var theme = formData.get("GPreportingSelectTheme");
    if (name && desc && theme) {
      this.data = {
        name,
        desc,
        theme
      };
    }
    return false;
  }
};
var DrawingActionByDefaut = class {
  /**
   * @classdesc
   * Drawing action for the Reporting control.
   * This class handles drawing actions on the map, allowing users to create and manage drawings.
   * @constructor
   * @alias DrawingActionByDefaut
   * @param {Map} [map] - Optional OpenLayers map instance.
   * @description
   * The constructor initializes the action with an optional map instance.
   * If no map is provided, it defaults to null.
   * It also initializes properties for data, map, DOM elements, and the Drawing instance.
   * The Drawing instance is used to manage the drawing functionality on the map.
   * The DOM elements for the drawing button and panel will be set by the IoC (Inversion of Control) container.
   */
  constructor(map) {
    logger49.info("DrawingActionByDefaut constructor");
    this.data = null;
    this.format = "geojson";
    this.map = map || null;
    this.dom = null;
    this.Drawing = null;
    this.DrawingBtn = null;
    this.DrawingPanel = null;
  }
  /**
   * Activate the action by adding event listeners
   * @api
   * @description
   * This method initializes the Drawing instance if it is not already created.
   * It sets the Drawing instance to be active and configures its panel.
   * The Drawing instance allows users to create and manage drawings on the map.
   * It also sets the position of the Drawing panel to be relative, allowing it to be positioned within its parent container.
   * If the Drawing instance is already initialized, it simply makes the Drawing panel visible.
   * This method is typically called when the user wants to start drawing on the map.
   */
  active() {
    logger49.info("ServiceActionByDefaut active");
    if (!this.Drawing) {
      this._initializeDrawing();
    }
    this.Drawing.setCollapsed(false);
    this.DrawingPanel.style.position = "relative";
    this.DrawingPanel.style.left = "0px";
    this.DrawingPanel.style.top = "0px";
    this.DrawingPanel.style.bottom = "unset";
    this.DrawingPanel.style.right = "unset";
  }
  /**
   * Disable the action by removing event listeners
   * @api
   * @description
   * This method collapses the Drawing instance, effectively hiding the drawing panel.
   * It is typically called when the user wants to stop drawing or hide the drawing panel.
   * If the Drawing instance is not initialized, it simply returns without performing any action.
   * This method is intended to be called when the drawing functionality is no longer needed.
   * It ensures that the Drawing panel is hidden and the Drawing instance is not active.
   */
  disable() {
    logger49.info("DrawingActionByDefaut disable");
    if (!this.Drawing) {
      return;
    }
    this.Drawing.setCollapsed(true);
  }
  /**
   * Clear the data
   * @api
   * @description
   * This method resets the data property to null,
   * effectively clearing any previously captured drawing data.
   * It is intended to be called when the drawing needs to be reset or cleared.
   * It does not perform any action on the Drawing instance itself.
   * This method is useful when the user wants to start a new drawing or discard the current drawing.
   * It ensures that the data property is cleared, allowing for a fresh start on the next drawing action.
   * It does not remove the Drawing instance or its event listeners, allowing the user to continue drawing if desired.
   */
  clear() {
    logger49.info("DrawingActionByDefaut clear");
    this.data = null;
  }
  /**
   * Get the data for this action
   * @api
   * @returns {Object} data - Data for this action.
   * @description
   * This method retrieves the data captured from the drawing.
   * It exports the features from the Drawing instance
   * and returns them as an object.
   * If no drawing data is available, it returns an empty object.
   * @example
   * var data = drawingAction.getData();
   * console.log(data);
   * // Output:
   * // {
   * //   drawing: {
   * //     type: "FeatureCollection",
   * //     features: [...]
   * //   }
   * // }
   */
  getData() {
    logger49.info("DrawingActionByDefaut data");
    if (this.Drawing) {
      var content = this.Drawing.exportFeatures();
      this.data = {
        drawing: this.format.toLowerCase() === "geojson" ? JSON.parse(content) : content
      };
    }
    return this.data || { drawing: null };
  }
  /**
   * Set the map for this action
   * @api
   * @param {Map} map - Map.
   * @description
   * This method sets the map instance for the Drawing action.
   * It initializes the Drawing instance if it is not already created.
   * If the Drawing instance is already initialized, it simply updates the map property.
   * This method is typically called when the map is ready or when the Drawing action needs to be associated with a specific map instance.
   */
  setMap(map) {
    logger49.info("DrawingActionByDefaut map");
    this.map = map;
  }
  /**
   * Set the target DOM element for the Drawing action
   * @api
   * @param {HTMLElement} dom - The DOM element to set as the target for the Drawing action.
   */
  setTarget(dom) {
    logger49.info("DrawingActionByDefaut target");
    if (!dom) {
      logger49.warn("DrawingActionByDefaut target is null");
      return;
    }
    this.dom = dom;
  }
  /**
   * Set the format for exporting drawings
   * @api
   * @param {String} format - The format to set for exporting drawings.
   */
  setFormat(format) {
    logger49.info("DrawingActionByDefaut format");
    if (format) {
      this.format = format;
    }
  }
  // ######################################################## //
  // ######################### privates ##################### //
  _initializeDrawing() {
    logger49.info("DrawingActionByDefaut initializeDrawing");
    if (!this.map) {
      return;
    }
    var id = 1e3;
    this.Drawing = new Drawing_default({
      target: this.dom,
      id,
      layerDescription: {
        title: "Signalement",
        description: "Dessin de signalement"
      },
      popup: {
        display: false
      },
      tools: {
        export: false
      }
    });
    this.Drawing.setExportFormat(this.format);
    var container = this.Drawing.getContainer();
    container.className = "";
    var button = this.DrawingBtn = container.querySelector("#GPshowDrawingPicto-" + id);
    if (button) {
      button.style.display = "none";
    }
    var panel = this.DrawingPanel = container.querySelector("#GPdrawingPanel-" + id);
    if (panel) {
      panel.style.position = "relative";
      panel.style.left = "0px";
      panel.style.top = "0px";
      panel.style.bottom = "unset";
      panel.style.right = "unset";
      panel.style.margin = "auto";
    }
    var header = container.querySelector(".gpf-panel__header");
    if (header) {
      header.style.display = "none";
    }
    this.map.addControl(this.Drawing);
  }
};
var ServiceActionByDefaut = class {
  constructor() {
    logger49.info("ServiceActionByDefaut constructor");
  }
  /**
   * Activate the action by adding event listeners
   * @api
   * @description
   * This method does not perform any action in this implementation.
   * It is intended to be overridden in subclasses if needed.
   */
  active() {
    logger49.info("ServiceActionByDefaut active");
  }
  /**
   * Disable the action by removing event listeners
   * @api
   * @description
   * This method does not perform any action in this implementation.
   * It is intended to be overridden in subclasses if needed.
   */
  disable() {
    logger49.info("ServiceActionByDefaut disable");
  }
  /**
   * Send data to the service
   * @api
   * @param {Object} data - Data to send.
   * @returns {Promise} - A promise that resolves when the data is sent.
   * @description
   * This method is intended to send data to a service.
   * It currently throws an error indicating that the method is not implemented.
   * @example
   * var serviceAction = new ServiceActionByDefaut();
   * serviceAction.send(data);
   * // Output data to the service :
   * // {
   * //   location: { ... }, // GeoJSON FeatureCollection with Point geometry
   * //   name: "Report Name",
   * //   desc: "Report Description",
   * //   theme: "Selected Theme",
   * //   drawing: { ... } // GeoJSON FeatureCollection with drawing features
   * // }
   */
  send(data) {
    logger49.info("ServiceActionByDefaut send");
    return Promise.reject(new Error("ServiceActionByDefaut send not implemented"));
  }
  /**
   * Clear the data
   * @api
   * @description
   * This method does not perform any action in this implementation.
   * It is intended to be overridden in subclasses if needed.
   */
  clear() {
    logger49.info("ServiceActionByDefaut clear");
  }
};
var _Reporting_instances, initialize_fn, initContainer_fn;
var _Reporting = class _Reporting extends Control_default2 {
  /**
   * @constructor
   * @param {Object} [options] - options
   * @param {Boolean} [options.collapsed=true] - specify if control is collapsed (true) or not (false)
   * @param {Boolean} [options.draggable=false] - specify if control is draggable (true) or not (false)
   * @param {Boolean} [options.auto=true] - specify if control add some stuff auto
   * @param {Array} [options.thematics] - specify the list of thematics
   * @param {String} [options.format="geojson"] - specify the format for export (default: "geojson")
   * @param {String} [options.icon] - specify the icon for point entry (default: base64 encoded SVG)
   * @param {HTMLElement} [options.element] - specify the DOM element to append the control
   * @param {String} [options.target] - specify the target element to append the control
   * @param {Function} [options.render] - specify the render function
   * @description
   * The Reporting control is a custom OpenLayers control that allows users to report issues or provide
   * feedback on the map. It provides a user interface for inputting details about the report, including
   * the location, description, and thematic category of the issue.
   * @fires reporting:sending
   * @fires reporting:opened
   * @example
   * var reporting = new ol.control.Reporting();
   * map.addControl(reporting);
   */
  constructor(options) {
    options = options || {};
    super({
      element: options.element,
      target: options.target,
      render: options.render
    });
    __privateAdd(this, _Reporting_instances);
    if (!(this instanceof _Reporting)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    __privateMethod(this, _Reporting_instances, initialize_fn).call(this, options);
    this.container = __privateMethod(this, _Reporting_instances, initContainer_fn).call(this);
    this.element ? this.element.appendChild(this.container) : this.element = this.container;
    return this;
  }
  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //
  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {Map} map - Map.
   */
  setMap(map) {
    if (map) {
      this.setStep(0);
      this._setComponents(map);
      if (this.draggable) {
        Draggable_default.dragElement(
          this.panelReportingContainer,
          this.panelReportingHeaderContainer,
          this.options.position ? null : map.getTargetElement()
        );
      }
      if (!this.collapsed) {
        this.buttonReportingShow.click();
      }
      if (this.auto) {
        this._addEventsListeners(map);
      }
    } else {
      if (this.auto) {
        this._removeEventsListeners();
      }
    }
    super.setMap(map);
    if (this.options.position) {
      this.setPosition(this.options.position);
    }
    if (this.options.gutter === false) {
      this.getContainer().classList.add("gpf-button-no-gutter");
    }
  }
  /**
   * Get container
   *
   * @returns {HTMLElement} container
   */
  getContainer() {
    return this.container;
  }
  /**
   * Returns true if widget is collapsed (minimized), false otherwise
   *
   * @returns {Boolean} collapsed - true if widget is collapsed
   */
  getCollapsed() {
    return this.collapsed;
  }
  /**
   * Collapse or display widget main container
   *
   * @param {Boolean} collapsed - True to collapse widget, False to display it
   */
  setCollapsed(collapsed) {
    if (collapsed === void 0) {
      return;
    }
    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
      return;
    }
    if (collapsed) {
      this.buttonReportingClose.click();
    } else {
      this.buttonReportingShow.click();
    }
    this.collapsed = collapsed;
  }
  // ################################################################### //
  // ##################### public methods IoC ########################## //
  // ################################################################### //
  /**
   * Set the components for the Reporting control.
   * @private
   * @param {Map} map - The OpenLayers map instance to set for the components.
   * @description
   * This method initializes the IoC (Inversion of Control) components for the Reporting control.
   * It sets up the input, form, service, and drawing actions by creating instances of the respective classes.
   */
  _setComponents(map) {
    if (!this.iocInput) {
      this.iocInput = new InputActionByDefaut();
    }
    this.iocInput.setMap(map);
    this.iocInput.setIcon(this.options.icon || null);
    if (!this.iocForm) {
      this.iocForm = new FormActionByDefaut();
    }
    this.iocForm.setForm(this.formReportingContainer);
    if (!this.iocService) {
      this.iocService = new ServiceActionByDefaut();
    }
    if (!this.iocDrawing) {
      this.iocDrawing = new DrawingActionByDefaut();
    }
    this.iocDrawing.setFormat(this.options.format || "geojson");
    this.iocDrawing.setMap(map);
    this.iocDrawing.setTarget(this.drawingReportingContainer);
    this.stepContainer[0].action = this.iocInput;
    this.stepContainer[1].action = this.iocForm;
    this.stepContainer[2].action = this.iocService;
    this.stepContainer[3].action = this.iocDrawing;
  }
  /**
   * Add ioc
   * @param {IocInput} input - instance
   */
  setComponentInput(input) {
    this.iocInput = input;
  }
  /**
   * Add ioc
   * @param {IocForm} form - instance
   */
  setComponentForm(form) {
    this.iocForm = form;
  }
  /**
   * Add ioc
   * @param {IocService} service - instance
   */
  setComponentService(service) {
    this.iocService = service;
  }
  /**
   * Add ioc
   * @param {IocDrawing} drawing - instance
   */
  setComponentDrawing(drawing) {
    this.iocDrawing = drawing;
  }
  /**
   * Add events listener on map (called by setMap)
   *
   * @param {Map} map - map
   * @private
   */
  _addEventsListeners(map) {
    var self2 = this;
    this.eventsListeners["custom:action"] = function(e) {
      logger49.trace(e);
    };
    map.getLayers().on("some:event", this.eventsListeners["custom:action"]);
  }
  /**
   * Remove events listener on map (called by setMap)
   * @private
   */
  _removeEventsListeners() {
    var map = this.getMap();
    map.getLayers().un("some:event", this.eventsListeners["custom:action"]);
    delete this.eventsListeners["custom:action"];
  }
  // ################################################################### //
  // ############################ steps ################################ //
  // ################################################################### //
  /**
   * Set the current step of the reporting process.
   * @param {*} num - The step number to set.
   * @returns {void}
   * @description
   * This method sets the current step of the reporting process.
   * It updates the visibility of the step containers,
   * activates the corresponding IoC action,
   * and updates the reporting title and footer display.
   * It is typically called when the user navigates to a different step in the reporting process,
   * such as moving from the input step to the form step or the send step.
   */
  setStep(num) {
    if (num === void 0) {
      return;
    }
    for (let index2 = 0; index2 < this.stepContainer.length; index2++) {
      const element = this.stepContainer[index2].container;
      element.classList.replace("gpf-visible", "gpf-hidden");
      var action = this.stepContainer[index2].action;
      if (action) {
        action.disable();
        action.clear();
      }
    }
    this.step = num;
    var panel = this.stepContainer[num].container;
    panel.classList.replace("gpf-hidden", "gpf-visible");
    var action = this.stepContainer[num].action;
    if (action) {
      action.active();
    }
    this.divReportingTitle.innerHTML = this.stepContainer[num].name;
    this.panelReportingFooterContainer.style.display = this.stepContainer[num].footer ? "flex" : "none";
    this.reportingBtnAnnulerFooter.style.display = this.stepContainer[num].prev === -1 ? "none" : "flex";
    this.reportingBtnSuivantFooter.style.display = this.stepContainer[num].next === -1 ? "none" : "flex";
    this.labelReportingIcon.style.display = this.stepContainer[num].prev === -1 ? "none" : "flex";
  }
  /**
   * Move to the next step in the reporting process.
   * This method checks if there is a next step available.
   * @returns {void}
   * @description
   * This method is used to navigate to the next step in the reporting process.
   * It retrieves the next step from the stepContainer array based on the current step index.
   * If a next step exists (indicated by a valid index), it retrieves the action associated with the current step,
   * clears its data, and disables it.
   * The data from the current action is merged into the reporting data object.
   */
  nextStep() {
    var current = this.step;
    var next = this.stepContainer[current].next;
    if (next !== -1) {
      var action = this.stepContainer[current].action;
      if (action) {
        var data = action.getData();
        if (!data) {
          return;
        }
        logger49.trace("Reporting nextStep", data);
        this.data = Object.assign({}, this.data, data);
        action.disable();
        action.clear();
      }
      this.setStep(next);
    }
  }
  /**
   * Move to the previous step in the reporting process.
   * This method checks if there is a previous step available.
   * If there is a previous step, it clears the current action's data
   * and sets the step to the previous one.
   * @returns {void}
   * @description
   * This method is used to navigate back to the previous step in the reporting process.
   * It retrieves the previous step from the stepContainer array based on the current step index.
   * If a previous step exists (indicated by a valid index), it clears the current action's data
   * and sets the step to the previous one.
   * The current action's data is cleared to ensure that any unsaved changes are discarded.
   * This method is typically called when the user wants to go back to the previous step
   * in the reporting process, allowing them to review or modify their input before proceeding.
   * It is useful for scenarios where users may need to correct or change their input
   * before finalizing their report.
   * If the current step does not have a previous step (indicated by prev being -1),
   * the method does nothing, effectively preventing navigation to a non-existent step.
   * This ensures that the reporting process remains linear and prevents users from navigating
   * to steps that are not part of the defined workflow.
   */
  prevStep() {
    var current = this.step;
    var prev = this.stepContainer[current].prev;
    if (prev !== -1) {
      var action = this.stepContainer[current].action;
      if (action) {
        action.clear();
      }
      this.setStep(prev);
    }
  }
  clear() {
    for (let index2 = 0; index2 < this.stepContainer.length; index2++) {
      const element = this.stepContainer[index2].container;
      element.classList.replace("gpf-visible", "gpf-hidden");
      var action = this.stepContainer[index2].action;
      if (action) {
        action.disable();
        action.clear();
      }
    }
    var drawing = this.iocDrawing.Drawing;
    if (drawing) {
      var layer = drawing.getLayer();
      var map = this.getMap();
      if (layer) {
        map.removeLayer(layer);
        drawing.setLayer();
      }
    }
  }
  // ################################################################### //
  // ######################## event dom ################################ //
  // ################################################################### //
  /**
   * Handle the click event on the "Show Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onShowReportingClick(e) {
    logger49.trace("onShowReportingClick", e);
    var opened = this.buttonReportingShow.ariaPressed;
    if (opened === "true") {
      this.onPanelOpen();
    }
    this.collapsed = !(opened === "true");
    this.dispatchEvent("change:collapsed");
    if (this.collapsed) {
      this.clear();
    } else {
      this.setStep(0);
      this.dispatchEvent(this.OPENED_REPORTING_EVENT);
    }
  }
  /**
   * Handle the click event on the "Previous Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onPrevReportingClick(e) {
    logger49.trace("onPrevReportingClick", e);
    this.prevStep();
  }
  /**
   * Handle the click event on the "Next Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onNextReportingClick(e) {
    logger49.trace("onNextReportingClick", e);
    this.nextStep();
  }
  /**
   * Handle the click event on the "Close Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onCloseReportingClick(e) {
    logger49.trace("onCloseReportingClick", e);
    this.clear();
  }
  /**
   * Handle the click event on the "Cancel Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onCancelReportingClick(e) {
    logger49.trace("onCancelReportingClick", e);
    this.clear();
    this.setStep(0);
  }
  // ######################################### //
  // ############# Panel Form ################ //
  /**
   * Handle the form submission event for the reporting form.
   * @param {*} e - The form submission event object.
   * @private
   */
  onReportingFormSubmit(e) {
    logger49.trace("onReportingFormSubmit", e);
  }
  /**
   * Handle the click event on the "Show Form Drawing Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onShowFormDrawingReportingClick(e) {
    logger49.trace("onShowFormDrawingReportingClick", e);
    this.setStep(3);
  }
  /**
   * Handle the click event on the "Show Form Input Reporting" button.
   * @param {*} e - The click event object.
   * @private
   */
  onEntryFormNameReportingChange(e) {
    logger49.trace("onEntryFormNameReportingChange", e);
  }
  /**
   * Handle the change event on the "Form Theme Reporting" select element.
   * @param {*} e - The change event object.
   * @private
   */
  onSelectFormThemeReportingChange(e) {
    logger49.trace("onSelectFormThemeReportingChange", e);
  }
  /**
   * Handle the change event on the "Form Description Reporting" textarea element.
   * @param {*} e - The change event object.
   * @private
   */
  onEntryFormDescReportingChange(e) {
    logger49.trace("onEntryFormDescReportingChange", e);
  }
  // ######################################### //
  // ############# Panel Send ################ //
  /**
   * Handle the change event on the "Send Mail Reporting" input element.
   * @param {*} e - The change event object.
   * @private
   */
  onEntrySendMailReportingChange(e) {
    logger49.trace("onEntrySendMailReportingChange", e);
  }
  /**
   * Handle the click event on the "Send Reporting" button.
   * @param {*} e - {mail, name, desc, theme, drawing, location}
   * @fires reporting:send
   * @description
   * This method is called when the user clicks on the "Send Reporting" button.
   * It is responsible for handling the click event and processing the reporting data.
   * It retrieves the mail from the event, updates the data object,
   * and sends the reporting data to the server or processes it as needed.
   * If the sending is successful, it clears the data and resets the step to the first step.
   * If there is an error during the sending process, it displays an error message for a limited time.
   * @private
   */
  onShowSendReportingClick(e) {
    logger49.trace("onShowSendReportingClick", e);
    this.data = Object.assign({}, this.data, {
      mail: e.mail
    });
    var errorDom = this.sendReportingContainer.querySelector("#GPreportingSendFieldset");
    var messDom = this.sendReportingContainer.querySelector("#GPreportingSendFieldsetMessages");
    if (!e.mail) {
      errorDom.classList.add("fr-fieldset--error");
      messDom.classList.replace("gpf-hidden", "gpf-visible");
      return;
    } else {
      errorDom.classList.remove("fr-fieldset--error");
      messDom.classList.replace("gpf-visible", "gpf-hidden");
    }
    logger49.info("Reporting data to send:", this.data);
    this.iocService.send(this.data).then(() => {
      this.data = null;
      var drawing = this.iocDrawing.Drawing;
      if (drawing) {
        var layer = drawing.getLayer();
        var map = this.getMap();
        if (layer) {
          map.removeLayer(layer);
          drawing.setLayer();
        }
      }
    }).then(() => {
      this.setStep(0);
    }).then(() => {
      this.dispatchEvent({
        type: this.SEND_REPORTING_EVENT,
        data: this.data
      });
    }).catch((e2) => {
      this.spanReportingError.classList.replace("gpf-hidden", "gpf-visible");
      setTimeout(() => {
        this.spanReportingError.classList.replace("gpf-visible", "gpf-hidden");
      }, 5e3);
      logger49.error(e2);
    });
  }
};
_Reporting_instances = new WeakSet();
// ################################################################### //
// #################### privates methods ############################# //
// ################################################################### //
/**
 * Initialize Reporting control (called by Reporting constructor)
 *
 * @param {Object} options - constructor options
 * @private
 */
initialize_fn = function(options) {
  this.uid = SelectorID_default.generate();
  this.options = {
    collapsed: true,
    draggable: false,
    auto: true,
    thematics: [
      "RÃ©seau routier",
      "BÃ¢timent",
      "Toponyme",
      "Touristique/randonnÃ©e",
      "Borne cadastrale",
      "Hydrographie",
      "VÃ©gÃ©tation",
      "Autre"
    ]
  };
  Helper_default2.assign(this.options, options);
  this.collapsed = this.options.collapsed;
  this.draggable = this.options.draggable;
  this.auto = this.options.auto;
  this.buttonReportingShow = null;
  this.panelReportingContainer = null;
  this.panelReportingHeaderContainer = null;
  this.panelReportingFooterContainer = null;
  this.reportingBtnAnnulerFooter = null;
  this.reportingBtnSuivantFooter = null;
  this.buttonReportingClose = null;
  this.divReportingTitle = null;
  this.labelReportingIcon = null;
  this.buttonReportingSubmit = null;
  this.spanReportingError = null;
  this.inputReportingContainer = null;
  this.formReportingContainer = null;
  this.sendReportingContainer = null;
  this.drawingReportingContainer = null;
  this.step = 0;
  this.stepContainer = [
    {
      name: "",
      footer: true,
      header: true,
      next: 1,
      prev: -1,
      action: null,
      // this.iocInput
      container: null
      // this.inputReportingContainer
    },
    {
      name: "DÃ©crire le signalement",
      footer: true,
      header: true,
      next: 2,
      prev: 0,
      action: null,
      // this.iocForm
      container: null
      // this.formReportingContainer
    },
    {
      name: "Envoyer un signalement",
      footer: false,
      header: true,
      next: -1,
      prev: 1,
      action: null,
      // this.iocService
      container: null
      // this.sendReportingContainer
    },
    {
      name: "Dessiner sur la carte",
      footer: true,
      header: true,
      next: 1,
      prev: 1,
      action: null,
      // this.iocDrawing
      container: null
      // this.drawingReportingContainer
    }
  ];
  this.iocInput = null;
  this.iocForm = null;
  this.iocService = null;
  this.iocDrawing = null;
  this.data = null;
  this.eventsListeners = [];
  this.OPENED_REPORTING_EVENT = "reporting:opened";
  this.SEND_REPORTING_EVENT = "reporting:sending";
};
/**
 * Create control main container (DOM initialize)
 *
 * @returns {HTMLElement} DOM element
 * @private
 */
initContainer_fn = function() {
  var container = this._createMainContainerElement();
  var picto = this.buttonReportingShow = this._createShowReportingPictoElement();
  container.appendChild(picto);
  var reportingPanel = this.panelReportingContainer = this._createReportingPanelElement();
  var reportingPanelDiv = this._createReportingPanelDivElement();
  reportingPanel.appendChild(reportingPanelDiv);
  var reportingPanelHeader = this.panelReportingHeaderContainer = this._createReportingPanelHeaderElement();
  var reportingPanelIcon = this.labelReportingIcon = this._createReportingPanelIconElement();
  reportingPanelHeader.appendChild(reportingPanelIcon);
  var reportingPanelTitle = this.divReportingTitle = this._createReportingPanelTitleElement();
  reportingPanelHeader.appendChild(reportingPanelTitle);
  var reportingCloseBtn = this.buttonReportingClose = this._createReportingPanelCloseElement();
  reportingPanelHeader.appendChild(reportingCloseBtn);
  var reportingPanelFooter = this.panelReportingFooterContainer = this._createReportingPanelFooterElement();
  var BtnAnnulerFooter = this.reportingBtnAnnulerFooter = this._createReportingButtonAnnulerFooterElement();
  var BtnSuivantFooter = this.reportingBtnSuivantFooter = this._createReportingButtonSuivantFooterElement();
  reportingPanelFooter.appendChild(BtnAnnulerFooter);
  reportingPanelFooter.appendChild(BtnSuivantFooter);
  var input = this.inputReportingContainer = this._createReportingPanelInputElement();
  this.stepContainer[0].container = input;
  var form = this.formReportingContainer = this._createReportingPanelFormElement(this.options.thematics);
  this.stepContainer[1].container = form;
  var send = this.sendReportingContainer = this._createReportingPanelSendElement();
  this.stepContainer[2].container = send;
  var draw = this.drawingReportingContainer = this._createReportingPanelDrawingElement();
  this.stepContainer[3].container = draw;
  var submit = this.buttonReportingSubmit = this._createReportingSubmitFormElement();
  form.appendChild(submit);
  var error = this.spanReportingError = this._createReportingErrorSendElement();
  send.appendChild(error);
  reportingPanelDiv.appendChild(reportingPanelHeader);
  reportingPanelDiv.appendChild(input);
  reportingPanelDiv.appendChild(form);
  reportingPanelDiv.appendChild(send);
  reportingPanelDiv.appendChild(draw);
  reportingPanelDiv.appendChild(reportingPanelFooter);
  container.appendChild(reportingPanel);
  logger49.log(container);
  return container;
};
var Reporting = _Reporting;
Object.assign(Reporting.prototype, ReportingDOM_default);
Object.assign(Reporting.prototype, Widget_default);
var Reporting_default = Reporting;
if (window.ol && window.ol.control) {
  window.ol.control.Reporting = Reporting;
}

// node_modules/geopf-extensions-openlayers/src/packages/Utils/JsonValidatorUtils.js
var import_ajv = __toESM(require_ajv());
var import_ajv_formats = __toESM(require_dist());

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/catalog.schema.json
var catalog_schema_default = {
  $id: "catalog",
  $schema: "http://json-schema.org/draft-07/schema#",
  jsdoc: "schema.jsdoc",
  title: "Generated schema for configuration service",
  type: "object",
  properties: {
    generalOptions: {
      type: "object",
      properties: {
        apiKeys: {
          type: "object",
          properties: {
            $apikey: {
              type: "array",
              items: {}
            }
          },
          required: []
        }
      },
      required: [
        "apiKeys"
      ]
    },
    layers: {
      type: "object",
      properties: {
        "$GEOPORTAIL:OGC:WMTS": {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            globalConstraint: {
              type: "object",
              properties: {
                maxScaleDenominator: {
                  type: "number"
                },
                minScaleDenominator: {
                  type: "number"
                },
                bbox: {
                  type: "object",
                  properties: {
                    left: {
                      type: "number"
                    },
                    right: {
                      type: "number"
                    },
                    top: {
                      type: "number"
                    },
                    bottom: {
                      type: "number"
                    }
                  },
                  required: [
                    "left",
                    "right",
                    "top",
                    "bottom"
                  ]
                }
              },
              required: [
                "maxScaleDenominator",
                "minScaleDenominator",
                "bbox"
              ]
            },
            serviceParams: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                version: {
                  type: "string"
                },
                serverUrl: {
                  type: "object",
                  properties: {
                    $apikey: {
                      type: "string"
                    }
                  },
                  required: [
                    "$apikey"
                  ]
                }
              },
              required: [
                "id",
                "version",
                "serverUrl"
              ]
            },
            defaultProjection: {
              type: "string"
            },
            wmtsOptions: {
              type: "object",
              properties: {
                tileMatrixSetLink: {
                  type: "string"
                },
                tileMatrixSetLimits: {
                  type: "object",
                  properties: {
                    $level: {
                      type: "object",
                      properties: {
                        minTileRow: {
                          type: "string"
                        },
                        maxTileRow: {
                          type: "string"
                        },
                        minTileCol: {
                          type: "string"
                        },
                        maxTileCol: {
                          type: "string"
                        }
                      },
                      required: [
                        "minTileRow",
                        "maxTileRow",
                        "minTileCol",
                        "maxTileCol"
                      ]
                    }
                  },
                  required: [
                    "$level"
                  ]
                }
              },
              required: [
                "tileMatrixSetLink",
                "tileMatrixSetLimits"
              ]
            },
            styles: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  title: {
                    type: "string"
                  },
                  current: {
                    type: "boolean"
                  },
                  url: {}
                },
                required: [
                  "name",
                  "title",
                  "current",
                  "url"
                ]
              }
            },
            legends: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  format: {
                    type: "string"
                  },
                  url: {
                    type: "string"
                  },
                  minScaleDenominator: {
                    type: "string"
                  }
                },
                required: [
                  "format",
                  "url",
                  "minScaleDenominator"
                ]
              }
            },
            formats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  current: {
                    type: "boolean"
                  }
                },
                required: [
                  "name",
                  "current"
                ]
              }
            }
          },
          required: [
            "name",
            "title",
            "description",
            "globalConstraint",
            "serviceParams",
            "defaultProjection",
            "wmtsOptions",
            "styles",
            "legends",
            "formats"
          ]
        },
        "$GEOPORTAIL:OGC:WMS": {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            globalConstraint: {
              type: "object",
              properties: {
                minScaleDenominator: {
                  type: "number"
                },
                maxScaleDenominator: {
                  type: "number"
                },
                bbox: {
                  type: "object",
                  properties: {
                    left: {
                      type: "number"
                    },
                    right: {
                      type: "number"
                    },
                    top: {
                      type: "number"
                    },
                    bottom: {
                      type: "number"
                    }
                  },
                  required: [
                    "left",
                    "right",
                    "top",
                    "bottom"
                  ]
                }
              },
              required: [
                "minScaleDenominator",
                "maxScaleDenominator",
                "bbox"
              ]
            },
            serviceParams: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                version: {
                  type: "string"
                },
                serverUrl: {
                  type: "object",
                  properties: {
                    $apikey: {
                      type: "string"
                    }
                  },
                  required: [
                    "$apikey"
                  ]
                }
              },
              required: [
                "id",
                "version",
                "serverUrl"
              ]
            },
            defaultProjection: {
              type: "string"
            },
            queryable: {
              type: "boolean"
            },
            metadata: {
              type: "array",
              items: {}
            },
            styles: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  title: {
                    type: "string"
                  }
                },
                required: [
                  "name",
                  "title"
                ]
              }
            },
            legends: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  format: {
                    type: "string"
                  },
                  url: {
                    type: "string"
                  }
                },
                required: [
                  "format",
                  "url"
                ]
              }
            },
            formats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  current: {
                    type: "boolean"
                  }
                },
                required: [
                  "name",
                  "current"
                ]
              }
            }
          },
          required: [
            "name",
            "title",
            "description",
            "globalConstraint",
            "serviceParams",
            "defaultProjection",
            "queryable",
            "metadata",
            "styles",
            "legends",
            "formats"
          ]
        },
        "$GEOPORTAIL:GPP:TMS": {
          type: "object",
          properties: {
            hidden: {
              type: "boolean"
            },
            queryable: {
              type: "boolean"
            },
            serviceParams: {
              type: "object",
              properties: {
                id: {
                  type: "string"
                },
                version: {
                  type: "string"
                },
                serverUrl: {
                  type: "object",
                  properties: {
                    $apikey: {
                      type: "string"
                    }
                  },
                  required: [
                    "$apikey"
                  ]
                }
              },
              required: [
                "id",
                "version",
                "serverUrl"
              ]
            },
            name: {
              type: "string"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            formats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  current: {
                    type: "boolean"
                  },
                  name: {
                    type: "string"
                  }
                },
                required: [
                  "current",
                  "name"
                ]
              }
            },
            styles: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  title: {
                    type: "string"
                  },
                  current: {
                    type: "boolean"
                  },
                  url: {
                    type: "string"
                  }
                },
                required: [
                  "name",
                  "title",
                  "current",
                  "url"
                ]
              }
            },
            globalConstraint: {
              type: "object",
              properties: {
                crs: {
                  type: "string"
                },
                bbox: {
                  type: "object",
                  properties: {
                    left: {
                      type: "number"
                    },
                    right: {
                      type: "number"
                    },
                    top: {
                      type: "number"
                    },
                    bottom: {
                      type: "number"
                    }
                  },
                  required: [
                    "left",
                    "right",
                    "top",
                    "bottom"
                  ]
                },
                minScaleDenominator: {},
                maxScaleDenominator: {}
              },
              required: [
                "crs",
                "bbox",
                "minScaleDenominator",
                "maxScaleDenominator"
              ]
            },
            layerId: {
              type: "string"
            },
            defaultProjection: {
              type: "string"
            }
          },
          required: [
            "hidden",
            "queryable",
            "serviceParams",
            "name",
            "title",
            "description",
            "formats",
            "styles",
            "globalConstraint",
            "layerId",
            "defaultProjection"
          ]
        }
      },
      required: []
    },
    tileMatrixSets: {
      type: "object",
      properties: {
        $tmsid: {
          type: "object",
          properties: {
            projection: {
              type: "string"
            },
            nativeResolutions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            tileMatrices: {
              type: "object",
              properties: {
                $level: {
                  type: "object",
                  properties: {
                    matrixId: {
                      type: "string"
                    },
                    matrixHeight: {
                      type: "number"
                    },
                    matrixWidth: {
                      type: "number"
                    },
                    scaleDenominator: {
                      type: "number"
                    },
                    tileHeight: {
                      type: "number"
                    },
                    tileWidth: {
                      type: "number"
                    },
                    topLeftCorner: {
                      type: "object",
                      properties: {
                        x: {
                          type: "number"
                        },
                        y: {
                          type: "number"
                        }
                      },
                      required: [
                        "x",
                        "y"
                      ]
                    }
                  },
                  required: [
                    "matrixId",
                    "matrixHeight",
                    "matrixWidth",
                    "scaleDenominator",
                    "tileHeight",
                    "tileWidth",
                    "topLeftCorner"
                  ]
                }
              },
              required: [
                "$level"
              ]
            }
          },
          required: [
            "projection",
            "nativeResolutions",
            "tileMatrices"
          ]
        }
      },
      required: []
    }
  },
  required: [
    "generalOptions",
    "layers",
    "tileMatrixSets"
  ]
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/territories.schema.json
var territories_schema_default = {
  $id: "territories",
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "array",
  items: {
    type: "object",
    required: ["id", "title", "description", "zoom", "thumbnail", "icon"],
    oneOf: [
      { required: ["bbox"] },
      { required: ["point"] }
    ],
    properties: {
      id: {
        type: "string",
        description: "Code du territoire"
      },
      title: {
        type: "string",
        description: "Nom affichÃ© du territoire"
      },
      description: {
        type: "string"
      },
      zoom: {
        type: ["integer", "null"],
        minimum: 0
      },
      bbox: {
        type: "array",
        minItems: 4,
        maxItems: 4,
        items: {
          type: "number"
        },
        description: "Bounding box au format [minX, minY, maxX, maxY]"
      },
      point: {
        type: "array",
        minItems: 2,
        maxItems: 2,
        items: { type: "number" },
        description: "CoordonnÃ©es"
      },
      thumbnail: {
        anyOf: [
          { type: "string", format: "uri" },
          { type: "string" }
        ]
      },
      icon: {
        anyOf: [
          { type: "string", format: "uri" },
          { type: "string" }
        ]
      }
    },
    additionalProperties: false
  }
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/layer-wmts.schema.json
var layer_wmts_schema_default = {
  $id: "layer-wmts",
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: ["name", "globalConstraint", "params"],
  properties: {
    name: { type: "string" },
    globalConstraint: {
      type: "object",
      required: ["maxScaleDenominator", "minScaleDenominator", "bbox"],
      properties: {
        maxScaleDenominator: { type: "number" },
        minScaleDenominator: { type: "number" },
        bbox: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    },
    params: {
      type: "object",
      required: ["url", "styles", "version", "format", "projection", "minScale", "maxScale", "extent", "legends", "title", "description", "tileMatrixSetLimits", "TMSLink", "matrixIds", "tileMatrices", "nativeResolutions"],
      properties: {
        url: { type: "string", format: "uri" },
        styles: { type: "string" },
        version: { type: "string" },
        format: { type: "string" },
        projection: { type: "string" },
        minScale: { type: "number" },
        maxScale: { type: "number" },
        extent: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        },
        legends: {
          type: "array",
          items: {
            type: "object",
            required: ["format", "url", "minScaleDenominator"],
            properties: {
              format: { type: "string" },
              url: { type: "string" },
              minScaleDenominator: {
                type: ["string", "number"]
              }
            },
            additionalProperties: false
          }
        },
        title: { type: "string" },
        description: { type: "string" },
        tileMatrixSetLimits: {
          type: "object",
          patternProperties: {
            "^[0-9]+$": {
              type: "object",
              required: ["minTileRow", "maxTileRow", "minTileCol", "maxTileCol"],
              properties: {
                minTileRow: { type: "string" },
                maxTileRow: { type: "string" },
                minTileCol: { type: "string" },
                maxTileCol: { type: "string" }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        },
        TMSLink: { type: "string" },
        matrixIds: {
          type: "array",
          items: { type: "string" }
        },
        tileMatrices: {
          type: "object",
          patternProperties: {
            "^[0-9]+$": {
              type: "object",
              required: ["matrixId", "matrixHeight", "matrixWidth", "scaleDenominator", "tileHeight", "tileWidth", "topLeftCorner"],
              properties: {
                matrixId: { type: "string" },
                matrixHeight: { type: "integer" },
                matrixWidth: { type: "integer" },
                scaleDenominator: { type: "number" },
                tileHeight: { type: "integer" },
                tileWidth: { type: "integer" },
                topLeftCorner: {
                  type: "object",
                  required: ["x", "y"],
                  properties: {
                    x: { type: "number" },
                    y: { type: "number" }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        },
        nativeResolutions: {
          type: "array",
          items: { type: "string" }
        }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/layer-wms.schema.json
var layer_wms_schema_default = {
  $id: "layer-wms",
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: ["name", "title", "description", "globalConstraint", "serviceParams", "defaultProjection", "queryable", "metadata", "styles", "legends", "formats", "producer", "thematic", "base", "key", "position", "opacity", "visible", "grayscale", "params"],
  properties: {
    name: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    globalConstraint: {
      type: "object",
      required: ["minScaleDenominator", "maxScaleDenominator", "bbox"],
      properties: {
        minScaleDenominator: { type: "number" },
        maxScaleDenominator: { type: "number" },
        bbox: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    },
    serviceParams: {
      type: "object",
      required: ["id", "version", "serverUrl"],
      properties: {
        id: { type: "string" },
        version: { type: "string" },
        serverUrl: {
          type: "object",
          required: ["full"],
          properties: {
            full: {
              type: "string",
              format: "uri"
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    },
    defaultProjection: { type: "string" },
    queryable: { type: "boolean" },
    metadata: {
      type: "array",
      items: {}
    },
    styles: {
      type: "array",
      items: {
        type: "object",
        required: ["name", "title"],
        properties: {
          name: { type: "string" },
          title: { type: "string" }
        },
        additionalProperties: false
      }
    },
    legends: {
      type: "array",
      items: {
        type: "object",
        required: ["format", "url"],
        properties: {
          format: { type: "string" },
          url: {
            type: "string",
            format: "uri"
          }
        },
        additionalProperties: false
      }
    },
    formats: {
      type: "array",
      items: {
        type: "object",
        required: ["name", "current"],
        properties: {
          name: { type: "string" },
          current: { type: "boolean" }
        },
        additionalProperties: false
      }
    },
    producer: {
      type: "array",
      items: { type: "string" }
    },
    thematic: {
      type: "array",
      items: { type: "string" }
    },
    base: { type: "boolean" },
    key: { type: "string" },
    position: { type: "integer" },
    opacity: { type: "number" },
    visible: { type: "boolean" },
    grayscale: { type: "boolean" },
    params: {
      type: "object",
      required: ["url", "styles", "version", "format", "projection", "minScale", "maxScale", "extent", "legends", "title", "description"],
      properties: {
        url: {
          type: "string",
          format: "uri"
        },
        styles: { type: "string" },
        version: { type: "string" },
        format: { type: "string" },
        projection: { type: "string" },
        minScale: { type: "number" },
        maxScale: { type: "number" },
        extent: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        },
        legends: {
          type: "array",
          items: {
            type: "object",
            required: ["format", "url"],
            properties: {
              format: { type: "string" },
              url: {
                type: "string",
                format: "uri"
              }
            },
            additionalProperties: false
          }
        },
        title: { type: "string" },
        description: { type: "string" }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/layer-wfs.schema.json
var layer_wfs_schema_default = {
  $id: "layer-wfs",
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object"
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/schemas/layer-tms.schema.json
var layer_tms_schema_default = {
  $id: "layer-tms",
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: ["name", "title", "description", "params", "formats", "styles", "globalConstraint"],
  properties: {
    hidden: { type: "boolean" },
    queryable: { type: "boolean" },
    serviceParams: {
      type: "object",
      required: ["id", "version", "serverUrl"],
      properties: {
        id: { type: "string" },
        version: { type: "string" },
        serverUrl: {
          type: "object",
          required: ["full"],
          properties: {
            full: { type: "string", format: "uri" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    },
    name: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    formats: {
      type: "array",
      items: {
        type: "object",
        required: ["name", "current"],
        properties: {
          name: { type: "string" },
          current: { type: "boolean" }
        },
        additionalProperties: false
      }
    },
    styles: {
      type: "array",
      items: {
        type: "object",
        required: ["name", "title", "url"],
        properties: {
          name: { type: "string" },
          title: { type: "string" },
          current: { type: "boolean" },
          url: { type: "string", format: "uri" }
        },
        additionalProperties: false
      }
    },
    globalConstraint: {
      type: "object",
      required: ["crs", "bbox", "minScaleDenominator", "maxScaleDenominator"],
      properties: {
        crs: { type: "string" },
        bbox: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        },
        minScaleDenominator: { type: "number" },
        maxScaleDenominator: { type: "number" }
      },
      additionalProperties: false
    },
    defaultProjection: { type: "string" },
    thematic: {
      type: "array",
      items: { type: "string" }
    },
    base: { type: "boolean" },
    producer: {
      type: "array",
      items: { type: "string" }
    },
    key: { type: "string" },
    position: { type: "integer" },
    opacity: { type: "number" },
    visible: { type: "boolean" },
    grayscale: { type: "boolean" },
    params: {
      type: "object",
      required: ["url", "styles", "version", "format", "projection", "minScale", "maxScale", "extent", "title", "description"],
      properties: {
        url: { type: "string", format: "uri" },
        styles: { type: "string" },
        version: { type: "string" },
        format: { type: "string" },
        projection: { type: "string" },
        minScale: { type: "number" },
        maxScale: { type: "number" },
        extent: {
          type: "object",
          required: ["left", "right", "top", "bottom"],
          properties: {
            left: { type: "number" },
            right: { type: "number" },
            top: { type: "number" },
            bottom: { type: "number" }
          },
          additionalProperties: false
        },
        title: { type: "string" },
        description: { type: "string" }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};

// node_modules/geopf-extensions-openlayers/src/packages/Utils/JsonValidatorUtils.js
var JsonValidatorUtils = class {
  constructor() {
    this.ajv = new import_ajv.default({ strict: false, allErrors: true });
    (0, import_ajv_formats.default)(this.ajv, { mode: "fast", formats: ["uri"], keywords: true });
    this.schemas = {};
    this.loadSchemas();
  }
  loadSchemas() {
    this.ajv.addSchema(catalog_schema_default, catalog_schema_default.$id);
    this.schemas[catalog_schema_default.$id] = catalog_schema_default;
    this.ajv.addSchema(territories_schema_default, territories_schema_default.$id);
    this.schemas[territories_schema_default.$id] = territories_schema_default;
    this.ajv.addSchema(layer_wmts_schema_default, layer_wmts_schema_default.$id);
    this.schemas[layer_wmts_schema_default.$id] = layer_wmts_schema_default;
    this.ajv.addSchema(layer_wms_schema_default, layer_wms_schema_default.$id);
    this.schemas[layer_wms_schema_default.$id] = layer_wms_schema_default;
    this.ajv.addSchema(layer_wfs_schema_default, layer_wfs_schema_default.$id);
    this.schemas[layer_wfs_schema_default.$id] = layer_wfs_schema_default;
    this.ajv.addSchema(layer_tms_schema_default, layer_tms_schema_default.$id);
    this.schemas[layer_tms_schema_default.$id] = layer_tms_schema_default;
  }
  validate(type, data) {
    if (!this.schemas[type]) {
      throw new Error(`Aucun schÃ©ma trouvÃ© pour le type "${type}"`);
    }
    const validate = this.ajv.getSchema(type);
    const valid = validate(data);
    if (!valid) {
      return {
        valid: false,
        errors: validate.errors
      };
    }
    return { valid: true };
  }
};
var JsonValidatorUtils_default = JsonValidatorUtils;
if (window.Gp) {
  window.Gp.JsonValidatorUtils = JsonValidatorUtils;
}

// node_modules/geopf-extensions-openlayers/src/index.js
var version2 = package_default.version;
var date = package_default.date;
export {
  Export_default as ButtonExport,
  CRS_default as CRS,
  Catalog_default as Catalog,
  ColorUtils_default as ColorUtils,
  ContextMenu_default as ContextMenu,
  ControlList_default as ControlList,
  Drawing_default as Drawing,
  Editor_default as Editor,
  Filter_default as EditorFilter,
  Group_default as EditorGroup,
  Layer_default2 as EditorLayer,
  Legend_default as EditorLegend,
  Search_default2 as EditorSearch,
  Style_default2 as EditorStyle,
  Themes_default as EditorThemes,
  ElevationPath_default as ElevationPath,
  GPX_default2 as GPX,
  GeoJSON_default2 as GeoJSON,
  GeoportalAttribution_default as GeoportalAttribution,
  GeoportalFullScreen_default as GeoportalFullScreen,
  GeoportalOverviewMap_default as GeoportalOverviewMap,
  GeoportalZoom_default as GeoportalZoom,
  GetFeatureInfo_default as GetFeatureInfo,
  Gfi_default as GfiUtils,
  Helper_default2 as HelperUtils,
  Interactions_default as InteractionsUtils,
  Isocurve_default as Isocurve,
  JsonValidatorUtils_default as JsonValidatorUtils,
  KML_default2 as KML,
  LayerImport_default as LayerImport,
  LayerMapBox_default as LayerMapBox,
  LayerSwitcher_default as LayerSwitcher,
  LayerUtils_default as LayerUtils,
  LayerWFS_default as LayerWFS,
  LayerWMS_default as LayerWMS,
  LayerWMTS_default as LayerWMTS,
  Legends_default as Legends,
  LocationSelector_default as LocationSelector,
  LoggerByDefault_default2 as LoggerUtils,
  Markers_default as Markers,
  Markers_default as MarkersUtils,
  MathUtils_default as MathUtils,
  MeasureArea_default as MeasureArea,
  MeasureAzimuth_default as MeasureAzimuth,
  MeasureLength_default as MeasureLength,
  MousePosition_default as MousePosition,
  lib_default as Proj4,
  ProxyUtils_default as ProxyUtils,
  Reporting_default as Reporting,
  ReverseGeocode_default2 as ReverseGeocode,
  Route_default2 as Route,
  SearchEngine_default as SearchEngine,
  SourceWFS_default as SourceWFS,
  SourceWMS_default as SourceWMS,
  SourceWMTS_default as SourceWMTS,
  Territories_default2 as Territories,
  WMTS_default3 as WMTS,
  date,
  version2 as version
};
/*! Bundled license information:

es6-promise/dist/es6-promise.js:
  (*!
   * @overview es6-promise - a tiny implementation of Promises/A+.
   * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
   * @license   Licensed under MIT license
   *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
   * @version   v4.2.8+1e68dce6
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.3
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

ol-contextmenu/dist/ol-contextmenu.js:
  (*!
  * ol-contextmenu - v5.5.0
  * https://github.com/jonataswalker/ol-contextmenu
  * Built: Wed Aug 07 2024 12:29:18 GMT+0000 (Coordinated Universal Time)
  *)
*/
//# sourceMappingURL=geopf-extensions-openlayers.js.map
