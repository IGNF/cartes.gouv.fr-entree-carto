{
  "version": 3,
  "sources": ["webpack://OAuth2Client/webpack/universalModuleDefinition", "webpack://OAuth2Client/src/client.ts", "webpack://OAuth2Client/src/client/authorization-code.ts", "webpack://OAuth2Client/src/error.ts", "webpack://OAuth2Client/src/fetch-wrapper.ts", "webpack://OAuth2Client/webpack/bootstrap", "webpack://OAuth2Client/src/index.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OAuth2Client\"] = factory();\n\telse\n\t\troot[\"OAuth2Client\"] = factory();\n})(self, () => {\nreturn ", "import { OAuth2Token } from './token';\nimport {\n  AuthorizationCodeRequest,\n  ClientCredentialsRequest,\n  IntrospectionRequest,\n  IntrospectionResponse,\n  PasswordRequest,\n  OAuth2TokenTypeHint,\n  RefreshRequest,\n  RevocationRequest,\n  ServerMetadataResponse,\n  TokenResponse,\n} from './messages';\nimport { OAuth2HttpError } from './error';\nimport { OAuth2AuthorizationCodeClient } from './client/authorization-code';\n\n\ntype ClientCredentialsParams = {\n  scope?: string[];\n  extraParams?: Record<string, string>;\n\n  /**\n   * The resource  the client intends to access.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8707\n   */\n  resource?: string | string[];\n}\n\ntype PasswordParams = {\n  username: string;\n  password: string;\n\n  scope?: string[];\n\n  /**\n   * The resource  the client intends to access.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8707\n   */\n  resource?: string | string[];\n\n}\n\n/**\n * Extra options that may be passed to refresh()\n */\ntype RefreshParams = {\n  scope?: string[];\n\n  /**\n   * The resource  the client intends to access.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8707\n   */\n  resource?: string | string[];\n\n}\n\nexport interface ClientSettings {\n\n  /**\n   * The hostname of the OAuth2 server.\n   * If provided, we'll attempt to discover all the other related endpoints.\n   *\n   * If this is not desired, just specify the other endpoints manually.\n   *\n   * This url will also be used as the base URL for all other urls. This lets\n   * you specify all the other urls as relative.\n   */\n  server?: string;\n\n  /**\n   * OAuth2 clientId\n   */\n  clientId: string;\n\n  /**\n   * OAuth2 clientSecret\n   *\n   * This is required when using the 'client_secret_basic' authenticationMethod\n   * for the client_credentials and password flows, but not authorization_code\n   * or implicit.\n   */\n  clientSecret?: string;\n\n  /**\n   * The /authorize endpoint.\n   *\n   * Required only for the browser-portion of the authorization_code flow.\n   */\n  authorizationEndpoint?: string;\n\n  /**\n   * The token endpoint.\n   *\n   * Required for most grant types and refreshing tokens.\n   */\n  tokenEndpoint?: string;\n\n  /**\n   * Introspection endpoint.\n   *\n   * Required for, well, introspecting tokens.\n   * If not provided we'll try to discover it, or otherwise default to /introspect\n   */\n  introspectionEndpoint?: string;\n\n  /**\n   * Revocation endpoint.\n   *\n   * Required for revoking tokens. Not supported by all servers.\n   * If not provided we'll try to discover it, or otherwise default to /revoke\n   */\n  revocationEndpoint?: string;\n\n  /**\n   * OAuth 2.0 Authorization Server Metadata endpoint or OpenID\n   * Connect Discovery 1.0 endpoint.\n   *\n   * If this endpoint is provided it can be used to automatically figure\n   * out all the other endpoints.\n   *\n   * Usually the URL for this is: https://server/.well-known/oauth-authorization-server\n   */\n  discoveryEndpoint?: string;\n\n  /**\n   * Fetch implementation to use.\n   *\n   * Set this if you wish to explicitly set the fetch implementation, e.g. to\n   * implement middlewares or set custom headers.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * Client authentication method that is used to authenticate\n   * when using the token endpoint.\n   *\n   * Can be one of 'client_secret_basic' | 'client_secret_post'.\n   *\n   * The default value is 'client_secret_basic' if not provided.\n   */\n  authenticationMethod?: string;\n}\n\n\ntype OAuth2Endpoint = 'tokenEndpoint' | 'authorizationEndpoint' | 'discoveryEndpoint' | 'introspectionEndpoint' | 'revocationEndpoint';\n\nexport class OAuth2Client {\n\n  settings: ClientSettings;\n\n  constructor(clientSettings: ClientSettings) {\n\n    if (!clientSettings?.fetch) {\n      clientSettings.fetch = fetch.bind(globalThis);\n    }\n    this.settings = clientSettings;\n\n  }\n\n  /**\n   * Refreshes an existing token, and returns a new one.\n   */\n  async refreshToken(token: OAuth2Token, params?: RefreshParams): Promise<OAuth2Token> {\n\n    if (!token.refreshToken) {\n      throw new Error('This token didn\\'t have a refreshToken. It\\'s not possible to refresh this');\n    }\n\n    const body: RefreshRequest = {\n      grant_type: 'refresh_token',\n      refresh_token: token.refreshToken,\n    };\n    if (!this.settings.clientSecret) {\n      // If there's no secret, send the clientId in the body.\n      body.client_id = this.settings.clientId;\n    }\n\n    if (params?.scope) body.scope = params.scope.join(' ');\n    if (params?.resource) body.resource = params.resource;\n\n    const newToken = await this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n    if (!newToken.refreshToken && token.refreshToken) {\n      // Reuse old refresh token if we didn't get a new one.\n      newToken.refreshToken = token.refreshToken;\n    }\n    return newToken;\n\n  }\n\n  /**\n   * Retrieves an OAuth2 token using the client_credentials grant.\n   */\n  async clientCredentials(params?: ClientCredentialsParams): Promise<OAuth2Token> {\n\n    const disallowed = ['client_id', 'client_secret', 'grant_type', 'scope'];\n\n    if (params?.extraParams && Object.keys(params.extraParams).filter((key) => disallowed.includes(key)).length > 0) {\n      throw new Error(`The following extraParams are disallowed: '${disallowed.join(\"', '\")}'`);\n    }\n\n    const body: ClientCredentialsRequest = {\n      grant_type: 'client_credentials',\n      scope: params?.scope?.join(' '),\n      resource: params?.resource,\n      ...params?.extraParams\n    };\n\n    if (!this.settings.clientSecret) {\n      throw new Error('A clientSecret must be provided to use client_credentials');\n    }\n\n    return this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n\n  }\n\n  /**\n   * Retrieves an OAuth2 token using the 'password' grant'.\n   */\n  async password(params: PasswordParams): Promise<OAuth2Token> {\n\n    const body: PasswordRequest = {\n      grant_type: 'password',\n      ...params,\n      scope: params.scope?.join(' '),\n    };\n    return this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n\n  }\n\n  /**\n   * Returns the helper object for the `authorization_code` grant.\n   */\n  get authorizationCode(): OAuth2AuthorizationCodeClient {\n\n    return new OAuth2AuthorizationCodeClient(\n      this,\n    );\n\n  }\n\n  /**\n   * Introspect a token\n   *\n   * This will give information about the validity, owner, which client\n   * created the token and more.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7662\n   */\n  async introspect(token: OAuth2Token): Promise<IntrospectionResponse> {\n\n    const body: IntrospectionRequest = {\n      token: token.accessToken,\n      token_type_hint: 'access_token',\n    };\n    return this.request('introspectionEndpoint', body);\n\n  }\n\n  /**\n   * Revoke a token\n   *\n   * This will revoke a token, provided that the server supports this feature.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009\n   */\n  async revoke(token: OAuth2Token, tokenTypeHint: OAuth2TokenTypeHint = 'access_token'): Promise<void> {\n    let tokenValue = token.accessToken;\n    if (tokenTypeHint === 'refresh_token') {\n      tokenValue = token.refreshToken!;\n    }\n\n    const body: RevocationRequest = {\n      token: tokenValue,\n      token_type_hint: tokenTypeHint,\n    };\n    return this.request('revocationEndpoint', body);\n\n  }\n\n  /**\n   * Returns a url for an OAuth2 endpoint.\n   *\n   * Potentially fetches a discovery document to get it.\n   */\n  async getEndpoint(endpoint: OAuth2Endpoint): Promise<string> {\n\n    if (this.settings[endpoint] !== undefined) {\n      return resolve(this.settings[endpoint] as string, this.settings.server);\n    }\n\n    if (endpoint !== 'discoveryEndpoint') {\n      // This condition prevents infinite loops.\n      await this.discover();\n      if (this.settings[endpoint] !== undefined) {\n        return resolve(this.settings[endpoint] as string, this.settings.server);\n      }\n    }\n\n    // If we got here it means we need to 'guess' the endpoint.\n    if (!this.settings.server) {\n      throw new Error(`Could not determine the location of ${endpoint}. Either specify ${endpoint} in the settings, or the \"server\" endpoint to let the client discover it.`);\n    }\n\n    switch (endpoint) {\n      case 'authorizationEndpoint':\n        return resolve('/authorize', this.settings.server);\n      case 'tokenEndpoint':\n        return resolve('/token', this.settings.server);\n      case 'discoveryEndpoint':\n        return resolve('/.well-known/oauth-authorization-server', this.settings.server);\n      case 'introspectionEndpoint':\n        return resolve('/introspect', this.settings.server);\n      case 'revocationEndpoint':\n        return resolve('/revoke', this.settings.server);\n    }\n\n  }\n\n  private discoveryDone = false;\n  private serverMetadata: ServerMetadataResponse | null = null;\n\n\n  /**\n   * Fetches the OAuth2 discovery document\n   */\n  private async discover(): Promise<void> {\n\n    // Never discover twice\n    if (this.discoveryDone) return;\n    this.discoveryDone = true;\n\n    let discoverUrl;\n    try {\n      discoverUrl = await this.getEndpoint('discoveryEndpoint');\n    } catch (err) {\n      console.warn('[oauth2] OAuth2 discovery endpoint could not be determined. Either specify the \"server\" or \"discoveryEndpoint');\n      return;\n    }\n    const resp = await this.settings.fetch!(discoverUrl, { headers: { Accept: 'application/json' }});\n\n    if (!resp.ok) return;\n    if (!resp.headers.get('Content-Type')?.startsWith('application/json')) {\n      console.warn('[oauth2] OAuth2 discovery endpoint was not a JSON response. Response is ignored');\n      return;\n    }\n    this.serverMetadata = await resp.json();\n\n    const urlMap = [\n      ['authorization_endpoint', 'authorizationEndpoint'],\n      ['token_endpoint', 'tokenEndpoint'],\n      ['introspection_endpoint', 'introspectionEndpoint'],\n      ['revocation_endpoint', 'revocationEndpoint'],\n    ] as const;\n\n    if (this.serverMetadata === null) return;\n\n    for (const [property, setting] of urlMap) {\n      if (!this.serverMetadata[property]) continue;\n      this.settings[setting] = resolve(this.serverMetadata[property]!, discoverUrl);\n    }\n\n    if (this.serverMetadata.token_endpoint_auth_methods_supported && !this.settings.authenticationMethod) {\n      this.settings.authenticationMethod = this.serverMetadata.token_endpoint_auth_methods_supported[0];\n    }\n\n  }\n\n  /**\n   * Does a HTTP request on the 'token' endpoint.\n   */\n  async request(endpoint: 'tokenEndpoint', body: RefreshRequest | ClientCredentialsRequest | PasswordRequest | AuthorizationCodeRequest): Promise<TokenResponse>;\n  async request(endpoint: 'introspectionEndpoint', body: IntrospectionRequest): Promise<IntrospectionResponse>;\n  async request(endpoint: 'revocationEndpoint', body: RevocationRequest): Promise<void>;\n  async request(endpoint: OAuth2Endpoint, body: Record<string, any>): Promise<unknown> {\n\n    const uri = await this.getEndpoint(endpoint);\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      // Although it shouldn't be needed, Github OAUth2 will return JSON\n      // unless this is set.\n      'Accept': 'application/json',\n    };\n\n    let authMethod = this.settings.authenticationMethod;\n\n    if (!this.settings.clientSecret) {\n      // Basic auth should only be used when there's a client_secret, for\n      // non-confidential clients we may only have a client_id, which\n      // always gets added to the body.\n      authMethod = 'client_secret_post';\n    }\n    if (!authMethod) {\n      // If we got here, it means no preference was provided by anything,\n      // and we have a secret. In this case its preferred to embed\n      // authentication in the Authorization header.\n      authMethod = 'client_secret_basic';\n    }\n\n    switch(authMethod) {\n      case 'client_secret_basic' :\n        headers.Authorization = 'Basic ' +\n          btoa(this.settings.clientId + ':' + this.settings.clientSecret);\n        break;\n      case 'client_secret_post' :\n        body.client_id = this.settings.clientId;\n        if (this.settings.clientSecret) {\n          body.client_secret = this.settings.clientSecret;\n        }\n        break;\n      default:\n        throw new Error('Authentication method not yet supported:' + authMethod + '. Open a feature request if you want this!');\n    }\n\n    const resp = await this.settings.fetch!(uri, {\n      method: 'POST',\n      body: generateQueryString(body),\n      headers,\n    });\n\n    let responseBody;\n    if (resp.status !== 204 && resp.headers.has('Content-Type') && resp.headers.get('Content-Type')!.match(/^application\\/(.*\\+)?json/)) {\n      responseBody = await resp.json();\n    }\n    if (resp.ok) {\n      return responseBody;\n    }\n\n    let errorMessage;\n    let oauth2Code;\n\n    if (responseBody?.error) {\n      // This is likely an OAUth2-formatted error\n      errorMessage = 'OAuth2 error ' + responseBody.error + '.';\n      if (responseBody.error_description) {\n        errorMessage += ' ' + responseBody.error_description;\n      }\n      oauth2Code = responseBody.error;\n\n    } else {\n      errorMessage = 'HTTP Error ' + resp.status + ' ' + resp.statusText;\n      if (resp.status === 401 && this.settings.clientSecret) {\n        errorMessage += '. It\\'s likely that the clientId and/or clientSecret was incorrect';\n      }\n      oauth2Code = null;\n    }\n    throw new OAuth2HttpError(errorMessage, oauth2Code, resp, responseBody);\n  }\n\n  /**\n   * Converts the JSON response body from the token endpoint to an OAuth2Token type.\n   */\n  async tokenResponseToOAuth2Token(resp: Promise<TokenResponse>): Promise<OAuth2Token> {\n\n    const body = await resp;\n\n    if (!body?.access_token) {\n      console.warn('Invalid OAuth2 Token Response: ', body);\n      throw new TypeError('We received an invalid token response from an OAuth2 server.');\n    }\n\n    return {\n      accessToken: body.access_token,\n      expiresAt: body.expires_in ? Date.now() + (body.expires_in * 1000) : null,\n      refreshToken: body.refresh_token ?? null,\n    };\n\n  }\n\n}\n\nfunction resolve(uri: string, base?: string): string {\n\n  return new URL(uri, base).toString();\n\n}\n\n/**\n * Generates a query string.\n *\n * This function filters out any undefined values.\n */\nexport function generateQueryString(params: Record<string, undefined | number | string | string[]>): string {\n\n  const query = new URLSearchParams();\n  for (const [k, v] of Object.entries(params)) {\n    if (Array.isArray(v)) {\n      for(const vItem of v) query.append(k, vItem);\n    } else if (v !== undefined) query.set(k, v.toString());\n  }\n  return query.toString();\n\n}\n", "import { OAuth2Client } from '../client';\nimport { OAuth2Token } from '../token';\nimport { AuthorizationCodeRequest } from '../messages';\nimport { OAuth2Error } from '../error';\n\ntype GetAuthorizeUrlParams = {\n  /**\n   * Where to redirect the user back to after authentication.\n   */\n  redirectUri: string;\n\n  /**\n   * The 'state' is a string that can be sent to the authentication server,\n   * and back to the redirectUri.\n   */\n  state?: string;\n\n  /**\n   * Code verifier for PKCE support. If you used this in the redirect\n   * to the authorization endpoint, you also need to use this again\n   * when getting the access_token on the token endpoint.\n   */\n  codeVerifier?: string;\n\n  /**\n   * List of scopes.\n   */\n  scope?: string[];\n\n  /**\n   * The resource the client intends to access.\n   *\n   * This is defined in RFC 8707.\n   */\n  resource?: string[] | string;\n\n  /**\n   * Any parameters listed here will be added to the query string for the authorization server endpoint.\n   */\n  extraParams?: Record<string, string>;\n\n  /**\n   * By default response parameters for the authorization_flow will be added\n   * to the query string.\n   *\n   * Some servers let you put this in the fragment instead. This may be\n   * benefical if your client is a browser, as embedding the authorization\n   * code in the fragment part of the URI prevents it from being sent back\n   * to the server.\n   *\n   * See: https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html\n   */\n  responseMode?: 'query' | 'fragment';\n}\n\ntype ValidateResponseResult = {\n\n  /**\n   * The authorization code. This code should be used to obtain an access token.\n   */\n  code: string;\n\n  /**\n   * List of scopes that the client requested.\n   */\n  scope?: string[];\n\n}\n\ntype GetTokenParams = {\n\n  code: string;\n\n  redirectUri: string;\n  state?: string;\n  codeVerifier?:string;\n\n  /**\n   * The resource the client intends to access.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8707\n   */\n  resource?: string[] | string;\n\n}\n\nexport class OAuth2AuthorizationCodeClient {\n\n  client: OAuth2Client;\n\n  constructor(client: OAuth2Client) {\n\n    this.client = client;\n\n  }\n\n  /**\n   * Returns the URi that the user should open in a browser to initiate the\n   * authorization_code flow.\n   */\n  async getAuthorizeUri(params: GetAuthorizeUrlParams): Promise<string> {\n\n    const [\n      codeChallenge,\n      authorizationEndpoint\n    ] = await Promise.all([\n      params.codeVerifier ? getCodeChallenge(params.codeVerifier) : undefined,\n      this.client.getEndpoint('authorizationEndpoint')\n    ]);\n\n    const query = new URLSearchParams({\n      client_id: this.client.settings.clientId,\n      response_type: 'code',\n      redirect_uri: params.redirectUri,\n    });\n    if (codeChallenge) {\n      query.set('code_challenge_method', codeChallenge[0]);\n      query.set('code_challenge', codeChallenge[1]);\n    }\n    if (params.state) {\n      query.set('state', params.state);\n    }\n    if (params.scope) {\n      query.set('scope', params.scope.join(' '));\n    }\n\n    if (params.resource) for(const resource of [].concat(params.resource as any)) {\n      query.append('resource', resource);\n    }\n\n    if (params.responseMode && params.responseMode!=='query') {\n      query.append('response_mode', params.responseMode);\n    }\n\n    if (params.extraParams) for(const [k,v] of Object.entries(params.extraParams)) {\n      if (query.has(k)) throw new Error(`Property in extraParams would overwrite standard property: ${k}`);\n      query.set(k, v);\n    }\n\n    return authorizationEndpoint + '?' + query.toString();\n\n  }\n\n  async getTokenFromCodeRedirect(url: string|URL, params: Omit<GetTokenParams, 'code'> ): Promise<OAuth2Token> {\n\n    const { code } = this.validateResponse(url, {\n      state: params.state\n    });\n\n    return this.getToken({\n      code,\n      redirectUri: params.redirectUri,\n      codeVerifier: params.codeVerifier,\n    });\n\n  }\n\n  /**\n   * After the user redirected back from the authorization endpoint, the\n   * url will contain a 'code' and other information.\n   *\n   * This function takes the url and validate the response. If the user\n   * redirected back with an error, an error will be thrown.\n   */\n  validateResponse(url: string|URL, params: {state?: string}): ValidateResponseResult {\n\n    url = new URL(url);\n    let queryParams = url.searchParams;\n    if (!queryParams.has('code') && !queryParams.has('error') && url.hash.length>0) {\n      // Try the fragment\n      queryParams = new URLSearchParams(url.hash.slice(1));\n    }\n\n    if (queryParams.has('error')) {\n      throw new OAuth2Error(\n        queryParams.get('error_description') ?? 'OAuth2 error',\n        queryParams.get('error') as any,\n      );\n    }\n\n    if (!queryParams.has('code')) throw new Error(`The url did not contain a code parameter ${url}`);\n\n    if (params.state && params.state !== queryParams.get('state')) {\n      throw new Error(`The \"state\" parameter in the url did not match the expected value of ${params.state}`);\n    }\n\n    return {\n      code: queryParams.get('code')!,\n      scope: queryParams.has('scope') ? queryParams.get('scope')!.split(' ') : undefined,\n    };\n\n  }\n\n\n  /**\n   * Receives an OAuth2 token using 'authorization_code' grant\n   */\n  async getToken(params: GetTokenParams): Promise<OAuth2Token> {\n\n    const body:AuthorizationCodeRequest = {\n      grant_type: 'authorization_code',\n      code: params.code,\n      redirect_uri: params.redirectUri,\n      code_verifier: params.codeVerifier,\n      resource: params.resource,\n    };\n    return this.client.tokenResponseToOAuth2Token(this.client.request('tokenEndpoint', body));\n\n  }\n\n\n}\n\nexport async function generateCodeVerifier(): Promise<string> {\n\n  const webCrypto = getWebCrypto();\n  if (webCrypto) {\n    const arr = new Uint8Array(32);\n    webCrypto.getRandomValues(arr);\n    return base64Url(arr);\n  } else {\n\n    // Old node doesn't have 'webcrypto', so this is a fallback\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const nodeCrypto = require('crypto');\n    return new Promise<string>((res, rej) => {\n      nodeCrypto.randomBytes(32, (err:Error, buf: Buffer) => {\n        if (err) rej(err);\n        res(buf.toString('base64url'));\n      });\n    });\n\n  }\n\n}\n\nexport async function getCodeChallenge(codeVerifier: string): Promise<['plain' | 'S256', string]> {\n\n  const webCrypto = getWebCrypto();\n  if (webCrypto?.subtle) {\n    return ['S256', base64Url(await webCrypto.subtle.digest('SHA-256', stringToBuffer(codeVerifier)))];\n  } else {\n    // Node 14.x fallback\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const nodeCrypto = require('crypto');\n    const hash = nodeCrypto.createHash('sha256');\n    hash.update(stringToBuffer(codeVerifier));\n    return ['S256', hash.digest('base64url')];\n  }\n\n}\n\nfunction getWebCrypto() {\n\n  // Browsers\n  if ((typeof window !== 'undefined' && window.crypto)) {\n    return window.crypto;\n  }\n  // Web workers possibly\n  if ((typeof self !== 'undefined' && self.crypto)) {\n    return self.crypto;\n  }\n  // Node\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const crypto = require('crypto');\n  if (crypto.webcrypto) {\n    return crypto.webcrypto;\n  }\n  return null;\n\n}\n\nfunction stringToBuffer(input: string): ArrayBuffer {\n\n  const buf = new Uint8Array(input.length);\n  for(let i=0; i<input.length;i++) {\n    buf[i] = input.charCodeAt(i) & 0xFF;\n  }\n  return buf;\n\n}\n\nfunction base64Url(buf: ArrayBuffer) {\n  return (\n    btoa(String.fromCharCode(...new Uint8Array(buf)))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/, '')\n  );\n}\n\n", "import { OAuth2ErrorCode } from './messages';\n\n/**\n * An error class for any error the server emits.\n *\n * The 'oauth2Code' property will have the oauth2 error type,\n * such as:\n * - invalid_request\n * - invalid_client\n * - invalid_grant\n * - unauthorized_client\n * - unsupported_grant_type\n * - invalid_scope\n */\nexport class OAuth2Error extends Error {\n\n  oauth2Code: OAuth2ErrorCode|string;\n\n  constructor(message: OAuth2ErrorCode|string, oauth2Code: OAuth2ErrorCode) {\n\n    super(message);\n    this.oauth2Code = oauth2Code;\n\n  }\n\n}\n\n/**\n * A OAuth2 error that was emitted as a HTTP error\n *\n * The 'code' property will have the oauth2 error type,\n * such as:\n * - invalid_request\n * - invalid_client\n * - invalid_grant\n * - unauthorized_client\n * - unsupported_grant_type\n * - invalid_scope\n *\n * This Error also gives you access to the HTTP status code and response body.\n */\nexport class OAuth2HttpError extends OAuth2Error {\n\n  httpCode: number;\n\n  response: Response;\n  parsedBody: Record<string, any>;\n\n  constructor(message: string, oauth2Code: OAuth2ErrorCode, response: Response, parsedBody: Record<string, any>) {\n\n    super(message, oauth2Code);\n\n    this.httpCode = response.status;\n    this.response = response;\n    this.parsedBody = parsedBody;\n\n  }\n\n}\n", "import { OAuth2Token } from './token';\nimport { OAuth2Client } from './client';\n\ntype FetchMiddleware = (request: Request, next: (request: Request) => Promise<Response>) => Promise<Response>;\n\ntype OAuth2FetchOptions = {\n\n  /**\n   * Reference to OAuth2 client.\n   */\n  client: OAuth2Client;\n\n  /**\n   * You are responsible for implementing this function.\n   * it's purpose is to supply the 'initial' oauth2 token.\n   *\n   * This function may be async. Return `null` to fail the process.\n   */\n  getNewToken(): OAuth2Token | null | Promise<OAuth2Token | null>;\n\n  /**\n   * If set, will be called if authentication fatally failed.\n   */\n  onError?: (err: Error) => void;\n\n  /**\n   * This function is called whenever the active token changes. Using this is\n   * optional, but it may be used to (for example) put the token in off-line\n   * storage for later usage.\n   */\n  storeToken?: (token: OAuth2Token) => void;\n\n  /**\n   * Also an optional feature. Implement this if you want the wrapper to try a\n   * stored token before attempting a full re-authentication.\n   *\n   * This function may be async. Return null if there was no token.\n   */\n  getStoredToken?: () => OAuth2Token | null | Promise<OAuth2Token | null>;\n\n  /**\n   * Whether to automatically schedule token refresh.\n   *\n   * Certain execution environments, e.g. React Native, do not handle scheduled\n   * tasks with setTimeout() in a graceful or predictable fashion. The default\n   * behavior is to schedule refresh. Set this to false to disable scheduling.\n   */\n  scheduleRefresh?: boolean;\n\n}\n\nexport class OAuth2Fetch {\n\n  private options: OAuth2FetchOptions;\n\n  /**\n   * Current active token (if any)\n   */\n  private token: OAuth2Token | null = null;\n\n  /**\n   * If the user had a storedToken, the process to fetch it\n   * may be async. We keep track of this process in this\n   * promise, so it may be awaited to avoid race conditions.\n   *\n   * As soon as this promise resolves, this property gets nulled.\n   */\n  private activeGetStoredToken: null | Promise<void> = null;\n\n  constructor(options: OAuth2FetchOptions) {\n\n    if (options?.scheduleRefresh === undefined) {\n      options.scheduleRefresh = true;\n    }\n    this.options = options;\n    if (options.getStoredToken) {\n      this.activeGetStoredToken = (async () => {\n        this.token = await options.getStoredToken!();\n        this.activeGetStoredToken = null;\n      })();\n    }\n    this.scheduleRefresh();\n\n  }\n\n  /**\n   * Does a fetch request and adds a Bearer / access token.\n   *\n   * If the access token is not known, this function attempts to fetch it\n   * first. If the access token is almost expiring, this function might attempt\n   * to refresh it.\n   */\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n\n    // input might be a string or a Request object, we want to make sure this\n    // is always a fully-formed Request object.\n    const request = new Request(input, init);\n\n    return this.mw()(\n      request,\n      req => fetch(req)\n    );\n\n  }\n\n  /**\n   * This function allows the fetch-mw to be called as more traditional\n   * middleware.\n   *\n   * This function returns a middleware function with the signature\n   *    (request, next): Response\n   */\n  mw(): FetchMiddleware {\n\n    return async (request, next) => {\n\n      const accessToken = await this.getAccessToken();\n\n      // Make a clone. We need to clone if we need to retry the request later.\n      let authenticatedRequest = request.clone();\n      authenticatedRequest.headers.set('Authorization', 'Bearer '  + accessToken);\n      let response = await next(authenticatedRequest);\n\n      if (!response.ok && response.status === 401) {\n\n        const newToken = await this.refreshToken();\n\n        authenticatedRequest = request.clone();\n        authenticatedRequest.headers.set('Authorization', 'Bearer '  + newToken.accessToken);\n        response = await next(authenticatedRequest);\n\n      }\n      return response;\n    };\n\n  }\n\n  /**\n   * Returns current token information.\n   *\n   * There result object will have:\n   *   * accessToken\n   *   * expiresAt - when the token expires, or null.\n   *   * refreshToken - may be null\n   *\n   * This function will attempt to automatically refresh if stale.\n   */\n  async getToken(): Promise<OAuth2Token> {\n\n    if (this.token && (this.token.expiresAt === null || this.token.expiresAt > Date.now())) {\n\n      // The current token is still valid\n      return this.token;\n\n    }\n\n    return this.refreshToken();\n\n  }\n\n  /**\n   * Returns an access token.\n   *\n   * If the current access token is not known, it will attempt to fetch it.\n   * If the access token is expiring, it will attempt to refresh it.\n   */\n  async getAccessToken(): Promise<string> {\n\n    // Ensure getStoredToken finished.\n    await this.activeGetStoredToken;\n\n    const token = await this.getToken();\n    return token.accessToken;\n\n  }\n\n  /**\n   * Keeping track of an active refreshToken operation.\n   *\n   * This will allow us to ensure only 1 such operation happens at any\n   * given time.\n   */\n  private activeRefresh: Promise<OAuth2Token> | null = null;\n\n  /**\n   * Forces an access token refresh\n   */\n  async refreshToken(): Promise<OAuth2Token> {\n\n    if (this.activeRefresh) {\n      // If we are currently already doing this operation,\n      // make sure we don't do it twice in parallel.\n      return this.activeRefresh;\n    }\n\n    const oldToken = this.token;\n    this.activeRefresh = (async() => {\n\n      let newToken: OAuth2Token|null = null;\n\n      try {\n        if (oldToken?.refreshToken) {\n          // We had a refresh token, lets see if we can use it!\n          newToken = await this.options.client.refreshToken(oldToken);\n        }\n      } catch (err) {\n        console.warn('[oauth2] refresh token not accepted, we\\'ll try reauthenticating');\n      }\n\n      if (!newToken) {\n        newToken = await this.options.getNewToken();\n      }\n\n      if (!newToken) {\n        const err = new Error('Unable to obtain OAuth2 tokens, a full reauth may be needed');\n        this.options.onError?.(err);\n        throw err;\n      }\n      return newToken;\n\n    })();\n\n    try {\n      const token = await this.activeRefresh;\n      this.token = token;\n      this.options.storeToken?.(token);\n      this.scheduleRefresh();\n      return token;\n    } catch (err: any) {\n      if (this.options.onError) {\n        this.options.onError(err);\n      }\n      throw err;\n    } finally {\n      // Make sure we clear the current refresh operation.\n      this.activeRefresh = null;\n    }\n\n  }\n\n  /**\n   * Timer trigger for the next automated refresh\n   */\n  private refreshTimer: ReturnType<typeof setTimeout> | null = null;\n\n  private scheduleRefresh() {\n    if (!this.options.scheduleRefresh) {\n      return;\n    }\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n\n    if (!this.token?.expiresAt || !this.token.refreshToken) {\n      // If we don't know when the token expires, or don't have a refresh_token, don't bother.\n      return;\n    }\n\n    const expiresIn = this.token.expiresAt - Date.now();\n\n    // We only schedule this event if it happens more than 2 minutes in the future.\n    if (expiresIn < 120*1000) {\n      return;\n    }\n\n    // Schedule 1 minute before expiry\n    this.refreshTimer = setTimeout(async () => {\n      try {\n        await this.refreshToken();\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('[fetch-mw-oauth2] error while doing a background OAuth2 auto-refresh', err);\n      }\n    }, expiresIn - 60*1000);\n\n  }\n\n}\n", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "export { OAuth2Client } from './client';\nexport { OAuth2AuthorizationCodeClient, generateCodeVerifier } from './client/authorization-code';\nexport { OAuth2Fetch } from './fetch-wrapper';\nexport { OAuth2Token } from './token';\nexport { OAuth2Error, OAuth2HttpError } from './error';\n\nexport { IntrospectionResponse } from './messages';\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "self", "e", "t", "r", "n", "resolve", "uri", "base", "URL", "toString", "generateQueryString", "params", "query", "URLSearchParams", "k", "v", "Object", "entries", "Array", "isArray", "vItem", "append", "set", "clientSettings", "discoveryDone", "serverMetadata", "fetch", "bind", "globalThis", "this", "settings", "token", "refreshToken", "Error", "body", "grant_type", "refresh_token", "clientSecret", "client_id", "clientId", "scope", "join", "resource", "newToken", "tokenResponseToOAuth2Token", "request", "disallowed", "extraParams", "keys", "filter", "key", "includes", "length", "authorizationCode", "OAuth2AuthorizationCodeClient", "accessToken", "token_type_hint", "tokenTypeHint", "tokenValue", "endpoint", "server", "discover", "discoverUrl", "getEndpoint", "err", "console", "warn", "resp", "headers", "Accept", "ok", "get", "startsWith", "json", "urlMap", "property", "setting", "token_endpoint_auth_methods_supported", "authenticationMethod", "authMethod", "Authorization", "btoa", "client_secret", "method", "responseBody", "errorMessage", "oauth2Code", "status", "has", "match", "error", "error_description", "statusText", "OAuth2HttpError", "access_token", "TypeError", "expiresAt", "expires_in", "Date", "now", "async", "webCrypto", "getWebCrypto", "arr", "Uint8Array", "getRandomValues", "base64Url", "nodeCrypto", "Promise", "res", "rej", "randomBytes", "buf", "getCodeChallenge", "codeVerifier", "subtle", "digest", "stringToBuffer", "hash", "createHash", "update", "window", "crypto", "webcrypto", "input", "i", "charCodeAt", "String", "fromCharCode", "replace", "client", "codeChallenge", "authorizationEndpoint", "all", "response_type", "redirect_uri", "redirectUri", "state", "concat", "responseMode", "url", "code", "validateResponse", "getToken", "queryParams", "searchParams", "slice", "OAuth2Error", "split", "undefined", "code_verifier", "message", "super", "response", "parsedBody", "httpCode", "options", "activeGetStoredToken", "activeRefresh", "refreshTimer", "scheduleRefresh", "getStoredToken", "init", "Request", "mw", "req", "next", "getAccessToken", "authenticatedRequest", "clone", "oldToken", "getNewToken", "onError", "storeToken", "clearTimeout", "expiresIn", "setTimeout", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "OAuth2Client", "generateCodeVerifier", "OAuth2Fetch"]
}
