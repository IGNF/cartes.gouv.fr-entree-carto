import {
  Tile_default as Tile_default2
} from "./chunk-YFKPCRPS.js";
import {
  VectorTile_default as VectorTile_default3
} from "./chunk-QQJC5LUN.js";
import {
  Group_default,
  Map_default,
  TileQueue_default
} from "./chunk-RRLVLT2C.js";
import {
  Image_default as Image_default2
} from "./chunk-SXACVEOG.js";
import {
  TileImage_default
} from "./chunk-2NYVGOCQ.js";
import {
  VectorTile_default,
  VectorTile_default2,
  defaultLoadFunction
} from "./chunk-XG4JV5BN.js";
import {
  Tile_default,
  createFromTemplates,
  createXYZ,
  extentFromProjection
} from "./chunk-YXQOICK3.js";
import {
  TileGrid_default
} from "./chunk-P4YRBDRD.js";
import {
  TileState_default
} from "./chunk-5D2XPBR2.js";
import {
  GeoJSON_default
} from "./chunk-UNQXYW3Y.js";
import {
  MVT_default
} from "./chunk-MV2VUHK3.js";
import {
  Vector_default as Vector_default2
} from "./chunk-VGD5ZFRF.js";
import {
  Layer_default
} from "./chunk-ZS6NWXXU.js";
import {
  Layer_default as Layer_default2
} from "./chunk-TCIJLOO2.js";
import {
  ViewHint_default,
  View_default
} from "./chunk-35QVNFWV.js";
import {
  Vector_default,
  bbox
} from "./chunk-ZGJDJBRN.js";
import {
  Source_default
} from "./chunk-PN7WQG2G.js";
import {
  MapEventType_default
} from "./chunk-BHVDQB66.js";
import {
  Circle_default,
  Fill_default,
  Icon_default,
  Stroke_default,
  Style_default,
  Text_default,
  checkedFonts,
  registerFont
} from "./chunk-5NYXTALQ.js";
import {
  ImageState_default,
  Image_default
} from "./chunk-CQE3WXS6.js";
import {
  createCanvasContext2D,
  outerHeight,
  outerWidth,
  removeChildren
} from "./chunk-UB2MKVXK.js";
import {
  CLASS_SELECTABLE
} from "./chunk-GNM7L5BH.js";
import {
  Feature_default
} from "./chunk-4IIN5XG6.js";
import {
  apply,
  compose,
  create
} from "./chunk-GBB7CYUH.js";
import {
  METERS_PER_UNIT,
  applyTransform,
  containsCoordinate,
  containsExtent,
  distance,
  equals,
  equivalent,
  fromLonLat,
  fromUserExtent,
  get2 as get,
  getCenter,
  getHeight,
  getIntersection,
  getPointResolution,
  getTopLeft,
  getTransformFromProjections,
  getUserProjection,
  getWidth,
  intersects,
  isEmpty
} from "./chunk-L3VKSXTG.js";
import {
  Disposable_default,
  Event_default,
  Object_default,
  listen,
  unlistenByKey
} from "./chunk-6ND2A3JA.js";
import {
  getUid
} from "./chunk-DFJETQDJ.js";
import {
  EventType_default,
  toPromise
} from "./chunk-FWIKGVSX.js";

// node_modules/@maplibre/maplibre-gl-style-spec/dist/index.mjs
var $version = 8;
var $root = {
  version: {
    required: true,
    type: "enum",
    values: [
      8
    ]
  },
  name: {
    type: "string"
  },
  metadata: {
    type: "*"
  },
  center: {
    type: "array",
    value: "number"
  },
  centerAltitude: {
    type: "number"
  },
  zoom: {
    type: "number"
  },
  bearing: {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees"
  },
  pitch: {
    type: "number",
    "default": 0,
    units: "degrees"
  },
  roll: {
    type: "number",
    "default": 0,
    units: "degrees"
  },
  state: {
    type: "state",
    "default": {}
  },
  light: {
    type: "light"
  },
  sky: {
    type: "sky"
  },
  projection: {
    type: "projection"
  },
  terrain: {
    type: "terrain"
  },
  sources: {
    required: true,
    type: "sources"
  },
  sprite: {
    type: "sprite"
  },
  glyphs: {
    type: "string"
  },
  transition: {
    type: "transition"
  },
  layers: {
    required: true,
    type: "array",
    value: "layer"
  }
};
var sources = {
  "*": {
    type: "source"
  }
};
var source = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
];
var source_vector = {
  type: {
    required: true,
    type: "enum",
    values: {
      vector: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    "default": "xyz"
  },
  minzoom: {
    type: "number",
    "default": 0
  },
  maxzoom: {
    type: "number",
    "default": 22
  },
  attribution: {
    type: "string"
  },
  promoteId: {
    type: "promoteId"
  },
  volatile: {
    type: "boolean",
    "default": false
  },
  "*": {
    type: "*"
  }
};
var source_raster = {
  type: {
    required: true,
    type: "enum",
    values: {
      raster: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    "default": 0
  },
  maxzoom: {
    type: "number",
    "default": 22
  },
  tileSize: {
    type: "number",
    "default": 512,
    units: "pixels"
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    "default": "xyz"
  },
  attribution: {
    type: "string"
  },
  volatile: {
    type: "boolean",
    "default": false
  },
  "*": {
    type: "*"
  }
};
var source_raster_dem = {
  type: {
    required: true,
    type: "enum",
    values: {
      "raster-dem": {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    "default": [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    "default": 0
  },
  maxzoom: {
    type: "number",
    "default": 22
  },
  tileSize: {
    type: "number",
    "default": 512,
    units: "pixels"
  },
  attribution: {
    type: "string"
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {},
      mapbox: {},
      custom: {}
    },
    "default": "mapbox"
  },
  redFactor: {
    type: "number",
    "default": 1
  },
  blueFactor: {
    type: "number",
    "default": 1
  },
  greenFactor: {
    type: "number",
    "default": 1
  },
  baseShift: {
    type: "number",
    "default": 0
  },
  volatile: {
    type: "boolean",
    "default": false
  },
  "*": {
    type: "*"
  }
};
var source_geojson = {
  type: {
    required: true,
    type: "enum",
    values: {
      geojson: {}
    }
  },
  data: {
    required: true,
    type: "*"
  },
  maxzoom: {
    type: "number",
    "default": 18
  },
  attribution: {
    type: "string"
  },
  buffer: {
    type: "number",
    "default": 128,
    maximum: 512,
    minimum: 0
  },
  filter: {
    type: "*"
  },
  tolerance: {
    type: "number",
    "default": 0.375
  },
  cluster: {
    type: "boolean",
    "default": false
  },
  clusterRadius: {
    type: "number",
    "default": 50,
    minimum: 0
  },
  clusterMaxZoom: {
    type: "number"
  },
  clusterMinPoints: {
    type: "number"
  },
  clusterProperties: {
    type: "*"
  },
  lineMetrics: {
    type: "boolean",
    "default": false
  },
  generateId: {
    type: "boolean",
    "default": false
  },
  promoteId: {
    type: "promoteId"
  }
};
var source_video = {
  type: {
    required: true,
    type: "enum",
    values: {
      video: {}
    }
  },
  urls: {
    required: true,
    type: "array",
    value: "string"
  },
  coordinates: {
    required: true,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
};
var source_image = {
  type: {
    required: true,
    type: "enum",
    values: {
      image: {}
    }
  },
  url: {
    required: true,
    type: "string"
  },
  coordinates: {
    required: true,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
};
var layer = {
  id: {
    type: "string",
    required: true
  },
  type: {
    type: "enum",
    values: {
      fill: {},
      line: {},
      symbol: {},
      circle: {},
      heatmap: {},
      "fill-extrusion": {},
      raster: {},
      hillshade: {},
      "color-relief": {},
      background: {}
    },
    required: true
  },
  metadata: {
    type: "*"
  },
  source: {
    type: "string"
  },
  "source-layer": {
    type: "string"
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  filter: {
    type: "filter"
  },
  layout: {
    type: "layout"
  },
  paint: {
    type: "paint"
  }
};
var layout = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_color-relief",
  "layout_background"
];
var layout_background = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_fill = {
  "fill-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_circle = {
  "circle-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_heatmap = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_line = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {},
      round: {},
      square: {}
    },
    "default": "butt",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {},
      round: {},
      miter: {}
    },
    "default": "miter",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    "default": 2,
    requires: [
      {
        "line-join": "miter"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    "default": 1.05,
    requires: [
      {
        "line-join": "round"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_symbol = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {},
      line: {},
      "line-center": {}
    },
    "default": "point",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    "default": 250,
    minimum: 1,
    units: "pixels",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    "default": false,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {},
      "viewport-y": {},
      source: {}
    },
    "default": "auto",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    "default": false,
    requires: [
      "icon-image",
      {
        "!": "icon-overlap"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    "default": false,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    "default": false,
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    "default": "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    "default": 1,
    minimum: 0,
    units: "factor of the original icon size",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {},
      width: {},
      height: {},
      both: {}
    },
    "default": "none",
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    "default": [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    tokens: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "padding",
    "default": [
      2
    ],
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-keep-upright": {
    type: "boolean",
    "default": false,
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    "default": "center",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    "default": "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    "default": "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      "viewport-glyph": {},
      auto: {}
    },
    "default": "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    "default": "",
    tokens: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    "default": [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    "default": 16,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    "default": 10,
    minimum: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    "default": 1.2,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-letter-spacing": {
    type: "number",
    "default": 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {},
      left: {},
      center: {},
      right: {}
    },
    "default": "center",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    "default": 0,
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-variable-anchor-offset": {
    type: "variableAnchorOffsetCollection",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    "default": "center",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    "default": 45,
    units: "degrees",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {},
      vertical: {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    units: "degrees",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    "default": 2,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    "default": true,
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {},
      uppercase: {},
      lowercase: {}
    },
    "default": "none",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    value: "number",
    units: "ems",
    length: 2,
    "default": [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    "default": false,
    requires: [
      "text-field",
      {
        "!": "text-overlap"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    "default": false,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    "default": false,
    requires: [
      "text-field",
      "icon-image"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_raster = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var layout_hillshade = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    "default": "visible",
    "property-type": "constant"
  }
};
var filter = {
  type: "array",
  value: "*"
};
var filter_operator = {
  type: "enum",
  values: {
    "==": {},
    "!=": {},
    ">": {},
    ">=": {},
    "<": {},
    "<=": {},
    "in": {},
    "!in": {},
    all: {},
    any: {},
    none: {},
    has: {},
    "!has": {}
  }
};
var geometry_type = {
  type: "enum",
  values: {
    Point: {},
    LineString: {},
    Polygon: {}
  }
};
var function_stop = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2
};
var expression$1 = {
  type: "array",
  value: "*",
  minimum: 1
};
var light = {
  anchor: {
    type: "enum",
    "default": "viewport",
    values: {
      map: {},
      viewport: {}
    },
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    }
  },
  position: {
    type: "array",
    "default": [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    "default": "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    "default": 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  }
};
var sky = {
  "sky-color": {
    type: "color",
    "property-type": "data-constant",
    "default": "#88C6FC",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "horizon-color": {
    type: "color",
    "property-type": "data-constant",
    "default": "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "fog-color": {
    type: "color",
    "property-type": "data-constant",
    "default": "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "fog-ground-blend": {
    type: "number",
    "property-type": "data-constant",
    "default": 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "horizon-fog-blend": {
    type: "number",
    "property-type": "data-constant",
    "default": 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "sky-horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    "default": 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  },
  "atmosphere-blend": {
    type: "number",
    "property-type": "data-constant",
    "default": 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true
  }
};
var terrain = {
  source: {
    type: "string",
    required: true
  },
  exaggeration: {
    type: "number",
    minimum: 0,
    "default": 1
  }
};
var projection = {
  type: {
    type: "projectionDefinition",
    "default": "mercator",
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    }
  }
};
var paint = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_color-relief",
  "paint_background"
];
var paint_fill = {
  "fill-antialias": {
    type: "boolean",
    "default": true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": true
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    requires: [
      "fill-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  }
};
var paint_line = {
  "line-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    requires: [
      "line-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    "default": 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    minimum: 0,
    transition: true,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    transition: false,
    requires: [
      {
        "!": "line-dasharray"
      },
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: true
        }
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  }
};
var paint_circle = {
  "circle-radius": {
    type: "number",
    "default": 5,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    "default": 0,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    requires: [
      "circle-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "viewport",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
};
var paint_heatmap = {
  "heatmap-radius": {
    type: "number",
    "default": 30,
    minimum: 1,
    transition: true,
    units: "pixels",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    "default": 1,
    minimum: 0,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    "default": [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var paint_symbol = {
  "icon-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    "default": "rgba(0, 0, 0, 0)",
    transition: true,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    overridable: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    "default": "rgba(0, 0, 0, 0)",
    transition: true,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    "default": 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    "default": [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var paint_raster = {
  "raster-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    "default": 0,
    period: 360,
    transition: true,
    units: "degrees",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    "default": 0,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    "default": 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    "default": 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    values: {
      linear: {},
      nearest: {}
    },
    "default": "linear",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    "default": 300,
    minimum: 0,
    transition: false,
    units: "milliseconds",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var paint_hillshade = {
  "hillshade-illumination-direction": {
    type: "numberArray",
    "default": 335,
    minimum: 0,
    maximum: 359,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-altitude": {
    type: "numberArray",
    "default": 45,
    minimum: 0,
    maximum: 90,
    transition: false,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    "default": "viewport",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    "default": 0.5,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "colorArray",
    "default": "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "colorArray",
    "default": "#FFFFFF",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-method": {
    type: "enum",
    values: {
      standard: {},
      basic: {},
      combined: {},
      igor: {},
      multidirectional: {}
    },
    "default": "standard",
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var paint_background = {
  "background-color": {
    type: "color",
    "default": "#000000",
    transition: true,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: true,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    "default": 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var transition = {
  duration: {
    type: "number",
    "default": 300,
    minimum: 0,
    units: "milliseconds"
  },
  delay: {
    type: "number",
    "default": 0,
    minimum: 0,
    units: "milliseconds"
  }
};
var promoteId = {
  "*": {
    type: "string"
  }
};
var v8Spec = {
  $version,
  $root,
  sources,
  source,
  source_vector,
  source_raster,
  source_raster_dem,
  source_geojson,
  source_video,
  source_image,
  layer,
  layout,
  layout_background,
  layout_fill,
  layout_circle,
  layout_heatmap,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      "default": "visible",
      "property-type": "constant"
    }
  },
  layout_line,
  layout_symbol,
  layout_raster,
  layout_hillshade,
  "layout_color-relief": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      "default": "visible",
      "property-type": "constant"
    }
  },
  filter,
  filter_operator,
  geometry_type,
  "function": {
    expression: {
      type: "expression"
    },
    stops: {
      type: "array",
      value: "function_stop"
    },
    base: {
      type: "number",
      "default": 1,
      minimum: 0
    },
    property: {
      type: "string",
      "default": "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {},
        exponential: {},
        interval: {},
        categorical: {}
      },
      "default": "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {},
        lab: {},
        hcl: {}
      },
      "default": "rgb"
    },
    "default": {
      type: "*",
      required: false
    }
  },
  function_stop,
  expression: expression$1,
  light,
  sky,
  terrain,
  projection,
  paint,
  paint_fill,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      "default": 1,
      minimum: 0,
      maximum: 1,
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      "default": "#000000",
      transition: true,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      "default": [
        0,
        0
      ],
      transition: true,
      units: "pixels",
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      "default": "map",
      requires: [
        "fill-extrusion-translate"
      ],
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: true,
      expression: {
        interpolated: false,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      "default": 0,
      minimum: 0,
      units: "meters",
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      "default": 0,
      minimum: 0,
      units: "meters",
      transition: true,
      requires: [
        "fill-extrusion-height"
      ],
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      "default": true,
      transition: false,
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  },
  paint_line,
  paint_circle,
  paint_heatmap,
  paint_symbol,
  paint_raster,
  paint_hillshade,
  "paint_color-relief": {
    "color-relief-opacity": {
      type: "number",
      "default": 1,
      minimum: 0,
      maximum: 1,
      transition: true,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "color-relief-color": {
      type: "color",
      transition: false,
      expression: {
        interpolated: true,
        parameters: [
          "elevation"
        ]
      },
      "property-type": "color-ramp"
    }
  },
  paint_background,
  transition,
  "property-type": {
    "data-driven": {
      type: "property-type"
    },
    "cross-faded": {
      type: "property-type"
    },
    "cross-faded-data-driven": {
      type: "property-type"
    },
    "color-ramp": {
      type: "property-type"
    },
    "data-constant": {
      type: "property-type"
    },
    constant: {
      type: "property-type"
    }
  },
  promoteId
};
var refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function deref(layer2, parent) {
  const result = {};
  for (const k in layer2) {
    if (k !== "ref") {
      result[k] = layer2[k];
    }
  }
  refProperties.forEach((k) => {
    if (k in parent) {
      result[k] = parent[k];
    }
  });
  return result;
}
function derefLayers(layers) {
  layers = layers.slice();
  const map = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < layers.length; i++) {
    map[layers[i].id] = layers[i];
  }
  for (let i = 0; i < layers.length; i++) {
    if ("ref" in layers[i]) {
      layers[i] = deref(layers[i], map[layers[i].ref]);
    }
  }
  return layers;
}
var ValidationError = class {
  constructor(key, value, message, identifier) {
    this.message = (key ? `${key}: ` : "") + message;
    if (identifier)
      this.identifier = identifier;
    if (value !== null && value !== void 0 && value.__line__) {
      this.line = value.__line__;
    }
  }
};
function extendBy(output, ...inputs) {
  for (const input of inputs) {
    for (const k in input) {
      output[k] = input[k];
    }
  }
  return output;
}
var ExpressionParsingError = class extends Error {
  constructor(key, message) {
    super(message);
    this.message = message;
    this.key = key;
  }
};
var Scope = class _Scope {
  constructor(parent, bindings = []) {
    this.parent = parent;
    this.bindings = {};
    for (const [name, expression] of bindings) {
      this.bindings[name] = expression;
    }
  }
  concat(bindings) {
    return new _Scope(this, bindings);
  }
  get(name) {
    if (this.bindings[name]) {
      return this.bindings[name];
    }
    if (this.parent) {
      return this.parent.get(name);
    }
    throw new Error(`${name} not found in scope.`);
  }
  has(name) {
    if (this.bindings[name])
      return true;
    return this.parent ? this.parent.has(name) : false;
  }
};
var NullType = { kind: "null" };
var NumberType = { kind: "number" };
var StringType = { kind: "string" };
var BooleanType = { kind: "boolean" };
var ColorType = { kind: "color" };
var ProjectionDefinitionType = { kind: "projectionDefinition" };
var ObjectType = { kind: "object" };
var ValueType = { kind: "value" };
var ErrorType = { kind: "error" };
var CollatorType = { kind: "collator" };
var FormattedType = { kind: "formatted" };
var PaddingType = { kind: "padding" };
var ColorArrayType = { kind: "colorArray" };
var NumberArrayType = { kind: "numberArray" };
var ResolvedImageType = { kind: "resolvedImage" };
var VariableAnchorOffsetCollectionType = { kind: "variableAnchorOffsetCollection" };
function array(itemType, N) {
  return {
    kind: "array",
    itemType,
    N
  };
}
function typeToString(type) {
  if (type.kind === "array") {
    const itemType = typeToString(type.itemType);
    return typeof type.N === "number" ? `array<${itemType}, ${type.N}>` : type.itemType.kind === "value" ? "array" : `array<${itemType}>`;
  } else {
    return type.kind;
  }
}
var valueMemberTypes = [
  NullType,
  NumberType,
  StringType,
  BooleanType,
  ColorType,
  ProjectionDefinitionType,
  FormattedType,
  ObjectType,
  array(ValueType),
  PaddingType,
  NumberArrayType,
  ColorArrayType,
  ResolvedImageType,
  VariableAnchorOffsetCollectionType
];
function checkSubtype(expected, t) {
  if (t.kind === "error") {
    return null;
  } else if (expected.kind === "array") {
    if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== "number" || expected.N === t.N)) {
      return null;
    }
  } else if (expected.kind === t.kind) {
    return null;
  } else if (expected.kind === "value") {
    for (const memberType of valueMemberTypes) {
      if (!checkSubtype(memberType, t)) {
        return null;
      }
    }
  }
  return `Expected ${typeToString(expected)} but found ${typeToString(t)} instead.`;
}
function isValidType(provided, allowedTypes) {
  return allowedTypes.some((t) => t.kind === provided.kind);
}
function isValidNativeType(provided, allowedTypes) {
  return allowedTypes.some((t) => {
    if (t === "null") {
      return provided === null;
    } else if (t === "array") {
      return Array.isArray(provided);
    } else if (t === "object") {
      return provided && !Array.isArray(provided) && typeof provided === "object";
    } else {
      return t === typeof provided;
    }
  });
}
function verifyType(provided, sample) {
  if (provided.kind === "array" && sample.kind === "array") {
    return provided.itemType.kind === sample.itemType.kind && typeof provided.N === "number";
  }
  return provided.kind === sample.kind;
}
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;
function constrainAngle(angle) {
  angle = angle % 360;
  if (angle < 0) {
    angle += 360;
  }
  return angle;
}
function rgbToLab([r, g, b, alpha]) {
  r = rgb2xyz(r);
  g = rgb2xyz(g);
  b = rgb2xyz(b);
  let x, z;
  const y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn);
  if (r === g && g === b) {
    x = z = y;
  } else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  const l = 116 * y - 16;
  return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z), alpha];
}
function rgb2xyz(x) {
  return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function labToRgb([l, a, b, alpha]) {
  let y = (l + 16) / 116, x = isNaN(a) ? y : y + a / 500, z = isNaN(b) ? y : y - b / 200;
  y = Yn * lab2xyz(y);
  x = Xn * lab2xyz(x);
  z = Zn * lab2xyz(z);
  return [
    xyz2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
    // D50 -> sRGB
    xyz2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
    xyz2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
    alpha
  ];
}
function xyz2rgb(x) {
  x = x <= 304e-5 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
  return x < 0 ? 0 : x > 1 ? 1 : x;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function rgbToHcl(rgbColor) {
  const [l, a, b, alpha] = rgbToLab(rgbColor);
  const c = Math.sqrt(a * a + b * b);
  const h = Math.round(c * 1e4) ? constrainAngle(Math.atan2(b, a) * rad2deg) : NaN;
  return [h, c, l, alpha];
}
function hclToRgb([h, c, l, alpha]) {
  h = isNaN(h) ? 0 : h * deg2rad;
  return labToRgb([l, Math.cos(h) * c, Math.sin(h) * c, alpha]);
}
function hslToRgb([h, s, l, alpha]) {
  h = constrainAngle(h);
  s /= 100;
  l /= 100;
  function f(n) {
    const k = (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
  }
  return [f(0), f(8), f(4), alpha];
}
var hasOwnProperty = Object.hasOwn || function hasOwnProperty2(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};
function getOwn(object, key) {
  return hasOwnProperty(object, key) ? object[key] : void 0;
}
function parseCssColor(input) {
  input = input.toLowerCase().trim();
  if (input === "transparent") {
    return [0, 0, 0, 0];
  }
  const namedColorsMatch = getOwn(namedColors, input);
  if (namedColorsMatch) {
    const [r, g, b] = namedColorsMatch;
    return [r / 255, g / 255, b / 255, 1];
  }
  if (input.startsWith("#")) {
    const hexRegexp = /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/;
    if (hexRegexp.test(input)) {
      const step = input.length < 6 ? 1 : 2;
      let i = 1;
      return [
        parseHex(input.slice(i, i += step)),
        parseHex(input.slice(i, i += step)),
        parseHex(input.slice(i, i += step)),
        parseHex(input.slice(i, i + step) || "ff")
      ];
    }
  }
  if (input.startsWith("rgb")) {
    const rgbRegExp = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/;
    const rgbMatch = input.match(rgbRegExp);
    if (rgbMatch) {
      const [
        _,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        r,
        // <numeric>
        rp,
        // %         (optional)
        f1,
        // ,         (optional)
        g,
        // <numeric>
        gp,
        // %         (optional)
        f2,
        // ,         (optional)
        b,
        // <numeric>
        bp,
        // %         (optional)
        f3,
        // ,|/       (optional)
        a,
        // <numeric> (optional)
        ap
        // %         (optional)
      ] = rgbMatch;
      const argFormat = [f1 || " ", f2 || " ", f3].join("");
      if (argFormat === "  " || argFormat === "  /" || argFormat === ",," || argFormat === ",,,") {
        const valFormat = [rp, gp, bp].join("");
        const maxValue = valFormat === "%%%" ? 100 : valFormat === "" ? 255 : 0;
        if (maxValue) {
          const rgba2 = [
            clamp(+r / maxValue, 0, 1),
            clamp(+g / maxValue, 0, 1),
            clamp(+b / maxValue, 0, 1),
            a ? parseAlpha(+a, ap) : 1
          ];
          if (validateNumbers(rgba2)) {
            return rgba2;
          }
        }
      }
      return;
    }
  }
  const hslRegExp = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/;
  const hslMatch = input.match(hslRegExp);
  if (hslMatch) {
    const [
      _,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      h,
      // <numeric>
      f1,
      // ,         (optional)
      s,
      // <numeric>
      f2,
      // ,         (optional)
      l,
      // <numeric>
      f3,
      // ,|/       (optional)
      a,
      // <numeric> (optional)
      ap
      // %         (optional)
    ] = hslMatch;
    const argFormat = [f1 || " ", f2 || " ", f3].join("");
    if (argFormat === "  " || argFormat === "  /" || argFormat === ",," || argFormat === ",,,") {
      const hsla = [
        +h,
        clamp(+s, 0, 100),
        clamp(+l, 0, 100),
        a ? parseAlpha(+a, ap) : 1
      ];
      if (validateNumbers(hsla)) {
        return hslToRgb(hsla);
      }
    }
  }
}
function parseHex(hex) {
  return parseInt(hex.padEnd(2, hex), 16) / 255;
}
function parseAlpha(a, asPercentage) {
  return clamp(asPercentage ? a / 100 : a, 0, 1);
}
function clamp(n, min, max) {
  return Math.min(Math.max(min, n), max);
}
function validateNumbers(array2) {
  return !array2.some(Number.isNaN);
}
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
function interpolateNumber(from, to, t) {
  return from + t * (to - from);
}
function interpolateArray(from, to, t) {
  return from.map((d, i) => {
    return interpolateNumber(d, to[i], t);
  });
}
var Color = class _Color {
  /**
   * @param r Red component premultiplied by `alpha` 0..1
   * @param g Green component premultiplied by `alpha` 0..1
   * @param b Blue component premultiplied by `alpha` 0..1
   * @param [alpha=1] Alpha component 0..1
   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
   * been multiplied by alpha. If `true` nothing happens if `false` then they will
   * be multiplied automatically.
   */
  constructor(r, g, b, alpha = 1, premultiplied = true) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = alpha;
    if (!premultiplied) {
      this.r *= alpha;
      this.g *= alpha;
      this.b *= alpha;
      if (!alpha) {
        this.overwriteGetter("rgb", [r, g, b, alpha]);
      }
    }
  }
  /**
   * Parses CSS color strings and converts colors to sRGB color space if needed.
   * Officially supported color formats:
   * - keyword, e.g. 'aquamarine' or 'steelblue'
   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
   *
   * @param input CSS color string to parse.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(input) {
    if (input instanceof _Color) {
      return input;
    }
    if (typeof input !== "string") {
      return;
    }
    const rgba2 = parseCssColor(input);
    if (rgba2) {
      return new _Color(...rgba2, false);
    }
  }
  /**
   * Used in color interpolation and by 'to-rgba' expression.
   *
   * @returns Gien color, with reversed alpha blending, in sRGB color space.
   */
  get rgb() {
    const { r, g, b, a } = this;
    const f = a || Infinity;
    return this.overwriteGetter("rgb", [r / f, g / f, b / f, a]);
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in HCL color space.
   */
  get hcl() {
    return this.overwriteGetter("hcl", rgbToHcl(this.rgb));
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in LAB color space.
   */
  get lab() {
    return this.overwriteGetter("lab", rgbToLab(this.rgb));
  }
  /**
   * Lazy getter pattern. When getter is called for the first time lazy value
   * is calculated and then overwrites getter function in given object instance.
   *
   * @example:
   * const redColor = Color.parse('red');
   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
   * // the value of red in HCL space and invoke this `overwriteGetter` function
   * // which in turn will set a field with a key 'hcl' in the `redColor` object.
   * // In other words it will override `get hcl()` from its `Color` prototype
   * // with its own property: hcl = [calculated red value in hcl].
   * let y = redColor.hcl; // next call will no longer invoke getter but simply
   * // return the previously calculated value
   * x === y; // true - `x` is exactly the same object as `y`
   *
   * @param getterKey Getter key
   * @param lazyValue Lazily calculated value to be memoized by current instance
   * @private
   */
  overwriteGetter(getterKey, lazyValue) {
    Object.defineProperty(this, getterKey, { value: lazyValue });
    return lazyValue;
  }
  /**
   * Used by 'to-string' expression.
   *
   * @returns Serialized color in format `rgba(r,g,b,a)`
   * where r,g,b are numbers within 0..255 and alpha is number within 1..0
   *
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [r, g, b, a] = this.rgb;
    return `rgba(${[r, g, b].map((n) => Math.round(n * 255)).join(",")},${a})`;
  }
  static interpolate(from, to, t, spaceKey = "rgb") {
    switch (spaceKey) {
      case "rgb": {
        const [r, g, b, alpha] = interpolateArray(from.rgb, to.rgb, t);
        return new _Color(r, g, b, alpha, false);
      }
      case "hcl": {
        const [hue0, chroma0, light0, alphaF] = from.hcl;
        const [hue1, chroma1, light1, alphaT] = to.hcl;
        let hue, chroma;
        if (!isNaN(hue0) && !isNaN(hue1)) {
          let dh = hue1 - hue0;
          if (hue1 > hue0 && dh > 180) {
            dh -= 360;
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
            dh += 360;
          }
          hue = hue0 + t * dh;
        } else if (!isNaN(hue0)) {
          hue = hue0;
          if (light1 === 1 || light1 === 0)
            chroma = chroma0;
        } else if (!isNaN(hue1)) {
          hue = hue1;
          if (light0 === 1 || light0 === 0)
            chroma = chroma1;
        } else {
          hue = NaN;
        }
        const [r, g, b, alpha] = hclToRgb([
          hue,
          chroma !== null && chroma !== void 0 ? chroma : interpolateNumber(chroma0, chroma1, t),
          interpolateNumber(light0, light1, t),
          interpolateNumber(alphaF, alphaT, t)
        ]);
        return new _Color(r, g, b, alpha, false);
      }
      case "lab": {
        const [r, g, b, alpha] = labToRgb(interpolateArray(from.lab, to.lab, t));
        return new _Color(r, g, b, alpha, false);
      }
    }
  }
};
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);
var Collator = class {
  constructor(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive)
      this.sensitivity = diacriticSensitive ? "variant" : "case";
    else
      this.sensitivity = diacriticSensitive ? "accent" : "base";
    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
var VERTICAL_ALIGN_OPTIONS = ["bottom", "center", "top"];
var FormattedSection = class {
  constructor(text, image, scale2, fontStack, textColor, verticalAlign) {
    this.text = text;
    this.image = image;
    this.scale = scale2;
    this.fontStack = fontStack;
    this.textColor = textColor;
    this.verticalAlign = verticalAlign;
  }
};
var Formatted = class _Formatted {
  constructor(sections) {
    this.sections = sections;
  }
  static fromString(unformatted) {
    return new _Formatted([new FormattedSection(unformatted, null, null, null, null, null)]);
  }
  isEmpty() {
    if (this.sections.length === 0)
      return true;
    return !this.sections.some((section) => section.text.length !== 0 || section.image && section.image.name.length !== 0);
  }
  static factory(text) {
    if (text instanceof _Formatted) {
      return text;
    } else {
      return _Formatted.fromString(text);
    }
  }
  toString() {
    if (this.sections.length === 0)
      return "";
    return this.sections.map((section) => section.text).join("");
  }
};
var Padding = class _Padding {
  constructor(values) {
    this.values = values.slice();
  }
  /**
   * Numeric padding values
   * @param input A padding value
   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
   */
  static parse(input) {
    if (input instanceof _Padding) {
      return input;
    }
    if (typeof input === "number") {
      return new _Padding([input, input, input, input]);
    }
    if (!Array.isArray(input)) {
      return void 0;
    }
    if (input.length < 1 || input.length > 4) {
      return void 0;
    }
    for (const val of input) {
      if (typeof val !== "number") {
        return void 0;
      }
    }
    switch (input.length) {
      case 1:
        input = [input[0], input[0], input[0], input[0]];
        break;
      case 2:
        input = [input[0], input[1], input[0], input[1]];
        break;
      case 3:
        input = [input[0], input[1], input[2], input[1]];
        break;
    }
    return new _Padding(input);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(from, to, t) {
    return new _Padding(interpolateArray(from.values, to.values, t));
  }
};
var NumberArray = class _NumberArray {
  constructor(values) {
    this.values = values.slice();
  }
  /**
   * Numeric NumberArray values
   * @param input A NumberArray value
   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
   */
  static parse(input) {
    if (input instanceof _NumberArray) {
      return input;
    }
    if (typeof input === "number") {
      return new _NumberArray([input]);
    }
    if (!Array.isArray(input)) {
      return void 0;
    }
    for (const val of input) {
      if (typeof val !== "number") {
        return void 0;
      }
    }
    return new _NumberArray(input);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(from, to, t) {
    return new _NumberArray(interpolateArray(from.values, to.values, t));
  }
};
var ColorArray = class _ColorArray {
  constructor(values) {
    this.values = values.slice();
  }
  /**
   * ColorArray values
   * @param input A ColorArray value
   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
   */
  static parse(input) {
    if (input instanceof _ColorArray) {
      return input;
    }
    if (typeof input === "string") {
      const parsed_val = Color.parse(input);
      if (!parsed_val) {
        return void 0;
      }
      return new _ColorArray([parsed_val]);
    }
    if (!Array.isArray(input)) {
      return void 0;
    }
    const colors = [];
    for (const val of input) {
      if (typeof val !== "string") {
        return void 0;
      }
      const parsed_val = Color.parse(val);
      if (!parsed_val) {
        return void 0;
      }
      colors.push(parsed_val);
    }
    return new _ColorArray(colors);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(from, to, t, spaceKey = "rgb") {
    const colors = [];
    if (from.values.length != to.values.length) {
      throw new Error(`colorArray: Arrays have mismatched length (${from.values.length} vs. ${to.values.length}), cannot interpolate.`);
    }
    for (let i = 0; i < from.values.length; i++) {
      colors.push(Color.interpolate(from.values[i], to.values[i], t, spaceKey));
    }
    return new _ColorArray(colors);
  }
};
var RuntimeError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
};
var anchors = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
var VariableAnchorOffsetCollection = class _VariableAnchorOffsetCollection {
  constructor(values) {
    this.values = values.slice();
  }
  static parse(input) {
    if (input instanceof _VariableAnchorOffsetCollection) {
      return input;
    }
    if (!Array.isArray(input) || input.length < 1 || input.length % 2 !== 0) {
      return void 0;
    }
    for (let i = 0; i < input.length; i += 2) {
      const anchorValue = input[i];
      const offsetValue = input[i + 1];
      if (typeof anchorValue !== "string" || !anchors.has(anchorValue)) {
        return void 0;
      }
      if (!Array.isArray(offsetValue) || offsetValue.length !== 2 || typeof offsetValue[0] !== "number" || typeof offsetValue[1] !== "number") {
        return void 0;
      }
    }
    return new _VariableAnchorOffsetCollection(input);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(from, to, t) {
    const fromValues = from.values;
    const toValues = to.values;
    if (fromValues.length !== toValues.length) {
      throw new RuntimeError(`Cannot interpolate values of different length. from: ${from.toString()}, to: ${to.toString()}`);
    }
    const output = [];
    for (let i = 0; i < fromValues.length; i += 2) {
      if (fromValues[i] !== toValues[i]) {
        throw new RuntimeError(`Cannot interpolate values containing mismatched anchors. from[${i}]: ${fromValues[i]}, to[${i}]: ${toValues[i]}`);
      }
      output.push(fromValues[i]);
      const [fx, fy] = fromValues[i + 1];
      const [tx, ty] = toValues[i + 1];
      output.push([interpolateNumber(fx, tx, t), interpolateNumber(fy, ty, t)]);
    }
    return new _VariableAnchorOffsetCollection(output);
  }
};
var ResolvedImage = class _ResolvedImage {
  constructor(options) {
    this.name = options.name;
    this.available = options.available;
  }
  toString() {
    return this.name;
  }
  static fromString(name) {
    if (!name)
      return null;
    return new _ResolvedImage({ name, available: false });
  }
};
var ProjectionDefinition = class _ProjectionDefinition {
  constructor(from, to, transition2) {
    this.from = from;
    this.to = to;
    this.transition = transition2;
  }
  static interpolate(from, to, t) {
    return new _ProjectionDefinition(from, to, t);
  }
  static parse(input) {
    if (input instanceof _ProjectionDefinition) {
      return input;
    }
    if (Array.isArray(input) && input.length === 3 && typeof input[0] === "string" && typeof input[1] === "string" && typeof input[2] === "number") {
      return new _ProjectionDefinition(input[0], input[1], input[2]);
    }
    if (typeof input === "object" && typeof input.from === "string" && typeof input.to === "string" && typeof input.transition === "number") {
      return new _ProjectionDefinition(input.from, input.to, input.transition);
    }
    if (typeof input === "string") {
      return new _ProjectionDefinition(input, input, 1);
    }
    return void 0;
  }
};
function validateRGBA(r, g, b, a) {
  if (!(typeof r === "number" && r >= 0 && r <= 255 && typeof g === "number" && g >= 0 && g <= 255 && typeof b === "number" && b >= 0 && b <= 255)) {
    const value = typeof a === "number" ? [r, g, b, a] : [r, g, b];
    return `Invalid rgba value [${value.join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
  }
  if (!(typeof a === "undefined" || typeof a === "number" && a >= 0 && a <= 1)) {
    return `Invalid rgba value [${[r, g, b, a].join(", ")}]: 'a' must be between 0 and 1.`;
  }
  return null;
}
function isValue(mixed) {
  if (mixed === null || typeof mixed === "string" || typeof mixed === "boolean" || typeof mixed === "number" || mixed instanceof ProjectionDefinition || mixed instanceof Color || mixed instanceof Collator || mixed instanceof Formatted || mixed instanceof Padding || mixed instanceof NumberArray || mixed instanceof ColorArray || mixed instanceof VariableAnchorOffsetCollection || mixed instanceof ResolvedImage) {
    return true;
  } else if (Array.isArray(mixed)) {
    for (const item of mixed) {
      if (!isValue(item)) {
        return false;
      }
    }
    return true;
  } else if (typeof mixed === "object") {
    for (const key in mixed) {
      if (!isValue(mixed[key])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function typeOf(value) {
  if (value === null) {
    return NullType;
  } else if (typeof value === "string") {
    return StringType;
  } else if (typeof value === "boolean") {
    return BooleanType;
  } else if (typeof value === "number") {
    return NumberType;
  } else if (value instanceof Color) {
    return ColorType;
  } else if (value instanceof ProjectionDefinition) {
    return ProjectionDefinitionType;
  } else if (value instanceof Collator) {
    return CollatorType;
  } else if (value instanceof Formatted) {
    return FormattedType;
  } else if (value instanceof Padding) {
    return PaddingType;
  } else if (value instanceof NumberArray) {
    return NumberArrayType;
  } else if (value instanceof ColorArray) {
    return ColorArrayType;
  } else if (value instanceof VariableAnchorOffsetCollection) {
    return VariableAnchorOffsetCollectionType;
  } else if (value instanceof ResolvedImage) {
    return ResolvedImageType;
  } else if (Array.isArray(value)) {
    const length = value.length;
    let itemType;
    for (const item of value) {
      const t = typeOf(item);
      if (!itemType) {
        itemType = t;
      } else if (itemType === t) {
        continue;
      } else {
        itemType = ValueType;
        break;
      }
    }
    return array(itemType || ValueType, length);
  } else {
    return ObjectType;
  }
}
function valueToString(value) {
  const type = typeof value;
  if (value === null) {
    return "";
  } else if (type === "string" || type === "number" || type === "boolean") {
    return String(value);
  } else if (value instanceof Color || value instanceof ProjectionDefinition || value instanceof Formatted || value instanceof Padding || value instanceof NumberArray || value instanceof ColorArray || value instanceof VariableAnchorOffsetCollection || value instanceof ResolvedImage) {
    return value.toString();
  } else {
    return JSON.stringify(value);
  }
}
var Literal = class _Literal {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static parse(args, context) {
    if (args.length !== 2)
      return context.error(`'literal' expression requires exactly one argument, but found ${args.length - 1} instead.`);
    if (!isValue(args[1]))
      return context.error("invalid value");
    const value = args[1];
    let type = typeOf(value);
    const expected = context.expectedType;
    if (type.kind === "array" && type.N === 0 && expected && expected.kind === "array" && (typeof expected.N !== "number" || expected.N === 0)) {
      type = expected;
    }
    return new _Literal(type, value);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var types$1 = {
  string: StringType,
  number: NumberType,
  boolean: BooleanType,
  object: ObjectType
};
var Assertion = class _Assertion {
  constructor(type, args) {
    this.type = type;
    this.args = args;
  }
  static parse(args, context) {
    if (args.length < 2)
      return context.error("Expected at least one argument.");
    let i = 1;
    let type;
    const name = args[0];
    if (name === "array") {
      let itemType;
      if (args.length > 2) {
        const type2 = args[1];
        if (typeof type2 !== "string" || !(type2 in types$1) || type2 === "object")
          return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
        itemType = types$1[type2];
        i++;
      } else {
        itemType = ValueType;
      }
      let N;
      if (args.length > 3) {
        if (args[2] !== null && (typeof args[2] !== "number" || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
          return context.error('The length argument to "array" must be a positive integer literal', 2);
        }
        N = args[2];
        i++;
      }
      type = array(itemType, N);
    } else {
      if (!types$1[name])
        throw new Error(`Types doesn't contain name = ${name}`);
      type = types$1[name];
    }
    const parsed = [];
    for (; i < args.length; i++) {
      const input = context.parse(args[i], i, ValueType);
      if (!input)
        return null;
      parsed.push(input);
    }
    return new _Assertion(type, parsed);
  }
  evaluate(ctx) {
    for (let i = 0; i < this.args.length; i++) {
      const value = this.args[i].evaluate(ctx);
      const error2 = checkSubtype(this.type, typeOf(value));
      if (!error2) {
        return value;
      } else if (i === this.args.length - 1) {
        throw new RuntimeError(`Expected value to be of type ${typeToString(this.type)}, but found ${typeToString(typeOf(value))} instead.`);
      }
    }
    throw new Error();
  }
  eachChild(fn) {
    this.args.forEach(fn);
  }
  outputDefined() {
    return this.args.every((arg) => arg.outputDefined());
  }
};
var types = {
  "to-boolean": BooleanType,
  "to-color": ColorType,
  "to-number": NumberType,
  "to-string": StringType
};
var Coercion = class _Coercion {
  constructor(type, args) {
    this.type = type;
    this.args = args;
  }
  static parse(args, context) {
    if (args.length < 2)
      return context.error("Expected at least one argument.");
    const name = args[0];
    if (!types[name])
      throw new Error(`Can't parse ${name} as it is not part of the known types`);
    if ((name === "to-boolean" || name === "to-string") && args.length !== 2)
      return context.error("Expected one argument.");
    const type = types[name];
    const parsed = [];
    for (let i = 1; i < args.length; i++) {
      const input = context.parse(args[i], i, ValueType);
      if (!input)
        return null;
      parsed.push(input);
    }
    return new _Coercion(type, parsed);
  }
  evaluate(ctx) {
    switch (this.type.kind) {
      case "boolean":
        return Boolean(this.args[0].evaluate(ctx));
      case "color": {
        let input;
        let error2;
        for (const arg of this.args) {
          input = arg.evaluate(ctx);
          error2 = null;
          if (input instanceof Color) {
            return input;
          } else if (typeof input === "string") {
            const c = ctx.parseColor(input);
            if (c)
              return c;
          } else if (Array.isArray(input)) {
            if (input.length < 3 || input.length > 4) {
              error2 = `Invalid rgba value ${JSON.stringify(input)}: expected an array containing either three or four numeric values.`;
            } else {
              error2 = validateRGBA(input[0], input[1], input[2], input[3]);
            }
            if (!error2) {
              return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
            }
          }
        }
        throw new RuntimeError(error2 || `Could not parse color from value '${typeof input === "string" ? input : JSON.stringify(input)}'`);
      }
      case "padding": {
        let input;
        for (const arg of this.args) {
          input = arg.evaluate(ctx);
          const pad = Padding.parse(input);
          if (pad) {
            return pad;
          }
        }
        throw new RuntimeError(`Could not parse padding from value '${typeof input === "string" ? input : JSON.stringify(input)}'`);
      }
      case "numberArray": {
        let input;
        for (const arg of this.args) {
          input = arg.evaluate(ctx);
          const val = NumberArray.parse(input);
          if (val) {
            return val;
          }
        }
        throw new RuntimeError(`Could not parse numberArray from value '${typeof input === "string" ? input : JSON.stringify(input)}'`);
      }
      case "colorArray": {
        let input;
        for (const arg of this.args) {
          input = arg.evaluate(ctx);
          const val = ColorArray.parse(input);
          if (val) {
            return val;
          }
        }
        throw new RuntimeError(`Could not parse colorArray from value '${typeof input === "string" ? input : JSON.stringify(input)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let input;
        for (const arg of this.args) {
          input = arg.evaluate(ctx);
          const coll = VariableAnchorOffsetCollection.parse(input);
          if (coll) {
            return coll;
          }
        }
        throw new RuntimeError(`Could not parse variableAnchorOffsetCollection from value '${typeof input === "string" ? input : JSON.stringify(input)}'`);
      }
      case "number": {
        let value = null;
        for (const arg of this.args) {
          value = arg.evaluate(ctx);
          if (value === null)
            return 0;
          const num = Number(value);
          if (isNaN(num))
            continue;
          return num;
        }
        throw new RuntimeError(`Could not convert ${JSON.stringify(value)} to number.`);
      }
      case "formatted":
        return Formatted.fromString(valueToString(this.args[0].evaluate(ctx)));
      case "resolvedImage":
        return ResolvedImage.fromString(valueToString(this.args[0].evaluate(ctx)));
      case "projectionDefinition":
        return this.args[0].evaluate(ctx);
      default:
        return valueToString(this.args[0].evaluate(ctx));
    }
  }
  eachChild(fn) {
    this.args.forEach(fn);
  }
  outputDefined() {
    return this.args.every((arg) => arg.outputDefined());
  }
};
var geometryTypes = ["Unknown", "Point", "LineString", "Polygon"];
var EvaluationContext = class {
  constructor() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = /* @__PURE__ */ new Map();
    this.availableImages = null;
    this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type === "number" ? geometryTypes[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(input) {
    let cached = this._parseColorCache.get(input);
    if (!cached) {
      cached = Color.parse(input);
      this._parseColorCache.set(input, cached);
    }
    return cached;
  }
};
var ParsingContext = class _ParsingContext {
  constructor(registry, isConstantFunc, path = [], expectedType, scope = new Scope(), errors = []) {
    this.registry = registry;
    this.path = path;
    this.key = path.map((part) => `[${part}]`).join("");
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
    this._isConstant = isConstantFunc;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(expr, index, expectedType, bindings, options = {}) {
    if (index) {
      return this.concat(index, expectedType, bindings)._parse(expr, options);
    }
    return this._parse(expr, options);
  }
  _parse(expr, options) {
    if (expr === null || typeof expr === "string" || typeof expr === "boolean" || typeof expr === "number") {
      expr = ["literal", expr];
    }
    function annotate(parsed, type, typeAnnotation) {
      if (typeAnnotation === "assert") {
        return new Assertion(type, [parsed]);
      } else if (typeAnnotation === "coerce") {
        return new Coercion(type, [parsed]);
      } else {
        return parsed;
      }
    }
    if (Array.isArray(expr)) {
      if (expr.length === 0) {
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      }
      const op = expr[0];
      if (typeof op !== "string") {
        this.error(`Expression name must be a string, but found ${typeof op} instead. If you wanted a literal array, use ["literal", [...]].`, 0);
        return null;
      }
      const Expr = this.registry[op];
      if (Expr) {
        let parsed = Expr.parse(expr, this);
        if (!parsed)
          return null;
        if (this.expectedType) {
          const expected = this.expectedType;
          const actual = parsed.type;
          if ((expected.kind === "string" || expected.kind === "number" || expected.kind === "boolean" || expected.kind === "object" || expected.kind === "array") && actual.kind === "value") {
            parsed = annotate(parsed, expected, options.typeAnnotation || "assert");
          } else if ("projectionDefinition" === expected.kind && ["string", "array"].includes(actual.kind) || ["color", "formatted", "resolvedImage"].includes(expected.kind) && ["value", "string"].includes(actual.kind) || ["padding", "numberArray"].includes(expected.kind) && ["value", "number", "array"].includes(actual.kind) || "colorArray" === expected.kind && ["value", "string", "array"].includes(actual.kind) || "variableAnchorOffsetCollection" === expected.kind && ["value", "array"].includes(actual.kind)) {
            parsed = annotate(parsed, expected, options.typeAnnotation || "coerce");
          } else if (this.checkSubtype(expected, actual)) {
            return null;
          }
        }
        if (!(parsed instanceof Literal) && parsed.type.kind !== "resolvedImage" && this._isConstant(parsed)) {
          const ec = new EvaluationContext();
          try {
            parsed = new Literal(parsed.type, parsed.evaluate(ec));
          } catch (e) {
            this.error(e.message);
            return null;
          }
        }
        return parsed;
      }
      return this.error(`Unknown expression "${op}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else if (typeof expr === "undefined") {
      return this.error("'undefined' value invalid. Use null instead.");
    } else if (typeof expr === "object") {
      return this.error('Bare objects invalid. Use ["literal", {...}] instead.');
    } else {
      return this.error(`Expected an array, but found ${typeof expr} instead.`);
    }
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(index, expectedType, bindings) {
    const path = typeof index === "number" ? this.path.concat(index) : this.path;
    const scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new _ParsingContext(this.registry, this._isConstant, path, expectedType || null, scope, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(error2, ...keys) {
    const key = `${this.key}${keys.map((k) => `[${k}]`).join("")}`;
    this.errors.push(new ExpressionParsingError(key, error2));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   * @param expected The expected type
   * @param t The actual type
   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
   */
  checkSubtype(expected, t) {
    const error2 = checkSubtype(expected, t);
    if (error2)
      this.error(error2);
    return error2;
  }
};
var Let = class _Let {
  constructor(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
  }
  evaluate(ctx) {
    return this.result.evaluate(ctx);
  }
  eachChild(fn) {
    for (const binding of this.bindings) {
      fn(binding[1]);
    }
    fn(this.result);
  }
  static parse(args, context) {
    if (args.length < 4)
      return context.error(`Expected at least 3 arguments, but found ${args.length - 1} instead.`);
    const bindings = [];
    for (let i = 1; i < args.length - 1; i += 2) {
      const name = args[i];
      if (typeof name !== "string") {
        return context.error(`Expected string, but found ${typeof name} instead.`, i);
      }
      if (/[^a-zA-Z0-9_]/.test(name)) {
        return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
      }
      const value = context.parse(args[i + 1], i + 1);
      if (!value)
        return null;
      bindings.push([name, value]);
    }
    const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
    if (!result)
      return null;
    return new _Let(bindings, result);
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
var Var = class _Var {
  constructor(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
  }
  static parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== "string")
      return context.error("'var' expression requires exactly one string literal argument.");
    const name = args[1];
    if (!context.scope.has(name)) {
      return context.error(`Unknown variable "${name}". Make sure "${name}" has been bound in an enclosing "let" expression before using it.`, 1);
    }
    return new _Var(name, context.scope.get(name));
  }
  evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var At = class _At {
  constructor(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
  }
  static parse(args, context) {
    if (args.length !== 3)
      return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);
    const index = context.parse(args[1], 1, NumberType);
    const input = context.parse(args[2], 2, array(context.expectedType || ValueType));
    if (!index || !input)
      return null;
    const t = input.type;
    return new _At(t.itemType, index, input);
  }
  evaluate(ctx) {
    const index = this.index.evaluate(ctx);
    const array2 = this.input.evaluate(ctx);
    if (index < 0) {
      throw new RuntimeError(`Array index out of bounds: ${index} < 0.`);
    }
    if (index >= array2.length) {
      throw new RuntimeError(`Array index out of bounds: ${index} > ${array2.length - 1}.`);
    }
    if (index !== Math.floor(index)) {
      throw new RuntimeError(`Array index must be an integer, but found ${index} instead.`);
    }
    return array2[index];
  }
  eachChild(fn) {
    fn(this.index);
    fn(this.input);
  }
  outputDefined() {
    return false;
  }
};
var In = class _In {
  constructor(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
  }
  static parse(args, context) {
    if (args.length !== 3) {
      return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);
    }
    const needle = context.parse(args[1], 1, ValueType);
    const haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack)
      return null;
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
      return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(needle.type)} instead`);
    }
    return new _In(needle, haystack);
  }
  evaluate(ctx) {
    const needle = this.needle.evaluate(ctx);
    const haystack = this.haystack.evaluate(ctx);
    if (!haystack)
      return false;
    if (!isValidNativeType(needle, ["boolean", "string", "number", "null"])) {
      throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(typeOf(needle))} instead.`);
    }
    if (!isValidNativeType(haystack, ["string", "array"])) {
      throw new RuntimeError(`Expected second argument to be of type array or string, but found ${typeToString(typeOf(haystack))} instead.`);
    }
    return haystack.indexOf(needle) >= 0;
  }
  eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
var IndexOf = class _IndexOf {
  constructor(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
  }
  static parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
      return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);
    }
    const needle = context.parse(args[1], 1, ValueType);
    const haystack = context.parse(args[2], 2, ValueType);
    if (!needle || !haystack)
      return null;
    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
      return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(needle.type)} instead`);
    }
    if (args.length === 4) {
      const fromIndex = context.parse(args[3], 3, NumberType);
      if (!fromIndex)
        return null;
      return new _IndexOf(needle, haystack, fromIndex);
    } else {
      return new _IndexOf(needle, haystack);
    }
  }
  evaluate(ctx) {
    const needle = this.needle.evaluate(ctx);
    const haystack = this.haystack.evaluate(ctx);
    if (!isValidNativeType(needle, ["boolean", "string", "number", "null"])) {
      throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${typeToString(typeOf(needle))} instead.`);
    }
    let fromIndex;
    if (this.fromIndex) {
      fromIndex = this.fromIndex.evaluate(ctx);
    }
    if (isValidNativeType(haystack, ["string"])) {
      const rawIndex = haystack.indexOf(needle, fromIndex);
      if (rawIndex === -1) {
        return -1;
      } else {
        return [...haystack.slice(0, rawIndex)].length;
      }
    } else if (isValidNativeType(haystack, ["array"])) {
      return haystack.indexOf(needle, fromIndex);
    } else {
      throw new RuntimeError(`Expected second argument to be of type array or string, but found ${typeToString(typeOf(haystack))} instead.`);
    }
  }
  eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
    if (this.fromIndex) {
      fn(this.fromIndex);
    }
  }
  outputDefined() {
    return false;
  }
};
var Match = class _Match {
  constructor(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
  }
  static parse(args, context) {
    if (args.length < 5)
      return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
    if (args.length % 2 !== 1)
      return context.error("Expected an even number of arguments.");
    let inputType;
    let outputType;
    if (context.expectedType && context.expectedType.kind !== "value") {
      outputType = context.expectedType;
    }
    const cases = {};
    const outputs = [];
    for (let i = 2; i < args.length - 1; i += 2) {
      let labels = args[i];
      const value = args[i + 1];
      if (!Array.isArray(labels)) {
        labels = [labels];
      }
      const labelContext = context.concat(i);
      if (labels.length === 0) {
        return labelContext.error("Expected at least one branch label.");
      }
      for (const label of labels) {
        if (typeof label !== "number" && typeof label !== "string") {
          return labelContext.error("Branch labels must be numbers or strings.");
        } else if (typeof label === "number" && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
          return labelContext.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        } else if (typeof label === "number" && Math.floor(label) !== label) {
          return labelContext.error("Numeric branch labels must be integer values.");
        } else if (!inputType) {
          inputType = typeOf(label);
        } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
          return null;
        }
        if (typeof cases[String(label)] !== "undefined") {
          return labelContext.error("Branch labels must be unique.");
        }
        cases[String(label)] = outputs.length;
      }
      const result = context.parse(value, i, outputType);
      if (!result)
        return null;
      outputType = outputType || result.type;
      outputs.push(result);
    }
    const input = context.parse(args[1], 1, ValueType);
    if (!input)
      return null;
    const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise)
      return null;
    if (input.type.kind !== "value" && context.concat(1).checkSubtype(inputType, input.type)) {
      return null;
    }
    return new _Match(inputType, outputType, input, cases, outputs, otherwise);
  }
  evaluate(ctx) {
    const input = this.input.evaluate(ctx);
    const output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
  }
  eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((out) => out.outputDefined()) && this.otherwise.outputDefined();
  }
};
var Case = class _Case {
  constructor(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
  }
  static parse(args, context) {
    if (args.length < 4)
      return context.error(`Expected at least 3 arguments, but found only ${args.length - 1}.`);
    if (args.length % 2 !== 0)
      return context.error("Expected an odd number of arguments.");
    let outputType;
    if (context.expectedType && context.expectedType.kind !== "value") {
      outputType = context.expectedType;
    }
    const branches = [];
    for (let i = 1; i < args.length - 1; i += 2) {
      const test = context.parse(args[i], i, BooleanType);
      if (!test)
        return null;
      const result = context.parse(args[i + 1], i + 1, outputType);
      if (!result)
        return null;
      branches.push([test, result]);
      outputType = outputType || result.type;
    }
    const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
    if (!otherwise)
      return null;
    if (!outputType)
      throw new Error("Can't infer output type");
    return new _Case(outputType, branches, otherwise);
  }
  evaluate(ctx) {
    for (const [test, expression] of this.branches) {
      if (test.evaluate(ctx)) {
        return expression.evaluate(ctx);
      }
    }
    return this.otherwise.evaluate(ctx);
  }
  eachChild(fn) {
    for (const [test, expression] of this.branches) {
      fn(test);
      fn(expression);
    }
    fn(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([_, out]) => out.outputDefined()) && this.otherwise.outputDefined();
  }
};
var Slice = class _Slice {
  constructor(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
  }
  static parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
      return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);
    }
    const input = context.parse(args[1], 1, ValueType);
    const beginIndex = context.parse(args[2], 2, NumberType);
    if (!input || !beginIndex)
      return null;
    if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {
      return context.error(`Expected first argument to be of type array or string, but found ${typeToString(input.type)} instead`);
    }
    if (args.length === 4) {
      const endIndex = context.parse(args[3], 3, NumberType);
      if (!endIndex)
        return null;
      return new _Slice(input.type, input, beginIndex, endIndex);
    } else {
      return new _Slice(input.type, input, beginIndex);
    }
  }
  evaluate(ctx) {
    const input = this.input.evaluate(ctx);
    const beginIndex = this.beginIndex.evaluate(ctx);
    let endIndex;
    if (this.endIndex) {
      endIndex = this.endIndex.evaluate(ctx);
    }
    if (isValidNativeType(input, ["string"])) {
      return [...input].slice(beginIndex, endIndex).join("");
    } else if (isValidNativeType(input, ["array"])) {
      return input.slice(beginIndex, endIndex);
    } else {
      throw new RuntimeError(`Expected first argument to be of type array or string, but found ${typeToString(typeOf(input))} instead.`);
    }
  }
  eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);
    if (this.endIndex) {
      fn(this.endIndex);
    }
  }
  outputDefined() {
    return false;
  }
};
function findStopLessThanOrEqualTo(stops, input) {
  const lastIndex = stops.length - 1;
  let lowerIndex = 0;
  let upperIndex = lastIndex;
  let currentIndex = 0;
  let currentValue, nextValue;
  while (lowerIndex <= upperIndex) {
    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
    currentValue = stops[currentIndex];
    nextValue = stops[currentIndex + 1];
    if (currentValue <= input) {
      if (currentIndex === lastIndex || input < nextValue) {
        return currentIndex;
      }
      lowerIndex = currentIndex + 1;
    } else if (currentValue > input) {
      upperIndex = currentIndex - 1;
    } else {
      throw new RuntimeError("Input is not a number.");
    }
  }
  return 0;
}
var Step = class _Step {
  constructor(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (const [label, expression] of stops) {
      this.labels.push(label);
      this.outputs.push(expression);
    }
  }
  static parse(args, context) {
    if (args.length - 1 < 4) {
      return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
    }
    if ((args.length - 1) % 2 !== 0) {
      return context.error("Expected an even number of arguments.");
    }
    const input = context.parse(args[1], 1, NumberType);
    if (!input)
      return null;
    const stops = [];
    let outputType = null;
    if (context.expectedType && context.expectedType.kind !== "value") {
      outputType = context.expectedType;
    }
    for (let i = 1; i < args.length; i += 2) {
      const label = i === 1 ? -Infinity : args[i];
      const value = args[i + 1];
      const labelKey = i;
      const valueKey = i + 1;
      if (typeof label !== "number") {
        return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
      }
      if (stops.length && stops[stops.length - 1][0] >= label) {
        return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
      }
      const parsed = context.parse(value, valueKey, outputType);
      if (!parsed)
        return null;
      outputType = outputType || parsed.type;
      stops.push([label, parsed]);
    }
    return new _Step(outputType, input, stops);
  }
  evaluate(ctx) {
    const labels = this.labels;
    const outputs = this.outputs;
    if (labels.length === 1) {
      return outputs[0].evaluate(ctx);
    }
    const value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
      return outputs[0].evaluate(ctx);
    }
    const stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
      return outputs[stopCount - 1].evaluate(ctx);
    }
    const index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
  }
  eachChild(fn) {
    fn(this.input);
    for (const expression of this.outputs) {
      fn(expression);
    }
  }
  outputDefined() {
    return this.outputs.every((out) => out.outputDefined());
  }
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var unitbezier;
var hasRequiredUnitbezier;
function requireUnitbezier() {
  if (hasRequiredUnitbezier) return unitbezier;
  hasRequiredUnitbezier = 1;
  unitbezier = UnitBezier2;
  function UnitBezier2(p1x, p1y, p2x, p2y) {
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
    this.p1x = p1x;
    this.p1y = p1y;
    this.p2x = p2x;
    this.p2y = p2y;
  }
  UnitBezier2.prototype = {
    sampleCurveX: function(t) {
      return ((this.ax * t + this.bx) * t + this.cx) * t;
    },
    sampleCurveY: function(t) {
      return ((this.ay * t + this.by) * t + this.cy) * t;
    },
    sampleCurveDerivativeX: function(t) {
      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
    },
    solveCurveX: function(x, epsilon) {
      if (epsilon === void 0) epsilon = 1e-6;
      if (x < 0) return 0;
      if (x > 1) return 1;
      var t = x;
      for (var i = 0; i < 8; i++) {
        var x2 = this.sampleCurveX(t) - x;
        if (Math.abs(x2) < epsilon) return t;
        var d2 = this.sampleCurveDerivativeX(t);
        if (Math.abs(d2) < 1e-6) break;
        t = t - x2 / d2;
      }
      var t02 = 0;
      var t12 = 1;
      t = x;
      for (i = 0; i < 20; i++) {
        x2 = this.sampleCurveX(t);
        if (Math.abs(x2 - x) < epsilon) break;
        if (x > x2) {
          t02 = t;
        } else {
          t12 = t;
        }
        t = (t12 - t02) * 0.5 + t02;
      }
      return t;
    },
    solve: function(x, epsilon) {
      return this.sampleCurveY(this.solveCurveX(x, epsilon));
    }
  };
  return unitbezier;
}
var unitbezierExports = requireUnitbezier();
var UnitBezier = getDefaultExportFromCjs(unitbezierExports);
var Interpolate = class _Interpolate {
  constructor(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];
    for (const [label, expression] of stops) {
      this.labels.push(label);
      this.outputs.push(expression);
    }
  }
  static interpolationFactor(interpolation, input, lower, upper) {
    let t = 0;
    if (interpolation.name === "exponential") {
      t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === "linear") {
      t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === "cubic-bezier") {
      const c = interpolation.controlPoints;
      const ub = new UnitBezier(c[0], c[1], c[2], c[3]);
      t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }
    return t;
  }
  static parse(args, context) {
    let [operator, interpolation, input, ...rest] = args;
    if (!Array.isArray(interpolation) || interpolation.length === 0) {
      return context.error("Expected an interpolation type expression.", 1);
    }
    if (interpolation[0] === "linear") {
      interpolation = { name: "linear" };
    } else if (interpolation[0] === "exponential") {
      const base = interpolation[1];
      if (typeof base !== "number")
        return context.error("Exponential interpolation requires a numeric base.", 1, 1);
      interpolation = {
        name: "exponential",
        base
      };
    } else if (interpolation[0] === "cubic-bezier") {
      const controlPoints = interpolation.slice(1);
      if (controlPoints.length !== 4 || controlPoints.some((t) => typeof t !== "number" || t < 0 || t > 1)) {
        return context.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      }
      interpolation = {
        name: "cubic-bezier",
        controlPoints
      };
    } else {
      return context.error(`Unknown interpolation type ${String(interpolation[0])}`, 1, 0);
    }
    if (args.length - 1 < 4) {
      return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);
    }
    if ((args.length - 1) % 2 !== 0) {
      return context.error("Expected an even number of arguments.");
    }
    input = context.parse(input, 2, NumberType);
    if (!input)
      return null;
    const stops = [];
    let outputType = null;
    if ((operator === "interpolate-hcl" || operator === "interpolate-lab") && context.expectedType != ColorArrayType) {
      outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== "value") {
      outputType = context.expectedType;
    }
    for (let i = 0; i < rest.length; i += 2) {
      const label = rest[i];
      const value = rest[i + 1];
      const labelKey = i + 3;
      const valueKey = i + 4;
      if (typeof label !== "number") {
        return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
      }
      if (stops.length && stops[stops.length - 1][0] >= label) {
        return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
      }
      const parsed = context.parse(value, valueKey, outputType);
      if (!parsed)
        return null;
      outputType = outputType || parsed.type;
      stops.push([label, parsed]);
    }
    if (!verifyType(outputType, NumberType) && !verifyType(outputType, ProjectionDefinitionType) && !verifyType(outputType, ColorType) && !verifyType(outputType, PaddingType) && !verifyType(outputType, NumberArrayType) && !verifyType(outputType, ColorArrayType) && !verifyType(outputType, VariableAnchorOffsetCollectionType) && !verifyType(outputType, array(NumberType))) {
      return context.error(`Type ${typeToString(outputType)} is not interpolatable.`);
    }
    return new _Interpolate(outputType, operator, interpolation, input, stops);
  }
  evaluate(ctx) {
    const labels = this.labels;
    const outputs = this.outputs;
    if (labels.length === 1) {
      return outputs[0].evaluate(ctx);
    }
    const value = this.input.evaluate(ctx);
    if (value <= labels[0]) {
      return outputs[0].evaluate(ctx);
    }
    const stopCount = labels.length;
    if (value >= labels[stopCount - 1]) {
      return outputs[stopCount - 1].evaluate(ctx);
    }
    const index = findStopLessThanOrEqualTo(labels, value);
    const lower = labels[index];
    const upper = labels[index + 1];
    const t = _Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    const outputLower = outputs[index].evaluate(ctx);
    const outputUpper = outputs[index + 1].evaluate(ctx);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return interpolateNumber(outputLower, outputUpper, t);
          case "color":
            return Color.interpolate(outputLower, outputUpper, t);
          case "padding":
            return Padding.interpolate(outputLower, outputUpper, t);
          case "colorArray":
            return ColorArray.interpolate(outputLower, outputUpper, t);
          case "numberArray":
            return NumberArray.interpolate(outputLower, outputUpper, t);
          case "variableAnchorOffsetCollection":
            return VariableAnchorOffsetCollection.interpolate(outputLower, outputUpper, t);
          case "array":
            return interpolateArray(outputLower, outputUpper, t);
          case "projectionDefinition":
            return ProjectionDefinition.interpolate(outputLower, outputUpper, t);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return Color.interpolate(outputLower, outputUpper, t, "hcl");
          case "colorArray":
            return ColorArray.interpolate(outputLower, outputUpper, t, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return Color.interpolate(outputLower, outputUpper, t, "lab");
          case "colorArray":
            return ColorArray.interpolate(outputLower, outputUpper, t, "lab");
        }
    }
  }
  eachChild(fn) {
    fn(this.input);
    for (const expression of this.outputs) {
      fn(expression);
    }
  }
  outputDefined() {
    return this.outputs.every((out) => out.outputDefined());
  }
};
function exponentialInterpolation(input, base, lowerValue, upperValue) {
  const difference = upperValue - lowerValue;
  const progress = input - lowerValue;
  if (difference === 0) {
    return 0;
  } else if (base === 1) {
    return progress / difference;
  } else {
    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
  }
}
var interpolateFactory = {
  color: Color.interpolate,
  number: interpolateNumber,
  padding: Padding.interpolate,
  numberArray: NumberArray.interpolate,
  colorArray: ColorArray.interpolate,
  variableAnchorOffsetCollection: VariableAnchorOffsetCollection.interpolate,
  array: interpolateArray
};
var Coalesce = class _Coalesce {
  constructor(type, args) {
    this.type = type;
    this.args = args;
  }
  static parse(args, context) {
    if (args.length < 2) {
      return context.error("Expected at least one argument.");
    }
    let outputType = null;
    const expectedType = context.expectedType;
    if (expectedType && expectedType.kind !== "value") {
      outputType = expectedType;
    }
    const parsedArgs = [];
    for (const arg of args.slice(1)) {
      const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, void 0, { typeAnnotation: "omit" });
      if (!parsed)
        return null;
      outputType = outputType || parsed.type;
      parsedArgs.push(parsed);
    }
    if (!outputType)
      throw new Error("No output type");
    const needsAnnotation = expectedType && parsedArgs.some((arg) => checkSubtype(expectedType, arg.type));
    return needsAnnotation ? new _Coalesce(ValueType, parsedArgs) : new _Coalesce(outputType, parsedArgs);
  }
  evaluate(ctx) {
    let result = null;
    let argCount = 0;
    let requestedImageName;
    for (const arg of this.args) {
      argCount++;
      result = arg.evaluate(ctx);
      if (result && result instanceof ResolvedImage && !result.available) {
        if (!requestedImageName) {
          requestedImageName = result.name;
        }
        result = null;
        if (argCount === this.args.length) {
          result = requestedImageName;
        }
      }
      if (result !== null)
        break;
    }
    return result;
  }
  eachChild(fn) {
    this.args.forEach(fn);
  }
  outputDefined() {
    return this.args.every((arg) => arg.outputDefined());
  }
};
function isComparableType(op, type) {
  if (op === "==" || op === "!=") {
    return type.kind === "boolean" || type.kind === "string" || type.kind === "number" || type.kind === "null" || type.kind === "value";
  } else {
    return type.kind === "string" || type.kind === "number" || type.kind === "value";
  }
}
function eq(ctx, a, b) {
  return a === b;
}
function neq(ctx, a, b) {
  return a !== b;
}
function lt(ctx, a, b) {
  return a < b;
}
function gt(ctx, a, b) {
  return a > b;
}
function lteq(ctx, a, b) {
  return a <= b;
}
function gteq(ctx, a, b) {
  return a >= b;
}
function eqCollate(ctx, a, b, c) {
  return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
  return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
  return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
  return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
  return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
  return c.compare(a, b) >= 0;
}
function makeComparison(op, compareBasic, compareWithCollator) {
  const isOrderComparison = op !== "==" && op !== "!=";
  return class Comparison {
    constructor(lhs, rhs, collator) {
      this.type = BooleanType;
      this.lhs = lhs;
      this.rhs = rhs;
      this.collator = collator;
      this.hasUntypedArgument = lhs.type.kind === "value" || rhs.type.kind === "value";
    }
    static parse(args, context) {
      if (args.length !== 3 && args.length !== 4)
        return context.error("Expected two or three arguments.");
      const op2 = args[0];
      let lhs = context.parse(args[1], 1, ValueType);
      if (!lhs)
        return null;
      if (!isComparableType(op2, lhs.type)) {
        return context.concat(1).error(`"${op2}" comparisons are not supported for type '${typeToString(lhs.type)}'.`);
      }
      let rhs = context.parse(args[2], 2, ValueType);
      if (!rhs)
        return null;
      if (!isComparableType(op2, rhs.type)) {
        return context.concat(2).error(`"${op2}" comparisons are not supported for type '${typeToString(rhs.type)}'.`);
      }
      if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== "value" && rhs.type.kind !== "value") {
        return context.error(`Cannot compare types '${typeToString(lhs.type)}' and '${typeToString(rhs.type)}'.`);
      }
      if (isOrderComparison) {
        if (lhs.type.kind === "value" && rhs.type.kind !== "value") {
          lhs = new Assertion(rhs.type, [lhs]);
        } else if (lhs.type.kind !== "value" && rhs.type.kind === "value") {
          rhs = new Assertion(lhs.type, [rhs]);
        }
      }
      let collator = null;
      if (args.length === 4) {
        if (lhs.type.kind !== "string" && rhs.type.kind !== "string" && lhs.type.kind !== "value" && rhs.type.kind !== "value") {
          return context.error("Cannot use collator to compare non-string types.");
        }
        collator = context.parse(args[3], 3, CollatorType);
        if (!collator)
          return null;
      }
      return new Comparison(lhs, rhs, collator);
    }
    evaluate(ctx) {
      const lhs = this.lhs.evaluate(ctx);
      const rhs = this.rhs.evaluate(ctx);
      if (isOrderComparison && this.hasUntypedArgument) {
        const lt2 = typeOf(lhs);
        const rt = typeOf(rhs);
        if (lt2.kind !== rt.kind || !(lt2.kind === "string" || lt2.kind === "number")) {
          throw new RuntimeError(`Expected arguments for "${op}" to be (string, string) or (number, number), but found (${lt2.kind}, ${rt.kind}) instead.`);
        }
      }
      if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
        const lt2 = typeOf(lhs);
        const rt = typeOf(rhs);
        if (lt2.kind !== "string" || rt.kind !== "string") {
          return compareBasic(ctx, lhs, rhs);
        }
      }
      return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
    }
    eachChild(fn) {
      fn(this.lhs);
      fn(this.rhs);
      if (this.collator) {
        fn(this.collator);
      }
    }
    outputDefined() {
      return true;
    }
  };
}
var Equals = makeComparison("==", eq, eqCollate);
var NotEquals = makeComparison("!=", neq, neqCollate);
var LessThan = makeComparison("<", lt, ltCollate);
var GreaterThan = makeComparison(">", gt, gtCollate);
var LessThanOrEqual = makeComparison("<=", lteq, lteqCollate);
var GreaterThanOrEqual = makeComparison(">=", gteq, gteqCollate);
var CollatorExpression = class _CollatorExpression {
  constructor(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
  }
  static parse(args, context) {
    if (args.length !== 2)
      return context.error("Expected one argument.");
    const options = args[1];
    if (typeof options !== "object" || Array.isArray(options))
      return context.error("Collator options argument must be an object.");
    const caseSensitive = context.parse(options["case-sensitive"] === void 0 ? false : options["case-sensitive"], 1, BooleanType);
    if (!caseSensitive)
      return null;
    const diacriticSensitive = context.parse(options["diacritic-sensitive"] === void 0 ? false : options["diacritic-sensitive"], 1, BooleanType);
    if (!diacriticSensitive)
      return null;
    let locale = null;
    if (options["locale"]) {
      locale = context.parse(options["locale"], 1, StringType);
      if (!locale)
        return null;
    }
    return new _CollatorExpression(caseSensitive, diacriticSensitive, locale);
  }
  evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
  }
  eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);
    if (this.locale) {
      fn(this.locale);
    }
  }
  outputDefined() {
    return false;
  }
};
var NumberFormat = class _NumberFormat {
  constructor(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
  }
  static parse(args, context) {
    if (args.length !== 3)
      return context.error("Expected two arguments.");
    const number = context.parse(args[1], 1, NumberType);
    if (!number)
      return null;
    const options = args[2];
    if (typeof options !== "object" || Array.isArray(options))
      return context.error("NumberFormat options argument must be an object.");
    let locale = null;
    if (options["locale"]) {
      locale = context.parse(options["locale"], 1, StringType);
      if (!locale)
        return null;
    }
    let currency = null;
    if (options["currency"]) {
      currency = context.parse(options["currency"], 1, StringType);
      if (!currency)
        return null;
    }
    let minFractionDigits = null;
    if (options["min-fraction-digits"]) {
      minFractionDigits = context.parse(options["min-fraction-digits"], 1, NumberType);
      if (!minFractionDigits)
        return null;
    }
    let maxFractionDigits = null;
    if (options["max-fraction-digits"]) {
      maxFractionDigits = context.parse(options["max-fraction-digits"], 1, NumberType);
      if (!maxFractionDigits)
        return null;
    }
    return new _NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
  }
  evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
      style: this.currency ? "currency" : "decimal",
      currency: this.currency ? this.currency.evaluate(ctx) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : void 0
    }).format(this.number.evaluate(ctx));
  }
  eachChild(fn) {
    fn(this.number);
    if (this.locale) {
      fn(this.locale);
    }
    if (this.currency) {
      fn(this.currency);
    }
    if (this.minFractionDigits) {
      fn(this.minFractionDigits);
    }
    if (this.maxFractionDigits) {
      fn(this.maxFractionDigits);
    }
  }
  outputDefined() {
    return false;
  }
};
var FormatExpression = class _FormatExpression {
  constructor(sections) {
    this.type = FormattedType;
    this.sections = sections;
  }
  static parse(args, context) {
    if (args.length < 2) {
      return context.error("Expected at least one argument.");
    }
    const firstArg = args[1];
    if (!Array.isArray(firstArg) && typeof firstArg === "object") {
      return context.error("First argument must be an image or text section.");
    }
    const sections = [];
    let nextTokenMayBeObject = false;
    for (let i = 1; i <= args.length - 1; ++i) {
      const arg = args[i];
      if (nextTokenMayBeObject && typeof arg === "object" && !Array.isArray(arg)) {
        nextTokenMayBeObject = false;
        let scale2 = null;
        if (arg["font-scale"]) {
          scale2 = context.parse(arg["font-scale"], 1, NumberType);
          if (!scale2)
            return null;
        }
        let font = null;
        if (arg["text-font"]) {
          font = context.parse(arg["text-font"], 1, array(StringType));
          if (!font)
            return null;
        }
        let textColor = null;
        if (arg["text-color"]) {
          textColor = context.parse(arg["text-color"], 1, ColorType);
          if (!textColor)
            return null;
        }
        let verticalAlign = null;
        if (arg["vertical-align"]) {
          if (typeof arg["vertical-align"] === "string" && !VERTICAL_ALIGN_OPTIONS.includes(arg["vertical-align"])) {
            return context.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${arg["vertical-align"]}' instead.`);
          }
          verticalAlign = context.parse(arg["vertical-align"], 1, StringType);
          if (!verticalAlign)
            return null;
        }
        const lastExpression = sections[sections.length - 1];
        lastExpression.scale = scale2;
        lastExpression.font = font;
        lastExpression.textColor = textColor;
        lastExpression.verticalAlign = verticalAlign;
      } else {
        const content = context.parse(args[i], 1, ValueType);
        if (!content)
          return null;
        const kind = content.type.kind;
        if (kind !== "string" && kind !== "value" && kind !== "null" && kind !== "resolvedImage")
          return context.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        nextTokenMayBeObject = true;
        sections.push({ content, scale: null, font: null, textColor: null, verticalAlign: null });
      }
    }
    return new _FormatExpression(sections);
  }
  evaluate(ctx) {
    const evaluateSection = (section) => {
      const evaluatedContent = section.content.evaluate(ctx);
      if (typeOf(evaluatedContent) === ResolvedImageType) {
        return new FormattedSection("", evaluatedContent, null, null, null, section.verticalAlign ? section.verticalAlign.evaluate(ctx) : null);
      }
      return new FormattedSection(valueToString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(",") : null, section.textColor ? section.textColor.evaluate(ctx) : null, section.verticalAlign ? section.verticalAlign.evaluate(ctx) : null);
    };
    return new Formatted(this.sections.map(evaluateSection));
  }
  eachChild(fn) {
    for (const section of this.sections) {
      fn(section.content);
      if (section.scale) {
        fn(section.scale);
      }
      if (section.font) {
        fn(section.font);
      }
      if (section.textColor) {
        fn(section.textColor);
      }
      if (section.verticalAlign) {
        fn(section.verticalAlign);
      }
    }
  }
  outputDefined() {
    return false;
  }
};
var ImageExpression = class _ImageExpression {
  constructor(input) {
    this.type = ResolvedImageType;
    this.input = input;
  }
  static parse(args, context) {
    if (args.length !== 2) {
      return context.error("Expected two arguments.");
    }
    const name = context.parse(args[1], 1, StringType);
    if (!name)
      return context.error("No image name provided.");
    return new _ImageExpression(name);
  }
  evaluate(ctx) {
    const evaluatedImageName = this.input.evaluate(ctx);
    const value = ResolvedImage.fromString(evaluatedImageName);
    if (value && ctx.availableImages)
      value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    return value;
  }
  eachChild(fn) {
    fn(this.input);
  }
  outputDefined() {
    return false;
  }
};
var Length = class _Length {
  constructor(input) {
    this.type = NumberType;
    this.input = input;
  }
  static parse(args, context) {
    if (args.length !== 2)
      return context.error(`Expected 1 argument, but found ${args.length - 1} instead.`);
    const input = context.parse(args[1], 1);
    if (!input)
      return null;
    if (input.type.kind !== "array" && input.type.kind !== "string" && input.type.kind !== "value")
      return context.error(`Expected argument of type string or array, but found ${typeToString(input.type)} instead.`);
    return new _Length(input);
  }
  evaluate(ctx) {
    const input = this.input.evaluate(ctx);
    if (typeof input === "string") {
      return [...input].length;
    } else if (Array.isArray(input)) {
      return input.length;
    } else {
      throw new RuntimeError(`Expected value to be of type string or array, but found ${typeToString(typeOf(input))} instead.`);
    }
  }
  eachChild(fn) {
    fn(this.input);
  }
  outputDefined() {
    return false;
  }
};
var EXTENT = 8192;
function getTileCoordinates(p, canonical) {
  const x = mercatorXfromLng(p[0]);
  const y = mercatorYfromLat(p[1]);
  const tilesAtZoom = Math.pow(2, canonical.z);
  return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
}
function getLngLatFromTileCoord(coord, canonical) {
  const tilesAtZoom = Math.pow(2, canonical.z);
  const x = (coord[0] / EXTENT + canonical.x) / tilesAtZoom;
  const y = (coord[1] / EXTENT + canonical.y) / tilesAtZoom;
  return [lngFromMercatorXfromLng(x), latFromMercatorY(y)];
}
function mercatorXfromLng(lng) {
  return (180 + lng) / 360;
}
function lngFromMercatorXfromLng(mercatorX) {
  return mercatorX * 360 - 180;
}
function mercatorYfromLat(lat) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function latFromMercatorY(mercatorY) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - mercatorY * 360) * Math.PI / 180)) - 90;
}
function updateBBox(bbox2, coord) {
  bbox2[0] = Math.min(bbox2[0], coord[0]);
  bbox2[1] = Math.min(bbox2[1], coord[1]);
  bbox2[2] = Math.max(bbox2[2], coord[0]);
  bbox2[3] = Math.max(bbox2[3], coord[1]);
}
function boxWithinBox(bbox1, bbox2) {
  if (bbox1[0] <= bbox2[0])
    return false;
  if (bbox1[2] >= bbox2[2])
    return false;
  if (bbox1[1] <= bbox2[1])
    return false;
  if (bbox1[3] >= bbox2[3])
    return false;
  return true;
}
function rayIntersect(p, p1, p2) {
  return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
function pointOnBoundary(p, p1, p2) {
  const x1 = p[0] - p1[0];
  const y1 = p[1] - p1[1];
  const x2 = p[0] - p2[0];
  const y2 = p[1] - p2[1];
  return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function segmentIntersectSegment(a, b, c, d) {
  const vectorP = [b[0] - a[0], b[1] - a[1]];
  const vectorQ = [d[0] - c[0], d[1] - c[1]];
  if (perp(vectorQ, vectorP) === 0)
    return false;
  if (twoSided(a, b, c, d) && twoSided(c, d, a, b))
    return true;
  return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
  for (const ring of polygon) {
    for (let j = 0; j < ring.length - 1; ++j) {
      if (segmentIntersectSegment(p1, p2, ring[j], ring[j + 1])) {
        return true;
      }
    }
  }
  return false;
}
function pointWithinPolygon(point, rings, trueIfOnBoundary = false) {
  let inside = false;
  for (const ring of rings) {
    for (let j = 0; j < ring.length - 1; j++) {
      if (pointOnBoundary(point, ring[j], ring[j + 1]))
        return trueIfOnBoundary;
      if (rayIntersect(point, ring[j], ring[j + 1]))
        inside = !inside;
    }
  }
  return inside;
}
function pointWithinPolygons(point, polygons) {
  for (const polygon of polygons) {
    if (pointWithinPolygon(point, polygon))
      return true;
  }
  return false;
}
function lineStringWithinPolygon(line, polygon) {
  for (const point of line) {
    if (!pointWithinPolygon(point, polygon)) {
      return false;
    }
  }
  for (let i = 0; i < line.length - 1; ++i) {
    if (lineIntersectPolygon(line[i], line[i + 1], polygon)) {
      return false;
    }
  }
  return true;
}
function lineStringWithinPolygons(line, polygons) {
  for (const polygon of polygons) {
    if (lineStringWithinPolygon(line, polygon))
      return true;
  }
  return false;
}
function perp(v1, v2) {
  return v1[0] * v2[1] - v1[1] * v2[0];
}
function twoSided(p1, p2, q1, q2) {
  const x1 = p1[0] - q1[0];
  const y1 = p1[1] - q1[1];
  const x2 = p2[0] - q1[0];
  const y2 = p2[1] - q1[1];
  const x3 = q2[0] - q1[0];
  const y3 = q2[1] - q1[1];
  const det1 = x1 * y3 - x3 * y1;
  const det2 = x2 * y3 - x3 * y2;
  if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0)
    return true;
  return false;
}
function getTilePolygon(coordinates, bbox2, canonical) {
  const polygon = [];
  for (let i = 0; i < coordinates.length; i++) {
    const ring = [];
    for (let j = 0; j < coordinates[i].length; j++) {
      const coord = getTileCoordinates(coordinates[i][j], canonical);
      updateBBox(bbox2, coord);
      ring.push(coord);
    }
    polygon.push(ring);
  }
  return polygon;
}
function getTilePolygons(coordinates, bbox2, canonical) {
  const polygons = [];
  for (let i = 0; i < coordinates.length; i++) {
    const polygon = getTilePolygon(coordinates[i], bbox2, canonical);
    polygons.push(polygon);
  }
  return polygons;
}
function updatePoint(p, bbox2, polyBBox, worldSize) {
  if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
    const halfWorldSize = worldSize * 0.5;
    let shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
    if (shift === 0) {
      shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
    }
    p[0] += shift;
  }
  updateBBox(bbox2, p);
}
function resetBBox(bbox2) {
  bbox2[0] = bbox2[1] = Infinity;
  bbox2[2] = bbox2[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
  const worldSize = Math.pow(2, canonical.z) * EXTENT;
  const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
  const tilePoints = [];
  for (const points of geometry) {
    for (const point of points) {
      const p = [point.x + shifts[0], point.y + shifts[1]];
      updatePoint(p, pointBBox, polyBBox, worldSize);
      tilePoints.push(p);
    }
  }
  return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
  const worldSize = Math.pow(2, canonical.z) * EXTENT;
  const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
  const tileLines = [];
  for (const line of geometry) {
    const tileLine = [];
    for (const point of line) {
      const p = [point.x + shifts[0], point.y + shifts[1]];
      updateBBox(lineBBox, p);
      tileLine.push(p);
    }
    tileLines.push(tileLine);
  }
  if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
    resetBBox(lineBBox);
    for (const line of tileLines) {
      for (const p of line) {
        updatePoint(p, lineBBox, polyBBox, worldSize);
      }
    }
  }
  return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
  const pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
  const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
  const canonical = ctx.canonicalID();
  if (polygonGeometry.type === "Polygon") {
    const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
    const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
    if (!boxWithinBox(pointBBox, polyBBox))
      return false;
    for (const point of tilePoints) {
      if (!pointWithinPolygon(point, tilePolygon))
        return false;
    }
  }
  if (polygonGeometry.type === "MultiPolygon") {
    const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
    const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
    if (!boxWithinBox(pointBBox, polyBBox))
      return false;
    for (const point of tilePoints) {
      if (!pointWithinPolygons(point, tilePolygons))
        return false;
    }
  }
  return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
  const lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
  const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
  const canonical = ctx.canonicalID();
  if (polygonGeometry.type === "Polygon") {
    const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
    const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
    if (!boxWithinBox(lineBBox, polyBBox))
      return false;
    for (const line of tileLines) {
      if (!lineStringWithinPolygon(line, tilePolygon))
        return false;
    }
  }
  if (polygonGeometry.type === "MultiPolygon") {
    const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
    const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
    if (!boxWithinBox(lineBBox, polyBBox))
      return false;
    for (const line of tileLines) {
      if (!lineStringWithinPolygons(line, tilePolygons))
        return false;
    }
  }
  return true;
}
var Within = class _Within {
  constructor(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
  }
  static parse(args, context) {
    if (args.length !== 2)
      return context.error(`'within' expression requires exactly one argument, but found ${args.length - 1} instead.`);
    if (isValue(args[1])) {
      const geojson = args[1];
      if (geojson.type === "FeatureCollection") {
        const polygonsCoords = [];
        for (const polygon of geojson.features) {
          const { type, coordinates } = polygon.geometry;
          if (type === "Polygon") {
            polygonsCoords.push(coordinates);
          }
          if (type === "MultiPolygon") {
            polygonsCoords.push(...coordinates);
          }
        }
        if (polygonsCoords.length) {
          const multipolygonWrapper = {
            type: "MultiPolygon",
            coordinates: polygonsCoords
          };
          return new _Within(geojson, multipolygonWrapper);
        }
      } else if (geojson.type === "Feature") {
        const type = geojson.geometry.type;
        if (type === "Polygon" || type === "MultiPolygon") {
          return new _Within(geojson, geojson.geometry);
        }
      } else if (geojson.type === "Polygon" || geojson.type === "MultiPolygon") {
        return new _Within(geojson, geojson);
      }
    }
    return context.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
      if (ctx.geometryType() === "Point") {
        return pointsWithinPolygons(ctx, this.geometries);
      } else if (ctx.geometryType() === "LineString") {
        return linesWithinPolygons(ctx, this.geometries);
      }
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var TinyQueue = class {
  constructor(data = [], compare2 = (a, b) => a < b ? -1 : a > b ? 1 : 0) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare2;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    if (--this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare: compare2 } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare2(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare: compare2 } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let bestChild = (pos << 1) + 1;
      const right = bestChild + 1;
      if (right < this.length && compare2(data[right], data[bestChild]) < 0) {
        bestChild = right;
      }
      if (compare2(data[bestChild], item) >= 0) break;
      data[pos] = data[bestChild];
      pos = bestChild;
    }
    data[pos] = item;
  }
};
function quickselect(arr, k, left = 0, right = arr.length - 1, compare2 = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare2);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare2(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare2(arr[i], t) < 0) i++;
      while (compare2(arr[j], t) > 0) j--;
    }
    if (compare2(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function classifyRings(rings, maxRings) {
  const len = rings.length;
  if (len <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (const ring of rings) {
    const area = calculateSignedArea(ring);
    if (area === 0)
      continue;
    ring.area = Math.abs(area);
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [ring];
    } else {
      polygon.push(ring);
    }
  }
  if (polygon)
    polygons.push(polygon);
  if (maxRings > 1) {
    for (let j = 0; j < polygons.length; j++) {
      if (polygons[j].length <= maxRings)
        continue;
      quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);
      polygons[j] = polygons[j].slice(0, maxRings);
    }
  }
  return polygons;
}
function compareAreas(a, b) {
  return b.area - a.area;
}
function calculateSignedArea(ring) {
  let sum = 0;
  for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2.x - p1.x) * (p1.y + p2.y);
  }
  return sum;
}
var RE = 6378.137;
var FE = 1 / 298.257223563;
var E2 = FE * (2 - FE);
var RAD = Math.PI / 180;
var CheapRuler = class {
  constructor(lat) {
    const m = RAD * RE * 1e3;
    const coslat = Math.cos(lat * RAD);
    const w2 = 1 / (1 - E2 * (1 - coslat * coslat));
    const w = Math.sqrt(w2);
    this.kx = m * w * coslat;
    this.ky = m * w * w2 * (1 - E2);
  }
  /**
   * Given two points of the form [longitude, latitude], returns the distance.
   *
   * @param a - point [longitude, latitude]
   * @param b - point [longitude, latitude]
   * @returns distance
   * @example
   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
   * //=distance
   */
  distance(a, b) {
    const dx = this.wrap(a[0] - b[0]) * this.kx;
    const dy = (a[1] - b[1]) * this.ky;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Returns an object of the form {point, index, t}, where point is closest point on the line
   * from the given point, index is the start index of the segment with the closest point,
   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
   *
   * @param line - an array of points that form the line
   * @param p - point [longitude, latitude]
   * @returns the nearest point, its index in the array and the proportion along the line
   * @example
   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
   * //=point
   */
  pointOnLine(line, p) {
    let minDist = Infinity;
    let minX, minY, minI, minT;
    for (let i = 0; i < line.length - 1; i++) {
      let x = line[i][0];
      let y = line[i][1];
      let dx = this.wrap(line[i + 1][0] - x) * this.kx;
      let dy = (line[i + 1][1] - y) * this.ky;
      let t = 0;
      if (dx !== 0 || dy !== 0) {
        t = (this.wrap(p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x = line[i + 1][0];
          y = line[i + 1][1];
        } else if (t > 0) {
          x += dx / this.kx * t;
          y += dy / this.ky * t;
        }
      }
      dx = this.wrap(p[0] - x) * this.kx;
      dy = (p[1] - y) * this.ky;
      const sqDist = dx * dx + dy * dy;
      if (sqDist < minDist) {
        minDist = sqDist;
        minX = x;
        minY = y;
        minI = i;
        minT = t;
      }
    }
    return {
      point: [minX, minY],
      index: minI,
      t: Math.max(0, Math.min(1, minT))
    };
  }
  wrap(deg) {
    while (deg < -180)
      deg += 360;
    while (deg > 180)
      deg -= 360;
    return deg;
  }
};
var MinPointsSize = 100;
var MinLinePointsSize = 50;
function compareDistPair(a, b) {
  return b[0] - a[0];
}
function getRangeSize(range) {
  return range[1] - range[0] + 1;
}
function isRangeSafe(range, threshold) {
  return range[1] >= range[0] && range[1] < threshold;
}
function splitRange(range, isLine) {
  if (range[0] > range[1]) {
    return [null, null];
  }
  const size = getRangeSize(range);
  if (isLine) {
    if (size === 2) {
      return [range, null];
    }
    const size12 = Math.floor(size / 2);
    return [
      [range[0], range[0] + size12],
      [range[0] + size12, range[1]]
    ];
  }
  if (size === 1) {
    return [range, null];
  }
  const size1 = Math.floor(size / 2) - 1;
  return [
    [range[0], range[0] + size1],
    [range[0] + size1 + 1, range[1]]
  ];
}
function getBBox(coords, range) {
  if (!isRangeSafe(range, coords.length)) {
    return [Infinity, Infinity, -Infinity, -Infinity];
  }
  const bbox2 = [Infinity, Infinity, -Infinity, -Infinity];
  for (let i = range[0]; i <= range[1]; ++i) {
    updateBBox(bbox2, coords[i]);
  }
  return bbox2;
}
function getPolygonBBox(polygon) {
  const bbox2 = [Infinity, Infinity, -Infinity, -Infinity];
  for (const ring of polygon) {
    for (const coord of ring) {
      updateBBox(bbox2, coord);
    }
  }
  return bbox2;
}
function isValidBBox(bbox2) {
  return bbox2[0] !== -Infinity && bbox2[1] !== -Infinity && bbox2[2] !== Infinity && bbox2[3] !== Infinity;
}
function bboxToBBoxDistance(bbox1, bbox2, ruler) {
  if (!isValidBBox(bbox1) || !isValidBBox(bbox2)) {
    return NaN;
  }
  let dx = 0;
  let dy = 0;
  if (bbox1[2] < bbox2[0]) {
    dx = bbox2[0] - bbox1[2];
  }
  if (bbox1[0] > bbox2[2]) {
    dx = bbox1[0] - bbox2[2];
  }
  if (bbox1[1] > bbox2[3]) {
    dy = bbox1[1] - bbox2[3];
  }
  if (bbox1[3] < bbox2[1]) {
    dy = bbox2[1] - bbox1[3];
  }
  return ruler.distance([0, 0], [dx, dy]);
}
function pointToLineDistance(point, line, ruler) {
  const nearestPoint = ruler.pointOnLine(line, point);
  return ruler.distance(point, nearestPoint.point);
}
function segmentToSegmentDistance(p1, p2, q1, q2, ruler) {
  const dist1 = Math.min(pointToLineDistance(p1, [q1, q2], ruler), pointToLineDistance(p2, [q1, q2], ruler));
  const dist2 = Math.min(pointToLineDistance(q1, [p1, p2], ruler), pointToLineDistance(q2, [p1, p2], ruler));
  return Math.min(dist1, dist2);
}
function lineToLineDistance(line1, range1, line2, range2, ruler) {
  const rangeSafe = isRangeSafe(range1, line1.length) && isRangeSafe(range2, line2.length);
  if (!rangeSafe) {
    return Infinity;
  }
  let dist = Infinity;
  for (let i = range1[0]; i < range1[1]; ++i) {
    const p1 = line1[i];
    const p2 = line1[i + 1];
    for (let j = range2[0]; j < range2[1]; ++j) {
      const q1 = line2[j];
      const q2 = line2[j + 1];
      if (segmentIntersectSegment(p1, p2, q1, q2)) {
        return 0;
      }
      dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));
    }
  }
  return dist;
}
function pointsToPointsDistance(points1, range1, points2, range2, ruler) {
  const rangeSafe = isRangeSafe(range1, points1.length) && isRangeSafe(range2, points2.length);
  if (!rangeSafe) {
    return NaN;
  }
  let dist = Infinity;
  for (let i = range1[0]; i <= range1[1]; ++i) {
    for (let j = range2[0]; j <= range2[1]; ++j) {
      dist = Math.min(dist, ruler.distance(points1[i], points2[j]));
      if (dist === 0) {
        return dist;
      }
    }
  }
  return dist;
}
function pointToPolygonDistance(point, polygon, ruler) {
  if (pointWithinPolygon(point, polygon, true)) {
    return 0;
  }
  let dist = Infinity;
  for (const ring of polygon) {
    const front = ring[0];
    const back = ring[ring.length - 1];
    if (front !== back) {
      dist = Math.min(dist, pointToLineDistance(point, [back, front], ruler));
      if (dist === 0) {
        return dist;
      }
    }
    const nearestPoint = ruler.pointOnLine(ring, point);
    dist = Math.min(dist, ruler.distance(point, nearestPoint.point));
    if (dist === 0) {
      return dist;
    }
  }
  return dist;
}
function lineToPolygonDistance(line, range, polygon, ruler) {
  if (!isRangeSafe(range, line.length)) {
    return NaN;
  }
  for (let i = range[0]; i <= range[1]; ++i) {
    if (pointWithinPolygon(line[i], polygon, true)) {
      return 0;
    }
  }
  let dist = Infinity;
  for (let i = range[0]; i < range[1]; ++i) {
    const p1 = line[i];
    const p2 = line[i + 1];
    for (const ring of polygon) {
      for (let j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
        const q1 = ring[k];
        const q2 = ring[j];
        if (segmentIntersectSegment(p1, p2, q1, q2)) {
          return 0;
        }
        dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));
      }
    }
  }
  return dist;
}
function polygonIntersect(poly1, poly2) {
  for (const ring of poly1) {
    for (const point of ring) {
      if (pointWithinPolygon(point, poly2, true)) {
        return true;
      }
    }
  }
  return false;
}
function polygonToPolygonDistance(polygon1, polygon2, ruler, currentMiniDist = Infinity) {
  const bbox1 = getPolygonBBox(polygon1);
  const bbox2 = getPolygonBBox(polygon2);
  if (currentMiniDist !== Infinity && bboxToBBoxDistance(bbox1, bbox2, ruler) >= currentMiniDist) {
    return currentMiniDist;
  }
  if (boxWithinBox(bbox1, bbox2)) {
    if (polygonIntersect(polygon1, polygon2)) {
      return 0;
    }
  } else if (polygonIntersect(polygon2, polygon1)) {
    return 0;
  }
  let dist = Infinity;
  for (const ring1 of polygon1) {
    for (let i = 0, len1 = ring1.length, l = len1 - 1; i < len1; l = i++) {
      const p1 = ring1[l];
      const p2 = ring1[i];
      for (const ring2 of polygon2) {
        for (let j = 0, len2 = ring2.length, k = len2 - 1; j < len2; k = j++) {
          const q1 = ring2[k];
          const q2 = ring2[j];
          if (segmentIntersectSegment(p1, p2, q1, q2)) {
            return 0;
          }
          dist = Math.min(dist, segmentToSegmentDistance(p1, p2, q1, q2, ruler));
        }
      }
    }
  }
  return dist;
}
function updateQueue(distQueue, miniDist, ruler, points, polyBBox, rangeA) {
  if (!rangeA) {
    return;
  }
  const tempDist = bboxToBBoxDistance(getBBox(points, rangeA), polyBBox, ruler);
  if (tempDist < miniDist) {
    distQueue.push([tempDist, rangeA, [0, 0]]);
  }
}
function updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, range1, range2) {
  if (!range1 || !range2) {
    return;
  }
  const tempDist = bboxToBBoxDistance(getBBox(pointSet1, range1), getBBox(pointSet2, range2), ruler);
  if (tempDist < miniDist) {
    distQueue.push([tempDist, range1, range2]);
  }
}
function pointsToPolygonDistance(points, isLine, polygon, ruler, currentMiniDist = Infinity) {
  let miniDist = Math.min(ruler.distance(points[0], polygon[0][0]), currentMiniDist);
  if (miniDist === 0) {
    return miniDist;
  }
  const distQueue = new TinyQueue([[0, [0, points.length - 1], [0, 0]]], compareDistPair);
  const polyBBox = getPolygonBBox(polygon);
  while (distQueue.length > 0) {
    const distPair = distQueue.pop();
    if (distPair[0] >= miniDist) {
      continue;
    }
    const range = distPair[1];
    const threshold = isLine ? MinLinePointsSize : MinPointsSize;
    if (getRangeSize(range) <= threshold) {
      if (!isRangeSafe(range, points.length)) {
        return NaN;
      }
      if (isLine) {
        const tempDist = lineToPolygonDistance(points, range, polygon, ruler);
        if (isNaN(tempDist) || tempDist === 0) {
          return tempDist;
        }
        miniDist = Math.min(miniDist, tempDist);
      } else {
        for (let i = range[0]; i <= range[1]; ++i) {
          const tempDist = pointToPolygonDistance(points[i], polygon, ruler);
          miniDist = Math.min(miniDist, tempDist);
          if (miniDist === 0) {
            return 0;
          }
        }
      }
    } else {
      const newRangesA = splitRange(range, isLine);
      updateQueue(distQueue, miniDist, ruler, points, polyBBox, newRangesA[0]);
      updateQueue(distQueue, miniDist, ruler, points, polyBBox, newRangesA[1]);
    }
  }
  return miniDist;
}
function pointSetToPointSetDistance(pointSet1, isLine1, pointSet2, isLine2, ruler, currentMiniDist = Infinity) {
  let miniDist = Math.min(currentMiniDist, ruler.distance(pointSet1[0], pointSet2[0]));
  if (miniDist === 0) {
    return miniDist;
  }
  const distQueue = new TinyQueue([[0, [0, pointSet1.length - 1], [0, pointSet2.length - 1]]], compareDistPair);
  while (distQueue.length > 0) {
    const distPair = distQueue.pop();
    if (distPair[0] >= miniDist) {
      continue;
    }
    const rangeA = distPair[1];
    const rangeB = distPair[2];
    const threshold1 = isLine1 ? MinLinePointsSize : MinPointsSize;
    const threshold2 = isLine2 ? MinLinePointsSize : MinPointsSize;
    if (getRangeSize(rangeA) <= threshold1 && getRangeSize(rangeB) <= threshold2) {
      if (!isRangeSafe(rangeA, pointSet1.length) && isRangeSafe(rangeB, pointSet2.length)) {
        return NaN;
      }
      let tempDist;
      if (isLine1 && isLine2) {
        tempDist = lineToLineDistance(pointSet1, rangeA, pointSet2, rangeB, ruler);
        miniDist = Math.min(miniDist, tempDist);
      } else if (isLine1 && !isLine2) {
        const sublibe = pointSet1.slice(rangeA[0], rangeA[1] + 1);
        for (let i = rangeB[0]; i <= rangeB[1]; ++i) {
          tempDist = pointToLineDistance(pointSet2[i], sublibe, ruler);
          miniDist = Math.min(miniDist, tempDist);
          if (miniDist === 0) {
            return miniDist;
          }
        }
      } else if (!isLine1 && isLine2) {
        const sublibe = pointSet2.slice(rangeB[0], rangeB[1] + 1);
        for (let i = rangeA[0]; i <= rangeA[1]; ++i) {
          tempDist = pointToLineDistance(pointSet1[i], sublibe, ruler);
          miniDist = Math.min(miniDist, tempDist);
          if (miniDist === 0) {
            return miniDist;
          }
        }
      } else {
        tempDist = pointsToPointsDistance(pointSet1, rangeA, pointSet2, rangeB, ruler);
        miniDist = Math.min(miniDist, tempDist);
      }
    } else {
      const newRangesA = splitRange(rangeA, isLine1);
      const newRangesB = splitRange(rangeB, isLine2);
      updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[0], newRangesB[0]);
      updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[0], newRangesB[1]);
      updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[1], newRangesB[0]);
      updateQueueTwoSets(distQueue, miniDist, ruler, pointSet1, pointSet2, newRangesA[1], newRangesB[1]);
    }
  }
  return miniDist;
}
function pointToGeometryDistance(ctx, geometries) {
  const tilePoints = ctx.geometry();
  const pointPosition = tilePoints.flat().map((p) => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));
  if (tilePoints.length === 0) {
    return NaN;
  }
  const ruler = new CheapRuler(pointPosition[0][1]);
  let dist = Infinity;
  for (const geometry of geometries) {
    switch (geometry.type) {
      case "Point":
        dist = Math.min(dist, pointSetToPointSetDistance(pointPosition, false, [geometry.coordinates], false, ruler, dist));
        break;
      case "LineString":
        dist = Math.min(dist, pointSetToPointSetDistance(pointPosition, false, geometry.coordinates, true, ruler, dist));
        break;
      case "Polygon":
        dist = Math.min(dist, pointsToPolygonDistance(pointPosition, false, geometry.coordinates, ruler, dist));
        break;
    }
    if (dist === 0) {
      return dist;
    }
  }
  return dist;
}
function lineStringToGeometryDistance(ctx, geometries) {
  const tileLine = ctx.geometry();
  const linePositions = tileLine.flat().map((p) => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));
  if (tileLine.length === 0) {
    return NaN;
  }
  const ruler = new CheapRuler(linePositions[0][1]);
  let dist = Infinity;
  for (const geometry of geometries) {
    switch (geometry.type) {
      case "Point":
        dist = Math.min(dist, pointSetToPointSetDistance(linePositions, true, [geometry.coordinates], false, ruler, dist));
        break;
      case "LineString":
        dist = Math.min(dist, pointSetToPointSetDistance(linePositions, true, geometry.coordinates, true, ruler, dist));
        break;
      case "Polygon":
        dist = Math.min(dist, pointsToPolygonDistance(linePositions, true, geometry.coordinates, ruler, dist));
        break;
    }
    if (dist === 0) {
      return dist;
    }
  }
  return dist;
}
function polygonToGeometryDistance(ctx, geometries) {
  const tilePolygon = ctx.geometry();
  if (tilePolygon.length === 0 || tilePolygon[0].length === 0) {
    return NaN;
  }
  const polygons = classifyRings(tilePolygon, 0).map((polygon) => {
    return polygon.map((ring) => {
      return ring.map((p) => getLngLatFromTileCoord([p.x, p.y], ctx.canonical));
    });
  });
  const ruler = new CheapRuler(polygons[0][0][0][1]);
  let dist = Infinity;
  for (const geometry of geometries) {
    for (const polygon of polygons) {
      switch (geometry.type) {
        case "Point":
          dist = Math.min(dist, pointsToPolygonDistance([geometry.coordinates], false, polygon, ruler, dist));
          break;
        case "LineString":
          dist = Math.min(dist, pointsToPolygonDistance(geometry.coordinates, true, polygon, ruler, dist));
          break;
        case "Polygon":
          dist = Math.min(dist, polygonToPolygonDistance(polygon, geometry.coordinates, ruler, dist));
          break;
      }
      if (dist === 0) {
        return dist;
      }
    }
  }
  return dist;
}
function toSimpleGeometry(geometry) {
  if (geometry.type === "MultiPolygon") {
    return geometry.coordinates.map((polygon) => {
      return {
        type: "Polygon",
        coordinates: polygon
      };
    });
  }
  if (geometry.type === "MultiLineString") {
    return geometry.coordinates.map((lineString) => {
      return {
        type: "LineString",
        coordinates: lineString
      };
    });
  }
  if (geometry.type === "MultiPoint") {
    return geometry.coordinates.map((point) => {
      return {
        type: "Point",
        coordinates: point
      };
    });
  }
  return [geometry];
}
var Distance = class _Distance {
  constructor(geojson, geometries) {
    this.type = NumberType;
    this.geojson = geojson;
    this.geometries = geometries;
  }
  static parse(args, context) {
    if (args.length !== 2)
      return context.error(`'distance' expression requires exactly one argument, but found ${args.length - 1} instead.`);
    if (isValue(args[1])) {
      const geojson = args[1];
      if (geojson.type === "FeatureCollection") {
        return new _Distance(geojson, geojson.features.map((feature) => toSimpleGeometry(feature.geometry)).flat());
      } else if (geojson.type === "Feature") {
        return new _Distance(geojson, toSimpleGeometry(geojson.geometry));
      } else if ("type" in geojson && "coordinates" in geojson) {
        return new _Distance(geojson, toSimpleGeometry(geojson));
      }
    }
    return context.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
      if (ctx.geometryType() === "Point") {
        return pointToGeometryDistance(ctx, this.geometries);
      } else if (ctx.geometryType() === "LineString") {
        return lineStringToGeometryDistance(ctx, this.geometries);
      } else if (ctx.geometryType() === "Polygon") {
        return polygonToGeometryDistance(ctx, this.geometries);
      }
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
var GlobalState = class _GlobalState {
  constructor(key) {
    this.type = ValueType;
    this.key = key;
  }
  static parse(args, context) {
    if (args.length !== 2) {
      return context.error(`Expected 1 argument, but found ${args.length - 1} instead.`);
    }
    const key = args[1];
    if (key === void 0 || key === null) {
      return context.error("Global state property must be defined.");
    }
    if (typeof key !== "string") {
      return context.error(`Global state property must be string, but found ${typeof args[1]} instead.`);
    }
    return new _GlobalState(key);
  }
  evaluate(ctx) {
    var _a;
    const globalState = (_a = ctx.globals) === null || _a === void 0 ? void 0 : _a.globalState;
    if (!globalState || Object.keys(globalState).length === 0)
      return null;
    return getOwn(globalState, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
var expressions$1 = {
  // special forms
  "==": Equals,
  "!=": NotEquals,
  ">": GreaterThan,
  "<": LessThan,
  ">=": GreaterThanOrEqual,
  "<=": LessThanOrEqual,
  "array": Assertion,
  "at": At,
  "boolean": Assertion,
  "case": Case,
  "coalesce": Coalesce,
  "collator": CollatorExpression,
  "format": FormatExpression,
  "image": ImageExpression,
  "in": In,
  "index-of": IndexOf,
  "interpolate": Interpolate,
  "interpolate-hcl": Interpolate,
  "interpolate-lab": Interpolate,
  "length": Length,
  "let": Let,
  "literal": Literal,
  "match": Match,
  "number": Assertion,
  "number-format": NumberFormat,
  "object": Assertion,
  "slice": Slice,
  "step": Step,
  "string": Assertion,
  "to-boolean": Coercion,
  "to-color": Coercion,
  "to-number": Coercion,
  "to-string": Coercion,
  "var": Var,
  "within": Within,
  "distance": Distance,
  "global-state": GlobalState
};
var CompoundExpression = class _CompoundExpression {
  constructor(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
  }
  evaluate(ctx) {
    return this._evaluate(ctx, this.args);
  }
  eachChild(fn) {
    this.args.forEach(fn);
  }
  outputDefined() {
    return false;
  }
  static parse(args, context) {
    const op = args[0];
    const definition = _CompoundExpression.definitions[op];
    if (!definition) {
      return context.error(`Unknown expression "${op}". If you wanted a literal array, use ["literal", [...]].`, 0);
    }
    const type = Array.isArray(definition) ? definition[0] : definition.type;
    const availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
    const overloads = availableOverloads.filter(([signature]) => !Array.isArray(signature) || // varags
    signature.length === args.length - 1);
    let signatureContext = null;
    for (const [params, evaluate] of overloads) {
      signatureContext = new ParsingContext(context.registry, isExpressionConstant, context.path, null, context.scope);
      const parsedArgs = [];
      let argParseFailed = false;
      for (let i = 1; i < args.length; i++) {
        const arg = args[i];
        const expectedType = Array.isArray(params) ? params[i - 1] : params.type;
        const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
        if (!parsed) {
          argParseFailed = true;
          break;
        }
        parsedArgs.push(parsed);
      }
      if (argParseFailed) {
        continue;
      }
      if (Array.isArray(params)) {
        if (params.length !== parsedArgs.length) {
          signatureContext.error(`Expected ${params.length} arguments, but found ${parsedArgs.length} instead.`);
          continue;
        }
      }
      for (let i = 0; i < parsedArgs.length; i++) {
        const expected = Array.isArray(params) ? params[i] : params.type;
        const arg = parsedArgs[i];
        signatureContext.concat(i + 1).checkSubtype(expected, arg.type);
      }
      if (signatureContext.errors.length === 0) {
        return new _CompoundExpression(op, type, evaluate, parsedArgs);
      }
    }
    if (overloads.length === 1) {
      context.errors.push(...signatureContext.errors);
    } else {
      const expected = overloads.length ? overloads : availableOverloads;
      const signatures = expected.map(([params]) => stringifySignature(params)).join(" | ");
      const actualTypes = [];
      for (let i = 1; i < args.length; i++) {
        const parsed = context.parse(args[i], 1 + actualTypes.length);
        if (!parsed)
          return null;
        actualTypes.push(typeToString(parsed.type));
      }
      context.error(`Expected arguments of type ${signatures}, but found (${actualTypes.join(", ")}) instead.`);
    }
    return null;
  }
  static register(registry, definitions) {
    _CompoundExpression.definitions = definitions;
    for (const name in definitions) {
      registry[name] = _CompoundExpression;
    }
  }
};
function rgba(ctx, [r, g, b, a]) {
  r = r.evaluate(ctx);
  g = g.evaluate(ctx);
  b = b.evaluate(ctx);
  const alpha = a ? a.evaluate(ctx) : 1;
  const error2 = validateRGBA(r, g, b, alpha);
  if (error2)
    throw new RuntimeError(error2);
  return new Color(r / 255, g / 255, b / 255, alpha, false);
}
function has(key, obj) {
  return key in obj;
}
function get2(key, obj) {
  const v = obj[key];
  return typeof v === "undefined" ? null : v;
}
function binarySearch(v, a, i, j) {
  while (i <= j) {
    const m = i + j >> 1;
    if (a[m] === v)
      return true;
    if (a[m] > v)
      j = m - 1;
    else
      i = m + 1;
  }
  return false;
}
function varargs(type) {
  return { type };
}
CompoundExpression.register(expressions$1, {
  "error": [
    ErrorType,
    [StringType],
    (ctx, [v]) => {
      throw new RuntimeError(v.evaluate(ctx));
    }
  ],
  "typeof": [
    StringType,
    [ValueType],
    (ctx, [v]) => typeToString(typeOf(v.evaluate(ctx)))
  ],
  "to-rgba": [
    array(NumberType, 4),
    [ColorType],
    (ctx, [v]) => {
      const [r, g, b, a] = v.evaluate(ctx).rgb;
      return [r * 255, g * 255, b * 255, a];
    }
  ],
  "rgb": [
    ColorType,
    [NumberType, NumberType, NumberType],
    rgba
  ],
  "rgba": [
    ColorType,
    [NumberType, NumberType, NumberType, NumberType],
    rgba
  ],
  "has": {
    type: BooleanType,
    overloads: [
      [
        [StringType],
        (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())
      ],
      [
        [StringType, ObjectType],
        (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))
      ]
    ]
  },
  "get": {
    type: ValueType,
    overloads: [
      [
        [StringType],
        (ctx, [key]) => get2(key.evaluate(ctx), ctx.properties())
      ],
      [
        [StringType, ObjectType],
        (ctx, [key, obj]) => get2(key.evaluate(ctx), obj.evaluate(ctx))
      ]
    ]
  },
  "feature-state": [
    ValueType,
    [StringType],
    (ctx, [key]) => get2(key.evaluate(ctx), ctx.featureState || {})
  ],
  "properties": [
    ObjectType,
    [],
    (ctx) => ctx.properties()
  ],
  "geometry-type": [
    StringType,
    [],
    (ctx) => ctx.geometryType()
  ],
  "id": [
    ValueType,
    [],
    (ctx) => ctx.id()
  ],
  "zoom": [
    NumberType,
    [],
    (ctx) => ctx.globals.zoom
  ],
  "heatmap-density": [
    NumberType,
    [],
    (ctx) => ctx.globals.heatmapDensity || 0
  ],
  "elevation": [
    NumberType,
    [],
    (ctx) => ctx.globals.elevation || 0
  ],
  "line-progress": [
    NumberType,
    [],
    (ctx) => ctx.globals.lineProgress || 0
  ],
  "accumulated": [
    ValueType,
    [],
    (ctx) => ctx.globals.accumulated === void 0 ? null : ctx.globals.accumulated
  ],
  "+": [
    NumberType,
    varargs(NumberType),
    (ctx, args) => {
      let result = 0;
      for (const arg of args) {
        result += arg.evaluate(ctx);
      }
      return result;
    }
  ],
  "*": [
    NumberType,
    varargs(NumberType),
    (ctx, args) => {
      let result = 1;
      for (const arg of args) {
        result *= arg.evaluate(ctx);
      }
      return result;
    }
  ],
  "-": {
    type: NumberType,
    overloads: [
      [
        [NumberType, NumberType],
        (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)
      ],
      [
        [NumberType],
        (ctx, [a]) => -a.evaluate(ctx)
      ]
    ]
  },
  "/": [
    NumberType,
    [NumberType, NumberType],
    (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)
  ],
  "%": [
    NumberType,
    [NumberType, NumberType],
    (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)
  ],
  "ln2": [
    NumberType,
    [],
    () => Math.LN2
  ],
  "pi": [
    NumberType,
    [],
    () => Math.PI
  ],
  "e": [
    NumberType,
    [],
    () => Math.E
  ],
  "^": [
    NumberType,
    [NumberType, NumberType],
    (ctx, [b, e]) => Math.pow(b.evaluate(ctx), e.evaluate(ctx))
  ],
  "sqrt": [
    NumberType,
    [NumberType],
    (ctx, [x]) => Math.sqrt(x.evaluate(ctx))
  ],
  "log10": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN10
  ],
  "ln": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.log(n.evaluate(ctx))
  ],
  "log2": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN2
  ],
  "sin": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.sin(n.evaluate(ctx))
  ],
  "cos": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.cos(n.evaluate(ctx))
  ],
  "tan": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.tan(n.evaluate(ctx))
  ],
  "asin": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.asin(n.evaluate(ctx))
  ],
  "acos": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.acos(n.evaluate(ctx))
  ],
  "atan": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.atan(n.evaluate(ctx))
  ],
  "min": [
    NumberType,
    varargs(NumberType),
    (ctx, args) => Math.min(...args.map((arg) => arg.evaluate(ctx)))
  ],
  "max": [
    NumberType,
    varargs(NumberType),
    (ctx, args) => Math.max(...args.map((arg) => arg.evaluate(ctx)))
  ],
  "abs": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.abs(n.evaluate(ctx))
  ],
  "round": [
    NumberType,
    [NumberType],
    (ctx, [n]) => {
      const v = n.evaluate(ctx);
      return v < 0 ? -Math.round(-v) : Math.round(v);
    }
  ],
  "floor": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.floor(n.evaluate(ctx))
  ],
  "ceil": [
    NumberType,
    [NumberType],
    (ctx, [n]) => Math.ceil(n.evaluate(ctx))
  ],
  "filter-==": [
    BooleanType,
    [StringType, ValueType],
    (ctx, [k, v]) => ctx.properties()[k.value] === v.value
  ],
  "filter-id-==": [
    BooleanType,
    [ValueType],
    (ctx, [v]) => ctx.id() === v.value
  ],
  "filter-type-==": [
    BooleanType,
    [StringType],
    (ctx, [v]) => ctx.geometryType() === v.value
  ],
  "filter-<": [
    BooleanType,
    [StringType, ValueType],
    (ctx, [k, v]) => {
      const a = ctx.properties()[k.value];
      const b = v.value;
      return typeof a === typeof b && a < b;
    }
  ],
  "filter-id-<": [
    BooleanType,
    [ValueType],
    (ctx, [v]) => {
      const a = ctx.id();
      const b = v.value;
      return typeof a === typeof b && a < b;
    }
  ],
  "filter->": [
    BooleanType,
    [StringType, ValueType],
    (ctx, [k, v]) => {
      const a = ctx.properties()[k.value];
      const b = v.value;
      return typeof a === typeof b && a > b;
    }
  ],
  "filter-id->": [
    BooleanType,
    [ValueType],
    (ctx, [v]) => {
      const a = ctx.id();
      const b = v.value;
      return typeof a === typeof b && a > b;
    }
  ],
  "filter-<=": [
    BooleanType,
    [StringType, ValueType],
    (ctx, [k, v]) => {
      const a = ctx.properties()[k.value];
      const b = v.value;
      return typeof a === typeof b && a <= b;
    }
  ],
  "filter-id-<=": [
    BooleanType,
    [ValueType],
    (ctx, [v]) => {
      const a = ctx.id();
      const b = v.value;
      return typeof a === typeof b && a <= b;
    }
  ],
  "filter->=": [
    BooleanType,
    [StringType, ValueType],
    (ctx, [k, v]) => {
      const a = ctx.properties()[k.value];
      const b = v.value;
      return typeof a === typeof b && a >= b;
    }
  ],
  "filter-id->=": [
    BooleanType,
    [ValueType],
    (ctx, [v]) => {
      const a = ctx.id();
      const b = v.value;
      return typeof a === typeof b && a >= b;
    }
  ],
  "filter-has": [
    BooleanType,
    [ValueType],
    (ctx, [k]) => k.value in ctx.properties()
  ],
  "filter-has-id": [
    BooleanType,
    [],
    (ctx) => ctx.id() !== null && ctx.id() !== void 0
  ],
  "filter-type-in": [
    BooleanType,
    [array(StringType)],
    (ctx, [v]) => v.value.indexOf(ctx.geometryType()) >= 0
  ],
  "filter-id-in": [
    BooleanType,
    [array(ValueType)],
    (ctx, [v]) => v.value.indexOf(ctx.id()) >= 0
  ],
  "filter-in-small": [
    BooleanType,
    [StringType, array(ValueType)],
    // assumes v is an array literal
    (ctx, [k, v]) => v.value.indexOf(ctx.properties()[k.value]) >= 0
  ],
  "filter-in-large": [
    BooleanType,
    [StringType, array(ValueType)],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (ctx, [k, v]) => binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1)
  ],
  "all": {
    type: BooleanType,
    overloads: [
      [
        [BooleanType, BooleanType],
        (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)
      ],
      [
        varargs(BooleanType),
        (ctx, args) => {
          for (const arg of args) {
            if (!arg.evaluate(ctx))
              return false;
          }
          return true;
        }
      ]
    ]
  },
  "any": {
    type: BooleanType,
    overloads: [
      [
        [BooleanType, BooleanType],
        (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)
      ],
      [
        varargs(BooleanType),
        (ctx, args) => {
          for (const arg of args) {
            if (arg.evaluate(ctx))
              return true;
          }
          return false;
        }
      ]
    ]
  },
  "!": [
    BooleanType,
    [BooleanType],
    (ctx, [b]) => !b.evaluate(ctx)
  ],
  "is-supported-script": [
    BooleanType,
    [StringType],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (ctx, [s]) => {
      const isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
      if (isSupportedScript) {
        return isSupportedScript(s.evaluate(ctx));
      }
      return true;
    }
  ],
  "upcase": [
    StringType,
    [StringType],
    (ctx, [s]) => s.evaluate(ctx).toUpperCase()
  ],
  "downcase": [
    StringType,
    [StringType],
    (ctx, [s]) => s.evaluate(ctx).toLowerCase()
  ],
  "concat": [
    StringType,
    varargs(ValueType),
    (ctx, args) => args.map((arg) => valueToString(arg.evaluate(ctx))).join("")
  ],
  "resolved-locale": [
    StringType,
    [CollatorType],
    (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()
  ]
});
function stringifySignature(signature) {
  if (Array.isArray(signature)) {
    return `(${signature.map(typeToString).join(", ")})`;
  } else {
    return `(${typeToString(signature.type)}...)`;
  }
}
function isExpressionConstant(expression) {
  if (expression instanceof Var) {
    return isExpressionConstant(expression.boundExpression);
  } else if (expression instanceof CompoundExpression && expression.name === "error") {
    return false;
  } else if (expression instanceof CollatorExpression) {
    return false;
  } else if (expression instanceof Within) {
    return false;
  } else if (expression instanceof Distance) {
    return false;
  } else if (expression instanceof GlobalState) {
    return false;
  }
  const isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
  let childrenConstant = true;
  expression.eachChild((child) => {
    if (isTypeAnnotation) {
      childrenConstant = childrenConstant && isExpressionConstant(child);
    } else {
      childrenConstant = childrenConstant && child instanceof Literal;
    }
  });
  if (!childrenConstant) {
    return false;
  }
  return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
}
function isFeatureConstant(e) {
  if (e instanceof CompoundExpression) {
    if (e.name === "get" && e.args.length === 1) {
      return false;
    } else if (e.name === "feature-state") {
      return false;
    } else if (e.name === "has" && e.args.length === 1) {
      return false;
    } else if (e.name === "properties" || e.name === "geometry-type" || e.name === "id") {
      return false;
    } else if (/^filter-/.test(e.name)) {
      return false;
    }
  }
  if (e instanceof Within) {
    return false;
  }
  if (e instanceof Distance) {
    return false;
  }
  let result = true;
  e.eachChild((arg) => {
    if (result && !isFeatureConstant(arg)) {
      result = false;
    }
  });
  return result;
}
function isStateConstant(e) {
  if (e instanceof CompoundExpression) {
    if (e.name === "feature-state") {
      return false;
    }
  }
  let result = true;
  e.eachChild((arg) => {
    if (result && !isStateConstant(arg)) {
      result = false;
    }
  });
  return result;
}
function isGlobalPropertyConstant(e, properties) {
  if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
    return false;
  }
  let result = true;
  e.eachChild((arg) => {
    if (result && !isGlobalPropertyConstant(arg, properties)) {
      result = false;
    }
  });
  return result;
}
function success(value) {
  return { result: "success", value };
}
function error(value) {
  return { result: "error", value };
}
function supportsPropertyExpression(spec) {
  return spec["property-type"] === "data-driven" || spec["property-type"] === "cross-faded-data-driven";
}
function supportsZoomExpression(spec) {
  return !!spec.expression && spec.expression.parameters.indexOf("zoom") > -1;
}
function supportsInterpolation(spec) {
  return !!spec.expression && spec.expression.interpolated;
}
function getType(val) {
  if (val instanceof Number) {
    return "number";
  } else if (val instanceof String) {
    return "string";
  } else if (val instanceof Boolean) {
    return "boolean";
  } else if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else {
    return typeof val;
  }
}
function isFunction$1(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value) && typeOf(value) === ObjectType;
}
var StyleExpression = class {
  constructor(expression, propertySpec) {
    this.expression = expression;
    this._warningHistory = {};
    this._evaluator = new EvaluationContext();
    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
    this._enumValues = propertySpec && propertySpec.type === "enum" ? propertySpec.values : null;
  }
  evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature;
    this._evaluator.featureState = featureState;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection;
    return this.expression.evaluate(this._evaluator);
  }
  evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    this._evaluator.globals = globals;
    this._evaluator.feature = feature || null;
    this._evaluator.featureState = featureState || null;
    this._evaluator.canonical = canonical;
    this._evaluator.availableImages = availableImages || null;
    this._evaluator.formattedSection = formattedSection || null;
    try {
      const val = this.expression.evaluate(this._evaluator);
      if (val === null || val === void 0 || typeof val === "number" && val !== val) {
        return this._defaultValue;
      }
      if (this._enumValues && !(val in this._enumValues)) {
        throw new RuntimeError(`Expected value to be one of ${Object.keys(this._enumValues).map((v) => JSON.stringify(v)).join(", ")}, but found ${JSON.stringify(val)} instead.`);
      }
      return val;
    } catch (e) {
      if (!this._warningHistory[e.message]) {
        this._warningHistory[e.message] = true;
        if (typeof console !== "undefined") {
          console.warn(e.message);
        }
      }
      return this._defaultValue;
    }
  }
};
function isExpression(expression) {
  return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === "string" && expression[0] in expressions$1;
}
function createExpression(expression, propertySpec) {
  const parser = new ParsingContext(expressions$1, isExpressionConstant, [], propertySpec ? getExpectedType(propertySpec) : void 0);
  const parsed = parser.parse(expression, void 0, void 0, void 0, propertySpec && propertySpec.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  if (!parsed) {
    return error(parser.errors);
  }
  return success(new StyleExpression(parsed, propertySpec));
}
var ZoomConstantExpression = class {
  constructor(kind, expression) {
    this.kind = kind;
    this._styleExpression = expression;
    this.isStateDependent = kind !== "constant" && !isStateConstant(expression.expression);
    this.globalStateRefs = findGlobalStateRefs(expression.expression);
  }
  evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
  }
  evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
  }
};
var ZoomDependentExpression = class {
  constructor(kind, expression, zoomStops, interpolationType) {
    this.kind = kind;
    this.zoomStops = zoomStops;
    this._styleExpression = expression;
    this.isStateDependent = kind !== "camera" && !isStateConstant(expression.expression);
    this.globalStateRefs = findGlobalStateRefs(expression.expression);
    this.interpolationType = interpolationType;
  }
  evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
  }
  evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
    return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
  }
  interpolationFactor(input, lower, upper) {
    if (this.interpolationType) {
      return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);
    } else {
      return 0;
    }
  }
};
function createPropertyExpression(expressionInput, propertySpec) {
  const expression = createExpression(expressionInput, propertySpec);
  if (expression.result === "error") {
    return expression;
  }
  const parsed = expression.value.expression;
  const isFeatureConstantResult = isFeatureConstant(parsed);
  if (!isFeatureConstantResult && !supportsPropertyExpression(propertySpec)) {
    return error([new ExpressionParsingError("", "data expressions not supported")]);
  }
  const isZoomConstant = isGlobalPropertyConstant(parsed, ["zoom"]);
  if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
    return error([new ExpressionParsingError("", "zoom expressions not supported")]);
  }
  const zoomCurve = findZoomCurve(parsed);
  if (!zoomCurve && !isZoomConstant) {
    return error([new ExpressionParsingError("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  } else if (zoomCurve instanceof ExpressionParsingError) {
    return error([zoomCurve]);
  } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
    return error([new ExpressionParsingError("", '"interpolate" expressions cannot be used with this property')]);
  }
  if (!zoomCurve) {
    return success(isFeatureConstantResult ? new ZoomConstantExpression("constant", expression.value) : new ZoomConstantExpression("source", expression.value));
  }
  const interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : void 0;
  return success(isFeatureConstantResult ? new ZoomDependentExpression("camera", expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression("composite", expression.value, zoomCurve.labels, interpolationType));
}
function findZoomCurve(expression) {
  let result = null;
  if (expression instanceof Let) {
    result = findZoomCurve(expression.result);
  } else if (expression instanceof Coalesce) {
    for (const arg of expression.args) {
      result = findZoomCurve(arg);
      if (result) {
        break;
      }
    }
  } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === "zoom") {
    result = expression;
  }
  if (result instanceof ExpressionParsingError) {
    return result;
  }
  expression.eachChild((child) => {
    const childResult = findZoomCurve(child);
    if (childResult instanceof ExpressionParsingError) {
      result = childResult;
    } else if (!result && childResult) {
      result = new ExpressionParsingError("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
    } else if (result && childResult && result !== childResult) {
      result = new ExpressionParsingError("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
    }
  });
  return result;
}
function findGlobalStateRefs(expression, results = /* @__PURE__ */ new Set()) {
  if (expression instanceof GlobalState) {
    results.add(expression.key);
  }
  expression.eachChild((childExpression) => {
    findGlobalStateRefs(childExpression, results);
  });
  return results;
}
function getExpectedType(spec) {
  const types3 = {
    color: ColorType,
    string: StringType,
    number: NumberType,
    enum: StringType,
    boolean: BooleanType,
    formatted: FormattedType,
    padding: PaddingType,
    numberArray: NumberArrayType,
    colorArray: ColorArrayType,
    projectionDefinition: ProjectionDefinitionType,
    resolvedImage: ResolvedImageType,
    variableAnchorOffsetCollection: VariableAnchorOffsetCollectionType
  };
  if (spec.type === "array") {
    return array(types3[spec.value] || ValueType, spec.length);
  }
  return types3[spec.type];
}
function getDefaultValue(spec) {
  if (spec.type === "color" && isFunction$1(spec.default)) {
    return new Color(0, 0, 0, 0);
  }
  switch (spec.type) {
    case "color":
      return Color.parse(spec.default) || null;
    case "padding":
      return Padding.parse(spec.default) || null;
    case "numberArray":
      return NumberArray.parse(spec.default) || null;
    case "colorArray":
      return ColorArray.parse(spec.default) || null;
    case "variableAnchorOffsetCollection":
      return VariableAnchorOffsetCollection.parse(spec.default) || null;
    case "projectionDefinition":
      return ProjectionDefinition.parse(spec.default) || null;
    default:
      return spec.default === void 0 ? null : spec.default;
  }
}
function isExpressionFilter(filter2) {
  if (filter2 === true || filter2 === false) {
    return true;
  }
  if (!Array.isArray(filter2) || filter2.length === 0) {
    return false;
  }
  switch (filter2[0]) {
    case "has":
      return filter2.length >= 2 && filter2[1] !== "$id" && filter2[1] !== "$type";
    case "in":
      return filter2.length >= 3 && (typeof filter2[1] !== "string" || Array.isArray(filter2[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return filter2.length !== 3 || (Array.isArray(filter2[1]) || Array.isArray(filter2[2]));
    case "any":
    case "all":
      for (const f of filter2.slice(1)) {
        if (!isExpressionFilter(f) && typeof f !== "boolean") {
          return false;
        }
      }
      return true;
    default:
      return true;
  }
}
var filterSpec = {
  "type": "boolean",
  "default": false,
  "transition": false,
  "property-type": "data-driven",
  "expression": {
    "interpolated": false,
    "parameters": ["zoom", "feature"]
  }
};
function featureFilter(filter2) {
  if (filter2 === null || filter2 === void 0) {
    return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
  }
  if (!isExpressionFilter(filter2)) {
    filter2 = convertFilter$1(filter2);
  }
  const compiled = createExpression(filter2, filterSpec);
  if (compiled.result === "error") {
    throw new Error(compiled.value.map((err) => `${err.key}: ${err.message}`).join(", "));
  } else {
    const needGeometry = geometryNeeded(filter2);
    return {
      filter: (globalProperties, feature, canonical) => compiled.value.evaluate(globalProperties, feature, {}, canonical),
      needGeometry,
      getGlobalStateRefs: () => findGlobalStateRefs(compiled.value.expression)
    };
  }
}
function compare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function geometryNeeded(filter2) {
  if (!Array.isArray(filter2))
    return false;
  if (filter2[0] === "within" || filter2[0] === "distance")
    return true;
  for (let index = 1; index < filter2.length; index++) {
    if (geometryNeeded(filter2[index]))
      return true;
  }
  return false;
}
function convertFilter$1(filter2) {
  if (!filter2)
    return true;
  const op = filter2[0];
  if (filter2.length <= 1)
    return op !== "any";
  const converted = op === "==" ? convertComparisonOp$1(filter2[1], filter2[2], "==") : op === "!=" ? convertNegation(convertComparisonOp$1(filter2[1], filter2[2], "==")) : op === "<" || op === ">" || op === "<=" || op === ">=" ? convertComparisonOp$1(filter2[1], filter2[2], op) : op === "any" ? convertDisjunctionOp(filter2.slice(1)) : op === "all" ? ["all"].concat(filter2.slice(1).map(convertFilter$1)) : op === "none" ? ["all"].concat(filter2.slice(1).map(convertFilter$1).map(convertNegation)) : op === "in" ? convertInOp$1(filter2[1], filter2.slice(2)) : op === "!in" ? convertNegation(convertInOp$1(filter2[1], filter2.slice(2))) : op === "has" ? convertHasOp$1(filter2[1]) : op === "!has" ? convertNegation(convertHasOp$1(filter2[1])) : true;
  return converted;
}
function convertComparisonOp$1(property, value, op) {
  switch (property) {
    case "$type":
      return [`filter-type-${op}`, value];
    case "$id":
      return [`filter-id-${op}`, value];
    default:
      return [`filter-${op}`, property, value];
  }
}
function convertDisjunctionOp(filters) {
  return ["any"].concat(filters.map(convertFilter$1));
}
function convertInOp$1(property, values) {
  if (values.length === 0) {
    return false;
  }
  switch (property) {
    case "$type":
      return ["filter-type-in", ["literal", values]];
    case "$id":
      return ["filter-id-in", ["literal", values]];
    default:
      if (values.length > 200 && !values.some((v) => typeof v !== typeof values[0])) {
        return ["filter-in-large", property, ["literal", values.sort(compare)]];
      } else {
        return ["filter-in-small", property, ["literal", values]];
      }
  }
}
function convertHasOp$1(property) {
  switch (property) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", property];
  }
}
function convertNegation(filter2) {
  return ["!", filter2];
}
function convertLiteral(value) {
  return typeof value === "object" ? ["literal", value] : value;
}
function convertFunction(parameters, propertySpec) {
  let stops = parameters.stops;
  if (!stops) {
    return convertIdentityFunction(parameters, propertySpec);
  }
  const zoomAndFeatureDependent = stops && typeof stops[0][0] === "object";
  const featureDependent = zoomAndFeatureDependent || parameters.property !== void 0;
  const zoomDependent = zoomAndFeatureDependent || !featureDependent;
  stops = stops.map((stop) => {
    if (!featureDependent && propertySpec.tokens && typeof stop[1] === "string") {
      return [stop[0], convertTokenString(stop[1])];
    }
    return [stop[0], convertLiteral(stop[1])];
  });
  if (zoomAndFeatureDependent) {
    return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
  } else if (zoomDependent) {
    return convertZoomFunction(parameters, propertySpec, stops);
  } else {
    return convertPropertyFunction(parameters, propertySpec, stops);
  }
}
function convertIdentityFunction(parameters, propertySpec) {
  const get3 = ["get", parameters.property];
  if (parameters.default === void 0) {
    return propertySpec.type === "string" ? ["string", get3] : get3;
  } else if (propertySpec.type === "enum") {
    return [
      "match",
      get3,
      Object.keys(propertySpec.values),
      get3,
      parameters.default
    ];
  } else {
    const expression = [propertySpec.type === "color" ? "to-color" : propertySpec.type, get3, convertLiteral(parameters.default)];
    if (propertySpec.type === "array") {
      expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
    }
    return expression;
  }
}
function getInterpolateOperator(parameters) {
  switch (parameters.colorSpace) {
    case "hcl":
      return "interpolate-hcl";
    case "lab":
      return "interpolate-lab";
    default:
      return "interpolate";
  }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
  const featureFunctionParameters = {};
  const featureFunctionStops = {};
  const zoomStops = [];
  for (let s = 0; s < stops.length; s++) {
    const stop = stops[s];
    const zoom = stop[0].zoom;
    if (featureFunctionParameters[zoom] === void 0) {
      featureFunctionParameters[zoom] = {
        zoom,
        type: parameters.type,
        property: parameters.property,
        default: parameters.default
      };
      featureFunctionStops[zoom] = [];
      zoomStops.push(zoom);
    }
    featureFunctionStops[zoom].push([stop[0].value, stop[1]]);
  }
  const functionType = getFunctionType({}, propertySpec);
  if (functionType === "exponential") {
    const expression = [getInterpolateOperator(parameters), ["linear"], ["zoom"]];
    for (const z of zoomStops) {
      const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
      appendStopPair(expression, z, output, false);
    }
    return expression;
  } else {
    const expression = ["step", ["zoom"]];
    for (const z of zoomStops) {
      const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
      appendStopPair(expression, z, output, true);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
  }
}
function coalesce(a, b) {
  if (a !== void 0)
    return a;
  if (b !== void 0)
    return b;
}
function getFallback(parameters, propertySpec) {
  const defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));
  if (defaultValue === void 0 && propertySpec.type === "resolvedImage") {
    return "";
  }
  return defaultValue;
}
function convertPropertyFunction(parameters, propertySpec, stops) {
  const type = getFunctionType(parameters, propertySpec);
  const get3 = ["get", parameters.property];
  if (type === "categorical" && typeof stops[0][0] === "boolean") {
    const expression = ["case"];
    for (const stop of stops) {
      expression.push(["==", get3, stop[0]], stop[1]);
    }
    expression.push(getFallback(parameters, propertySpec));
    return expression;
  } else if (type === "categorical") {
    const expression = ["match", get3];
    for (const stop of stops) {
      appendStopPair(expression, stop[0], stop[1], false);
    }
    expression.push(getFallback(parameters, propertySpec));
    return expression;
  } else if (type === "interval") {
    const expression = ["step", ["number", get3]];
    for (const stop of stops) {
      appendStopPair(expression, stop[0], stop[1], true);
    }
    fixupDegenerateStepCurve(expression);
    return parameters.default === void 0 ? expression : [
      "case",
      ["==", ["typeof", get3], "number"],
      expression,
      convertLiteral(parameters.default)
    ];
  } else if (type === "exponential") {
    const base = parameters.base !== void 0 ? parameters.base : 1;
    const expression = [
      getInterpolateOperator(parameters),
      base === 1 ? ["linear"] : ["exponential", base],
      ["number", get3]
    ];
    for (const stop of stops) {
      appendStopPair(expression, stop[0], stop[1], false);
    }
    return parameters.default === void 0 ? expression : [
      "case",
      ["==", ["typeof", get3], "number"],
      expression,
      convertLiteral(parameters.default)
    ];
  } else {
    throw new Error(`Unknown property function type ${type}`);
  }
}
function convertZoomFunction(parameters, propertySpec, stops, input = ["zoom"]) {
  const type = getFunctionType(parameters, propertySpec);
  let expression;
  let isStep = false;
  if (type === "interval") {
    expression = ["step", input];
    isStep = true;
  } else if (type === "exponential") {
    const base = parameters.base !== void 0 ? parameters.base : 1;
    expression = [getInterpolateOperator(parameters), base === 1 ? ["linear"] : ["exponential", base], input];
  } else {
    throw new Error(`Unknown zoom function type "${type}"`);
  }
  for (const stop of stops) {
    appendStopPair(expression, stop[0], stop[1], isStep);
  }
  fixupDegenerateStepCurve(expression);
  return expression;
}
function fixupDegenerateStepCurve(expression) {
  if (expression[0] === "step" && expression.length === 3) {
    expression.push(0);
    expression.push(expression[3]);
  }
}
function appendStopPair(curve, input, output, isStep) {
  if (curve.length > 3 && input === curve[curve.length - 2]) {
    return;
  }
  if (!(isStep && curve.length === 2)) {
    curve.push(input);
  }
  curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
  if (parameters.type) {
    return parameters.type;
  } else {
    return propertySpec.expression.interpolated ? "exponential" : "interval";
  }
}
function convertTokenString(s) {
  const result = ["concat"];
  const re = /{([^{}]+)}/g;
  let pos = 0;
  for (let match = re.exec(s); match !== null; match = re.exec(s)) {
    const literal = s.slice(pos, re.lastIndex - match[0].length);
    pos = re.lastIndex;
    if (literal.length > 0)
      result.push(literal);
    result.push(["get", match[1]]);
  }
  if (result.length === 1) {
    return s;
  }
  if (pos < s.length) {
    result.push(s.slice(pos));
  } else if (result.length === 2) {
    return ["to-string", result[1]];
  }
  return result;
}
function validateConstants(options) {
  const key = options.key;
  const constants = options.value;
  if (constants) {
    return [new ValidationError(key, constants, "constants have been deprecated as of v8")];
  } else {
    return [];
  }
}
function unbundle(value) {
  if (value instanceof Number || value instanceof String || value instanceof Boolean) {
    return value.valueOf();
  } else {
    return value;
  }
}
function deepUnbundle(value) {
  if (Array.isArray(value)) {
    return value.map(deepUnbundle);
  } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
    const unbundledValue = {};
    for (const key in value) {
      unbundledValue[key] = deepUnbundle(value[key]);
    }
    return unbundledValue;
  }
  return unbundle(value);
}
function validateObject(options) {
  const key = options.key;
  const object = options.value;
  const elementSpecs = options.valueSpec || {};
  const elementValidators = options.objectElementValidators || {};
  const style = options.style;
  const styleSpec = options.styleSpec;
  const validateSpec = options.validateSpec;
  let errors = [];
  const type = getType(object);
  if (type !== "object") {
    return [new ValidationError(key, object, `object expected, ${type} found`)];
  }
  for (const objectKey in object) {
    const elementSpecKey = objectKey.split(".")[0];
    const elementSpec = getOwn(elementSpecs, elementSpecKey) || elementSpecs["*"];
    let validateElement;
    if (getOwn(elementValidators, elementSpecKey)) {
      validateElement = elementValidators[elementSpecKey];
    } else if (getOwn(elementSpecs, elementSpecKey)) {
      validateElement = validateSpec;
    } else if (elementValidators["*"]) {
      validateElement = elementValidators["*"];
    } else if (elementSpecs["*"]) {
      validateElement = validateSpec;
    } else {
      errors.push(new ValidationError(key, object[objectKey], `unknown property "${objectKey}"`));
      continue;
    }
    errors = errors.concat(validateElement({
      key: (key ? `${key}.` : key) + objectKey,
      value: object[objectKey],
      valueSpec: elementSpec,
      style,
      styleSpec,
      object,
      objectKey,
      validateSpec
    }, object));
  }
  for (const elementSpecKey in elementSpecs) {
    if (elementValidators[elementSpecKey]) {
      continue;
    }
    if (elementSpecs[elementSpecKey].required && elementSpecs[elementSpecKey]["default"] === void 0 && object[elementSpecKey] === void 0) {
      errors.push(new ValidationError(key, object, `missing required property "${elementSpecKey}"`));
    }
  }
  return errors;
}
function validateArray(options) {
  const array2 = options.value;
  const arraySpec = options.valueSpec;
  const validateSpec = options.validateSpec;
  const style = options.style;
  const styleSpec = options.styleSpec;
  const key = options.key;
  const validateArrayElement = options.arrayElementValidator || validateSpec;
  if (getType(array2) !== "array") {
    return [new ValidationError(key, array2, `array expected, ${getType(array2)} found`)];
  }
  if (arraySpec.length && array2.length !== arraySpec.length) {
    return [new ValidationError(key, array2, `array length ${arraySpec.length} expected, length ${array2.length} found`)];
  }
  if (arraySpec["min-length"] && array2.length < arraySpec["min-length"]) {
    return [new ValidationError(key, array2, `array length at least ${arraySpec["min-length"]} expected, length ${array2.length} found`)];
  }
  let arrayElementSpec = {
    "type": arraySpec.value,
    "values": arraySpec.values
  };
  if (styleSpec.$version < 7) {
    arrayElementSpec["function"] = arraySpec.function;
  }
  if (getType(arraySpec.value) === "object") {
    arrayElementSpec = arraySpec.value;
  }
  let errors = [];
  for (let i = 0; i < array2.length; i++) {
    errors = errors.concat(validateArrayElement({
      array: array2,
      arrayIndex: i,
      value: array2[i],
      valueSpec: arrayElementSpec,
      validateSpec: options.validateSpec,
      style,
      styleSpec,
      key: `${key}[${i}]`
    }));
  }
  return errors;
}
function validateNumber(options) {
  const key = options.key;
  const value = options.value;
  const valueSpec = options.valueSpec;
  let type = getType(value);
  if (type === "number" && value !== value) {
    type = "NaN";
  }
  if (type !== "number") {
    return [new ValidationError(key, value, `number expected, ${type} found`)];
  }
  if ("minimum" in valueSpec && value < valueSpec.minimum) {
    return [new ValidationError(key, value, `${value} is less than the minimum value ${valueSpec.minimum}`)];
  }
  if ("maximum" in valueSpec && value > valueSpec.maximum) {
    return [new ValidationError(key, value, `${value} is greater than the maximum value ${valueSpec.maximum}`)];
  }
  return [];
}
function validateFunction(options) {
  const functionValueSpec = options.valueSpec;
  const functionType = unbundle(options.value.type);
  let stopKeyType;
  let stopDomainValues = {};
  let previousStopDomainValue;
  let previousStopDomainZoom;
  const isZoomFunction = functionType !== "categorical" && options.value.property === void 0;
  const isPropertyFunction = !isZoomFunction;
  const isZoomAndPropertyFunction = getType(options.value.stops) === "array" && getType(options.value.stops[0]) === "array" && getType(options.value.stops[0][0]) === "object";
  const errors = validateObject({
    key: options.key,
    value: options.value,
    valueSpec: options.styleSpec.function,
    validateSpec: options.validateSpec,
    style: options.style,
    styleSpec: options.styleSpec,
    objectElementValidators: {
      stops: validateFunctionStops,
      default: validateFunctionDefault
    }
  });
  if (functionType === "identity" && isZoomFunction) {
    errors.push(new ValidationError(options.key, options.value, 'missing required property "property"'));
  }
  if (functionType !== "identity" && !options.value.stops) {
    errors.push(new ValidationError(options.key, options.value, 'missing required property "stops"'));
  }
  if (functionType === "exponential" && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {
    errors.push(new ValidationError(options.key, options.value, "exponential functions not supported"));
  }
  if (options.styleSpec.$version >= 8) {
    if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {
      errors.push(new ValidationError(options.key, options.value, "property functions not supported"));
    } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {
      errors.push(new ValidationError(options.key, options.value, "zoom functions not supported"));
    }
  }
  if ((functionType === "categorical" || isZoomAndPropertyFunction) && options.value.property === void 0) {
    errors.push(new ValidationError(options.key, options.value, '"property" property is required'));
  }
  return errors;
  function validateFunctionStops(options2) {
    if (functionType === "identity") {
      return [new ValidationError(options2.key, options2.value, 'identity function may not have a "stops" property')];
    }
    let errors2 = [];
    const value = options2.value;
    errors2 = errors2.concat(validateArray({
      key: options2.key,
      value,
      valueSpec: options2.valueSpec,
      validateSpec: options2.validateSpec,
      style: options2.style,
      styleSpec: options2.styleSpec,
      arrayElementValidator: validateFunctionStop
    }));
    if (getType(value) === "array" && value.length === 0) {
      errors2.push(new ValidationError(options2.key, value, "array must have at least one stop"));
    }
    return errors2;
  }
  function validateFunctionStop(options2) {
    let errors2 = [];
    const value = options2.value;
    const key = options2.key;
    if (getType(value) !== "array") {
      return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];
    }
    if (value.length !== 2) {
      return [new ValidationError(key, value, `array length 2 expected, length ${value.length} found`)];
    }
    if (isZoomAndPropertyFunction) {
      if (getType(value[0]) !== "object") {
        return [new ValidationError(key, value, `object expected, ${getType(value[0])} found`)];
      }
      if (value[0].zoom === void 0) {
        return [new ValidationError(key, value, "object stop key must have zoom")];
      }
      if (value[0].value === void 0) {
        return [new ValidationError(key, value, "object stop key must have value")];
      }
      if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {
        return [new ValidationError(key, value[0].zoom, "stop zoom values must appear in ascending order")];
      }
      if (unbundle(value[0].zoom) !== previousStopDomainZoom) {
        previousStopDomainZoom = unbundle(value[0].zoom);
        previousStopDomainValue = void 0;
        stopDomainValues = {};
      }
      errors2 = errors2.concat(validateObject({
        key: `${key}[0]`,
        value: value[0],
        valueSpec: { zoom: {} },
        validateSpec: options2.validateSpec,
        style: options2.style,
        styleSpec: options2.styleSpec,
        objectElementValidators: { zoom: validateNumber, value: validateStopDomainValue }
      }));
    } else {
      errors2 = errors2.concat(validateStopDomainValue({
        key: `${key}[0]`,
        value: value[0],
        validateSpec: options2.validateSpec,
        style: options2.style,
        styleSpec: options2.styleSpec
      }, value));
    }
    if (isExpression(deepUnbundle(value[1]))) {
      return errors2.concat([new ValidationError(`${key}[1]`, value[1], "expressions are not allowed in function stops.")]);
    }
    return errors2.concat(options2.validateSpec({
      key: `${key}[1]`,
      value: value[1],
      valueSpec: functionValueSpec,
      validateSpec: options2.validateSpec,
      style: options2.style,
      styleSpec: options2.styleSpec
    }));
  }
  function validateStopDomainValue(options2, stop) {
    const type = getType(options2.value);
    const value = unbundle(options2.value);
    const reportValue = options2.value !== null ? options2.value : stop;
    if (!stopKeyType) {
      stopKeyType = type;
    } else if (type !== stopKeyType) {
      return [new ValidationError(options2.key, reportValue, `${type} stop domain type must match previous stop domain type ${stopKeyType}`)];
    }
    if (type !== "number" && type !== "string" && type !== "boolean") {
      return [new ValidationError(options2.key, reportValue, "stop domain value must be a number, string, or boolean")];
    }
    if (type !== "number" && functionType !== "categorical") {
      let message = `number expected, ${type} found`;
      if (supportsPropertyExpression(functionValueSpec) && functionType === void 0) {
        message += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.';
      }
      return [new ValidationError(options2.key, reportValue, message)];
    }
    if (functionType === "categorical" && type === "number" && (!isFinite(value) || Math.floor(value) !== value)) {
      return [new ValidationError(options2.key, reportValue, `integer expected, found ${value}`)];
    }
    if (functionType !== "categorical" && type === "number" && previousStopDomainValue !== void 0 && value < previousStopDomainValue) {
      return [new ValidationError(options2.key, reportValue, "stop domain values must appear in ascending order")];
    } else {
      previousStopDomainValue = value;
    }
    if (functionType === "categorical" && value in stopDomainValues) {
      return [new ValidationError(options2.key, reportValue, "stop domain values must be unique")];
    } else {
      stopDomainValues[value] = true;
    }
    return [];
  }
  function validateFunctionDefault(options2) {
    return options2.validateSpec({
      key: options2.key,
      value: options2.value,
      valueSpec: functionValueSpec,
      validateSpec: options2.validateSpec,
      style: options2.style,
      styleSpec: options2.styleSpec
    });
  }
}
function validateExpression(options) {
  const expression = (options.expressionContext === "property" ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);
  if (expression.result === "error") {
    return expression.value.map((error2) => {
      return new ValidationError(`${options.key}${error2.key}`, options.value, error2.message);
    });
  }
  const expressionObj = expression.value.expression || expression.value._styleExpression.expression;
  if (options.expressionContext === "property" && options.propertyKey === "text-font" && !expressionObj.outputDefined()) {
    return [new ValidationError(options.key, options.value, `Invalid data expression for "${options.propertyKey}". Output values must be contained as literals within the expression.`)];
  }
  if (options.expressionContext === "property" && options.propertyType === "layout" && !isStateConstant(expressionObj)) {
    return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with layout properties.')];
  }
  if (options.expressionContext === "filter" && !isStateConstant(expressionObj)) {
    return [new ValidationError(options.key, options.value, '"feature-state" data expressions are not supported with filters.')];
  }
  if (options.expressionContext && options.expressionContext.indexOf("cluster") === 0) {
    if (!isGlobalPropertyConstant(expressionObj, ["zoom", "feature-state"])) {
      return [new ValidationError(options.key, options.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    }
    if (options.expressionContext === "cluster-initial" && !isFeatureConstant(expressionObj)) {
      return [new ValidationError(options.key, options.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
    }
  }
  return [];
}
function validateBoolean(options) {
  const value = options.value;
  const key = options.key;
  const type = getType(value);
  if (type !== "boolean") {
    return [new ValidationError(key, value, `boolean expected, ${type} found`)];
  }
  return [];
}
function validateColor(options) {
  const key = options.key;
  const value = options.value;
  const type = getType(value);
  if (type !== "string") {
    return [new ValidationError(key, value, `color expected, ${type} found`)];
  }
  if (!Color.parse(String(value))) {
    return [new ValidationError(key, value, `color expected, "${value}" found`)];
  }
  return [];
}
function validateEnum(options) {
  const key = options.key;
  const value = options.value;
  const valueSpec = options.valueSpec;
  const errors = [];
  if (Array.isArray(valueSpec.values)) {
    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
      errors.push(new ValidationError(key, value, `expected one of [${valueSpec.values.join(", ")}], ${JSON.stringify(value)} found`));
    }
  } else {
    if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {
      errors.push(new ValidationError(key, value, `expected one of [${Object.keys(valueSpec.values).join(", ")}], ${JSON.stringify(value)} found`));
    }
  }
  return errors;
}
function validateFilter(options) {
  if (isExpressionFilter(deepUnbundle(options.value))) {
    return validateExpression(extendBy({}, options, {
      expressionContext: "filter",
      valueSpec: { value: "boolean" }
    }));
  } else {
    return validateNonExpressionFilter(options);
  }
}
function validateNonExpressionFilter(options) {
  const value = options.value;
  const key = options.key;
  if (getType(value) !== "array") {
    return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];
  }
  const styleSpec = options.styleSpec;
  let type;
  let errors = [];
  if (value.length < 1) {
    return [new ValidationError(key, value, "filter array must have at least 1 element")];
  }
  errors = errors.concat(validateEnum({
    key: `${key}[0]`,
    value: value[0],
    valueSpec: styleSpec.filter_operator,
    style: options.style,
    styleSpec: options.styleSpec
  }));
  switch (unbundle(value[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      if (value.length >= 2 && unbundle(value[1]) === "$type") {
        errors.push(new ValidationError(key, value, `"$type" cannot be use with operator "${value[0]}"`));
      }
    /* falls through */
    case "==":
    case "!=":
      if (value.length !== 3) {
        errors.push(new ValidationError(key, value, `filter array for operator "${value[0]}" must have 3 elements`));
      }
    /* falls through */
    case "in":
    case "!in":
      if (value.length >= 2) {
        type = getType(value[1]);
        if (type !== "string") {
          errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));
        }
      }
      for (let i = 2; i < value.length; i++) {
        type = getType(value[i]);
        if (unbundle(value[1]) === "$type") {
          errors = errors.concat(validateEnum({
            key: `${key}[${i}]`,
            value: value[i],
            valueSpec: styleSpec.geometry_type,
            style: options.style,
            styleSpec: options.styleSpec
          }));
        } else if (type !== "string" && type !== "number" && type !== "boolean") {
          errors.push(new ValidationError(`${key}[${i}]`, value[i], `string, number, or boolean expected, ${type} found`));
        }
      }
      break;
    case "any":
    case "all":
    case "none":
      for (let i = 1; i < value.length; i++) {
        errors = errors.concat(validateNonExpressionFilter({
          key: `${key}[${i}]`,
          value: value[i],
          style: options.style,
          styleSpec: options.styleSpec
        }));
      }
      break;
    case "has":
    case "!has":
      type = getType(value[1]);
      if (value.length !== 2) {
        errors.push(new ValidationError(key, value, `filter array for "${value[0]}" operator must have 2 elements`));
      } else if (type !== "string") {
        errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));
      }
      break;
  }
  return errors;
}
function validateProperty(options, propertyType) {
  const key = options.key;
  const validateSpec = options.validateSpec;
  const style = options.style;
  const styleSpec = options.styleSpec;
  const value = options.value;
  const propertyKey = options.objectKey;
  const layerSpec = styleSpec[`${propertyType}_${options.layerType}`];
  if (!layerSpec)
    return [];
  const transitionMatch = propertyKey.match(/^(.*)-transition$/);
  if (propertyType === "paint" && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
    return validateSpec({
      key,
      value,
      valueSpec: styleSpec.transition,
      style,
      styleSpec
    });
  }
  const valueSpec = options.valueSpec || layerSpec[propertyKey];
  if (!valueSpec) {
    return [new ValidationError(key, value, `unknown property "${propertyKey}"`)];
  }
  let tokenMatch;
  if (getType(value) === "string" && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {
    return [new ValidationError(key, value, `"${propertyKey}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(tokenMatch[1])} }\`.`)];
  }
  const errors = [];
  if (options.layerType === "symbol") {
    if (propertyKey === "text-field" && style && !style.glyphs) {
      errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
    }
    if (propertyKey === "text-font" && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === "identity") {
      errors.push(new ValidationError(key, value, '"text-font" does not support identity functions'));
    }
  }
  return errors.concat(validateSpec({
    key: options.key,
    value,
    valueSpec,
    style,
    styleSpec,
    expressionContext: "property",
    propertyType,
    propertyKey
  }));
}
function validatePaintProperty(options) {
  return validateProperty(options, "paint");
}
function validateLayoutProperty(options) {
  return validateProperty(options, "layout");
}
function validateLayer(options) {
  let errors = [];
  const layer2 = options.value;
  const key = options.key;
  const style = options.style;
  const styleSpec = options.styleSpec;
  if (getType(layer2) !== "object") {
    return [new ValidationError(key, layer2, `object expected, ${getType(layer2)} found`)];
  }
  if (!layer2.type && !layer2.ref) {
    errors.push(new ValidationError(key, layer2, 'either "type" or "ref" is required'));
  }
  let type = unbundle(layer2.type);
  const ref = unbundle(layer2.ref);
  if (layer2.id) {
    const layerId = unbundle(layer2.id);
    for (let i = 0; i < options.arrayIndex; i++) {
      const otherLayer = style.layers[i];
      if (unbundle(otherLayer.id) === layerId) {
        errors.push(new ValidationError(key, layer2.id, `duplicate layer id "${layer2.id}", previously used at line ${otherLayer.id.__line__}`));
      }
    }
  }
  if ("ref" in layer2) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((p) => {
      if (p in layer2) {
        errors.push(new ValidationError(key, layer2[p], `"${p}" is prohibited for ref layers`));
      }
    });
    let parent;
    style.layers.forEach((layer3) => {
      if (unbundle(layer3.id) === ref)
        parent = layer3;
    });
    if (!parent) {
      errors.push(new ValidationError(key, layer2.ref, `ref layer "${ref}" not found`));
    } else if (parent.ref) {
      errors.push(new ValidationError(key, layer2.ref, "ref cannot reference another ref layer"));
    } else {
      type = unbundle(parent.type);
    }
  } else if (type !== "background") {
    if (!layer2.source) {
      errors.push(new ValidationError(key, layer2, 'missing required property "source"'));
    } else {
      const source2 = style.sources && style.sources[layer2.source];
      const sourceType = source2 && unbundle(source2.type);
      if (!source2) {
        errors.push(new ValidationError(key, layer2.source, `source "${layer2.source}" not found`));
      } else if (sourceType === "vector" && type === "raster") {
        errors.push(new ValidationError(key, layer2.source, `layer "${layer2.id}" requires a raster source`));
      } else if (sourceType !== "raster-dem" && type === "hillshade") {
        errors.push(new ValidationError(key, layer2.source, `layer "${layer2.id}" requires a raster-dem source`));
      } else if (sourceType !== "raster-dem" && type === "color-relief") {
        errors.push(new ValidationError(key, layer2.source, `layer "${layer2.id}" requires a raster-dem source`));
      } else if (sourceType === "raster" && type !== "raster") {
        errors.push(new ValidationError(key, layer2.source, `layer "${layer2.id}" requires a vector source`));
      } else if (sourceType === "vector" && !layer2["source-layer"]) {
        errors.push(new ValidationError(key, layer2, `layer "${layer2.id}" must specify a "source-layer"`));
      } else if (sourceType === "raster-dem" && (type !== "hillshade" && type !== "color-relief")) {
        errors.push(new ValidationError(key, layer2.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'."));
      } else if (type === "line" && layer2.paint && layer2.paint["line-gradient"] && (sourceType !== "geojson" || !source2.lineMetrics)) {
        errors.push(new ValidationError(key, layer2, `layer "${layer2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`));
      }
    }
  }
  errors = errors.concat(validateObject({
    key,
    value: layer2,
    valueSpec: styleSpec.layer,
    style: options.style,
    styleSpec: options.styleSpec,
    validateSpec: options.validateSpec,
    objectElementValidators: {
      "*"() {
        return [];
      },
      // We don't want to enforce the spec's `"requires": true` for backward compatibility with refs;
      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.
      type() {
        return options.validateSpec({
          key: `${key}.type`,
          value: layer2.type,
          valueSpec: styleSpec.layer.type,
          style: options.style,
          styleSpec: options.styleSpec,
          validateSpec: options.validateSpec,
          object: layer2,
          objectKey: "type"
        });
      },
      filter: validateFilter,
      layout(options2) {
        return validateObject({
          layer: layer2,
          key: options2.key,
          value: options2.value,
          style: options2.style,
          styleSpec: options2.styleSpec,
          validateSpec: options2.validateSpec,
          objectElementValidators: {
            "*"(options3) {
              return validateLayoutProperty(extendBy({ layerType: type }, options3));
            }
          }
        });
      },
      paint(options2) {
        return validateObject({
          layer: layer2,
          key: options2.key,
          value: options2.value,
          style: options2.style,
          styleSpec: options2.styleSpec,
          validateSpec: options2.validateSpec,
          objectElementValidators: {
            "*"(options3) {
              return validatePaintProperty(extendBy({ layerType: type }, options3));
            }
          }
        });
      }
    }
  }));
  return errors;
}
function validateString(options) {
  const value = options.value;
  const key = options.key;
  const type = getType(value);
  if (type !== "string") {
    return [new ValidationError(key, value, `string expected, ${type} found`)];
  }
  return [];
}
function validateRasterDEMSource(options) {
  var _a;
  const sourceName = (_a = options.sourceName) !== null && _a !== void 0 ? _a : "";
  const rasterDEM = options.value;
  const styleSpec = options.styleSpec;
  const rasterDEMSpec = styleSpec.source_raster_dem;
  const style = options.style;
  let errors = [];
  const rootType = getType(rasterDEM);
  if (rasterDEM === void 0) {
    return errors;
  } else if (rootType !== "object") {
    errors.push(new ValidationError("source_raster_dem", rasterDEM, `object expected, ${rootType} found`));
    return errors;
  }
  const encoding = unbundle(rasterDEM.encoding);
  const isCustomEncoding = encoding === "custom";
  const customEncodingKeys = ["redFactor", "greenFactor", "blueFactor", "baseShift"];
  const encodingName = options.value.encoding ? `"${options.value.encoding}"` : "Default";
  for (const key in rasterDEM) {
    if (!isCustomEncoding && customEncodingKeys.includes(key)) {
      errors.push(new ValidationError(key, rasterDEM[key], `In "${sourceName}": "${key}" is only valid when "encoding" is set to "custom". ${encodingName} encoding found`));
    } else if (rasterDEMSpec[key]) {
      errors = errors.concat(options.validateSpec({
        key,
        value: rasterDEM[key],
        valueSpec: rasterDEMSpec[key],
        validateSpec: options.validateSpec,
        style,
        styleSpec
      }));
    } else {
      errors.push(new ValidationError(key, rasterDEM[key], `unknown property "${key}"`));
    }
  }
  return errors;
}
var objectElementValidators = {
  promoteId: validatePromoteId
};
function validateSource(options) {
  const value = options.value;
  const key = options.key;
  const styleSpec = options.styleSpec;
  const style = options.style;
  const validateSpec = options.validateSpec;
  if (!value.type) {
    return [new ValidationError(key, value, '"type" is required')];
  }
  const type = unbundle(value.type);
  let errors;
  switch (type) {
    case "vector":
    case "raster":
      errors = validateObject({
        key,
        value,
        valueSpec: styleSpec[`source_${type.replace("-", "_")}`],
        style: options.style,
        styleSpec,
        objectElementValidators,
        validateSpec
      });
      return errors;
    case "raster-dem":
      errors = validateRasterDEMSource({
        sourceName: key,
        value,
        style: options.style,
        styleSpec,
        validateSpec
      });
      return errors;
    case "geojson":
      errors = validateObject({
        key,
        value,
        valueSpec: styleSpec.source_geojson,
        style,
        styleSpec,
        validateSpec,
        objectElementValidators
      });
      if (value.cluster) {
        for (const prop in value.clusterProperties) {
          const [operator, mapExpr] = value.clusterProperties[prop];
          const reduceExpr = typeof operator === "string" ? [operator, ["accumulated"], ["get", prop]] : operator;
          errors.push(...validateExpression({
            key: `${key}.${prop}.map`,
            value: mapExpr,
            expressionContext: "cluster-map"
          }));
          errors.push(...validateExpression({
            key: `${key}.${prop}.reduce`,
            value: reduceExpr,
            expressionContext: "cluster-reduce"
          }));
        }
      }
      return errors;
    case "video":
      return validateObject({
        key,
        value,
        valueSpec: styleSpec.source_video,
        style,
        validateSpec,
        styleSpec
      });
    case "image":
      return validateObject({
        key,
        value,
        valueSpec: styleSpec.source_image,
        style,
        validateSpec,
        styleSpec
      });
    case "canvas":
      return [new ValidationError(key, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return validateEnum({
        key: `${key}.type`,
        value: value.type,
        valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }
      });
  }
}
function validatePromoteId({ key, value }) {
  if (getType(value) === "string") {
    return validateString({ key, value });
  } else {
    const errors = [];
    for (const prop in value) {
      errors.push(...validateString({ key: `${key}.${prop}`, value: value[prop] }));
    }
    return errors;
  }
}
function validateLight(options) {
  const light2 = options.value;
  const styleSpec = options.styleSpec;
  const lightSpec = styleSpec.light;
  const style = options.style;
  let errors = [];
  const rootType = getType(light2);
  if (light2 === void 0) {
    return errors;
  } else if (rootType !== "object") {
    errors = errors.concat([new ValidationError("light", light2, `object expected, ${rootType} found`)]);
    return errors;
  }
  for (const key in light2) {
    const transitionMatch = key.match(/^(.*)-transition$/);
    if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {
      errors = errors.concat(options.validateSpec({
        key,
        value: light2[key],
        valueSpec: styleSpec.transition,
        validateSpec: options.validateSpec,
        style,
        styleSpec
      }));
    } else if (lightSpec[key]) {
      errors = errors.concat(options.validateSpec({
        key,
        value: light2[key],
        valueSpec: lightSpec[key],
        validateSpec: options.validateSpec,
        style,
        styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, light2[key], `unknown property "${key}"`)]);
    }
  }
  return errors;
}
function validateSky(options) {
  const sky2 = options.value;
  const styleSpec = options.styleSpec;
  const skySpec = styleSpec.sky;
  const style = options.style;
  const rootType = getType(sky2);
  if (sky2 === void 0) {
    return [];
  } else if (rootType !== "object") {
    return [new ValidationError("sky", sky2, `object expected, ${rootType} found`)];
  }
  let errors = [];
  for (const key in sky2) {
    if (skySpec[key]) {
      errors = errors.concat(options.validateSpec({
        key,
        value: sky2[key],
        valueSpec: skySpec[key],
        style,
        styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, sky2[key], `unknown property "${key}"`)]);
    }
  }
  return errors;
}
function validateTerrain(options) {
  const terrain2 = options.value;
  const styleSpec = options.styleSpec;
  const terrainSpec = styleSpec.terrain;
  const style = options.style;
  let errors = [];
  const rootType = getType(terrain2);
  if (terrain2 === void 0) {
    return errors;
  } else if (rootType !== "object") {
    errors = errors.concat([new ValidationError("terrain", terrain2, `object expected, ${rootType} found`)]);
    return errors;
  }
  for (const key in terrain2) {
    if (terrainSpec[key]) {
      errors = errors.concat(options.validateSpec({
        key,
        value: terrain2[key],
        valueSpec: terrainSpec[key],
        validateSpec: options.validateSpec,
        style,
        styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, terrain2[key], `unknown property "${key}"`)]);
    }
  }
  return errors;
}
function validateFormatted(options) {
  if (validateString(options).length === 0) {
    return [];
  }
  return validateExpression(options);
}
function validateImage(options) {
  if (validateString(options).length === 0) {
    return [];
  }
  return validateExpression(options);
}
function validatePadding(options) {
  const key = options.key;
  const value = options.value;
  const type = getType(value);
  if (type === "array") {
    if (value.length < 1 || value.length > 4) {
      return [new ValidationError(key, value, `padding requires 1 to 4 values; ${value.length} values found`)];
    }
    const arrayElementSpec = {
      type: "number"
    };
    let errors = [];
    for (let i = 0; i < value.length; i++) {
      errors = errors.concat(options.validateSpec({
        key: `${key}[${i}]`,
        value: value[i],
        validateSpec: options.validateSpec,
        valueSpec: arrayElementSpec
      }));
    }
    return errors;
  } else {
    return validateNumber({
      key,
      value,
      valueSpec: {}
    });
  }
}
function validateNumberArray(options) {
  const key = options.key;
  const value = options.value;
  const type = getType(value);
  if (type === "array") {
    const arrayElementSpec = {
      type: "number"
    };
    if (value.length < 1) {
      return [new ValidationError(key, value, "array length at least 1 expected, length 0 found")];
    }
    let errors = [];
    for (let i = 0; i < value.length; i++) {
      errors = errors.concat(options.validateSpec({
        key: `${key}[${i}]`,
        value: value[i],
        validateSpec: options.validateSpec,
        valueSpec: arrayElementSpec
      }));
    }
    return errors;
  } else {
    return validateNumber({
      key,
      value,
      valueSpec: {}
    });
  }
}
function validateColorArray(options) {
  const key = options.key;
  const value = options.value;
  const type = getType(value);
  if (type === "array") {
    if (value.length < 1) {
      return [new ValidationError(key, value, "array length at least 1 expected, length 0 found")];
    }
    let errors = [];
    for (let i = 0; i < value.length; i++) {
      errors = errors.concat(validateColor({
        key: `${key}[${i}]`,
        value: value[i]
      }));
    }
    return errors;
  } else {
    return validateColor({
      key,
      value
    });
  }
}
function validateVariableAnchorOffsetCollection(options) {
  const key = options.key;
  const value = options.value;
  const type = getType(value);
  const styleSpec = options.styleSpec;
  if (type !== "array" || value.length < 1 || value.length % 2 !== 0) {
    return [new ValidationError(key, value, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  }
  let errors = [];
  for (let i = 0; i < value.length; i += 2) {
    errors = errors.concat(validateEnum({
      key: `${key}[${i}]`,
      value: value[i],
      valueSpec: styleSpec["layout_symbol"]["text-anchor"]
    }));
    errors = errors.concat(validateArray({
      key: `${key}[${i + 1}]`,
      value: value[i + 1],
      valueSpec: {
        length: 2,
        value: "number"
      },
      validateSpec: options.validateSpec,
      style: options.style,
      styleSpec
    }));
  }
  return errors;
}
function validateSprite(options) {
  let errors = [];
  const sprite = options.value;
  const key = options.key;
  if (!Array.isArray(sprite)) {
    return validateString({
      key,
      value: sprite
    });
  } else {
    const allSpriteIds = [];
    const allSpriteURLs = [];
    for (const i in sprite) {
      if (sprite[i].id && allSpriteIds.includes(sprite[i].id))
        errors.push(new ValidationError(key, sprite, `all the sprites' ids must be unique, but ${sprite[i].id} is duplicated`));
      allSpriteIds.push(sprite[i].id);
      if (sprite[i].url && allSpriteURLs.includes(sprite[i].url))
        errors.push(new ValidationError(key, sprite, `all the sprites' URLs must be unique, but ${sprite[i].url} is duplicated`));
      allSpriteURLs.push(sprite[i].url);
      const pairSpec = {
        id: {
          type: "string",
          required: true
        },
        url: {
          type: "string",
          required: true
        }
      };
      errors = errors.concat(validateObject({
        key: `${key}[${i}]`,
        value: sprite[i],
        valueSpec: pairSpec,
        validateSpec: options.validateSpec
      }));
    }
    return errors;
  }
}
function validateProjection(options) {
  const projection2 = options.value;
  const styleSpec = options.styleSpec;
  const projectionSpec = styleSpec.projection;
  const style = options.style;
  const rootType = getType(projection2);
  if (projection2 === void 0) {
    return [];
  } else if (rootType !== "object") {
    return [new ValidationError("projection", projection2, `object expected, ${rootType} found`)];
  }
  let errors = [];
  for (const key in projection2) {
    if (projectionSpec[key]) {
      errors = errors.concat(options.validateSpec({
        key,
        value: projection2[key],
        valueSpec: projectionSpec[key],
        style,
        styleSpec
      }));
    } else {
      errors = errors.concat([new ValidationError(key, projection2[key], `unknown property "${key}"`)]);
    }
  }
  return errors;
}
function validateProjectionDefinition(options) {
  const key = options.key;
  let value = options.value;
  value = value instanceof String ? value.valueOf() : value;
  const type = getType(value);
  if (type === "array" && !isProjectionDefinitionValue(value) && !isPropertyValueSpecification(value)) {
    return [new ValidationError(key, value, `projection expected, invalid array ${JSON.stringify(value)} found`)];
  } else if (!["array", "string"].includes(type)) {
    return [new ValidationError(key, value, `projection expected, invalid type "${type}" found`)];
  }
  return [];
}
function isPropertyValueSpecification(value) {
  if (["interpolate", "step", "literal"].includes(value[0])) {
    return true;
  }
  return false;
}
function isProjectionDefinitionValue(value) {
  return Array.isArray(value) && value.length === 3 && typeof value[0] === "string" && typeof value[1] === "string" && typeof value[2] === "number";
}
function isObjectLiteral(anything) {
  return Boolean(anything) && anything.constructor === Object;
}
function validateState(options) {
  if (!isObjectLiteral(options.value)) {
    return [
      new ValidationError(options.key, options.value, `object expected, ${getType(options.value)} found`)
    ];
  }
  return [];
}
var VALIDATORS = {
  "*"() {
    return [];
  },
  "array": validateArray,
  "boolean": validateBoolean,
  "number": validateNumber,
  "color": validateColor,
  "constants": validateConstants,
  "enum": validateEnum,
  "filter": validateFilter,
  "function": validateFunction,
  "layer": validateLayer,
  "object": validateObject,
  "source": validateSource,
  "light": validateLight,
  "sky": validateSky,
  "terrain": validateTerrain,
  "projection": validateProjection,
  "projectionDefinition": validateProjectionDefinition,
  "string": validateString,
  "formatted": validateFormatted,
  "resolvedImage": validateImage,
  "padding": validatePadding,
  "numberArray": validateNumberArray,
  "colorArray": validateColorArray,
  "variableAnchorOffsetCollection": validateVariableAnchorOffsetCollection,
  "sprite": validateSprite,
  "state": validateState
};
function validate(options) {
  const value = options.value;
  const valueSpec = options.valueSpec;
  const styleSpec = options.styleSpec;
  options.validateSpec = validate;
  if (valueSpec.expression && isFunction$1(unbundle(value))) {
    return validateFunction(options);
  } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {
    return validateExpression(options);
  } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
    return VALIDATORS[valueSpec.type](options);
  } else {
    const valid = validateObject(extendBy({}, options, {
      valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
    }));
    return valid;
  }
}
function validateGlyphsUrl(options) {
  const value = options.value;
  const key = options.key;
  const errors = validateString(options);
  if (errors.length)
    return errors;
  if (value.indexOf("{fontstack}") === -1) {
    errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
  }
  if (value.indexOf("{range}") === -1) {
    errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
  }
  return errors;
}
function validateStyleMin(style, styleSpec = v8Spec) {
  let errors = [];
  errors = errors.concat(validate({
    key: "",
    value: style,
    valueSpec: styleSpec.$root,
    styleSpec,
    style,
    validateSpec: validate,
    objectElementValidators: {
      glyphs: validateGlyphsUrl,
      "*"() {
        return [];
      }
    }
  }));
  if (style["constants"]) {
    errors = errors.concat(validateConstants({
      key: "constants",
      value: style["constants"]
    }));
  }
  return sortErrors(errors);
}
validateStyleMin.source = wrapCleanErrors(injectValidateSpec(validateSource));
validateStyleMin.sprite = wrapCleanErrors(injectValidateSpec(validateSprite));
validateStyleMin.glyphs = wrapCleanErrors(injectValidateSpec(validateGlyphsUrl));
validateStyleMin.light = wrapCleanErrors(injectValidateSpec(validateLight));
validateStyleMin.sky = wrapCleanErrors(injectValidateSpec(validateSky));
validateStyleMin.terrain = wrapCleanErrors(injectValidateSpec(validateTerrain));
validateStyleMin.state = wrapCleanErrors(injectValidateSpec(validateState));
validateStyleMin.layer = wrapCleanErrors(injectValidateSpec(validateLayer));
validateStyleMin.filter = wrapCleanErrors(injectValidateSpec(validateFilter));
validateStyleMin.paintProperty = wrapCleanErrors(injectValidateSpec(validatePaintProperty));
validateStyleMin.layoutProperty = wrapCleanErrors(injectValidateSpec(validateLayoutProperty));
function injectValidateSpec(validator) {
  return function(options) {
    return validator({
      ...options,
      validateSpec: validate
    });
  };
}
function sortErrors(errors) {
  return [].concat(errors).sort((a, b) => {
    return a.line - b.line;
  });
}
function wrapCleanErrors(inner) {
  return function(...args) {
    return sortErrors(inner.apply(this, args));
  };
}
var v8 = v8Spec;

// node_modules/mapbox-to-css-font/index.js
var fontWeights = {
  thin: 100,
  hairline: 100,
  "ultra-light": 200,
  "extra-light": 200,
  light: 300,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  "semi-bold": 600,
  "demi-bold": 600,
  bold: 700,
  "extra-bold": 800,
  "ultra-bold": 800,
  heavy: 900,
  black: 900,
  "heavy-black": 900,
  fat: 900,
  poster: 900,
  "ultra-black": 950,
  "extra-black": 950
};
var sp = " ";
var italicRE = /(italic|oblique)$/i;
var fontCache = {};
function mapbox_to_css_font_default(fonts, size, lineHeight) {
  var cssData = fontCache[fonts];
  if (!cssData) {
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    var weight = 400;
    var style = "normal";
    var fontFamilies = [];
    var haveWeight, haveStyle;
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      var parts = font.split(" ");
      var maybeWeight = parts[parts.length - 1].toLowerCase();
      if (maybeWeight == "normal" || maybeWeight == "italic" || maybeWeight == "oblique") {
        style = haveStyle ? style : maybeWeight;
        haveStyle = true;
        parts.pop();
        maybeWeight = parts[parts.length - 1].toLowerCase();
      } else if (italicRE.test(maybeWeight)) {
        maybeWeight = maybeWeight.replace(italicRE, "");
        style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, "");
        haveStyle = true;
      }
      for (var w in fontWeights) {
        var previousPart = parts.length > 1 ? parts[parts.length - 2].toLowerCase() : "";
        if (maybeWeight == w || maybeWeight == w.replace("-", "") || previousPart + "-" + maybeWeight == w) {
          weight = haveWeight ? weight : fontWeights[w];
          parts.pop();
          if (previousPart && w.startsWith(previousPart)) {
            parts.pop();
          }
          break;
        }
      }
      if (!haveWeight && typeof maybeWeight == "number") {
        weight = maybeWeight;
        haveWeight = true;
      }
      var fontFamily = parts.join(sp).replace("Klokantech Noto Sans", "Noto Sans").replace("DIN Pro", "Barlow").replace("Arial Unicode MS", "Arial");
      if (fontFamily.indexOf(sp) !== -1) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies.push(fontFamily);
    }
    cssData = fontCache[fonts] = [style, weight, fontFamilies];
  }
  return cssData[0] + sp + cssData[1] + sp + size + "px" + (lineHeight ? "/" + lineHeight : "") + sp + cssData[2];
}

// node_modules/ol/layer/Graticule.js
var DEFAULT_STROKE_STYLE = new Stroke_default({
  color: "rgba(0,0,0,0.2)"
});
var INTERVALS = [
  90,
  45,
  30,
  20,
  10,
  5,
  2,
  1,
  30 / 60,
  20 / 60,
  10 / 60,
  5 / 60,
  2 / 60,
  1 / 60,
  30 / 3600,
  20 / 3600,
  10 / 3600,
  5 / 3600,
  2 / 3600,
  1 / 3600
];

// node_modules/ol/ImageCanvas.js
var ImageCanvas = class extends Image_default {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement|OffscreenCanvas} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(extent, resolution, pixelRatio, canvas, loader) {
    const state = loader !== void 0 ? ImageState_default.IDLE : ImageState_default.LOADED;
    super(extent, resolution, pixelRatio, state);
    this.loader_ = loader !== void 0 ? loader : null;
    this.canvas_ = canvas;
    this.error_ = null;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(err) {
    if (err) {
      this.error_ = err;
      this.state = ImageState_default.ERROR;
    } else {
      this.state = ImageState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == ImageState_default.IDLE) {
      this.state = ImageState_default.LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas element.
   * @override
   */
  getImage() {
    return this.canvas_;
  }
};
var ImageCanvas_default = ImageCanvas;

// node_modules/ol/Overlay.js
var Property = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
var Overlay = class extends Object_default {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.options = options;
    this.id = options.id;
    this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    this.element = document.createElement("div");
    this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    this.element.style.position = "absolute";
    this.element.style.pointerEvents = "auto";
    this.autoPan = options.autoPan === true ? {} : options.autoPan || void 0;
    this.rendered = {
      transform_: "",
      visible: true
    };
    this.mapPostrenderListenerKey = null;
    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);
    this.addChangeListener(Property.MAP, this.handleMapChanged);
    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);
    this.addChangeListener(Property.POSITION, this.handlePositionChanged);
    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);
    if (options.element !== void 0) {
      this.setElement(options.element);
    }
    this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    this.setPositioning(options.positioning || "top-left");
    if (options.position !== void 0) {
      this.setPosition(options.position);
    }
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Property.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(Property.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(Property.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(Property.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    removeChildren(this.element);
    const element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  }
  /**
   * @protected
   */
  handleMapChanged() {
    var _a;
    if (this.mapPostrenderListenerKey) {
      (_a = this.element) == null ? void 0 : _a.remove();
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    const map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(
        map,
        MapEventType_default.POSTRENDER,
        this.render,
        this
      );
      this.updatePixelPosition();
      const container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition();
    this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(element) {
    this.set(Property.ELEMENT, element);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(map) {
    this.set(Property.MAP, map);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(offset) {
    this.set(Property.OFFSET, offset);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(position) {
    this.set(Property.POSITION, position);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(panIntoViewOptions) {
    const map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
      return;
    }
    const mapRect = this.getRect(map.getTargetElement(), map.getSize());
    const element = this.getElement();
    const overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    panIntoViewOptions = panIntoViewOptions || {};
    const myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      const offsetLeft = overlayRect[0] - mapRect[0];
      const offsetRight = mapRect[2] - overlayRect[2];
      const offsetTop = overlayRect[1] - mapRect[1];
      const offsetBottom = mapRect[3] - overlayRect[3];
      const delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        const center = (
          /** @type {import("./coordinate.js").Coordinate} */
          map.getView().getCenterInternal()
        );
        const centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        const panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(element, size) {
    const box = element.getBoundingClientRect();
    const offsetX = box.left + window.pageXOffset;
    const offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(positioning) {
    this.set(Property.POSITIONING, positioning);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const map = this.getMap();
    const position = this.getPosition();
    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }
    const pixel = map.getPixelFromCoordinate(position);
    const mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(pixel, mapSize) {
    const style = this.element.style;
    const offset = this.getOffset();
    const positioning = this.getPositioning();
    this.setVisible(true);
    const x = `${pixel[0] + offset[0]}px`;
    const y = `${pixel[1] + offset[1]}px`;
    let posX = "0%";
    let posY = "0%";
    if (positioning == "bottom-right" || positioning == "center-right" || positioning == "top-right") {
      posX = "-100%";
    } else if (positioning == "bottom-center" || positioning == "center-center" || positioning == "top-center") {
      posX = "-50%";
    }
    if (positioning == "bottom-left" || positioning == "bottom-center" || positioning == "bottom-right") {
      posY = "-100%";
    } else if (positioning == "center-left" || positioning == "center-center" || positioning == "center-right") {
      posY = "-50%";
    }
    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;
    if (this.rendered.transform_ != transform) {
      this.rendered.transform_ = transform;
      style.transform = transform;
    }
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
};
var Overlay_default = Overlay;

// node_modules/ol-mapbox-style/src/mapbox.js
var mapboxBaseUrl = "https://api.mapbox.com";
function getMapboxPath(url) {
  const startsWith = "mapbox://";
  if (url.indexOf(startsWith) !== 0) {
    return "";
  }
  return url.slice(startsWith.length);
}
function normalizeSpriteDefinition(sprite, token, styleUrl) {
  if (typeof sprite === "string") {
    return [
      {
        "id": "default",
        "url": normalizeSpriteUrl(sprite, token, styleUrl)
      }
    ];
  }
  for (const spriteObj of sprite) {
    spriteObj.url = normalizeSpriteUrl(spriteObj.url, token, styleUrl);
  }
  return sprite;
}
function normalizeSpriteUrl(url, token, styleUrl) {
  const mapboxPath = getMapboxPath(url);
  if (!mapboxPath) {
    return decodeURI(new URL(url, styleUrl).href);
  }
  const startsWith = "sprites/";
  if (mapboxPath.indexOf(startsWith) !== 0) {
    throw new Error(`unexpected sprites url: ${url}`);
  }
  const sprite = mapboxPath.slice(startsWith.length);
  return `${mapboxBaseUrl}/styles/v1/${sprite}/sprite?access_token=${token}`;
}
function normalizeStyleUrl(url, token) {
  const mapboxPath = getMapboxPath(url);
  if (!mapboxPath) {
    return decodeURI(new URL(url, location.href).href);
  }
  const startsWith = "styles/";
  if (mapboxPath.indexOf(startsWith) !== 0) {
    throw new Error(`unexpected style url: ${url}`);
  }
  const style = mapboxPath.slice(startsWith.length);
  return `${mapboxBaseUrl}/styles/v1/${style}?&access_token=${token}`;
}
var mapboxSubdomains = ["a", "b", "c", "d"];
function normalizeSourceUrl(url, token, tokenParam, styleUrl) {
  const urlObject = new URL(url, styleUrl || location.href);
  const mapboxPath = getMapboxPath(url);
  if (!mapboxPath) {
    if (!token) {
      return [decodeURI(urlObject.href)];
    }
    if (!urlObject.searchParams.has(tokenParam)) {
      urlObject.searchParams.set(tokenParam, token);
    }
    return [decodeURI(urlObject.href)];
  }
  if (mapboxPath === "mapbox.satellite") {
    const sizeFactor = window.devicePixelRatio >= 1.5 ? "@2x" : "";
    return [
      `https://api.mapbox.com/v4/${mapboxPath}/{z}/{x}/{y}${sizeFactor}.webp?access_token=${token}`
    ];
  }
  return mapboxSubdomains.map(
    (sub) => `https://${sub}.tiles.mapbox.com/v4/${mapboxPath}/{z}/{x}/{y}.vector.pbf?access_token=${token}`
  );
}

// node_modules/ol-mapbox-style/src/util.js
var emptyObj = Object.freeze({});
var functionCacheByStyleId = {};
var filterCacheByStyleId = {};
var styleId = 0;
function getStyleId(glStyle) {
  if (!glStyle.id) {
    glStyle.id = styleId++;
  }
  return glStyle.id;
}
function getStyleFunctionKey(glStyle, olLayer) {
  return getStyleId(glStyle) + "." + getUid(olLayer);
}
function getFunctionCache(glStyle) {
  let functionCache = functionCacheByStyleId[glStyle.id];
  if (!functionCache) {
    functionCache = {};
    functionCacheByStyleId[getStyleId(glStyle)] = functionCache;
  }
  return functionCache;
}
function clearFunctionCache() {
  for (const key in functionCacheByStyleId) {
    delete functionCacheByStyleId[key];
  }
}
function getFilterCache(glStyle) {
  let filterCache = filterCacheByStyleId[glStyle.id];
  if (!filterCache) {
    filterCache = {};
    filterCacheByStyleId[getStyleId(glStyle)] = filterCache;
  }
  return filterCache;
}
function deg2rad2(degrees) {
  return degrees * Math.PI / 180;
}
var defaultResolutions = (function() {
  const resolutions = [];
  for (let res = 78271.51696402048; resolutions.length <= 24; res /= 2) {
    resolutions.push(res);
  }
  return resolutions;
})();
function createCanvas(width, height) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== "undefined") {
    return (
      /** @type {?} */
      new OffscreenCanvas(width, height)
    );
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function getZoomForResolution(resolution, resolutions) {
  let i = 0;
  const ii = resolutions.length;
  for (; i < ii; ++i) {
    const candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      const zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}
function getResolutionForZoom(zoom, resolutions) {
  const base = Math.floor(zoom);
  const factor = Math.pow(2, zoom - base);
  return resolutions[base] / factor;
}
var pendingRequests = {};
function fetchResource(resourceType, url, options = {}, metadata) {
  if (url in pendingRequests) {
    if (metadata) {
      metadata.url = pendingRequests[url][0].url;
    }
    return pendingRequests[url][1];
  }
  const transformedRequest = options.transformRequest ? options.transformRequest(url, resourceType) || url : url;
  const handleError = function(error2) {
    delete pendingRequests[url];
    return Promise.reject(new Error("Error fetching source " + url));
  };
  const handleResponse = function(response) {
    delete pendingRequests[url];
    return response.ok ? response.json() : Promise.reject(new Error("Error fetching source " + url));
  };
  const pendingRequest = toPromise(() => transformedRequest).then((transformedRequest2) => {
    if (transformedRequest2 instanceof Response) {
      if (metadata) {
        metadata.url = transformedRequest2.url;
      }
      return handleResponse(transformedRequest2);
    }
    if (!(transformedRequest2 instanceof Request)) {
      transformedRequest2 = new Request(transformedRequest2);
    }
    if (!transformedRequest2.headers.get("Accept")) {
      transformedRequest2.headers.set("Accept", "application/json");
    }
    if (metadata) {
      metadata.url = transformedRequest2.url;
    }
    return fetch(transformedRequest2).then(handleResponse).catch(handleError);
  }).catch(handleError);
  pendingRequests[url] = [transformedRequest, pendingRequest];
  return pendingRequest;
}
function getGlStyle(glStyleOrUrl, options) {
  if (typeof glStyleOrUrl === "string") {
    if (glStyleOrUrl.trim().startsWith("{")) {
      try {
        const glStyle = JSON.parse(glStyleOrUrl);
        return Promise.resolve(glStyle);
      } catch (error2) {
        return Promise.reject(error2);
      }
    } else {
      glStyleOrUrl = normalizeStyleUrl(glStyleOrUrl, options.accessToken);
      return fetchResource("Style", glStyleOrUrl, options);
    }
  } else {
    return Promise.resolve(glStyleOrUrl);
  }
}
var tilejsonCache = {};
function getTileJson(glSource, styleUrl, options = {}) {
  const cacheKey = [styleUrl, JSON.stringify(glSource)].toString();
  let promise = tilejsonCache[cacheKey];
  if (!promise || options.transformRequest) {
    let tileLoadFunction;
    if (options.transformRequest) {
      tileLoadFunction = (tile, src) => {
        const transformedRequest = options.transformRequest ? options.transformRequest(src, "Tiles") || src : src;
        if (tile instanceof VectorTile_default) {
          tile.setLoader((extent, resolution, projection2) => {
            const handleResponse = function(response) {
              response.arrayBuffer().then((data) => {
                const format = tile.getFormat();
                const features = format.readFeatures(data, {
                  extent,
                  featureProjection: projection2
                });
                tile.setFeatures(features);
              });
            };
            toPromise(() => transformedRequest).then((transformedRequest2) => {
              if (transformedRequest2 instanceof Response) {
                return handleResponse(transformedRequest2);
              }
              fetch(transformedRequest2).then(handleResponse).catch((e) => tile.setState(TileState_default.ERROR));
            }).catch((e) => tile.setState(TileState_default.ERROR));
          });
        } else {
          const img = tile.getImage();
          toPromise(() => transformedRequest).then((transformedRequest2) => {
            if (typeof transformedRequest2 === "string") {
              img.src = transformedRequest2;
              return;
            }
            const handleResponse = (response) => response.blob().then((blob) => {
              const url2 = URL.createObjectURL(blob);
              img.addEventListener("load", () => URL.revokeObjectURL(url2));
              img.addEventListener("error", () => URL.revokeObjectURL(url2));
              img.src = url2;
            });
            if (transformedRequest2 instanceof Response) {
              return handleResponse(transformedRequest2);
            }
            fetch(transformedRequest2).then(handleResponse).catch((e) => tile.setState(TileState_default.ERROR));
          }).catch((e) => tile.setState(TileState_default.ERROR));
        }
      };
    }
    const url = glSource.url;
    if (url && !glSource.tiles) {
      const normalizedSourceUrl = normalizeSourceUrl(
        url,
        options.accessToken,
        options.accessTokenParam || "access_token",
        styleUrl || location.href
      );
      if (url.startsWith("mapbox://")) {
        promise = Promise.resolve({
          tileJson: Object.assign({}, glSource, {
            url: void 0,
            tiles: normalizedSourceUrl
          }),
          tileLoadFunction
        });
      } else {
        const metadata = {};
        promise = fetchResource(
          "Source",
          normalizedSourceUrl[0],
          options,
          metadata
        ).then(function(tileJson) {
          tileJson.tiles = tileJson.tiles.map(function(tileUrl) {
            if (tileJson.scheme === "tms") {
              tileUrl = tileUrl.replace("{y}", "{-y}");
            }
            return normalizeSourceUrl(
              tileUrl,
              options.accessToken,
              options.accessTokenParam || "access_token",
              metadata.url
            )[0];
          });
          return Promise.resolve({ tileJson, tileLoadFunction });
        });
      }
    } else if (glSource.tiles) {
      glSource = Object.assign({}, glSource, {
        tiles: glSource.tiles.map(function(tileUrl) {
          if (glSource.scheme === "tms") {
            tileUrl = tileUrl.replace("{y}", "{-y}");
          }
          return normalizeSourceUrl(
            tileUrl,
            options.accessToken,
            options.accessTokenParam || "access_token",
            styleUrl || location.href
          )[0];
        })
      });
      promise = Promise.resolve({
        tileJson: Object.assign({}, glSource),
        tileLoadFunction
      });
    } else {
      promise = Promise.reject(new Error("source has no `tiles` nor `url`"));
    }
    tilejsonCache[cacheKey] = promise;
  }
  return promise;
}
function drawIconHalo(spriteImage, spriteImageData, haloWidth, haloColor) {
  const imgSize = [
    2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.width,
    2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.height
  ];
  const imageCanvas = createCanvas(imgSize[0], imgSize[1]);
  const imageContext = imageCanvas.getContext("2d");
  imageContext.drawImage(
    spriteImage,
    spriteImageData.x,
    spriteImageData.y,
    spriteImageData.width,
    spriteImageData.height,
    haloWidth * spriteImageData.pixelRatio,
    haloWidth * spriteImageData.pixelRatio,
    spriteImageData.width,
    spriteImageData.height
  );
  const imageData = imageContext.getImageData(0, 0, imgSize[0], imgSize[1]);
  imageContext.globalCompositeOperation = "destination-over";
  imageContext.fillStyle = `rgba(${haloColor.r * 255},${haloColor.g * 255},${haloColor.b * 255},${haloColor.a})`;
  const data = imageData.data;
  for (let i = 0, ii = imageData.width; i < ii; ++i) {
    for (let j = 0, jj = imageData.height; j < jj; ++j) {
      const index = (j * ii + i) * 4;
      const alpha = data[index + 3];
      if (alpha > 0) {
        imageContext.arc(
          i,
          j,
          haloWidth * spriteImageData.pixelRatio,
          0,
          2 * Math.PI
        );
      }
    }
  }
  imageContext.fill();
  return imageCanvas;
}
function smoothstep(min, max, value) {
  const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
  return x * x * (3 - 2 * x);
}
function drawSDF(image, area, color) {
  const imageCanvas = createCanvas(area.width, area.height);
  const imageContext = imageCanvas.getContext("2d");
  imageContext.drawImage(
    image,
    area.x,
    area.y,
    area.width,
    area.height,
    0,
    0,
    area.width,
    area.height
  );
  const imageData = imageContext.getImageData(0, 0, area.width, area.height);
  const data = imageData.data;
  for (let i = 0, ii = imageData.width; i < ii; ++i) {
    for (let j = 0, jj = imageData.height; j < jj; ++j) {
      const index = (j * ii + i) * 4;
      const dist = data[index + 3] / 255;
      const buffer = 0.75;
      const gamma = 0.1;
      const alpha = smoothstep(buffer - gamma, buffer + gamma, dist);
      if (alpha > 0) {
        data[index + 0] = Math.round(255 * color.r * alpha);
        data[index + 1] = Math.round(255 * color.g * alpha);
        data[index + 2] = Math.round(255 * color.b * alpha);
        data[index + 3] = Math.round(255 * alpha);
      } else {
        data[index + 3] = 0;
      }
    }
  }
  imageContext.putImageData(imageData, 0, 0);
  return imageCanvas;
}

// node_modules/ol-mapbox-style/src/text.js
var hairSpacePool = Array(256).join("");
function applyLetterSpacing(text, letterSpacing) {
  if (letterSpacing >= 0.05) {
    let textWithLetterSpacing = "";
    const lines = text.split("\n");
    const joinSpaceString = hairSpacePool.slice(
      0,
      Math.round(letterSpacing / 0.1)
    );
    for (let l = 0, ll = lines.length; l < ll; ++l) {
      if (l > 0) {
        textWithLetterSpacing += "\n";
      }
      textWithLetterSpacing += lines[l].split("").join(joinSpaceString);
    }
    return textWithLetterSpacing;
  }
  return text;
}
var measureContext;
function getMeasureContext() {
  if (!measureContext) {
    measureContext = createCanvas(1, 1).getContext("2d");
  }
  return measureContext;
}
function measureText(text, letterSpacing) {
  return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;
}
var measureCache = {};
function wrapText(text, font, em, letterSpacing) {
  if (text.indexOf("\n") !== -1) {
    const hardLines = text.split("\n");
    const lines = [];
    for (let i = 0, ii = hardLines.length; i < ii; ++i) {
      lines.push(wrapText(hardLines[i], font, em, letterSpacing));
    }
    return lines.join("\n");
  }
  const key = em + "," + font + "," + text + "," + letterSpacing;
  let wrappedText = measureCache[key];
  if (!wrappedText) {
    const words = text.split(" ");
    if (words.length > 1) {
      const ctx = getMeasureContext();
      ctx.font = font;
      const oneEm = ctx.measureText("M").width;
      const maxWidth = oneEm * em;
      let line = "";
      const lines = [];
      for (let i = 0, ii = words.length; i < ii; ++i) {
        const word = words[i];
        const testLine = line + (line ? " " : "") + word;
        if (measureText(testLine, letterSpacing) <= maxWidth) {
          line = testLine;
        } else {
          if (line) {
            lines.push(line);
          }
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      for (let i = 0, ii = lines.length; i < ii && ii > 1; ++i) {
        const line2 = lines[i];
        if (measureText(line2, letterSpacing) < maxWidth * 0.35) {
          const prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;
          const nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;
          lines.splice(i, 1);
          ii -= 1;
          if (prevWidth < nextWidth) {
            lines[i - 1] += " " + line2;
            i -= 1;
          } else {
            lines[i] = line2 + " " + lines[i];
          }
        }
      }
      for (let i = 0, ii = lines.length - 1; i < ii; ++i) {
        const line2 = lines[i];
        const next = lines[i + 1];
        if (measureText(line2, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {
          const lineWords = line2.split(" ");
          const lastWord = lineWords.pop();
          if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {
            lines[i] = lineWords.join(" ");
            lines[i + 1] = lastWord + " " + next;
          }
          ii -= 1;
        }
      }
      wrappedText = lines.join("\n");
    } else {
      wrappedText = text;
    }
    wrappedText = applyLetterSpacing(wrappedText, letterSpacing);
    measureCache[key] = wrappedText;
  }
  return wrappedText;
}
var fontFamilyRegEx = /font-family: ?([^;]*);/;
var stripQuotesRegEx = /("|')/g;
var loadedFontFamilies;
function hasFontFamily(family) {
  if (!loadedFontFamilies) {
    loadedFontFamilies = {};
    const styleSheets = document.styleSheets;
    for (let i = 0, ii = styleSheets.length; i < ii; ++i) {
      const styleSheet = (
        /** @type {CSSStyleSheet} */
        styleSheets[i]
      );
      try {
        const cssRules = styleSheet.rules || styleSheet.cssRules;
        if (cssRules) {
          for (let j = 0, jj = cssRules.length; j < jj; ++j) {
            const cssRule = cssRules[j];
            if (cssRule.type == 5) {
              const match = cssRule.cssText.match(fontFamilyRegEx);
              loadedFontFamilies[match[1].replace(stripQuotesRegEx, "")] = true;
            }
          }
        }
      } catch {
      }
    }
  }
  return family in loadedFontFamilies;
}
var processedFontFamilies = {};
function getFonts(fonts, templateUrl = "https://cdn.jsdelivr.net/npm/@fontsource/{font-family}/{fontweight}{-fontstyle}.css") {
  const fontsKey = fonts.toString();
  if (fontsKey in processedFontFamilies) {
    return processedFontFamilies[fontsKey];
  }
  const fontDescriptions = [];
  for (let i = 0, ii = fonts.length; i < ii; ++i) {
    fonts[i] = fonts[i].replace("Arial Unicode MS", "Arial");
    const font = fonts[i];
    const cssFont = mapbox_to_css_font_default(font, 1);
    registerFont(cssFont);
    const parts = cssFont.split(" ");
    fontDescriptions.push([
      parts.slice(3).join(" ").replace(/"/g, ""),
      parts[1],
      parts[0]
    ]);
  }
  for (let i = 0, ii = fontDescriptions.length; i < ii; ++i) {
    const fontDescription = fontDescriptions[i];
    const family = fontDescription[0];
    if (!hasFontFamily(family)) {
      if (checkedFonts.get(
        `${fontDescription[2]}
${fontDescription[1]} 
${family}`
      ) !== 100) {
        const fontUrl = templateUrl.replace("{font-family}", family.replace(/ /g, "-").toLowerCase()).replace("{Font+Family}", family.replace(/ /g, "+")).replace("{fontweight}", fontDescription[1]).replace(
          "{-fontstyle}",
          fontDescription[2].replace("normal", "").replace(/(.+)/, "-$1")
        ).replace("{fontstyle}", fontDescription[2]);
        if (!document.querySelector('link[href="' + fontUrl + '"]')) {
          const markup = document.createElement("link");
          markup.href = fontUrl;
          markup.rel = "stylesheet";
          document.head.appendChild(markup);
        }
      }
    }
  }
  processedFontFamilies[fontsKey] = fonts;
  return fonts;
}

// node_modules/ol-mapbox-style/src/stylefunction.js
var types2 = {
  "Point": 1,
  "MultiPoint": 1,
  "LineString": 2,
  "MultiLineString": 2,
  "Polygon": 3,
  "MultiPolygon": 3
};
var anchor = {
  "center": [0.5, 0.5],
  "left": [0, 0.5],
  "right": [1, 0.5],
  "top": [0.5, 0],
  "bottom": [0.5, 1],
  "top-left": [0, 0],
  "top-right": [1, 0],
  "bottom-left": [0, 1],
  "bottom-right": [1, 1]
};
var expressionData = function(rawExpression, propertySpec) {
  const compiledExpression = createPropertyExpression(
    rawExpression,
    propertySpec
  );
  if (compiledExpression.result === "error") {
    throw new Error(
      compiledExpression.value.map((err) => `${err.key}: ${err.message}`).join(", ")
    );
  }
  return compiledExpression.value;
};
var cameraObj = { zoom: 0, distanceFromCenter: 0 };
CompoundExpression.register(expressions$1, {
  ...CompoundExpression.definitions,
  "pitch": [{ kind: "number" }, [], (ctx) => cameraObj.pitch || 90],
  "distance-from-center": [
    { kind: "number" },
    [],
    (ctx) => cameraObj.distanceFromCenter || 0
  ]
});
var renderFeatureCoordinates;
var renderFeature;
function getValue(layer2, layoutOrPaint, property, feature, functionCache, featureState) {
  const layerId = layer2.id;
  if (!functionCache) {
    functionCache = {};
    console.warn("No functionCache provided to getValue()");
  }
  if (!functionCache[layerId]) {
    functionCache[layerId] = {};
  }
  const functions = functionCache[layerId];
  if (!functions[property]) {
    let value = (layer2[layoutOrPaint] || emptyObj)[property];
    const propertySpec = v8[`${layoutOrPaint}_${layer2.type}`][property];
    if (value === void 0) {
      value = propertySpec.default;
    }
    let isExpr = isExpression(value);
    if (!isExpr && isFunction$1(value)) {
      value = convertFunction(value, propertySpec);
      isExpr = true;
    }
    if (isExpr) {
      const compiledExpression = expressionData(value, propertySpec);
      functions[property] = compiledExpression.evaluate.bind(compiledExpression);
    } else {
      if (propertySpec.type == "color") {
        value = Color.parse(value);
      }
      functions[property] = function() {
        return value;
      };
    }
  }
  return functions[property](cameraObj, feature, featureState);
}
function getDeclutterMode(layer2, feature, prefix, functionCache) {
  const allowOverlap = getValue(
    layer2,
    "layout",
    `${prefix}-allow-overlap`,
    feature,
    functionCache
  );
  if (!allowOverlap) {
    return "declutter";
  }
  const ignorePlacement = getValue(
    layer2,
    "layout",
    `${prefix}-ignore-placement`,
    feature,
    functionCache
  );
  if (!ignorePlacement) {
    return "obstacle";
  }
  return "none";
}
function evaluateFilter(layerId, filter2, feature, filterCache) {
  if (!filterCache) {
    console.warn("No filterCache provided to evaluateFilter()");
  }
  if (!(layerId in filterCache)) {
    try {
      filterCache[layerId] = featureFilter(filter2).filter;
    } catch (e) {
      console.warn("Filter will evaluate to false: " + e.message);
      filterCache[layerId] = function() {
        return false;
      };
    }
  }
  return filterCache[layerId](cameraObj, feature);
}
var renderTransparentEnabled = false;
function renderTransparent(enabled) {
  if (enabled !== renderTransparentEnabled) {
    clearFunctionCache();
    renderTransparentEnabled = enabled;
  }
}
function colorWithOpacity(color, opacity) {
  if (color) {
    if (!renderTransparentEnabled && (color.a === 0 || opacity === 0)) {
      return void 0;
    }
    const a = color.a;
    opacity = opacity === void 0 ? 1 : opacity;
    return a === 0 ? "transparent" : "rgba(" + Math.round(color.r * 255 / a) + "," + Math.round(color.g * 255 / a) + "," + Math.round(color.b * 255 / a) + "," + a * opacity + ")";
  }
  return color;
}
var templateRegEx = /\{[^{}}]*\}/g;
function fromTemplate(text, properties) {
  return text.replace(templateRegEx, function(match) {
    return properties[match.slice(1, -1)] || "";
  });
}
function getSpriteImageForIcon(icon, spriteImages) {
  let prefix = icon.split(":")[0];
  if (prefix === icon) {
    prefix = "default";
  }
  return spriteImages[prefix];
}
var recordLayer = false;
function recordStyleLayer(record = false) {
  recordLayer = record;
}
var styleFunctionArgs = {};
function stylefunction(olLayer, glStyle, sourceOrLayers, resolutions = defaultResolutions, spriteData = void 0, spriteImageUrl = void 0, getFonts2 = void 0, getImage = void 0) {
  if (typeof glStyle == "string") {
    glStyle = JSON.parse(glStyle);
  }
  if (glStyle.version != 8) {
    throw new Error("glStyle version 8 required.");
  }
  styleFunctionArgs[getStyleFunctionKey(glStyle, olLayer)] = Array.from(arguments);
  const spriteImages = {};
  if (typeof spriteImageUrl === "string" || spriteImageUrl instanceof Request || spriteImageUrl instanceof Response || spriteImageUrl instanceof Promise) {
    spriteImageUrl = { "default": spriteImageUrl };
  }
  for (const prefix in spriteImageUrl) {
    const imageUrl = spriteImageUrl[prefix];
    toPromise(() => imageUrl).then(async (imageUrl2) => {
      let blobUrl;
      if (typeof Image !== "undefined") {
        const img = new Image();
        if (typeof imageUrl2 === "string") {
          img.crossOrigin = "anonymous";
          img.src = imageUrl2;
        } else {
          let response;
          if (imageUrl2 instanceof Request) {
            response = await fetch(imageUrl2);
          } else if (imageUrl2 instanceof Response) {
            response = imageUrl2;
          }
          const blob = await response.blob();
          blobUrl = URL.createObjectURL(blob);
          img.src = blobUrl;
        }
        img.addEventListener("load", function load() {
          img.removeEventListener("load", load);
          spriteImages[prefix] = {
            image: img,
            size: [img.width, img.height]
          };
          olLayer.changed();
          if (blobUrl) {
            URL.revokeObjectURL(blobUrl);
          }
        });
        img.addEventListener("error", function error2() {
          URL.revokeObjectURL(blobUrl);
          img.removeEventListener("error", error2);
        });
      } else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
        const worker = (
          /** @type {*} */
          self
        );
        worker.postMessage({
          action: "loadImage",
          src: imageUrl2
        });
        worker.addEventListener("message", function handler(event) {
          if (event.data.action === "imageLoaded" && event.data.src === imageUrl2) {
            spriteImages[prefix] = {
              image: event.data.image,
              size: [event.data.image.width, event.data.image.height]
            };
          }
        });
      }
    });
  }
  const allLayers = derefLayers(glStyle.layers);
  const layersBySourceLayer = {};
  const mapboxLayers = [];
  const iconImageCache = {};
  const patternCache = {};
  const functionCache = getFunctionCache(glStyle);
  const filterCache = getFilterCache(glStyle);
  let mapboxSource;
  for (let i = 0, ii = allLayers.length; i < ii; ++i) {
    const layer2 = allLayers[i];
    const layerId = layer2.id;
    if (typeof sourceOrLayers == "string" && layer2.source == sourceOrLayers || Array.isArray(sourceOrLayers) && sourceOrLayers.indexOf(layerId) !== -1) {
      const sourceLayer = layer2["source-layer"];
      if (!mapboxSource) {
        mapboxSource = layer2.source;
        const source2 = glStyle.sources[mapboxSource];
        if (!source2) {
          throw new Error(`Source "${mapboxSource}" is not defined`);
        }
        const type = source2.type;
        if (type !== "vector" && type !== "geojson") {
          throw new Error(
            `Source "${mapboxSource}" is not of type "vector" or "geojson", but "${type}"`
          );
        }
      } else if (layer2.source !== mapboxSource) {
        throw new Error(
          `Layer "${layerId}" does not use source "${mapboxSource}`
        );
      }
      let layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = [];
        layersBySourceLayer[sourceLayer] = layers;
      }
      layers.push({
        layer: layer2,
        index: i
      });
      mapboxLayers.push(layerId);
    }
  }
  const textHalo = new Stroke_default();
  const textColor = new Fill_default();
  const styles = [];
  const styleFunction = function(feature, resolution, onlyLayer) {
    const properties = feature.getProperties();
    const layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return void 0;
    }
    let zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = getZoomForResolution(resolution, resolutions);
    }
    cameraObj.zoom = zoom;
    cameraObj.distanceFromCenter = 0;
    const featureGeometry = feature.getGeometry();
    const type = types2[featureGeometry.getType()];
    const map = olLayer.get("map");
    if (map && map instanceof Map_default && type === 1) {
      const size = map.getSize();
      if (size) {
        const mapCenter = map.getView().getCenter();
        const featureCenter = getCenter(featureGeometry.getExtent());
        cameraObj.distanceFromCenter = distance(mapCenter, featureCenter) / resolution / size[1];
      }
    }
    const f = {
      id: feature.getId(),
      properties,
      type
    };
    const featureState = olLayer.get("mapbox-featurestate")[feature.getId()];
    let stylesLength = -1;
    let featureBelongsToLayer;
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      const layerData = layers[i];
      const layer2 = layerData.layer;
      const layerId = layer2.id;
      if (onlyLayer !== void 0 && onlyLayer !== layerId) {
        continue;
      }
      const layout2 = layer2.layout || emptyObj;
      const paint2 = layer2.paint || emptyObj;
      if (layout2.visibility === "none" || "minzoom" in layer2 && zoom < layer2.minzoom || "maxzoom" in layer2 && zoom >= layer2.maxzoom) {
        continue;
      }
      const filter2 = layer2.filter;
      if (!filter2 || evaluateFilter(layerId, filter2, f, filterCache)) {
        featureBelongsToLayer = layer2;
        let color, opacity, fill, stroke, strokeColor, style;
        const index = layerData.index;
        if (type == 3 && (layer2.type == "fill" || layer2.type == "fill-extrusion")) {
          opacity = getValue(
            layer2,
            "paint",
            layer2.type + "-opacity",
            f,
            functionCache,
            featureState
          );
          if (layer2.type + "-pattern" in paint2) {
            const fillIcon = getValue(
              layer2,
              "paint",
              layer2.type + "-pattern",
              f,
              functionCache,
              featureState
            );
            if (fillIcon) {
              const icon2 = typeof fillIcon === "string" ? fromTemplate(fillIcon, properties) : fillIcon.toString();
              const spriteImage = getSpriteImageForIcon(icon2, spriteImages);
              if (spriteData && spriteData[icon2] && spriteImage) {
                ++stylesLength;
                style = styles[stylesLength];
                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                  style = new Style_default({
                    fill: new Fill_default()
                  });
                  styles[stylesLength] = style;
                }
                fill = style.getFill();
                style.setZIndex(index);
                const icon_cache_key = icon2 + "." + opacity;
                let pattern = patternCache[icon_cache_key];
                if (!pattern) {
                  const spriteImageData = spriteData[icon2];
                  const canvas = createCanvas(
                    spriteImageData.width,
                    spriteImageData.height
                  );
                  const ctx = (
                    /** @type {CanvasRenderingContext2D} */
                    canvas.getContext("2d")
                  );
                  ctx.globalAlpha = opacity;
                  ctx.drawImage(
                    spriteImage.image,
                    spriteImageData.x,
                    spriteImageData.y,
                    spriteImageData.width,
                    spriteImageData.height,
                    0,
                    0,
                    spriteImageData.width,
                    spriteImageData.height
                  );
                  pattern = ctx.createPattern(canvas, "repeat");
                  patternCache[icon_cache_key] = pattern;
                }
                fill.setColor(pattern);
              }
            }
          } else {
            color = colorWithOpacity(
              getValue(
                layer2,
                "paint",
                layer2.type + "-color",
                f,
                functionCache,
                featureState
              ),
              opacity
            );
            if (layer2.type + "-outline-color" in paint2) {
              strokeColor = colorWithOpacity(
                getValue(
                  layer2,
                  "paint",
                  layer2.type + "-outline-color",
                  f,
                  functionCache,
                  featureState
                ),
                opacity
              );
            }
            if (!strokeColor) {
              strokeColor = color;
            }
            if (color || strokeColor) {
              ++stylesLength;
              style = styles[stylesLength];
              if (!style || color && !style.getFill() || !color && style.getFill() || strokeColor && !style.getStroke() || !strokeColor && style.getStroke() || style.getText()) {
                style = new Style_default({
                  fill: color ? new Fill_default() : void 0,
                  stroke: strokeColor ? new Stroke_default() : void 0
                });
                styles[stylesLength] = style;
              }
              if (color) {
                fill = style.getFill();
                fill.setColor(color);
              }
              if (strokeColor) {
                stroke = style.getStroke();
                stroke.setColor(strokeColor);
                stroke.setWidth(0.5);
              }
              style.setZIndex(index);
            }
          }
        }
        if (type != 1 && layer2.type == "line") {
          if (!("line-pattern" in paint2)) {
            color = colorWithOpacity(
              getValue(
                layer2,
                "paint",
                "line-color",
                f,
                functionCache,
                featureState
              ),
              getValue(
                layer2,
                "paint",
                "line-opacity",
                f,
                functionCache,
                featureState
              )
            );
          } else {
            color = void 0;
          }
          const width = getValue(
            layer2,
            "paint",
            "line-width",
            f,
            functionCache,
            featureState
          );
          if (color && width > 0) {
            ++stylesLength;
            style = styles[stylesLength];
            if (!style || !style.getStroke() || style.getFill() || style.getText()) {
              style = new Style_default({
                stroke: new Stroke_default()
              });
              styles[stylesLength] = style;
            }
            stroke = style.getStroke();
            stroke.setLineCap(
              getValue(
                layer2,
                "layout",
                "line-cap",
                f,
                functionCache,
                featureState
              )
            );
            stroke.setLineJoin(
              getValue(
                layer2,
                "layout",
                "line-join",
                f,
                functionCache,
                featureState
              )
            );
            stroke.setMiterLimit(
              getValue(
                layer2,
                "layout",
                "line-miter-limit",
                f,
                functionCache,
                featureState
              )
            );
            stroke.setColor(color);
            stroke.setWidth(width);
            stroke.setLineDash(
              paint2["line-dasharray"] ? getValue(
                layer2,
                "paint",
                "line-dasharray",
                f,
                functionCache,
                featureState
              ).map(function(x) {
                return x * width;
              }) : null
            );
            style.setZIndex(index);
          }
        }
        let hasImage = false;
        let text = null;
        let placementAngle = 0;
        let icon, iconImg, skipLabel;
        if ((type == 1 || type == 2) && "icon-image" in layout2) {
          const iconImage = getValue(
            layer2,
            "layout",
            "icon-image",
            f,
            functionCache,
            featureState
          );
          if (iconImage) {
            icon = typeof iconImage === "string" ? fromTemplate(iconImage, properties) : iconImage.toString();
            let styleGeom = void 0;
            const imageElement = getImage ? getImage(olLayer, icon) : void 0;
            const spriteImage = getSpriteImageForIcon(icon, spriteImages);
            if (spriteData && spriteData[icon] && spriteImage || imageElement) {
              const iconRotationAlignment = getValue(
                layer2,
                "layout",
                "icon-rotation-alignment",
                f,
                functionCache,
                featureState
              );
              if (type == 2) {
                const geom = (
                  /** @type {*} */
                  feature.getGeometry()
                );
                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {
                  const extent = geom.getExtent();
                  const size = Math.sqrt(
                    Math.max(
                      Math.pow((extent[2] - extent[0]) / resolution, 2),
                      Math.pow((extent[3] - extent[1]) / resolution, 2)
                    )
                  );
                  if (size > 150) {
                    const midpoint = geom.getType() === "MultiLineString" ? geom.getFlatMidpoints() : geom.getFlatMidpoint();
                    if (!renderFeature) {
                      renderFeatureCoordinates = [NaN, NaN];
                      renderFeature = new Feature_default(
                        "Point",
                        renderFeatureCoordinates,
                        [],
                        2,
                        {},
                        void 0
                      );
                    }
                    styleGeom = renderFeature;
                    renderFeatureCoordinates[0] = midpoint[0];
                    renderFeatureCoordinates[1] = midpoint[1];
                    const placement = getValue(
                      layer2,
                      "layout",
                      "symbol-placement",
                      f,
                      functionCache,
                      featureState
                    );
                    if (placement === "line" && iconRotationAlignment === "map") {
                      const stride = geom.getStride();
                      const coordinates = geom.getFlatCoordinates();
                      for (let i2 = 0, ii2 = coordinates.length - stride; i2 < ii2; i2 += stride) {
                        const x1 = coordinates[i2];
                        const y1 = coordinates[i2 + 1];
                        const x2 = coordinates[i2 + stride];
                        const y2 = coordinates[i2 + stride + 1];
                        const minX = Math.min(x1, x2);
                        const maxX = Math.max(x1, x2);
                        const xM = midpoint[0];
                        const yM = midpoint[1];
                        const dotProduct = (y2 - y1) * (xM - x1) - (x2 - x1) * (yM - y1);
                        if (Math.abs(dotProduct) < 1e-3 && //midpoint is aligned with the segment
                        xM <= maxX && xM >= minX) {
                          placementAngle = Math.atan2(y1 - y2, x2 - x1);
                          break;
                        }
                      }
                    }
                  }
                }
              }
              if (type !== 2 || styleGeom) {
                const iconSize = getValue(
                  layer2,
                  "layout",
                  "icon-size",
                  f,
                  functionCache,
                  featureState
                );
                const iconColor = paint2["icon-color"] !== void 0 ? getValue(
                  layer2,
                  "paint",
                  "icon-color",
                  f,
                  functionCache,
                  featureState
                ) : null;
                if (!iconColor || iconColor.a !== 0) {
                  const haloColor = getValue(
                    layer2,
                    "paint",
                    "icon-halo-color",
                    f,
                    functionCache,
                    featureState
                  );
                  const haloWidth = getValue(
                    layer2,
                    "paint",
                    "icon-halo-width",
                    f,
                    functionCache,
                    featureState
                  );
                  let iconCacheKey = `${icon}.${iconSize}.${haloWidth}.${haloColor}`;
                  if (iconColor !== null) {
                    iconCacheKey += `.${iconColor}`;
                  }
                  iconImg = iconImageCache[iconCacheKey];
                  if (!iconImg) {
                    const declutterMode = getDeclutterMode(
                      layer2,
                      f,
                      "icon",
                      functionCache
                    );
                    let displacement;
                    if ("icon-offset" in layout2) {
                      displacement = getValue(
                        layer2,
                        "layout",
                        "icon-offset",
                        f,
                        functionCache,
                        featureState
                      ).slice(0);
                      displacement[0] *= iconSize;
                      displacement[1] *= -iconSize;
                    }
                    let color2 = iconColor ? [
                      iconColor.r * 255,
                      iconColor.g * 255,
                      iconColor.b * 255,
                      iconColor.a
                    ] : void 0;
                    if (imageElement) {
                      const iconOptions = {
                        color: color2,
                        rotateWithView: iconRotationAlignment === "map",
                        displacement,
                        declutterMode,
                        scale: iconSize
                      };
                      if (typeof imageElement === "string") {
                        iconOptions.src = imageElement;
                      } else {
                        iconOptions.img = imageElement;
                        iconOptions.imgSize = [
                          imageElement.width,
                          imageElement.height
                        ];
                      }
                      iconImg = new Icon_default(iconOptions);
                    } else {
                      const spriteImageData = spriteData[icon];
                      let img, size, offset;
                      if (haloWidth) {
                        if (spriteImageData.sdf) {
                          img = drawIconHalo(
                            drawSDF(
                              spriteImage.image,
                              spriteImageData,
                              iconColor || [0, 0, 0, 1]
                            ),
                            {
                              x: 0,
                              y: 0,
                              width: spriteImageData.width,
                              height: spriteImageData.height,
                              pixelRatio: spriteImageData.pixelRatio
                            },
                            haloWidth,
                            haloColor
                          );
                          color2 = void 0;
                        } else {
                          img = drawIconHalo(
                            spriteImage.image,
                            spriteImageData,
                            haloWidth,
                            haloColor
                          );
                        }
                      } else {
                        if (spriteImageData.sdf) {
                          if (!spriteImage.unSDFed) {
                            const spriteImageUnSDFed = drawSDF(
                              spriteImage.image,
                              {
                                x: 0,
                                y: 0,
                                width: spriteImage.size[0],
                                height: spriteImage.size[1]
                              },
                              { r: 1, g: 1, b: 1, a: 1 }
                            );
                            spriteImage.image = spriteImageUnSDFed;
                            spriteImage.unSDFed = true;
                          }
                        }
                        img = spriteImage.image;
                        size = [spriteImageData.width, spriteImageData.height];
                        offset = [spriteImageData.x, spriteImageData.y];
                      }
                      iconImg = new Icon_default({
                        color: color2,
                        img,
                        // @ts-ignore
                        imgSize: spriteImage.size,
                        size,
                        offset,
                        rotateWithView: iconRotationAlignment === "map",
                        scale: iconSize / spriteImageData.pixelRatio,
                        displacement,
                        declutterMode
                      });
                    }
                    iconImageCache[iconCacheKey] = iconImg;
                  }
                }
                if (iconImg) {
                  ++stylesLength;
                  style = styles[stylesLength];
                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                    style = new Style_default();
                    styles[stylesLength] = style;
                  }
                  style.setGeometry(styleGeom);
                  iconImg.setRotation(
                    placementAngle + deg2rad2(
                      getValue(
                        layer2,
                        "layout",
                        "icon-rotate",
                        f,
                        functionCache,
                        featureState
                      )
                    )
                  );
                  iconImg.setOpacity(
                    getValue(
                      layer2,
                      "paint",
                      "icon-opacity",
                      f,
                      functionCache,
                      featureState
                    )
                  );
                  iconImg.setAnchor(
                    anchor[getValue(
                      layer2,
                      "layout",
                      "icon-anchor",
                      f,
                      functionCache,
                      featureState
                    )]
                  );
                  style.setImage(iconImg);
                  text = style.getText();
                  style.setText(void 0);
                  style.setZIndex(index);
                  hasImage = true;
                  skipLabel = false;
                }
              } else {
                skipLabel = true;
              }
            }
          }
        }
        if (type == 1 && layer2.type === "circle") {
          ++stylesLength;
          style = styles[stylesLength];
          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
            style = new Style_default();
            styles[stylesLength] = style;
          }
          const circleRadius = "circle-radius" in paint2 ? getValue(
            layer2,
            "paint",
            "circle-radius",
            f,
            functionCache,
            featureState
          ) : 5;
          const circleStrokeColor = colorWithOpacity(
            getValue(
              layer2,
              "paint",
              "circle-stroke-color",
              f,
              functionCache,
              featureState
            ),
            getValue(
              layer2,
              "paint",
              "circle-stroke-opacity",
              f,
              functionCache,
              featureState
            )
          );
          const circleTranslate = getValue(
            layer2,
            "paint",
            "circle-translate",
            f,
            functionCache,
            featureState
          );
          const circleColor = colorWithOpacity(
            getValue(
              layer2,
              "paint",
              "circle-color",
              f,
              functionCache,
              featureState
            ),
            getValue(
              layer2,
              "paint",
              "circle-opacity",
              f,
              functionCache,
              featureState
            )
          );
          const circleStrokeWidth = getValue(
            layer2,
            "paint",
            "circle-stroke-width",
            f,
            functionCache,
            featureState
          );
          const cache_key = circleRadius + "." + circleStrokeColor + "." + circleColor + "." + circleStrokeWidth + "." + circleTranslate[0] + "." + circleTranslate[1];
          iconImg = iconImageCache[cache_key];
          if (!iconImg) {
            iconImg = new Circle_default({
              radius: circleRadius,
              displacement: [circleTranslate[0], -circleTranslate[1]],
              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke_default({
                width: circleStrokeWidth,
                color: circleStrokeColor
              }) : void 0,
              fill: circleColor ? new Fill_default({
                color: circleColor
              }) : void 0,
              declutterMode: "none"
            });
            iconImageCache[cache_key] = iconImg;
          }
          style.setImage(iconImg);
          text = style.getText();
          style.setText(void 0);
          style.setGeometry(void 0);
          style.setZIndex(index);
          hasImage = true;
        }
        let label, font, textLineHeight, textSize, letterSpacing, maxTextWidth;
        if ("text-field" in layout2) {
          textSize = Math.round(
            getValue(
              layer2,
              "layout",
              "text-size",
              f,
              functionCache,
              featureState
            )
          );
          const fontArray = getValue(
            layer2,
            "layout",
            "text-font",
            f,
            functionCache,
            featureState
          );
          textLineHeight = getValue(
            layer2,
            "layout",
            "text-line-height",
            f,
            functionCache,
            featureState
          );
          font = mapbox_to_css_font_default(
            getFonts2 ? getFonts2(
              fontArray,
              glStyle.metadata ? glStyle.metadata["ol:webfonts"] : void 0
            ) : fontArray,
            textSize,
            textLineHeight
          );
          if (!font.includes("sans-serif")) {
            font += ",sans-serif";
          }
          letterSpacing = getValue(
            layer2,
            "layout",
            "text-letter-spacing",
            f,
            functionCache,
            featureState
          );
          maxTextWidth = getValue(
            layer2,
            "layout",
            "text-max-width",
            f,
            functionCache,
            featureState
          );
          const textField = getValue(
            layer2,
            "layout",
            "text-field",
            f,
            functionCache,
            featureState
          );
          if (typeof textField === "object" && textField.sections) {
            if (textField.sections.length === 1) {
              label = textField.toString();
            } else {
              label = textField.sections.reduce((acc, chunk, i2) => {
                const fonts = chunk.fontStack ? chunk.fontStack.split(",") : fontArray;
                const chunkFont = mapbox_to_css_font_default(
                  getFonts2 ? getFonts2(fonts) : fonts,
                  textSize * (chunk.scale || 1),
                  textLineHeight
                );
                let text2 = chunk.text;
                if (text2 === "\n") {
                  acc.push("\n", "");
                  return acc;
                }
                if (type == 2) {
                  acc.push(applyLetterSpacing(text2, letterSpacing), chunkFont);
                  return acc;
                }
                text2 = wrapText(
                  text2,
                  chunkFont,
                  maxTextWidth,
                  letterSpacing
                ).split("\n");
                for (let i3 = 0, ii2 = text2.length; i3 < ii2; ++i3) {
                  if (i3 > 0) {
                    acc.push("\n", "");
                  }
                  acc.push(text2[i3], chunkFont);
                }
                return acc;
              }, []);
            }
          } else {
            label = fromTemplate(textField, properties).trim();
          }
          opacity = getValue(
            layer2,
            "paint",
            "text-opacity",
            f,
            functionCache,
            featureState
          );
        }
        if (label && opacity && !skipLabel) {
          if (!hasImage) {
            ++stylesLength;
            style = styles[stylesLength];
            if (!style || !style.getText() || style.getFill() || style.getStroke()) {
              style = new Style_default();
              styles[stylesLength] = style;
            }
            style.setImage(void 0);
            style.setGeometry(void 0);
          }
          const declutterMode = getDeclutterMode(
            layer2,
            f,
            "text",
            functionCache
          );
          if (!style.getText()) {
            style.setText(text);
          }
          text = style.getText();
          if (!text || "getDeclutterMode" in text && text.getDeclutterMode() !== declutterMode) {
            text = new Text_default({
              padding: [2, 2, 2, 2],
              // @ts-ignore
              declutterMode
            });
            style.setText(text);
          }
          const textTransform = getValue(
            layer2,
            "layout",
            "text-transform",
            f,
            functionCache,
            featureState
          );
          if (textTransform == "uppercase") {
            label = Array.isArray(label) ? label.map((t, i2) => i2 % 2 ? t : t.toUpperCase()) : label.toUpperCase();
          } else if (textTransform == "lowercase") {
            label = Array.isArray(label) ? label.map((t, i2) => i2 % 2 ? t : t.toLowerCase()) : label.toLowerCase();
          }
          const wrappedLabel = Array.isArray(label) ? label : type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);
          text.setText(wrappedLabel);
          text.setFont(font);
          text.setRotation(
            deg2rad2(
              getValue(
                layer2,
                "layout",
                "text-rotate",
                f,
                functionCache,
                featureState
              )
            )
          );
          if (typeof text.setKeepUpright === "function") {
            const keepUpright = getValue(
              layer2,
              "layout",
              "text-keep-upright",
              f,
              functionCache,
              featureState
            );
            text.setKeepUpright(keepUpright);
          }
          const textAnchor = getValue(
            layer2,
            "layout",
            "text-anchor",
            f,
            functionCache,
            featureState
          );
          const placement = hasImage || type == 1 ? "point" : getValue(
            layer2,
            "layout",
            "symbol-placement",
            f,
            functionCache,
            featureState
          );
          let textAlign;
          if (placement === "line-center") {
            text.setPlacement("line");
            textAlign = "center";
          } else {
            text.setPlacement(placement);
          }
          if (placement === "line" && typeof text.setRepeat === "function") {
            const symbolSpacing = getValue(
              layer2,
              "layout",
              "symbol-spacing",
              f,
              functionCache,
              featureState
            );
            text.setRepeat(symbolSpacing * 2);
          }
          text.setOverflow(placement === "point");
          let textHaloWidth = getValue(
            layer2,
            "paint",
            "text-halo-width",
            f,
            functionCache,
            featureState
          );
          const textOffset = getValue(
            layer2,
            "layout",
            "text-offset",
            f,
            functionCache,
            featureState
          );
          const textTranslate = getValue(
            layer2,
            "paint",
            "text-translate",
            f,
            functionCache,
            featureState
          );
          let vOffset = 0;
          let hOffset = 0;
          if (placement == "point") {
            textAlign = "center";
            if (textAnchor.indexOf("left") !== -1) {
              textAlign = "left";
              hOffset = textHaloWidth;
            } else if (textAnchor.indexOf("right") !== -1) {
              textAlign = "right";
              hOffset = -textHaloWidth;
            }
            const textRotationAlignment = getValue(
              layer2,
              "layout",
              "text-rotation-alignment",
              f,
              functionCache,
              featureState
            );
            text.setRotateWithView(textRotationAlignment == "map");
          } else {
            text.setMaxAngle(
              deg2rad2(
                getValue(
                  layer2,
                  "layout",
                  "text-max-angle",
                  f,
                  functionCache,
                  featureState
                )
              ) * label.length / wrappedLabel.length
            );
            text.setRotateWithView(false);
          }
          text.setTextAlign(textAlign);
          let textBaseline = "middle";
          if (textAnchor.indexOf("bottom") == 0) {
            textBaseline = "bottom";
            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
          } else if (textAnchor.indexOf("top") == 0) {
            textBaseline = "top";
            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
          }
          text.setTextBaseline(textBaseline);
          const textJustify = getValue(
            layer2,
            "layout",
            "text-justify",
            f,
            functionCache,
            featureState
          );
          text.setJustify(textJustify === "auto" ? void 0 : textJustify);
          text.setOffsetX(
            textOffset[0] * textSize + hOffset + textTranslate[0]
          );
          text.setOffsetY(
            textOffset[1] * textSize + vOffset + textTranslate[1]
          );
          textColor.setColor(
            colorWithOpacity(
              getValue(
                layer2,
                "paint",
                "text-color",
                f,
                functionCache,
                featureState
              ),
              opacity
            )
          );
          text.setFill(textColor);
          const haloColor = colorWithOpacity(
            getValue(
              layer2,
              "paint",
              "text-halo-color",
              f,
              functionCache,
              featureState
            ),
            opacity
          );
          if (haloColor && textHaloWidth > 0) {
            textHalo.setColor(haloColor);
            textHaloWidth *= 2;
            const halfTextSize = 0.5 * textSize;
            textHalo.setWidth(
              textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize
            );
            text.setStroke(textHalo);
          } else {
            text.setStroke(void 0);
          }
          const textPadding = getValue(
            layer2,
            "layout",
            "text-padding",
            f,
            functionCache,
            featureState
          );
          const padding = text.getPadding();
          if (textPadding !== padding[0]) {
            padding[0] = textPadding;
            padding[1] = textPadding;
            padding[2] = textPadding;
            padding[3] = textPadding;
          }
          style.setZIndex(index);
        }
      }
    }
    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      if (recordLayer) {
        if ("set" in feature) {
          feature.set("mapbox-layer", featureBelongsToLayer);
        } else {
          feature.getProperties()["mapbox-layer"] = featureBelongsToLayer;
        }
      }
      return styles;
    }
    return void 0;
  };
  olLayer.setStyle(styleFunction);
  olLayer.set("mapbox-layers", mapboxLayers);
  olLayer.set("mapbox-source", mapboxSource);
  olLayer.set("mapbox-featurestate", olLayer.get("mapbox-featurestate") || {});
  return styleFunction;
}
function getStyleForLayer(feature, resolution, olLayer, layerId) {
  const evaluateStyle = olLayer.getStyleFunction();
  if (evaluateStyle.length === 3) {
    return evaluateStyle(feature, resolution, layerId);
  }
  return void 0;
}

// node_modules/ol/renderer/canvas/ImageLayer.js
var CanvasImageLayerRenderer = class extends Layer_default {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(imageLayer) {
    super(imageLayer);
    this.image = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return !this.image ? null : this.image.getImage();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewResolution = viewState.resolution;
    const imageSource = this.getLayer().getSource();
    const hints = frameState.viewHints;
    let renderedExtent = frameState.extent;
    if (layerState.extent !== void 0) {
      renderedExtent = getIntersection(
        renderedExtent,
        fromUserExtent(layerState.extent, viewState.projection)
      );
    }
    if (!hints[ViewHint_default.ANIMATING] && !hints[ViewHint_default.INTERACTING] && !isEmpty(renderedExtent)) {
      if (imageSource) {
        const projection2 = viewState.projection;
        const image = imageSource.getImage(
          renderedExtent,
          viewResolution,
          pixelRatio,
          projection2
        );
        if (image) {
          if (this.loadImage(image)) {
            this.image = image;
          } else if (image.getState() === ImageState_default.EMPTY) {
            this.image = null;
          }
        }
      } else {
        this.image = null;
      }
    }
    return !!this.image;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer2 = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer2.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const imageExtent = this.image.getExtent();
    const img = this.image.getImage();
    const imageMapWidth = getWidth(imageExtent);
    const col = Math.floor(
      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)
    );
    if (col < 0 || col >= img.width) {
      return null;
    }
    const imageMapHeight = getHeight(imageExtent);
    const row = Math.floor(
      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)
    );
    if (row < 0 || row >= img.height) {
      return null;
    }
    return this.getImageData(img, col, row);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    const image = this.image;
    const imageExtent = image.getExtent();
    const imageResolution = image.getResolution();
    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution) ? imageResolution : [imageResolution, imageResolution];
    const imagePixelRatio = image.getPixelRatio();
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const pixelRatio = frameState.pixelRatio;
    const viewState = frameState.viewState;
    const viewCenter = viewState.center;
    const viewResolution = viewState.resolution;
    const scaleX = pixelRatio * imageResolutionX / (viewResolution * imagePixelRatio);
    const scaleY = pixelRatio * imageResolutionY / (viewResolution * imagePixelRatio);
    this.prepareContainer(frameState, target);
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;
    const context = this.getRenderContext(frameState);
    let clipped = false;
    let render = true;
    if (layerState.extent) {
      const layerExtent = fromUserExtent(
        layerState.extent,
        viewState.projection
      );
      render = intersects(layerExtent, frameState.extent);
      clipped = render && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    const img = image.getImage();
    const transform = compose(
      this.tempTransform,
      width / 2,
      height / 2,
      scaleX,
      scaleY,
      0,
      imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolutionX,
      imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolutionY
    );
    this.renderedResolution = imageResolutionY * pixelRatio / imagePixelRatio;
    const dw = img.width * transform[0];
    const dh = img.height * transform[3];
    if (!this.getLayer().getSource().getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    if (render && dw >= 0.5 && dh >= 0.5) {
      const dx = transform[4];
      const dy = transform[5];
      const opacity = layerState.opacity;
      if (opacity !== 1) {
        context.save();
        context.globalAlpha = opacity;
      }
      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);
      if (opacity !== 1) {
        context.restore();
      }
    }
    this.postRender(this.context, frameState);
    if (clipped) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    return this.container;
  }
};
var ImageLayer_default = CanvasImageLayerRenderer;

// node_modules/ol/layer/BaseImage.js
var BaseImageLayer = class extends Layer_default2 {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(options) {
    options = options ? options : {};
    super(options);
  }
};
var BaseImage_default = BaseImageLayer;

// node_modules/ol/layer/Image.js
var ImageLayer = class extends BaseImage_default {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(options) {
    super(options);
  }
  /**
   * @override
   */
  createRenderer() {
    return new ImageLayer_default(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var Image_default3 = ImageLayer;

// node_modules/ol/source/Raster.js
function createMinion(operation) {
  return function(data) {
    const buffers = data["buffers"];
    const meta = data["meta"];
    const imageOps = data["imageOps"];
    const width = data["width"];
    const height = data["height"];
    const numBuffers = buffers.length;
    const numBytes = buffers[0].byteLength;
    if (imageOps) {
      const images = new Array(numBuffers);
      for (let b = 0; b < numBuffers; ++b) {
        images[b] = new ImageData(
          new Uint8ClampedArray(buffers[b]),
          width,
          height
        );
      }
      const output2 = operation(images, meta).data;
      return output2.buffer;
    }
    const output = new Uint8ClampedArray(numBytes);
    const arrays = new Array(numBuffers);
    const pixels = new Array(numBuffers);
    for (let b = 0; b < numBuffers; ++b) {
      arrays[b] = new Uint8ClampedArray(buffers[b]);
      pixels[b] = [0, 0, 0, 0];
    }
    for (let i = 0; i < numBytes; i += 4) {
      for (let j = 0; j < numBuffers; ++j) {
        const array2 = arrays[j];
        pixels[j][0] = array2[i];
        pixels[j][1] = array2[i + 1];
        pixels[j][2] = array2[i + 2];
        pixels[j][3] = array2[i + 3];
      }
      const pixel = operation(pixels, meta);
      output[i] = pixel[0];
      output[i + 1] = pixel[1];
      output[i + 2] = pixel[2];
      output[i + 3] = pixel[3];
    }
    return output.buffer;
  };
}
function createWorker(config, onMessage) {
  const lib = Object.keys(config.lib || {}).map(function(name) {
    return "const " + name + " = " + config.lib[name].toString() + ";";
  });
  const lines = lib.concat([
    "const __minion__ = (" + createMinion.toString() + ")(",
    config.operation.toString(),
    ");",
    'self.addEventListener("message", function(event) {',
    "  const buffer = __minion__(event.data);",
    "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
    "});"
  ]);
  const worker = new Worker(
    typeof Blob === "undefined" ? "data:text/javascript;base64," + Buffer.from(lines.join("\n"), "binary").toString("base64") : URL.createObjectURL(new Blob(lines, { type: "text/javascript" }))
  );
  worker.addEventListener("message", onMessage);
  return worker;
}
function createFauxWorker(config, onMessage) {
  const minion = createMinion(config.operation);
  let terminated = false;
  return {
    postMessage: function(data) {
      setTimeout(function() {
        if (terminated) {
          return;
        }
        onMessage({ data: { buffer: minion(data), meta: data["meta"] } });
      }, 0);
    },
    terminate: function() {
      terminated = true;
    }
  };
}
var Processor = class extends Disposable_default {
  /**
   * @param {ProcessorOptions} config Configuration.
   */
  constructor(config) {
    super();
    this.imageOps_ = !!config.imageOps;
    let threads;
    if (config.threads === 0) {
      threads = 0;
    } else if (this.imageOps_) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }
    const workers = new Array(threads);
    if (threads) {
      for (let i = 0; i < threads; ++i) {
        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));
      }
    } else {
      workers[0] = createFauxWorker(
        config,
        this.onWorkerMessage_.bind(this, 0)
      );
    }
    this.workers_ = workers;
    this.queue_ = [];
    this.maxQueueLength_ = config.queue || Infinity;
    this.running_ = 0;
    this.dataLookup_ = {};
    this.job_ = null;
  }
  /**
   * Run operation on input data.
   * @param {Array<ImageData>} inputs Array of image data.
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */
  process(inputs, meta, callback) {
    this.enqueue_({
      inputs,
      meta,
      callback
    });
    this.dispatch_();
  }
  /**
   * Add a job to the queue.
   * @param {Job} job The job.
   */
  enqueue_(job) {
    this.queue_.push(job);
    while (this.queue_.length > this.maxQueueLength_) {
      this.queue_.shift().callback(null, null);
    }
  }
  /**
   * Dispatch a job.
   */
  dispatch_() {
    if (this.running_ || this.queue_.length === 0) {
      return;
    }
    const job = this.queue_.shift();
    this.job_ = job;
    const width = job.inputs[0].width;
    const height = job.inputs[0].height;
    const buffers = job.inputs.map(function(input) {
      return input.data.buffer;
    });
    const threads = this.workers_.length;
    this.running_ = threads;
    if (threads === 1) {
      this.workers_[0].postMessage(
        {
          buffers,
          meta: job.meta,
          imageOps: this.imageOps_,
          width,
          height
        },
        buffers
      );
      return;
    }
    const length = job.inputs[0].data.length;
    const segmentLength = 4 * Math.ceil(length / 4 / threads);
    for (let i = 0; i < threads; ++i) {
      const offset = i * segmentLength;
      const slices = [];
      for (let j = 0, jj = buffers.length; j < jj; ++j) {
        slices.push(buffers[j].slice(offset, offset + segmentLength));
      }
      this.workers_[i].postMessage(
        {
          buffers: slices,
          meta: job.meta,
          imageOps: this.imageOps_,
          width,
          height
        },
        slices
      );
    }
  }
  /**
   * Handle messages from the worker.
   * @param {number} index The worker index.
   * @param {MessageEvent} event The message event.
   */
  onWorkerMessage_(index, event) {
    if (this.disposed) {
      return;
    }
    this.dataLookup_[index] = event.data;
    --this.running_;
    if (this.running_ === 0) {
      this.resolveJob_();
    }
  }
  /**
   * Resolve a job.  If there are no more worker threads, the processor callback
   * will be called.
   */
  resolveJob_() {
    const job = this.job_;
    const threads = this.workers_.length;
    let data, meta;
    if (threads === 1) {
      data = new Uint8ClampedArray(this.dataLookup_[0]["buffer"]);
      meta = this.dataLookup_[0]["meta"];
    } else {
      const length = job.inputs[0].data.length;
      data = new Uint8ClampedArray(length);
      meta = new Array(threads);
      const segmentLength = 4 * Math.ceil(length / 4 / threads);
      for (let i = 0; i < threads; ++i) {
        const buffer = this.dataLookup_[i]["buffer"];
        const offset = i * segmentLength;
        data.set(new Uint8ClampedArray(buffer), offset);
        meta[i] = this.dataLookup_[i]["meta"];
      }
    }
    this.job_ = null;
    this.dataLookup_ = {};
    job.callback(
      null,
      new ImageData(data, job.inputs[0].width, job.inputs[0].height),
      meta
    );
    this.dispatch_();
  }
  /**
   * Terminate all workers associated with the processor.
   * @override
   */
  disposeInternal() {
    for (let i = 0; i < this.workers_.length; ++i) {
      this.workers_[i].terminate();
    }
    this.workers_.length = 0;
  }
};
var RasterEventType = {
  /**
   * Triggered before operations are run.  Listeners will receive an event object with
   * a `data` property that can be used to make data available to operations.
   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: "beforeoperations",
  /**
   * Triggered after operations are run.  Listeners will receive an event object with
   * a `data` property.  If more than one thread is used, `data` will be an array of
   * objects.  If a single thread is used, `data` will be a single object.
   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: "afteroperations"
};
var RasterSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
   * this will be an array of objects if more than one thread is used.
   */
  constructor(type, frameState, data) {
    super(type);
    this.extent = frameState.extent;
    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
    this.data = data;
  }
};
var RasterSource = class extends Image_default2 {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super({
      projection: null
    });
    this.on;
    this.once;
    this.un;
    this.processor_ = null;
    this.operationType_ = options.operationType !== void 0 ? options.operationType : "pixel";
    this.threads_ = options.threads !== void 0 ? options.threads : 1;
    this.layers_ = createLayers(options.sources);
    const changed = this.changed.bind(this);
    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {
      this.layers_[i].addEventListener(EventType_default.CHANGE, changed);
    }
    this.useResolutions_ = options.resolutions !== null;
    this.tileQueue_ = new TileQueue_default(function() {
      return 1;
    }, this.processSources_.bind(this));
    this.requestedFrameState_;
    this.renderedImageCanvas_ = null;
    this.renderedRevision_;
    this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: create(),
      declutter: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: create(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: (
        /** @type {import("../View.js").State} */
        {
          rotation: 0
        }
      ),
      viewHints: [],
      wantedTiles: {},
      mapId: getUid(this),
      renderTargets: {}
    };
    this.setAttributions(function(frameState) {
      var _a;
      const attributions = [];
      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {
        const sourceOrLayer = options.sources[i];
        const source2 = sourceOrLayer instanceof Source_default ? sourceOrLayer : sourceOrLayer.getSource();
        if (!source2) {
          continue;
        }
        const sourceAttributions = (_a = source2.getAttributions()) == null ? void 0 : _a(frameState);
        if (typeof sourceAttributions === "string") {
          attributions.push(sourceAttributions);
        } else if (sourceAttributions !== void 0) {
          attributions.push(...sourceAttributions);
        }
      }
      return attributions;
    });
    if (options.operation !== void 0) {
      this.setOperation(options.operation, options.lib);
    }
  }
  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object} [lib] Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  setOperation(operation, lib) {
    if (this.processor_) {
      this.processor_.dispose();
    }
    this.processor_ = new Processor({
      operation,
      imageOps: this.operationType_ === "image",
      queue: 1,
      lib,
      threads: this.threads_
    });
    this.changed();
  }
  /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../Map.js").FrameState} The updated frame state.
   * @private
   */
  updateFrameState_(extent, resolution, projection2) {
    const frameState = (
      /** @type {import("../Map.js").FrameState} */
      Object.assign({}, this.frameState_)
    );
    frameState.viewState = /** @type {import("../View.js").State} */
    Object.assign({}, frameState.viewState);
    const center = getCenter(extent);
    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);
    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);
    frameState.extent = [
      center[0] - frameState.size[0] * resolution / 2,
      center[1] - frameState.size[1] * resolution / 2,
      center[0] + frameState.size[0] * resolution / 2,
      center[1] + frameState.size[1] * resolution / 2
    ];
    frameState.time = Date.now();
    const viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection2;
    viewState.resolution = resolution;
    return frameState;
  }
  /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */
  allSourcesReady_() {
    let ready = true;
    let source2;
    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {
      source2 = this.layers_[i].getSource();
      if (!source2 || source2.getState() !== "ready") {
        ready = false;
        break;
      }
    }
    return ready;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   * @override
   */
  getImage(extent, resolution, pixelRatio, projection2) {
    if (!this.allSourcesReady_()) {
      return null;
    }
    this.tileQueue_.loadMoreTiles(16, 16);
    resolution = this.findNearestResolution(resolution);
    const frameState = this.updateFrameState_(extent, resolution, projection2);
    this.requestedFrameState_ = frameState;
    if (this.renderedImageCanvas_) {
      const renderedResolution = this.renderedImageCanvas_.getResolution();
      const renderedExtent = this.renderedImageCanvas_.getExtent();
      if (resolution !== renderedResolution || !equals(frameState.extent, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }
    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
    return this.renderedImageCanvas_;
  }
  /**
   * Start processing source data.
   * @private
   */
  processSources_() {
    const frameState = this.requestedFrameState_;
    const len = this.layers_.length;
    const imageDatas = new Array(len);
    for (let i = 0; i < len; ++i) {
      frameState.layerIndex = i;
      frameState.renderTargets = {};
      const imageData = getImageData(this.layers_[i], frameState);
      if (imageData) {
        imageDatas[i] = imageData;
      } else {
        return;
      }
    }
    const data = {};
    this.dispatchEvent(
      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data)
    );
    this.processor_.process(
      imageDatas,
      data,
      this.onWorkerComplete_.bind(this, frameState)
    );
  }
  /**
   * Called when pixel processing is complete.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
   * @private
   */
  onWorkerComplete_(frameState, err, output, data) {
    if (err || !output) {
      return;
    }
    const extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals(extent, this.requestedFrameState_.extent)) {
      return;
    }
    let context;
    if (this.renderedImageCanvas_) {
      context = /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
      this.renderedImageCanvas_.getImage().getContext("2d");
    } else {
      const width = Math.round(getWidth(extent) / resolution);
      const height = Math.round(getHeight(extent) / resolution);
      context = createCanvasContext2D(width, height);
      this.renderedImageCanvas_ = new ImageCanvas_default(
        extent,
        resolution,
        1,
        context.canvas
      );
    }
    context.putImageData(output, 0, 0);
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    } else {
      this.changed();
    }
    this.renderedRevision_ = this.getRevision();
    this.dispatchEvent(
      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data)
    );
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(projection2) {
    if (!this.useResolutions_) {
      return null;
    }
    let resolutions = super.getResolutions();
    if (!resolutions) {
      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {
        const source2 = this.layers_[i].getSource();
        resolutions = source2.getResolutions(projection2);
        if (resolutions) {
          break;
        }
      }
    }
    return resolutions;
  }
  /**
   * @override
   */
  disposeInternal() {
    if (this.processor_) {
      this.processor_.dispose();
    }
    super.disposeInternal();
  }
};
RasterSource.prototype.dispose;
var sharedContext = null;
function getImageData(layer2, frameState) {
  const renderer = layer2.getRenderer();
  if (!renderer) {
    throw new Error("Unsupported layer type: " + layer2);
  }
  if (!renderer.prepareFrame(frameState)) {
    return null;
  }
  const width = frameState.size[0];
  const height = frameState.size[1];
  if (width === 0 || height === 0) {
    return null;
  }
  const container = renderer.renderFrame(frameState, null);
  let element;
  if (container instanceof HTMLCanvasElement) {
    element = container;
  } else {
    if (container) {
      element = container.firstElementChild;
    }
    if (!(element instanceof HTMLCanvasElement)) {
      throw new Error("Unsupported rendered element: " + element);
    }
    if (element.width === width && element.height === height) {
      const context = element.getContext("2d");
      return context.getImageData(0, 0, width, height);
    }
  }
  if (!sharedContext) {
    sharedContext = createCanvasContext2D(width, height, void 0, {
      willReadFrequently: true
    });
  } else {
    const canvas = sharedContext.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = createCanvasContext2D(width, height, void 0, {
        willReadFrequently: true
      });
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }
  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}
function getLayerStatesArray(layers) {
  return layers.map(function(layer2) {
    return layer2.getLayerState();
  });
}
function createLayers(sources2) {
  const len = sources2.length;
  const layers = new Array(len);
  for (let i = 0; i < len; ++i) {
    layers[i] = createLayer(sources2[i]);
  }
  return layers;
}
function createLayer(layerOrSource) {
  let layer2;
  if (layerOrSource instanceof Source_default) {
    if (layerOrSource instanceof Tile_default) {
      layer2 = new Tile_default2({ source: layerOrSource });
    } else if (layerOrSource instanceof Image_default2) {
      layer2 = new Image_default3({ source: layerOrSource });
    }
  } else {
    layer2 = layerOrSource;
  }
  return layer2;
}
var Raster_default = RasterSource;

// node_modules/ol/net.js
function jsonp(url, callback, errback, callbackParam) {
  const script = document.createElement("script");
  const key = "olc_" + getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.includes("?") ? "&" : "?") + (callbackParam || "callback") + "=" + key;
  const timer = setTimeout(function() {
    cleanup();
    if (errback) {
      errback();
    }
  }, 1e4);
  window[key] = function(data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.head.appendChild(script);
}

// node_modules/ol/source/TileJSON.js
var TileJSON = class extends TileImage_default {
  /**
   * @param {Options} options TileJSON options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: get("EPSG:3857"),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.tileJSON_ = null;
    this.tileSize_ = options.tileSize;
    if (options.url) {
      if (options.jsonp) {
        jsonp(
          options.url,
          this.handleTileJSONResponse.bind(this),
          this.handleTileJSONError.bind(this)
        );
      } else {
        const client = new XMLHttpRequest();
        client.addEventListener("load", this.onXHRLoad_.bind(this));
        client.addEventListener("error", this.onXHRError_.bind(this));
        client.open("GET", options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      this.handleTileJSONResponse(options.tileJSON);
    } else {
      throw new Error("Either `url` or `tileJSON` options must be provided");
    }
  }
  /**
   * @private
   * @param {Event} event The load event.
   */
  onXHRLoad_(event) {
    const client = (
      /** @type {XMLHttpRequest} */
      event.target
    );
    if (!client.status || client.status >= 200 && client.status < 300) {
      let response;
      try {
        response = /** @type {Config} */
        JSON.parse(client.responseText);
      } catch {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  }
  /**
   * @private
   * @param {Event} event The error event.
   */
  onXHRError_(event) {
    this.handleTileJSONError();
  }
  /**
   * @return {Config} The tilejson object.
   * @api
   */
  getTileJSON() {
    return this.tileJSON_;
  }
  /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */
  handleTileJSONResponse(tileJSON) {
    const epsg4326Projection = get("EPSG:4326");
    const sourceProjection = this.getProjection();
    let extent;
    if (tileJSON["bounds"] !== void 0) {
      const transform = getTransformFromProjections(
        epsg4326Projection,
        sourceProjection
      );
      extent = applyTransform(tileJSON["bounds"], transform);
    }
    const gridExtent = extentFromProjection(sourceProjection);
    const minZoom = tileJSON["minzoom"] || 0;
    const maxZoom = tileJSON["maxzoom"] || 22;
    const tileGrid = createXYZ({
      extent: gridExtent,
      maxZoom,
      minZoom,
      tileSize: this.tileSize_
    });
    this.tileGrid = tileGrid;
    this.tileUrlFunction = createFromTemplates(tileJSON["tiles"], tileGrid);
    if (tileJSON["attribution"] && !this.getAttributions()) {
      const attributionExtent = extent !== void 0 ? extent : gridExtent;
      this.setAttributions(function(frameState) {
        if (intersects(attributionExtent, frameState.extent)) {
          return [tileJSON["attribution"]];
        }
        return null;
      });
    }
    this.tileJSON_ = tileJSON;
    this.setState("ready");
  }
  /**
   * @protected
   */
  handleTileJSONError() {
    this.setState("error");
  }
};
var TileJSON_default = TileJSON;

// node_modules/ol-mapbox-style/src/shaders.js
function hillshade(inputs, data) {
  const elevationImage = inputs[0];
  const width = elevationImage.width;
  const height = elevationImage.height;
  const elevationData = elevationImage.data;
  const shadeData = new Uint8ClampedArray(elevationData.length);
  const dp = data.resolution * 2;
  const maxX = width - 1;
  const maxY = height - 1;
  const pixel = [0, 0, 0, 0];
  const twoPi = 2 * Math.PI;
  const halfPi = Math.PI / 2;
  const sunEl = Math.PI * data.sunEl / 180;
  const sunAz = Math.PI * data.sunAz / 180;
  const cosSunEl = Math.cos(sunEl);
  const sinSunEl = Math.sin(sunEl);
  const highlightColor = data.highlightColor;
  const shadowColor = data.shadowColor;
  const accentColor = data.accentColor;
  const encoding = data.encoding;
  let pixelX, pixelY, x0, x1, y0, y1, offset, z0, z1, dzdx, dzdy, slope, aspect, accent, scaled, shade, scaledAccentColor, compositeShadeColor, clamp3, slopeScaleBase, scaledSlope, cosIncidence;
  function calculateElevation(pixel2, encoding2 = "mapbox") {
    if (encoding2 === "mapbox") {
      return (pixel2[0] * 256 * 256 + pixel2[1] * 256 + pixel2[2]) * 0.1 - 1e4;
    }
    if (encoding2 === "terrarium") {
      return pixel2[0] * 256 + pixel2[1] + pixel2[2] / 256 - 32768;
    }
  }
  for (pixelY = 0; pixelY <= maxY; ++pixelY) {
    y0 = pixelY === 0 ? 0 : pixelY - 1;
    y1 = pixelY === maxY ? maxY : pixelY + 1;
    for (pixelX = 0; pixelX <= maxX; ++pixelX) {
      x0 = pixelX === 0 ? 0 : pixelX - 1;
      x1 = pixelX === maxX ? maxX : pixelX + 1;
      offset = (pixelY * width + x0) * 4;
      pixel[0] = elevationData[offset];
      pixel[1] = elevationData[offset + 1];
      pixel[2] = elevationData[offset + 2];
      pixel[3] = elevationData[offset + 3];
      z0 = data.vert * calculateElevation(pixel, encoding);
      offset = (pixelY * width + x1) * 4;
      pixel[0] = elevationData[offset];
      pixel[1] = elevationData[offset + 1];
      pixel[2] = elevationData[offset + 2];
      pixel[3] = elevationData[offset + 3];
      z1 = data.vert * calculateElevation(pixel, encoding);
      dzdx = (z1 - z0) / dp;
      offset = (y0 * width + pixelX) * 4;
      pixel[0] = elevationData[offset];
      pixel[1] = elevationData[offset + 1];
      pixel[2] = elevationData[offset + 2];
      pixel[3] = elevationData[offset + 3];
      z0 = data.vert * calculateElevation(pixel, encoding);
      offset = (y1 * width + pixelX) * 4;
      pixel[0] = elevationData[offset];
      pixel[1] = elevationData[offset + 1];
      pixel[2] = elevationData[offset + 2];
      pixel[3] = elevationData[offset + 3];
      z1 = data.vert * calculateElevation(pixel, encoding);
      dzdy = (z1 - z0) / dp;
      aspect = Math.atan2(dzdy, -dzdx);
      if (aspect < 0) {
        aspect = halfPi - aspect;
      } else if (aspect > halfPi) {
        aspect = twoPi - aspect + halfPi;
      } else {
        aspect = halfPi - aspect;
      }
      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));
      cosIncidence = sinSunEl * Math.cos(slope) + cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);
      accent = Math.cos(slope);
      scaled = 255 * cosIncidence;
      clamp3 = Math.min(Math.max(2 * data.sunEl, 0), 1);
      slopeScaleBase = 1.875 - data.opacity * 1.75;
      scaledSlope = data.opacity !== 0.5 ? halfPi * ((Math.pow(slopeScaleBase, slope) - 1) / (Math.pow(slopeScaleBase, halfPi) - 1)) : slope;
      scaledAccentColor = {
        r: (1 - accent) * accentColor.r * clamp3 * 255,
        g: (1 - accent) * accentColor.g * clamp3 * 255,
        b: (1 - accent) * accentColor.b * clamp3 * 255,
        a: (1 - accent) * accentColor.a * clamp3 * 255
      };
      shade = Math.abs(((aspect + sunAz) / Math.PI + 0.5) % 2 - 1);
      compositeShadeColor = {
        r: (highlightColor.r * (1 - shade) + shadowColor.r * shade) * scaled,
        g: (highlightColor.g * (1 - shade) + shadowColor.g * shade) * scaled,
        b: (highlightColor.b * (1 - shade) + shadowColor.b * shade) * scaled,
        a: (highlightColor.a * (1 - shade) + shadowColor.a * shade) * scaled
      };
      offset = (pixelY * width + pixelX) * 4;
      shadeData[offset] = scaledAccentColor.r * (1 - shade) + compositeShadeColor.r;
      shadeData[offset + 1] = scaledAccentColor.g * (1 - shade) + compositeShadeColor.g;
      shadeData[offset + 2] = scaledAccentColor.b * (1 - shade) + compositeShadeColor.b;
      shadeData[offset + 3] = elevationData[offset + 3] * data.opacity * clamp3 * Math.sin(scaledSlope);
    }
  }
  return new ImageData(shadeData, width, height);
}

// node_modules/ol-mapbox-style/src/apply.js
function getTileResolutions(projection2, tileSize = 512) {
  return projection2.getExtent() ? createXYZ({
    extent: projection2.getExtent(),
    tileSize,
    maxZoom: 22
  }).getResolutions() : defaultResolutions;
}
function completeOptions(styleUrl, options) {
  if (!options.accessToken) {
    options = Object.assign({}, options);
    const searchParams = new URL(styleUrl).searchParams;
    searchParams.forEach((value, key) => {
      options.accessToken = value;
      options.accessTokenParam = key;
    });
  }
  return options;
}
function applyStyle(layer2, glStyle, sourceOrLayersOrOptions = "", optionsOrPath = {}, resolutions = void 0) {
  let styleUrl, sourceId;
  let options;
  let sourceOrLayers;
  let updateSource = true;
  if (typeof sourceOrLayersOrOptions !== "string" && !Array.isArray(sourceOrLayersOrOptions)) {
    options = sourceOrLayersOrOptions;
    sourceOrLayers = options.source || options.layers;
    optionsOrPath = options;
  } else {
    sourceOrLayers = sourceOrLayersOrOptions;
  }
  if (typeof optionsOrPath === "string") {
    styleUrl = optionsOrPath;
    options = {};
  } else {
    styleUrl = optionsOrPath.styleUrl;
    options = optionsOrPath;
  }
  if (options.updateSource === false) {
    updateSource = false;
  }
  if (!resolutions) {
    resolutions = options.resolutions;
  }
  if (!styleUrl && typeof glStyle === "string" && !glStyle.trim().startsWith("{")) {
    styleUrl = glStyle;
  }
  if (styleUrl) {
    styleUrl = styleUrl.startsWith("data:") ? location.href : normalizeStyleUrl(styleUrl, options.accessToken);
    options = completeOptions(styleUrl, options);
  }
  return new Promise(function(resolve, reject) {
    getGlStyle(glStyle, options).then(function(glStyle2) {
      if (glStyle2.version != 8) {
        return reject(new Error("glStyle version 8 required."));
      }
      if (!(layer2 instanceof Vector_default2 || layer2 instanceof VectorTile_default3)) {
        return reject(
          new Error("Can only apply to VectorLayer or VectorTileLayer")
        );
      }
      const type = layer2 instanceof VectorTile_default3 ? "vector" : "geojson";
      if (!sourceOrLayers) {
        sourceId = glStyle2.layers.find(function(layer3) {
          return layer3.source && glStyle2.sources[layer3.source].type === type;
        }).source;
        sourceOrLayers = sourceId;
      } else if (Array.isArray(sourceOrLayers)) {
        sourceId = glStyle2.layers.find(function(layer3) {
          return layer3.id === sourceOrLayers[0];
        }).source;
      } else {
        sourceId = sourceOrLayers;
      }
      if (!sourceId) {
        return reject(new Error(`No ${type} source found in the glStyle.`));
      }
      function assignSource() {
        if (!updateSource) {
          return Promise.resolve();
        }
        if (layer2 instanceof VectorTile_default3) {
          return setupVectorSource(
            glStyle2.sources[sourceId],
            styleUrl,
            options
          ).then(function(source3) {
            const targetSource2 = layer2.getSource();
            if (!targetSource2) {
              layer2.setSource(source3);
            } else if (source3 !== targetSource2) {
              targetSource2.setTileUrlFunction(source3.getTileUrlFunction());
              if (typeof targetSource2.setUrls === "function" && typeof source3.getUrls === "function") {
                targetSource2.setUrls(source3.getUrls());
              }
              if (!targetSource2.format_) {
                targetSource2.format_ = source3.format_;
              }
              if (!targetSource2.getAttributions()) {
                targetSource2.setAttributions(source3.getAttributions());
              }
              if (targetSource2.getTileLoadFunction() === defaultLoadFunction) {
                targetSource2.setTileLoadFunction(
                  source3.getTileLoadFunction()
                );
              }
              if (equivalent(
                targetSource2.getProjection(),
                source3.getProjection()
              )) {
                targetSource2.tileGrid = source3.getTileGrid();
              }
            }
            const tileGrid = layer2.getSource().getTileGrid();
            if (!isFinite(layer2.getMaxResolution()) && !isFinite(layer2.getMinZoom()) && tileGrid.getMinZoom() > 0) {
              layer2.setMaxResolution(
                getResolutionForZoom(
                  Math.max(0, tileGrid.getMinZoom() - 1e-12),
                  tileGrid.getResolutions()
                )
              );
            }
          });
        }
        const glSource = glStyle2.sources[sourceId];
        let source2 = layer2.getSource();
        if (!source2 || source2.get("mapbox-source") !== glSource) {
          source2 = setupGeoJSONSource(glSource, styleUrl, options);
        }
        const targetSource = (
          /** @type {VectorSource} */
          layer2.getSource()
        );
        if (!targetSource) {
          layer2.setSource(source2);
        } else if (source2 !== targetSource) {
          if (!targetSource.getAttributions()) {
            targetSource.setAttributions(source2.getAttributions());
          }
          if (!targetSource.format_) {
            targetSource.format_ = source2.getFormat();
          }
          targetSource.url_ = source2.getUrl();
        }
        return Promise.resolve();
      }
      let spriteScale, style;
      const spriteData = {};
      const spriteImageUrl = {};
      function onChange() {
        if (!style && (!glStyle2.sprite || spriteData)) {
          if (options.projection && !resolutions) {
            const projection2 = get(options.projection);
            const units = projection2.getUnits();
            if (units !== "m") {
              resolutions = defaultResolutions.map(
                (resolution) => resolution / METERS_PER_UNIT[units]
              );
            }
          }
          style = stylefunction(
            layer2,
            glStyle2,
            sourceOrLayers,
            resolutions,
            spriteData,
            spriteImageUrl,
            (fonts, templateUrl = options.webfonts) => getFonts(fonts, templateUrl),
            options.getImage
          );
          if (!layer2.getStyle()) {
            reject(new Error(`Nothing to show for source [${sourceId}]`));
          } else {
            assignSource().then(resolve).catch(reject);
          }
        } else if (style) {
          layer2.setStyle(style);
          assignSource().then(resolve).catch(reject);
        } else {
          reject(new Error("Something went wrong trying to apply style."));
        }
      }
      if (glStyle2.sprite) {
        const sprites = normalizeSpriteDefinition(
          glStyle2.sprite,
          options.accessToken,
          styleUrl || location.href
        );
        spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
        const sizeFactor = spriteScale == 0.5 ? "@2x" : "";
        Promise.all(
          sprites.map(function(sprite) {
            const spriteBaseUrl = new URL(sprite.url);
            let spriteUrl = spriteBaseUrl.origin + spriteBaseUrl.pathname + sizeFactor + ".json" + spriteBaseUrl.search;
            return new Promise(function(resolve2, reject2) {
              fetchResource("Sprite", spriteUrl, options).then(resolve2).catch(function(error2) {
                spriteUrl = spriteBaseUrl.origin + spriteBaseUrl.pathname + ".json" + spriteBaseUrl.search;
                fetchResource("Sprite", spriteUrl, options).then(resolve2).catch(reject2);
              });
            }).then(function(spritesJson) {
              if (spritesJson === void 0) {
                reject(new Error("No sprites found."));
              }
              let imageUrl;
              imageUrl = spriteBaseUrl.origin + spriteBaseUrl.pathname + sizeFactor + ".png" + spriteBaseUrl.search;
              if (options.transformRequest) {
                const transformed = options.transformRequest(imageUrl, "SpriteImage") || imageUrl;
                if (transformed instanceof Request || transformed instanceof Promise) {
                  imageUrl = transformed;
                }
              }
              spriteImageUrl[sprite.id] = imageUrl;
              for (const spriteName in spritesJson) {
                const key = sprite.id == "default" ? spriteName : `${sprite.id}:${spriteName}`;
                spriteData[key] = spritesJson[spriteName];
              }
            }).catch(function(err) {
              reject(
                new Error(
                  `Sprites cannot be loaded: ${spriteUrl}: ${err.message}`
                )
              );
            });
          })
        ).then(onChange).catch(reject);
      } else {
        onChange();
      }
    }).catch(reject);
  });
}
function setFirstBackground(mapOrLayer, glStyle, options) {
  glStyle.layers.some(function(layer2) {
    if (layer2.type === "background") {
      if (mapOrLayer instanceof Layer_default2) {
        mapOrLayer.setBackground(function(resolution) {
          return getBackgroundColor(layer2, resolution, options, {});
        });
        return true;
      }
      if (mapOrLayer instanceof Map_default || mapOrLayer instanceof Group_default) {
        mapOrLayer.getLayers().insertAt(0, setupBackgroundLayer(layer2, options, {}));
        return true;
      }
    }
  });
}
function applyBackground(mapOrLayer, glStyle, options = {}) {
  return getGlStyle(glStyle, options).then(function(glStyle2) {
    setFirstBackground(mapOrLayer, glStyle2, options);
  });
}
function getSourceIdByRef(layers, ref) {
  let sourceId;
  layers.some(function(layer2) {
    if (layer2.id == ref) {
      sourceId = layer2.source;
      return true;
    }
  });
  return sourceId;
}
function extentFromTileJSON(tileJSON, projection2) {
  const bounds = tileJSON.bounds;
  if (bounds) {
    const ll = fromLonLat([bounds[0], bounds[1]], projection2);
    const tr = fromLonLat([bounds[2], bounds[3]], projection2);
    return [ll[0], ll[1], tr[0], tr[1]];
  }
  return get(projection2).getExtent();
}
function sourceOptionsFromTileJSON(glSource, tileJSON, options) {
  const tileJSONSource = new TileJSON_default({
    tileJSON,
    tileSize: glSource.tileSize || tileJSON.tileSize || 512
  });
  const tileJSONDoc = tileJSONSource.getTileJSON();
  const tileGrid = tileJSONSource.getTileGrid();
  const projection2 = get(options.projection || "EPSG:3857");
  const extent = extentFromTileJSON(tileJSONDoc, projection2);
  const projectionExtent = projection2.getExtent();
  const minZoom = tileJSONDoc.minzoom || 0;
  const maxZoom = tileJSONDoc.maxzoom || 22;
  const sourceOptions = {
    attributions: tileJSONSource.getAttributions(),
    projection: projection2,
    tileGrid: new TileGrid_default({
      origin: projectionExtent ? getTopLeft(projectionExtent) : tileGrid.getOrigin(0),
      extent: extent || tileGrid.getExtent(),
      minZoom,
      resolutions: getTileResolutions(projection2, tileJSON.tileSize).slice(
        0,
        maxZoom + 1
      ),
      tileSize: tileGrid.getTileSize(0)
    })
  };
  if (Array.isArray(tileJSONDoc.tiles)) {
    sourceOptions.urls = tileJSONDoc.tiles;
  } else {
    sourceOptions.url = tileJSONDoc.tiles;
  }
  return sourceOptions;
}
function getBackgroundColor(glLayer, resolution, options, functionCache) {
  const background = {
    id: glLayer.id,
    type: glLayer.type
  };
  const layout2 = glLayer.layout || {};
  const paint2 = glLayer.paint || {};
  background["paint"] = paint2;
  cameraObj.zoom = getZoomForResolution(
    resolution,
    options.resolutions || defaultResolutions
  );
  cameraObj.distanceFromCenter = 0;
  let opacity;
  const bg = getValue(
    background,
    "paint",
    "background-color",
    emptyObj,
    functionCache
  );
  if (paint2["background-opacity"] !== void 0) {
    opacity = getValue(
      background,
      "paint",
      "background-opacity",
      emptyObj,
      functionCache
    );
  }
  return layout2.visibility == "none" ? void 0 : colorWithOpacity(bg, opacity);
}
function setupBackgroundLayer(glLayer, options, functionCache) {
  const div = document.createElement("div");
  div.className = "ol-mapbox-style-background";
  div.style.position = "absolute";
  div.style.width = "100%";
  div.style.height = "100%";
  return new Layer_default2({
    source: new Source_default({}),
    render(frameState) {
      const color = getBackgroundColor(
        glLayer,
        frameState.viewState.resolution,
        options,
        functionCache
      );
      div.style.backgroundColor = color;
      return div;
    }
  });
}
function setupVectorSource(glSource, styleUrl, options) {
  return new Promise(function(resolve, reject) {
    getTileJson(glSource, styleUrl, options).then(function({ tileJson, tileLoadFunction }) {
      const sourceOptions = sourceOptionsFromTileJSON(
        glSource,
        tileJson,
        options
      );
      sourceOptions.tileLoadFunction = tileLoadFunction;
      sourceOptions.format = new MVT_default();
      const source2 = new VectorTile_default2(sourceOptions);
      source2.set("mapbox-source", glSource);
      resolve(source2);
    }).catch(reject);
  });
}
function setupVectorLayer(glSource, styleUrl, options) {
  const layer2 = new VectorTile_default3({
    declutter: true,
    visible: false
  });
  setupVectorSource(glSource, styleUrl, options).then(function(source2) {
    layer2.setSource(source2);
  }).catch(function(error2) {
    layer2.setSource(void 0);
  });
  return layer2;
}
function getBboxTemplate(projection2) {
  const projCode = projection2 ? projection2.getCode() : "EPSG:3857";
  return `{bbox-${projCode.toLowerCase().replace(/[^a-z0-9]/g, "-")}}`;
}
function setupRasterSource(glSource, styleUrl, options) {
  return new Promise(function(resolve, reject) {
    getTileJson(glSource, styleUrl, options).then(function({ tileJson, tileLoadFunction }) {
      const source2 = new TileJSON_default({
        interpolate: options.interpolate === void 0 ? true : options.interpolate,
        transition: 0,
        crossOrigin: "anonymous",
        tileJSON: tileJson
      });
      source2.tileGrid = sourceOptionsFromTileJSON(
        glSource,
        tileJson,
        options
      ).tileGrid;
      if (options.projection) {
        source2.projection = get(options.projection);
      }
      const getTileUrl = source2.getTileUrlFunction();
      if (tileLoadFunction) {
        source2.setTileLoadFunction(tileLoadFunction);
      }
      source2.setTileUrlFunction(function(tileCoord, pixelRatio, projection2) {
        const bboxTemplate = getBboxTemplate(projection2);
        let src = getTileUrl(tileCoord, pixelRatio, projection2);
        if (src.indexOf(bboxTemplate) != -1) {
          const bbox2 = source2.getTileGrid().getTileCoordExtent(tileCoord);
          src = src.replace(bboxTemplate, bbox2.toString());
        }
        return src;
      });
      source2.set("mapbox-source", glSource);
      resolve(source2);
    }).catch(function(error2) {
      reject(error2);
    });
  });
}
function setupRasterLayer(glSource, styleUrl, options) {
  const layer2 = new Tile_default2();
  setupRasterSource(glSource, styleUrl, options).then(function(source2) {
    layer2.setSource(source2);
  }).catch(function() {
    layer2.setSource(void 0);
  });
  return layer2;
}
function setupHillshadeLayer(glSource, styleUrl, options) {
  const tileLayer = setupRasterLayer(glSource, styleUrl, options);
  const layer2 = new Image_default3({
    source: new Raster_default({
      operationType: "image",
      operation: hillshade,
      sources: [tileLayer]
    })
  });
  return layer2;
}
function setupGeoJSONSource(glSource, styleUrl, options) {
  const geoJsonFormat = options.projection ? new GeoJSON_default({ dataProjection: options.projection }) : new GeoJSON_default();
  const data = glSource.data;
  const sourceOptions = {};
  if (typeof data == "string") {
    const [geoJsonUrl] = normalizeSourceUrl(
      data,
      options.accessToken,
      options.accessTokenParam || "access_token",
      styleUrl || location.href
    );
    if (/\{bbox-[0-9a-z-]+\}/.test(geoJsonUrl)) {
      const extentUrl = (extent, resolution, projection2) => {
        const bboxTemplate = getBboxTemplate(projection2);
        return geoJsonUrl.replace(bboxTemplate, `${extent.join(",")}`);
      };
      const source4 = new Vector_default({
        attributions: glSource.attribution,
        format: geoJsonFormat,
        loader: (extent, resolution, projection2, success2, failure) => {
          const url = typeof extentUrl === "function" ? extentUrl(extent, resolution, projection2) : extentUrl;
          fetchResource("GeoJSON", url, options).then((json) => {
            const features = (
              /** @type {*} */
              source4.getFormat().readFeatures(json, { featureProjection: projection2 })
            );
            source4.addFeatures(features);
            success2(features);
          }).catch((response) => {
            source4.removeLoadedExtent(extent);
            failure();
          });
        },
        strategy: bbox
      });
      source4.set("mapbox-source", glSource);
      return source4;
    }
    const source3 = new Vector_default({
      attributions: glSource.attribution,
      format: geoJsonFormat,
      url: geoJsonUrl,
      loader: (extent, resolution, projection2, success2, failure) => {
        fetchResource("GeoJSON", geoJsonUrl, options).then((json) => {
          const features = (
            /** @type {*} */
            source3.getFormat().readFeatures(json, { featureProjection: projection2 })
          );
          source3.addFeatures(features);
          success2(features);
        }).catch((response) => {
          source3.removeLoadedExtent(extent);
          failure();
        });
      }
    });
    return source3;
  }
  sourceOptions.features = geoJsonFormat.readFeatures(data, {
    featureProjection: getUserProjection() || "EPSG:3857"
  });
  const source2 = new Vector_default(
    Object.assign(
      {
        attributions: glSource.attribution,
        format: geoJsonFormat
      },
      sourceOptions
    )
  );
  source2.set("mapbox-source", glSource);
  return (
    /** @type {VectorSource} */
    source2
  );
}
function setupGeoJSONLayer(glSource, styleUrl, options) {
  return new Vector_default2({
    declutter: true,
    source: setupGeoJSONSource(glSource, styleUrl, options),
    visible: false
  });
}
function prerenderRasterLayer(glLayer, layer2, functionCache) {
  let zoom = null;
  return function(event) {
    if (glLayer.paint && "raster-opacity" in glLayer.paint && event.frameState.viewState.zoom !== zoom) {
      zoom = event.frameState.viewState.zoom;
      delete functionCache[glLayer.id];
      updateRasterLayerProperties(glLayer, layer2, zoom, functionCache);
    }
  };
}
function updateRasterLayerProperties(glLayer, layer2, zoom, functionCache) {
  cameraObj.zoom = zoom;
  cameraObj.distanceFromCenter = 0;
  const opacity = getValue(
    glLayer,
    "paint",
    "raster-opacity",
    emptyObj,
    functionCache
  );
  layer2.setOpacity(opacity);
}
function manageVisibility(layer2, mapOrGroup) {
  function onChange() {
    const glStyle = mapOrGroup.get("mapbox-style");
    if (!glStyle) {
      return;
    }
    const mapboxLayers = derefLayers(glStyle.layers);
    const layerMapboxLayerids = layer2.get("mapbox-layers");
    const visible = mapboxLayers.filter(function(mapboxLayer) {
      return layerMapboxLayerids.includes(mapboxLayer.id);
    }).some(function(mapboxLayer) {
      return !mapboxLayer.layout || !mapboxLayer.layout.visibility || mapboxLayer.layout.visibility === "visible";
    });
    if (layer2.get("visible") !== visible) {
      layer2.setVisible(visible);
    }
  }
  layer2.on("change", onChange);
  onChange();
}
function setupLayer(glStyle, styleUrl, glLayer, options) {
  const functionCache = getFunctionCache(glStyle);
  const glLayers = glStyle.layers;
  const type = glLayer.type;
  const id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
  const glSource = glStyle.sources[id];
  let layer2;
  if (type == "background") {
    layer2 = setupBackgroundLayer(glLayer, options, functionCache);
  } else if (glSource.type == "vector") {
    layer2 = setupVectorLayer(glSource, styleUrl, options);
  } else if (glSource.type == "raster") {
    layer2 = setupRasterLayer(glSource, styleUrl, options);
    layer2.setVisible(
      glLayer.layout ? glLayer.layout.visibility !== "none" : true
    );
    layer2.on("prerender", prerenderRasterLayer(glLayer, layer2, functionCache));
  } else if (glSource.type == "geojson") {
    layer2 = setupGeoJSONLayer(glSource, styleUrl, options);
  } else if (glSource.type == "raster-dem" && glLayer.type == "hillshade") {
    const hillshadeLayer = setupHillshadeLayer(glSource, styleUrl, options);
    layer2 = hillshadeLayer;
    hillshadeLayer.getSource().on("beforeoperations", function(event) {
      const data = event.data;
      data.resolution = getPointResolution(
        options.projection || "EPSG:3857",
        event.resolution,
        getCenter(event.extent),
        "m"
      );
      cameraObj.zoom = getZoomForResolution(
        event.resolution,
        options.resolutions || defaultResolutions
      );
      cameraObj.distanceFromCenter = 0;
      data.encoding = glSource.encoding;
      data.vert = 5 * getValue(
        glLayer,
        "paint",
        "hillshade-exaggeration",
        emptyObj,
        functionCache
      );
      data.sunAz = getValue(
        glLayer,
        "paint",
        "hillshade-illumination-direction",
        emptyObj,
        functionCache
      );
      data.sunEl = 35;
      data.opacity = 0.3;
      data.highlightColor = getValue(
        glLayer,
        "paint",
        "hillshade-highlight-color",
        emptyObj,
        functionCache
      );
      data.shadowColor = getValue(
        glLayer,
        "paint",
        "hillshade-shadow-color",
        emptyObj,
        functionCache
      );
      data.accentColor = getValue(
        glLayer,
        "paint",
        "hillshade-accent-color",
        emptyObj,
        functionCache
      );
    });
    layer2.setVisible(
      glLayer.layout ? glLayer.layout.visibility !== "none" : true
    );
  }
  const glSourceId = id;
  if (layer2) {
    layer2.set("mapbox-source", glSourceId);
  }
  return layer2;
}
function processStyle(glStyle, mapOrGroup, styleUrl, options) {
  const promises = [];
  let view = null;
  if (mapOrGroup instanceof Map_default) {
    view = mapOrGroup.getView();
    if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {
      const projection2 = options.projection ? get(options.projection) : view.getProjection();
      view = new View_default(
        Object.assign(view.getProperties(), {
          maxResolution: defaultResolutions[0] / METERS_PER_UNIT[projection2.getUnits()],
          projection: options.projection || view.getProjection()
        })
      );
      mapOrGroup.setView(view);
    }
    if ("center" in glStyle && !view.getCenter()) {
      view.setCenter(fromLonLat(glStyle.center, view.getProjection()));
    }
    if ("zoom" in glStyle && view.getZoom() === void 0) {
      view.setResolution(
        defaultResolutions[0] / METERS_PER_UNIT[view.getProjection().getUnits()] / Math.pow(2, glStyle.zoom)
      );
    }
    if (!view.getCenter() || view.getZoom() === void 0) {
      view.fit(view.getProjection().getExtent(), {
        nearest: true,
        size: mapOrGroup.getSize()
      });
    }
  }
  mapOrGroup.set("mapbox-style", glStyle);
  mapOrGroup.set("mapbox-metadata", { styleUrl, options });
  const glLayers = glStyle.layers;
  let layerIds = [];
  let layer2, glSourceId, id;
  for (let i = 0, ii = glLayers.length; i < ii; ++i) {
    const glLayer = glLayers[i];
    const type = glLayer.type;
    if (type == "heatmap") {
      console.debug(`layers[${i}].type "${type}" not supported`);
      continue;
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (!id || id != glSourceId) {
        if (layerIds.length) {
          promises.push(
            finalizeLayer(
              layer2,
              layerIds,
              glStyle,
              styleUrl,
              mapOrGroup,
              options
            )
          );
          layerIds = [];
        }
        layer2 = setupLayer(glStyle, styleUrl, glLayer, options);
        if (!(layer2 instanceof Vector_default2 || layer2 instanceof VectorTile_default3)) {
          layerIds = [];
        }
        glSourceId = layer2.get("mapbox-source");
      }
      layerIds.push(glLayer.id);
    }
  }
  promises.push(
    finalizeLayer(layer2, layerIds, glStyle, styleUrl, mapOrGroup, options)
  );
  return Promise.all(promises);
}
function apply2(mapOrGroupOrElement, style, options = {}) {
  let promise;
  let mapOrGroup;
  if (typeof mapOrGroupOrElement === "string" || mapOrGroupOrElement instanceof HTMLElement) {
    mapOrGroup = new Map_default({
      target: mapOrGroupOrElement
    });
  } else {
    mapOrGroup = mapOrGroupOrElement;
  }
  if (typeof style === "string") {
    const styleUrl = style.startsWith("data:") ? location.href : normalizeStyleUrl(style, options.accessToken);
    options = completeOptions(styleUrl, options);
    promise = new Promise(function(resolve, reject) {
      getGlStyle(style, options).then(function(glStyle) {
        processStyle(glStyle, mapOrGroup, styleUrl, options).then(function() {
          resolve(mapOrGroup);
        }).catch(reject);
      }).catch(function(err) {
        reject(new Error(`Could not load ${style}: ${err.message}`));
      });
    });
  } else {
    promise = new Promise(function(resolve, reject) {
      processStyle(
        style,
        mapOrGroup,
        !options.styleUrl || options.styleUrl.startsWith("data:") ? location.href : normalizeStyleUrl(options.styleUrl, options.accessToken),
        options
      ).then(function() {
        resolve(mapOrGroup);
      }).catch(reject);
    });
  }
  return promise;
}
function finalizeLayer(layer2, layerIds, glStyle, styleUrl, mapOrGroup, options = {}) {
  let minZoom = 24;
  let maxZoom = 0;
  const glLayers = glStyle.layers;
  for (let i = 0, ii = glLayers.length; i < ii; ++i) {
    const glLayer = glLayers[i];
    if (layerIds.indexOf(glLayer.id) !== -1) {
      minZoom = Math.min("minzoom" in glLayer ? glLayer.minzoom : 0, minZoom);
      maxZoom = Math.max("maxzoom" in glLayer ? glLayer.maxzoom : 24, maxZoom);
    }
  }
  return new Promise(function(resolve, reject) {
    const setStyle = function() {
      const source2 = layer2.getSource();
      if (!source2 || source2.getState() === "error") {
        reject(
          new Error(
            "Error accessing data for source " + layer2.get("mapbox-source")
          )
        );
        return;
      }
      if ("getTileGrid" in source2) {
        const tileGrid = (
          /** @type {import("ol/source/Tile.js").default|import("ol/source/VectorTile.js").default} */
          source2.getTileGrid()
        );
        if (tileGrid) {
          const sourceMinZoom = tileGrid.getMinZoom();
          if (minZoom > 0 || sourceMinZoom > 0) {
            layer2.setMaxResolution(
              Math.min(
                getResolutionForZoom(
                  Math.max(0, minZoom - 1e-12),
                  defaultResolutions
                ),
                getResolutionForZoom(
                  Math.max(0, sourceMinZoom - 1e-12),
                  tileGrid.getResolutions()
                )
              )
            );
          }
          if (maxZoom < 24) {
            layer2.setMinResolution(
              getResolutionForZoom(maxZoom, defaultResolutions)
            );
          }
        }
      } else {
        if (minZoom > 0) {
          layer2.setMaxResolution(
            getResolutionForZoom(
              Math.max(0, minZoom - 1e-12),
              defaultResolutions
            )
          );
        }
      }
      if (source2 instanceof Vector_default || source2 instanceof VectorTile_default2) {
        applyStyle(
          /** @type {import("ol/layer/Vector").default|import("ol/layer/VectorTile").default} */
          layer2,
          glStyle,
          layerIds,
          Object.assign({ styleUrl }, options)
        ).then(function() {
          manageVisibility(layer2, mapOrGroup);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    };
    layer2.set("mapbox-layers", layerIds);
    const layers = mapOrGroup.getLayers();
    if (layers.getArray().indexOf(layer2) === -1) {
      layers.push(layer2);
    }
    if (layer2.getSource()) {
      setStyle();
    } else {
      layer2.once("change:source", setStyle);
    }
  });
}
function getMapboxLayer(mapOrGroup, layerId) {
  const style = mapOrGroup.get("mapbox-style");
  const layerStyle = style.layers.find(function(layer2) {
    return layer2.id === layerId;
  });
  return layerStyle;
}
function addMapboxLayer(mapOrGroup, mapboxLayer, beforeLayerId) {
  const glStyle = mapOrGroup.get("mapbox-style");
  const mapboxLayers = glStyle.layers;
  let spliceIndex;
  let sourceIndex = -1;
  if (beforeLayerId !== void 0) {
    const beforeMapboxLayer = getMapboxLayer(mapOrGroup, beforeLayerId);
    if (beforeMapboxLayer === void 0) {
      throw new Error(`Layer with id "${beforeLayerId}" not found.`);
    }
    spliceIndex = mapboxLayers.indexOf(beforeMapboxLayer);
  } else {
    spliceIndex = mapboxLayers.length;
  }
  let sourceOffset;
  if (spliceIndex > 0 && mapboxLayers[spliceIndex - 1].source === mapboxLayer.source) {
    sourceIndex = spliceIndex - 1;
    sourceOffset = -1;
  } else if (spliceIndex < mapboxLayers.length && mapboxLayers[spliceIndex].source === mapboxLayer.source) {
    sourceIndex = spliceIndex;
    sourceOffset = 0;
  }
  if (sourceIndex === -1) {
    const { options, styleUrl } = mapOrGroup.get("mapbox-metadata");
    const layer2 = setupLayer(glStyle, styleUrl, mapboxLayer, options);
    if (beforeLayerId) {
      const beforeLayer = getLayer(mapOrGroup, beforeLayerId);
      const beforeLayerIndex = mapOrGroup.getLayers().getArray().indexOf(beforeLayer);
      mapOrGroup.getLayers().insertAt(beforeLayerIndex, layer2);
    }
    mapboxLayers.splice(spliceIndex, 0, mapboxLayer);
    return finalizeLayer(
      layer2,
      [mapboxLayer.id],
      glStyle,
      styleUrl,
      mapOrGroup,
      options
    );
  }
  if (mapboxLayers.some((layer2) => layer2.id === mapboxLayer.id)) {
    throw new Error(`Layer with id "${mapboxLayer.id}" already exists.`);
  }
  const sourceLayerId = mapboxLayers[sourceIndex].id;
  const args = styleFunctionArgs[getStyleFunctionKey(
    mapOrGroup.get("mapbox-style"),
    getLayer(mapOrGroup, sourceLayerId)
  )];
  mapboxLayers.splice(spliceIndex, 0, mapboxLayer);
  if (args) {
    const [
      olLayer,
      glStyle2,
      sourceOrLayers,
      resolutions,
      spriteData,
      spriteImageUrl,
      getFonts2,
      getImage
    ] = args;
    if (Array.isArray(sourceOrLayers)) {
      const layerIndex = sourceOrLayers.indexOf(sourceLayerId) + sourceOffset;
      sourceOrLayers.splice(layerIndex, 0, mapboxLayer.id);
    }
    stylefunction(
      olLayer,
      glStyle2,
      sourceOrLayers,
      resolutions,
      spriteData,
      spriteImageUrl,
      getFonts2,
      getImage
    );
  } else {
    getLayer(mapOrGroup, mapboxLayers[sourceIndex].id).changed();
  }
  return Promise.resolve();
}
function updateMapboxLayer(mapOrGroup, mapboxLayer) {
  const glStyle = mapOrGroup.get("mapbox-style");
  const mapboxLayers = glStyle.layers;
  const index = mapboxLayers.findIndex(function(layer2) {
    return layer2.id === mapboxLayer.id;
  });
  if (index === -1) {
    throw new Error(`Layer with id "${mapboxLayer.id}" not found.`);
  }
  const oldLayer = mapboxLayers[index];
  if (oldLayer.source !== mapboxLayer.source) {
    throw new Error(
      "Updated layer and previous version must use the same source."
    );
  }
  delete getFunctionCache(glStyle)[mapboxLayer.id];
  delete getFilterCache(glStyle)[mapboxLayer.id];
  mapboxLayers[index] = mapboxLayer;
  const args = styleFunctionArgs[getStyleFunctionKey(
    mapOrGroup.get("mapbox-style"),
    getLayer(mapOrGroup, mapboxLayer.id)
  )];
  if (args) {
    stylefunction.apply(void 0, args);
  } else {
    getLayer(mapOrGroup, mapboxLayer.id).changed();
  }
}
function updateMapboxSource(mapOrGroup, id, mapboxSource) {
  const currentSource = getSource(mapOrGroup, id);
  const layers = (
    /** @type {Array<VectorLayer|TileLayer|VectorTileLayer>} */
    mapOrGroup.getLayers().getArray().filter(function(layer2) {
      return (layer2 instanceof Vector_default2 || layer2 instanceof Tile_default2 || layer2 instanceof VectorTile_default3) && layer2.getSource() === currentSource;
    })
  );
  const metadata = mapOrGroup.get("mapbox-metadata");
  let newSourcePromise;
  switch (mapboxSource.type) {
    case "vector":
      newSourcePromise = setupVectorSource(
        mapboxSource,
        metadata.styleUrl,
        metadata.options
      );
      break;
    case "geojson":
      newSourcePromise = Promise.resolve(
        setupGeoJSONSource(mapboxSource, metadata.styleUrl, metadata.options)
      );
      break;
    case "raster":
    case "raster-dem":
      newSourcePromise = setupRasterSource(
        mapboxSource,
        metadata.styleUrl,
        metadata.options
      );
      break;
    default:
      return Promise.reject(
        new Error("Unsupported source type " + mapboxSource.type)
      );
  }
  newSourcePromise.then(function(newSource) {
    layers.forEach(function(layer2) {
      layer2.setSource(newSource);
    });
  });
  return newSourcePromise;
}
function removeMapboxLayer(mapOrGroup, mapboxLayerIdOrLayer) {
  const mapboxLayerId = typeof mapboxLayerIdOrLayer === "string" ? mapboxLayerIdOrLayer : mapboxLayerIdOrLayer.id;
  const layer2 = getLayer(mapOrGroup, mapboxLayerId);
  const layerMapboxLayers = layer2.get("mapbox-layers");
  if (layerMapboxLayers.length === 1) {
    throw new Error(
      "Cannot remove last Mapbox layer from an OpenLayers layer."
    );
  }
  layerMapboxLayers.splice(layerMapboxLayers.indexOf(mapboxLayerId), 1);
  const glStyle = mapOrGroup.get("mapbox-style");
  const layers = glStyle.layers;
  layers.splice(
    layers.findIndex((layer3) => layer3.id === mapboxLayerId),
    1
  );
  const args = styleFunctionArgs[getStyleFunctionKey(glStyle, layer2)];
  if (args) {
    const [
      olLayer,
      glStyle2,
      sourceOrLayers,
      resolutions,
      spriteData,
      spriteImageUrl,
      getFonts2,
      getImage
    ] = args;
    if (Array.isArray(sourceOrLayers)) {
      sourceOrLayers.splice(
        sourceOrLayers.findIndex((layer3) => layer3 === mapboxLayerId),
        1
      );
    }
    stylefunction(
      olLayer,
      glStyle2,
      sourceOrLayers,
      resolutions,
      spriteData,
      spriteImageUrl,
      getFonts2,
      getImage
    );
  } else {
    getLayer(mapOrGroup, mapboxLayerId).changed();
  }
}
function getLayer(map, layerId) {
  const layers = map.getLayers().getArray();
  for (let i = 0, ii = layers.length; i < ii; ++i) {
    const mapboxLayers = layers[i].get("mapbox-layers");
    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {
      return (
        /** @type {Layer} */
        layers[i]
      );
    }
  }
  return void 0;
}
function getLayers(map, sourceId) {
  const result = [];
  const layers = map.getLayers().getArray();
  for (let i = 0, ii = layers.length; i < ii; ++i) {
    if (layers[i].get("mapbox-source") === sourceId) {
      result.push(
        /** @type {Layer} */
        layers[i]
      );
    }
  }
  return result;
}
function getSource(map, sourceId) {
  const layers = map.getLayers().getArray();
  for (let i = 0, ii = layers.length; i < ii; ++i) {
    const source2 = (
      /** @type {Layer} */
      layers[i].getSource()
    );
    if (layers[i].get("mapbox-source") === sourceId) {
      return source2;
    }
  }
  return void 0;
}
function setFeatureState(mapOrLayer, feature, state) {
  const layers = "getLayers" in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];
  for (let i = 0, ii = layers.length; i < ii; ++i) {
    const featureState = layers[i].get("mapbox-featurestate");
    if (featureState) {
      if (state) {
        featureState[feature.id] = state;
      } else {
        delete featureState[feature.id];
      }
      layers[i].changed();
    } else {
      throw new Error(`Map or layer for source "${feature.source}" not found.`);
    }
  }
}
function getFeatureState(mapOrLayer, feature) {
  const layers = "getLayers" in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];
  for (let i = 0, ii = layers.length; i < ii; ++i) {
    const featureState = layers[i].get("mapbox-featurestate");
    if (featureState && featureState[feature.id]) {
      return featureState[feature.id];
    }
  }
  return void 0;
}

// node_modules/ol-mapbox-style/src/MapboxVectorLayer.js
var ErrorEvent = class extends Event_default {
  /**
   * @param {Error} error error object.
   */
  constructor(error2) {
    super(EventType_default.ERROR);
    this.error = error2;
  }
};
var MapboxVectorLayer = class extends VectorTile_default3 {
  /**
   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`
   * must be provided.
   */
  constructor(options) {
    const declutter = "declutter" in options ? options.declutter : true;
    const source2 = new VectorTile_default2({
      state: "loading",
      format: new MVT_default()
    });
    super({
      source: source2,
      background: options.background === false ? null : options.background,
      declutter,
      className: options.className,
      opacity: options.opacity,
      visible: options.visible,
      zIndex: options.zIndex,
      minResolution: options.minResolution,
      maxResolution: options.maxResolution,
      minZoom: options.minZoom,
      maxZoom: options.maxZoom,
      renderOrder: options.renderOrder,
      renderBuffer: options.renderBuffer,
      renderMode: options.renderMode,
      map: options.map,
      updateWhileAnimating: options.updateWhileAnimating,
      updateWhileInteracting: options.updateWhileInteracting,
      preload: options.preload,
      useInterimTilesOnError: options.useInterimTilesOnError,
      properties: options.properties
    });
    if (options.accessToken) {
      this.accessToken = options.accessToken;
    }
    const url = options.styleUrl;
    const promises = [
      applyStyle(this, url, options.layers || options.source, {
        accessToken: this.accessToken
      })
    ];
    if (this.getBackground() === void 0) {
      promises.push(
        applyBackground(this, options.styleUrl, {
          accessToken: this.accessToken
        })
      );
    }
    Promise.all(promises).then(() => {
      source2.setState("ready");
    }).catch((error2) => {
      this.dispatchEvent(new ErrorEvent(error2));
      const source3 = this.getSource();
      source3.setState("error");
    });
  }
};

export {
  Overlay_default,
  TileJSON_default,
  renderTransparent,
  recordStyleLayer,
  stylefunction,
  getStyleForLayer,
  applyStyle,
  applyBackground,
  apply2 as apply,
  getMapboxLayer,
  addMapboxLayer,
  updateMapboxLayer,
  updateMapboxSource,
  removeMapboxLayer,
  getLayer,
  getLayers,
  getSource,
  setFeatureState,
  getFeatureState,
  MapboxVectorLayer
};
//# sourceMappingURL=chunk-3H6ZIZKV.js.map
