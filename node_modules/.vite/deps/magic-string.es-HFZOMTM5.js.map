{
  "version": 3,
  "sources": ["../../@jridgewell/sourcemap-codec/src/vlq.ts", "../../@jridgewell/sourcemap-codec/src/strings.ts", "../../@jridgewell/sourcemap-codec/src/scopes.ts", "../../@jridgewell/sourcemap-codec/src/sourcemap-codec.ts", "../../magic-string/src/BitSet.js", "../../magic-string/src/Chunk.js", "../../magic-string/src/SourceMap.js", "../../magic-string/src/utils/guessIndent.js", "../../magic-string/src/utils/getRelativePath.js", "../../magic-string/src/utils/isObject.js", "../../magic-string/src/utils/getLocator.js", "../../magic-string/src/utils/Mappings.js", "../../magic-string/src/MagicString.js", "../../magic-string/src/Bundle.js"],
  "sourcesContent": ["import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n", "const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n", "import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n", "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n", "export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n", "export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\tif (DEBUG) {\n\t\t\t// we make these non-enumerable, for sanity while debugging\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tprevious: { writable: true, value: null },\n\t\t\t\tnext: { writable: true, value: null },\n\t\t\t});\n\t\t} else {\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n", "import { encode } from '@jridgewell/sourcemap-codec';\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n", "export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n", "export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n", "const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n", "export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n", "const wordRegex = /\\w/;\n\nexport default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n", "import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\tif (this.outro) {\n\t\t\tmappings.advance(this.outro);\n\t\t}\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('reset');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('reset');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\treplacement = replacement(string, index, original);\n\t\t\t}\n\t\t\tif (string !== replacement) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tlet _replacement = replacement;\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\t_replacement = replacement(previous, index, original);\n\t\t\t}\n\t\t\tif (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n", "import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["n", "segment", "replacement"]
}
