"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createContext: () => createContext,
  default: () => viteEnvRuntimePlugin
});
module.exports = __toCommonJS(src_exports);
var import_node_fs = require("fs");
var import_node_path = require("path");
var import_node_process = __toESM(require("process"), 1);
var import_consola = __toESM(require("consola"), 1);
var import_defu = __toESM(require("defu"), 1);
var import_dotenv = __toESM(require("dotenv"), 1);
var import_magic_string = __toESM(require("magic-string"), 1);

// src/utils.ts
var import_minimatch = require("minimatch");
function arraify(target) {
  return Array.isArray(target) ? target : [target];
}
function createFilter(include, exclude) {
  const includeMatchers = arraify(include);
  const excludeMatchers = arraify(exclude);
  return (content) => {
    if (typeof content !== "string")
      return false;
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if ((0, import_minimatch.minimatch)(content, matcher))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if ((0, import_minimatch.minimatch)(content, matcher))
        return true;
    }
    return !includeMatchers.length;
  };
}

// src/index.ts
function createContext(viteConfig, rawOptions) {
  const { base, build: { outDir }, envPrefix, envDir } = (0, import_defu.default)(viteConfig, {
    base: "/",
    build: { outDir: "dist" },
    envPrefix: "VITE_",
    envDir: ""
  });
  const options = (0, import_defu.default)(rawOptions, {
    name: "__PRODUCTION__APP__CONF__",
    filename: "config.js",
    exclude: []
  });
  const includes = arraify(options.include ?? arraify(envPrefix).map((v) => `${v}*`));
  const excludes = arraify(options.exclude);
  const filter = createFilter(includes, excludes);
  const ENV_DISABLE_KEY = "VITE_ENV_RUNTIME";
  const CONFIG_NAME = options.name;
  const FILENAME = options.filename;
  const OUTPUT_DIR = outDir;
  const BASE = base;
  const ENV_DIR = envDir;
  function getGlobName() {
    return CONFIG_NAME.toUpperCase().replace(/\s/g, "");
  }
  function transform(code, {
    includeList = includes,
    excludeList = excludes,
    globName = getGlobName()
  } = {}) {
    const s = new import_magic_string.default(code);
    function generatePattern(patterns) {
      return patterns.map((prefix) => {
        const regex = prefix.includes("*") ? prefix.replace("*", "[^\\W]+") : prefix;
        return `(${regex})`;
      }).join("|");
    }
    const includePattern = generatePattern(includeList);
    const excludePattern = generatePattern(excludeList);
    const generateReg = (pattern) => `import\\.meta\\.env\\.(${pattern})\\b`;
    const includeReg = new RegExp(generateReg(includePattern), "g");
    s.replace(includeReg, (match) => {
      const excludeReg = new RegExp(generateReg(excludePattern), "g");
      if (!!excludeList.length && excludeReg.test(match)) {
        return match;
      }
      return match.replace("import.meta.env.", `window.${globName}.`);
    });
    return {
      code: s.toString(),
      map: s.generateMap({ hires: "boundary" })
    };
  }
  function transformIndexHtml() {
    return [{
      tag: "script",
      attrs: { src: `${BASE + FILENAME}?v=${(/* @__PURE__ */ new Date()).getTime()}` }
    }];
  }
  function getConfFiles() {
    const script = import_node_process.default.env.npm_lifecycle_script;
    const reg = /--mode ([a-z_\d]+)/;
    const result = reg.exec(script);
    if (result) {
      const mode = result[1];
      return [".env", `.env.${mode}`];
    }
    return [".env", ".env.production"];
  }
  function getEnvConfig(confFiles = getConfFiles()) {
    let envConfig = {};
    confFiles.forEach((item) => {
      const path = (0, import_node_path.resolve)(import_node_process.default.cwd(), ENV_DIR, item);
      if (!(0, import_node_fs.existsSync)(path))
        return;
      try {
        const env = import_dotenv.default.parse((0, import_node_fs.readFileSync)(path));
        envConfig = { ...envConfig, ...env };
      } catch (e) {
        import_consola.default.error(`Error in parsing ${item}`, e);
      }
    });
    if (envConfig[ENV_DISABLE_KEY] === "false")
      return {};
    Object.keys(envConfig).forEach((key) => {
      if (!filter(key))
        Reflect.deleteProperty(envConfig, key);
    });
    return envConfig;
  }
  function runBuildConfig(envConfig = getEnvConfig(), globName = getGlobName(), configFilename = FILENAME) {
    try {
      const windowConf = `window.${globName}`;
      const configContent = `${windowConf}=${JSON.stringify(envConfig)};
         Object.freeze(${windowConf});
         Object.defineProperty(window, "${globName}", {
           configurable: false,
           writable: false,
         });
       `.replace(/\s/g, "");
      const outputDir = (0, import_node_path.resolve)(import_node_process.default.cwd(), OUTPUT_DIR);
      const outputFile = (0, import_node_path.resolve)(outputDir, configFilename);
      (0, import_node_fs.mkdirSync)(outputDir, { recursive: true });
      (0, import_node_fs.writeFileSync)(outputFile, configContent);
      import_consola.default.success(`[vite-plugin-env-runtime] Configuration file is build successfully: ${`${OUTPUT_DIR}/${configFilename}`}`);
    } catch (error) {
      import_consola.default.error(`configuration file failed to package:
${error}`);
    }
  }
  return {
    transform,
    transformIndexHtml,
    runBuildConfig
  };
}
function viteEnvRuntimePlugin(options) {
  let ctx;
  return {
    name: "vite-plugin-env-runtime",
    apply: "build",
    configResolved(resolvedConfig) {
      ctx = createContext(resolvedConfig, options);
    },
    transform(code) {
      return ctx.transform(code);
    },
    transformIndexHtml() {
      return ctx.transformIndexHtml();
    },
    closeBundle() {
      try {
        ctx.runBuildConfig();
      } catch (error) {
        import_consola.default.error(error);
        import_node_process.default.exit(1);
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createContext
});
