// src/index.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import process from "node:process";
import consola from "consola";
import defu from "defu";
import dotenv from "dotenv";
import MagicString from "magic-string";

// src/utils.ts
import { minimatch } from "minimatch";
function arraify(target) {
  return Array.isArray(target) ? target : [target];
}
function createFilter(include, exclude) {
  const includeMatchers = arraify(include);
  const excludeMatchers = arraify(exclude);
  return (content) => {
    if (typeof content !== "string")
      return false;
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (minimatch(content, matcher))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (minimatch(content, matcher))
        return true;
    }
    return !includeMatchers.length;
  };
}

// src/index.ts
function createContext(viteConfig, rawOptions) {
  const { base, build: { outDir }, envPrefix, envDir } = defu(viteConfig, {
    base: "/",
    build: { outDir: "dist" },
    envPrefix: "VITE_",
    envDir: ""
  });
  const options = defu(rawOptions, {
    name: "__PRODUCTION__APP__CONF__",
    filename: "config.js",
    exclude: []
  });
  const includes = arraify(options.include ?? arraify(envPrefix).map((v) => `${v}*`));
  const excludes = arraify(options.exclude);
  const filter = createFilter(includes, excludes);
  const ENV_DISABLE_KEY = "VITE_ENV_RUNTIME";
  const CONFIG_NAME = options.name;
  const FILENAME = options.filename;
  const OUTPUT_DIR = outDir;
  const BASE = base;
  const ENV_DIR = envDir;
  function getGlobName() {
    return CONFIG_NAME.toUpperCase().replace(/\s/g, "");
  }
  function transform(code, {
    includeList = includes,
    excludeList = excludes,
    globName = getGlobName()
  } = {}) {
    const s = new MagicString(code);
    function generatePattern(patterns) {
      return patterns.map((prefix) => {
        const regex = prefix.includes("*") ? prefix.replace("*", "[^\\W]+") : prefix;
        return `(${regex})`;
      }).join("|");
    }
    const includePattern = generatePattern(includeList);
    const excludePattern = generatePattern(excludeList);
    const generateReg = (pattern) => `import\\.meta\\.env\\.(${pattern})\\b`;
    const includeReg = new RegExp(generateReg(includePattern), "g");
    s.replace(includeReg, (match) => {
      const excludeReg = new RegExp(generateReg(excludePattern), "g");
      if (!!excludeList.length && excludeReg.test(match)) {
        return match;
      }
      return match.replace("import.meta.env.", `window.${globName}.`);
    });
    return {
      code: s.toString(),
      map: s.generateMap({ hires: "boundary" })
    };
  }
  function transformIndexHtml() {
    return [{
      tag: "script",
      attrs: { src: `${BASE + FILENAME}?v=${(/* @__PURE__ */ new Date()).getTime()}` }
    }];
  }
  function getConfFiles() {
    // const script = process.env.npm_lifecycle_script;
    // const reg = /--mode ([a-z_\d]+)/;
    // const result = reg.exec(script);
    const args = process.argv.slice(2); // Ignore les deux premiers (node + script path)
    // Check if the script contains the --mode flag
    const modeIndex = args.findIndex((arg) => arg === "--mode");
    if (modeIndex !== -1 && args[modeIndex + 1]) {
      const mode = args[modeIndex + 1];
      consola.success(`[vite-plugin-env-runtime] use custom env : ${mode}`);
      return [".env", `.env.${mode}`];
    }
    consola.success("[vite-plugin-env-runtime] use default env : production");
    return [".env", ".env.production"];
  }
  function getEnvConfig(confFiles = getConfFiles()) {
    let envConfig = {};
    confFiles.forEach((item) => {
      const path = resolve(process.cwd(), ENV_DIR, item);
      if (!existsSync(path))
        return;
      try {
        const env = dotenv.parse(readFileSync(path));
        envConfig = { ...envConfig, ...env };
      } catch (e) {
        consola.error(`Error in parsing ${item}`, e);
      }
    });
    if (envConfig[ENV_DISABLE_KEY] === "false")
      return {};
    Object.keys(envConfig).forEach((key) => {
      if (!filter(key))
        Reflect.deleteProperty(envConfig, key);
    });
    return envConfig;
  }
  function runBuildConfig(envConfig = getEnvConfig(), globName = getGlobName(), configFilename = FILENAME) {
    try {
      const windowConf = `window.${globName}`;
      const configContent = `${windowConf}=${JSON.stringify(envConfig)};
         Object.freeze(${windowConf});
         Object.defineProperty(window, "${globName}", {
           configurable: false,
           writable: false,
         });
       `.replace(/\s/g, "");
      const outputDir = resolve(process.cwd(), OUTPUT_DIR);
      const outputFile = resolve(outputDir, configFilename);
      mkdirSync(outputDir, { recursive: true });
      writeFileSync(outputFile, configContent);
      consola.success(`[vite-plugin-env-runtime] Configuration file is build successfully: ${`${OUTPUT_DIR}/${configFilename}`}`);
    } catch (error) {
      consola.error(`configuration file failed to package:
${error}`);
    }
  }
  return {
    transform,
    transformIndexHtml,
    runBuildConfig
  };
}
function viteEnvRuntimePlugin(options) {
  let ctx;
  return {
    name: "vite-plugin-env-runtime",
    apply: "build",
    configResolved(resolvedConfig) {
      ctx = createContext(resolvedConfig, options);
    },
    transform(code) {
      return ctx.transform(code);
    },
    transformIndexHtml() {
      return ctx.transformIndexHtml();
    },
    closeBundle() {
      try {
        ctx.runBuildConfig();
      } catch (error) {
        consola.error(error);
        process.exit(1);
      }
    }
  };
}
export {
  createContext,
  viteEnvRuntimePlugin as default
};
